/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./build/src/apack_dependency_provider.js":
/*!************************************************!*\
  !*** ./build/src/apack_dependency_provider.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApackDependencyProvider = void 0;
const xml_js_1 = __webpack_require__(/*! xml-js */ "./node_modules/xml-js/lib/index.js");
class ApackDependencyProvider {
    static fromManifest(manifestContents) {
        var _a, _b;
        if (!manifestContents || !manifestContents.length) {
            return [];
        }
        const result = [];
        const manifest = (0, xml_js_1.xml2js)(manifestContents, { compact: true });
        let apackDependencies = (_b = (_a = manifest["asx:abap"]["asx:values"]["DATA"]) === null || _a === void 0 ? void 0 : _a["DEPENDENCIES"]) === null || _b === void 0 ? void 0 : _b.item;
        if (!apackDependencies) {
            return [];
        }
        else if (!apackDependencies.length) {
            apackDependencies = [apackDependencies];
        }
        for (const dependency of apackDependencies) {
            result.push({
                files: "/src/**/*.*",
                url: dependency["GIT_URL"]["_text"],
            });
        }
        return result;
    }
}
exports.ApackDependencyProvider = ApackDependencyProvider;
//# sourceMappingURL=apack_dependency_provider.js.map

/***/ }),

/***/ "./build/src/compressed_file.js":
/*!**************************************!*\
  !*** ./build/src/compressed_file.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompressedFile = void 0;
const core_1 = __webpack_require__(/*! @abaplint/core */ "./node_modules/@abaplint/core/build/src/index.js");
const zlib = __webpack_require__(/*! zlib */ "zlib");
class CompressedFile extends core_1.AbstractFile {
    constructor(filename, compressed) {
        super(filename);
        this.compressed = compressed;
    }
    getRaw() {
        return this.decompress(this.compressed);
    }
    getRawRows() {
        return this.decompress(this.compressed).split("\n");
    }
    decompress(compressed) {
        return zlib.inflateSync(Buffer.from(compressed, "base64")).toString("utf8");
    }
}
exports.CompressedFile = CompressedFile;
//# sourceMappingURL=compressed_file.js.map

/***/ }),

/***/ "./build/src/file_operations.js":
/*!**************************************!*\
  !*** ./build/src/file_operations.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FileOperations = void 0;
const fs = __webpack_require__(/*! fs */ "fs");
const path = __webpack_require__(/*! path */ "path");
const zlib = __webpack_require__(/*! zlib */ "zlib");
const glob = __webpack_require__(/*! glob */ "./node_modules/glob/glob.js");
const core_1 = __webpack_require__(/*! @abaplint/core */ "./node_modules/@abaplint/core/build/src/index.js");
const compressed_file_1 = __webpack_require__(/*! ./compressed_file */ "./build/src/compressed_file.js");
class FileOperations {
    static deleteFolderRecursive(dir) {
        if (fs.existsSync(dir) === false) {
            return;
        }
        fs.rmSync(dir, { recursive: true });
    }
    static loadFileNames(arg, error = true) {
        const files = glob.sync(arg, { nosort: true, nodir: true });
        if (files.length === 0 && error) {
            throw "Error: No files found";
        }
        return files;
    }
    static async loadFiles(compress, input, bar) {
        const files = [];
        bar.set(input.length, "Reading files");
        for (const filename of input) {
            bar.tick("Reading files - " + path.basename(filename));
            const base = filename.split("/").reverse()[0];
            if (base.split(".").length <= 2) {
                continue; // not a abapGit file
            }
            // note that readFileSync is typically faster than async readFile,
            // https://medium.com/@adamhooper/node-synchronous-code-runs-faster-than-asynchronous-code-b0553d5cf54e
            const raw = fs.readFileSync(filename, "utf8");
            if (compress === true) {
                // todo, util.promisify(zlib.deflate) does not seem to work?
                files.push(new compressed_file_1.CompressedFile(filename, zlib.deflateSync(raw).toString("base64")));
            }
            else {
                files.push(new core_1.MemoryFile(filename, raw));
            }
        }
        return files;
    }
}
exports.FileOperations = FileOperations;
//# sourceMappingURL=file_operations.js.map

/***/ }),

/***/ "./build/src/fixes.js":
/*!****************************!*\
  !*** ./build/src/fixes.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplyFixes = void 0;
const core_1 = __webpack_require__(/*! @abaplint/core */ "./node_modules/@abaplint/core/build/src/index.js");
class ApplyFixes {
    constructor() {
        this.changedFiles = new Set();
    }
    // Strategy:
    // Execute one rule at a time and apply fixes for that rule
    // Some rules are quite expensive to initialize(like downport),
    // so running all rules every time is expensive.
    async applyFixes(reg, fs, extra) {
        let iteration = 0;
        this.changedFiles.clear();
        const MAX_ITERATIONS = 50000;
        const objects = new core_1.RulesRunner(reg).objectsToCheck(reg.getObjects());
        const rules = reg.getConfig().getEnabledRules();
        while (iteration <= MAX_ITERATIONS) {
            let changed = 0;
            for (const rule of rules) {
                while (iteration <= MAX_ITERATIONS) {
                    const before = Date.now();
                    rule.initialize(reg);
                    let issues = [];
                    for (const obj of objects) {
                        issues.push(...rule.run(obj));
                    }
                    issues = new core_1.RulesRunner(reg).excludeIssues(issues);
                    iteration++;
                    const applied = this.applyList(issues, reg);
                    const appliedCount = applied.files.length;
                    const runtime = Date.now() - before;
                    if ((extra === null || extra === void 0 ? void 0 : extra.quiet) !== true) {
                        process.stderr.write(`\tIteration ${iteration.toString().padStart(3, " ")}, ${appliedCount.toString().padStart(3, " ")} fixes applied, ${runtime.toString().padStart(4, " ")}ms, rule ${rule.getMetadata().key}\n`);
                        if ((extra === null || extra === void 0 ? void 0 : extra.extraInfo) === true) {
                            for (const i of applied.appliedIssues) {
                                process.stderr.write("\t\t" + i.getKey() + ": " + i.getMessage() + "\n");
                            }
                        }
                    }
                    if (appliedCount > 0) {
                        changed += appliedCount;
                        const before = Date.now();
                        reg.parse();
                        const runtime = Date.now() - before;
                        if ((extra === null || extra === void 0 ? void 0 : extra.quiet) !== true) {
                            process.stderr.write(`\tParse, ${runtime}ms\n`);
                        }
                    }
                    else {
                        break;
                    }
                }
            }
            if (changed === 0) {
                break;
            }
        }
        this.writeChangesToFS(fs, reg);
        this.clearSyntaxCache(reg);
    }
    ///////////////////////////////////////////////////
    clearSyntaxCache(reg) {
        for (const obj of reg.getObjects()) {
            if (obj instanceof core_1.ABAPObject) {
                obj.setDirty();
            }
        }
    }
    writeChangesToFS(fs, reg) {
        for (const filename of this.changedFiles.values()) {
            const file = reg.getFileByName(filename);
            if (file === undefined) {
                continue;
            }
            fs.writeFileSync(file.getFilename(), file.getRaw());
        }
    }
    possibleOverlap(edit, list) {
        // only checks if the edits have changes in the same rows
        for (const e of list) {
            for (const file1 of Object.keys(e)) {
                for (const file2 of Object.keys(edit)) {
                    if (file1 === file2) {
                        for (const list1 of e[file1]) {
                            for (const list2 of edit[file2]) {
                                if (list2.range.start.getRow() <= list1.range.start.getRow()
                                    && list2.range.end.getRow() >= list1.range.start.getRow()) {
                                    return true;
                                }
                                if (list2.range.start.getRow() <= list1.range.end.getRow()
                                    && list2.range.end.getRow() >= list1.range.end.getRow()) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
        }
        return false;
    }
    applyList(issues, reg) {
        const edits = [];
        const appliedIssues = [];
        for (const i of issues) {
            const edit = i.getDefaultFix();
            if (edit === undefined) {
                continue;
            }
            else if (this.possibleOverlap(edit, edits) === true) {
                continue;
            }
            appliedIssues.push(i);
            edits.push(edit);
        }
        /*
        if (edits.length > 0) {
          console.log("EDITS:");
          for (const e of edits) {
            for (const filename of Object.keys(e)) {
              console.log("\t" + filename);
              for (const i of e[filename]) {
                console.dir(i.range);
                console.dir(i.newText);
              }
            }
          }
        }
        */
        const changed = (0, core_1.applyEditList)(reg, edits);
        for (const filename of changed) {
            this.changedFiles.add(filename);
        }
        return {
            files: changed,
            appliedIssues: appliedIssues,
        };
    }
}
exports.ApplyFixes = ApplyFixes;
//# sourceMappingURL=fixes.js.map

/***/ }),

/***/ "./build/src/formatters/_format.js":
/*!*****************************************!*\
  !*** ./build/src/formatters/_format.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Formatter = void 0;
const Formatters = __webpack_require__(/*! . */ "./build/src/formatters/index.js");
class Formatter {
    static format(issues, format, fileCount) {
        // todo, this can be done more generic, move to artifacts.ts?
        switch (format) {
            case "total":
                return new Formatters.Total().output(issues, fileCount);
            case "json":
                return new Formatters.Json().output(issues, fileCount);
            case "junit":
                return new Formatters.Junit().output(issues, fileCount);
            case "codeframe":
                return new Formatters.CodeFrame().output(issues, fileCount);
            case "checkstyle":
                return new Formatters.Checkstyle().output(issues, fileCount);
            case "sonarqube":
                return new Formatters.Sonarqube().output(issues, fileCount);
            case "codeclimate":
                return new Formatters.CodeClimate().output(issues, fileCount);
            default:
                return new Formatters.Standard().output(issues, fileCount);
        }
    }
}
exports.Formatter = Formatter;
//# sourceMappingURL=_format.js.map

/***/ }),

/***/ "./build/src/formatters/checkstyle.js":
/*!********************************************!*\
  !*** ./build/src/formatters/checkstyle.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Checkstyle = void 0;
const xml_js_1 = __webpack_require__(/*! xml-js */ "./node_modules/xml-js/lib/index.js");
class Checkstyle {
    output(issues, _fileCount) {
        const outputObj = {
            _declaration: {
                _attributes: {
                    version: "1.0",
                    encoding: "UTF-8",
                },
            },
            checkstyle: {
                _attributes: {
                    version: "8.36",
                },
                file: [],
            },
        };
        if (issues.length > 0) {
            for (const issue of issues) {
                outputObj.checkstyle.file.push({
                    _attributes: {
                        name: issue.getFilename(),
                    },
                    error: {
                        _attributes: {
                            line: issue.getStart().getRow(),
                            column: issue.getStart().getCol(),
                            severity: issue.getSeverity().toString(),
                            message: issue.getMessage(),
                            source: "abaplint",
                        },
                    },
                });
            }
        }
        const xml = (0, xml_js_1.js2xml)(outputObj, { compact: true, spaces: 2 });
        return xml;
    }
}
exports.Checkstyle = Checkstyle;
//# sourceMappingURL=checkstyle.js.map

/***/ }),

/***/ "./build/src/formatters/codeclimate.js":
/*!*********************************************!*\
  !*** ./build/src/formatters/codeclimate.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeClimate = void 0;
const node_crypto_1 = __webpack_require__(/*! node:crypto */ "node:crypto");
function md5(content) {
    return (0, node_crypto_1.createHash)("md5").update(content).digest("hex");
}
class CodeClimate {
    output(issues, _fileCount) {
        const out = [];
        const defaultSeverity = "info";
        const severityArray = ["info", "minor", "major", "critical", "blocker"];
        for (const issue of issues) {
            const single = {
                type: "issue",
                check_name: issue.getKey(),
                description: issue.getMessage(),
                categories: ["Code Quality"],
                location: {
                    path: issue.getFilename(),
                    lines: {
                        begin: issue.getStart().getRow(),
                        end: issue.getEnd().getRow(),
                    },
                },
                severity: (severityArray.includes(issue.getSeverity().toLowerCase())) ? issue.getSeverity().toLowerCase() : defaultSeverity,
                fingerprint: md5(issue.getKey() + issue.getMessage() + issue.getFilename() + issue.getStart().getRow() + issue.getEnd().getRow()),
            };
            out.push(single);
        }
        return JSON.stringify(out) + "\n";
    }
}
exports.CodeClimate = CodeClimate;
//# sourceMappingURL=codeclimate.js.map

/***/ }),

/***/ "./build/src/formatters/codeframe.js":
/*!*******************************************!*\
  !*** ./build/src/formatters/codeframe.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeFrame = void 0;
const total_1 = __webpack_require__(/*! ./total */ "./build/src/formatters/total.js");
const fs = __webpack_require__(/*! fs */ "fs");
const chalk_1 = __webpack_require__(/*! chalk */ "./node_modules/chalk/source/index.js");
function issueSort(a, b) {
    return a.filename.localeCompare(b.filename)
        || (a.row - b.row)
        || (a.col - b.col);
}
class CodeFrame {
    constructor() {
        this.currentFilename = "";
        this.currentFileLinesCount = 0;
        this.fileContent = [];
    }
    output(issues, fileCount) {
        const builtIssues = this.convertAllIssues(issues).sort(issueSort); // Make sure it is sorted by filename for caching to work
        return [
            ...builtIssues.map(i => this.renderIssue(i)),
            (issues.length > 0 ? chalk_1.default.red(new total_1.Total().output(issues, fileCount)) : chalk_1.default.green(new total_1.Total().output(issues, fileCount))),
        ].join("\n");
    }
    convertAllIssues(issues) {
        return issues.map(i => this.convertIssue(i));
    }
    cacheFile(filename) {
        if (filename !== this.currentFilename) {
            this.currentFilename = filename;
            this.fileContent = fs.readFileSync(filename, "utf8").split(/\r?\n/);
            this.currentFileLinesCount = this.fileContent.length;
        }
    }
    renderIssue(issue) {
        this.cacheFile(issue.filename);
        const frameSize = 1;
        const lineFrom = Math.max(issue.row - frameSize, 1);
        const lineTo = Math.min(issue.row + frameSize, this.currentFileLinesCount);
        const issueLineIndex = issue.row - 1;
        const padSize = Math.ceil(Math.log10(lineTo)) + 4;
        const code = [];
        for (let lineIndex = lineFrom - 1; lineIndex < lineTo; lineIndex++) {
            const prefix = `${ /*(lineIndex === issueLineIndex) ? ">" :*/" "}${lineIndex + 1} |`.padStart(padSize);
            code.push(prefix + this.fileContent[lineIndex]);
            if (lineIndex === issueLineIndex) {
                code.push("|".padStart(padSize) + " ".repeat(issue.col - 1) + "^");
            }
        }
        const severityStr = issue.severity === "E"
            ? chalk_1.default.red(issue.severity)
            : chalk_1.default.yellow(issue.severity);
        return `[${severityStr}] ${issue.description} (${issue.issueKey}) @ ${issue.location}`
            + "\n"
            + code.map(str => chalk_1.default.grey(str)).join("\n")
            + "\n";
    }
    renderLocation(issue) {
        return issue.getFilename() + "[" + issue.getStart().getRow() + ", " + issue.getStart().getCol() + "]";
    }
    convertIssue(issue) {
        return {
            location: this.renderLocation(issue),
            description: issue.getMessage(),
            issueKey: issue.getKey(),
            filename: issue.getFilename(),
            severity: issue.getSeverity().toString().charAt(0), //E/W/I
            row: issue.getStart().getRow(),
            col: issue.getStart().getCol(),
        };
    }
}
exports.CodeFrame = CodeFrame;
//# sourceMappingURL=codeframe.js.map

/***/ }),

/***/ "./build/src/formatters/index.js":
/*!***************************************!*\
  !*** ./build/src/formatters/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./json */ "./build/src/formatters/json.js"), exports);
__exportStar(__webpack_require__(/*! ./junit */ "./build/src/formatters/junit.js"), exports);
__exportStar(__webpack_require__(/*! ./standard */ "./build/src/formatters/standard.js"), exports);
__exportStar(__webpack_require__(/*! ./total */ "./build/src/formatters/total.js"), exports);
__exportStar(__webpack_require__(/*! ./codeframe */ "./build/src/formatters/codeframe.js"), exports);
__exportStar(__webpack_require__(/*! ./checkstyle */ "./build/src/formatters/checkstyle.js"), exports);
__exportStar(__webpack_require__(/*! ./sonarqube */ "./build/src/formatters/sonarqube.js"), exports);
__exportStar(__webpack_require__(/*! ./codeclimate */ "./build/src/formatters/codeclimate.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./build/src/formatters/json.js":
/*!**************************************!*\
  !*** ./build/src/formatters/json.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Json = void 0;
class Json {
    output(issues, _fileCount) {
        const out = [];
        for (const issue of issues) {
            const single = {
                description: issue.getMessage(),
                key: issue.getKey(),
                file: issue.getFilename(),
                start: {
                    row: issue.getStart().getRow(),
                    col: issue.getStart().getCol(),
                },
                end: {
                    row: issue.getEnd().getRow(),
                    col: issue.getEnd().getCol(),
                },
                severity: issue.getSeverity(),
            };
            out.push(single);
        }
        return JSON.stringify(out) + "\n";
    }
}
exports.Json = Json;
//# sourceMappingURL=json.js.map

/***/ }),

/***/ "./build/src/formatters/junit.js":
/*!***************************************!*\
  !*** ./build/src/formatters/junit.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Junit = void 0;
const xml_js_1 = __webpack_require__(/*! xml-js */ "./node_modules/xml-js/lib/index.js");
const fs = __webpack_require__(/*! fs */ "fs");
class Junit {
    constructor() {
        this.currentFilename = "";
        this.currentFileLinesCount = 0;
        this.fileContent = [];
    }
    output(issues, _fileCount) {
        const outputObj = {
            _declaration: {
                _attributes: {
                    version: "1.0",
                    encoding: "UTF-8",
                },
            },
            testsuites: {
                testsuite: {
                    _attributes: {
                        name: "abaplint",
                        tests: issues.length || 1,
                        failures: issues.length,
                        errors: 0,
                        skipped: 0,
                    },
                    testcase: [],
                },
            },
        };
        if (issues.length > 0) {
            for (const issue of issues) {
                outputObj.testsuites.testsuite.testcase.push({
                    _attributes: {
                        classname: issue.getFilename().split(".")[0],
                        file: issue.getFilename(),
                        name: `${issue.getFilename()}: [${issue.getStart().getRow()}, ${issue.getStart().getCol()}] - ${issue.getKey()}`,
                    },
                    failure: {
                        _attributes: {
                            message: this.formatFailureMessage(issue.getMessage()),
                            type: issue.getSeverity().toString(),
                        },
                        _cdata: `${this.renderIssue(issue)}`,
                    },
                });
            }
        }
        else {
            outputObj.testsuites.testsuite.testcase.push({
                _attributes: {
                    classname: "none",
                    name: "OK",
                },
            });
        }
        const xml = (0, xml_js_1.js2xml)(outputObj, { compact: true, spaces: 2 });
        return xml;
    }
    cacheFile(filename) {
        if (filename !== this.currentFilename) {
            this.currentFilename = filename;
            this.fileContent = fs.readFileSync(filename, "utf8").split(/\r?\n/);
            this.currentFileLinesCount = this.fileContent.length;
        }
    }
    renderIssue(issue) {
        this.cacheFile(issue.getFilename());
        const frameSize = 1;
        const lineFrom = Math.max(issue.getStart().getRow() - frameSize, 1);
        const lineTo = Math.min(issue.getStart().getRow() + frameSize, this.currentFileLinesCount);
        const issueLineIndex = issue.getStart().getRow() - 1;
        const padSize = Math.ceil(Math.log10(lineTo)) + 4;
        const code = [];
        for (let lineIndex = lineFrom - 1; lineIndex < lineTo; lineIndex++) {
            const prefix = `${lineIndex + 1} | `.padStart(padSize, "0");
            code.push(prefix + this.fileContent[lineIndex]);
            if (lineIndex === issueLineIndex) {
                code.push("| ".padStart(padSize) + " ".repeat(issue.getStart().getCol() - 1) + "^");
            }
        }
        return code.map(str => str).join("\n");
    }
    formatFailureMessage(message) {
        let ret = message;
        while (ret.includes("<")) {
            ret = ret.replace("<", "&lt;");
        }
        while (ret.includes(">")) {
            ret = ret.replace(">", "&gt;");
        }
        return ret;
    }
}
exports.Junit = Junit;
//# sourceMappingURL=junit.js.map

/***/ }),

/***/ "./build/src/formatters/sonarqube.js":
/*!*******************************************!*\
  !*** ./build/src/formatters/sonarqube.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sonarqube = void 0;
class Sonarqube {
    output(issues, _fileCount) {
        const out = {};
        const issueArray = [];
        const defaultSeverity = "INFO";
        const severityArray = ["INFO", "MINOR", "MAJOR", "CRITICAL", "BLOCKER"];
        for (const issue of issues) {
            const startOffset = issue.getStart().getCol() - 1;
            const endOffset = issue.getEnd().getCol() - 2;
            const single = {
                engineId: "abaplint",
                ruleId: issue.getKey(),
                severity: (severityArray.includes(issue.getSeverity().toUpperCase())) ? issue.getSeverity().toUpperCase() : defaultSeverity,
                type: "CODE_SMELL",
                primaryLocation: {
                    message: issue.getMessage(),
                    filePath: issue.getFilename(),
                    textRange: {
                        startLine: issue.getStart().getRow(),
                        endLine: issue.getEnd().getRow(),
                        startColumn: startOffset,
                        endColumn: endOffset,
                    },
                },
                effortMinutes: 10,
            };
            if (startOffset >= endOffset) {
                delete single.primaryLocation.textRange.startColumn;
                delete single.primaryLocation.textRange.endColumn;
            }
            issueArray.push(single);
        }
        out.issues = issueArray;
        return JSON.stringify(out) + "\n";
    }
}
exports.Sonarqube = Sonarqube;
//# sourceMappingURL=sonarqube.js.map

/***/ }),

/***/ "./build/src/formatters/standard.js":
/*!******************************************!*\
  !*** ./build/src/formatters/standard.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Standard = void 0;
const total_1 = __webpack_require__(/*! ./total */ "./build/src/formatters/total.js");
class Standard {
    output(issues, fileCount) {
        const tuples = [];
        for (const issue of issues) {
            tuples.push(this.build(issue));
        }
        tuples.sort((a, b) => {
            const nameCompare = a.rawFilename.localeCompare(b.rawFilename);
            if (nameCompare === 0) {
                const rowCompare = a.startPos.getRow() - b.startPos.getRow();
                if (rowCompare === 0) {
                    return a.startPos.getCol() - b.startPos.getCol();
                }
                else {
                    return rowCompare;
                }
            }
            else {
                return nameCompare;
            }
        });
        const result = this.columns(tuples);
        return result + new total_1.Total().output(issues, fileCount);
    }
    columns(issues) {
        let max = 0;
        issues.forEach((tuple) => { if (max < tuple.filename.length) {
            max = tuple.filename.length;
        } });
        let result = "";
        issues.forEach((issue) => {
            result = result +
                this.pad(issue.filename, max - issue.filename.length) +
                issue.description +
                ` [${issue.severity.charAt(0)}]\n`; //E/W/I
        });
        return result;
    }
    pad(input, length) {
        let output = input;
        for (let i = 0; i < length; i++) {
            output = output + " ";
        }
        return output + " - ";
    }
    build(issue) {
        return {
            filename: issue.getFilename() + "[" + issue.getStart().getRow() + ", " + issue.getStart().getCol() + "]",
            description: issue.getMessage() + " (" + issue.getKey() + ")",
            startPos: issue.getStart(),
            rawFilename: issue.getFilename(),
            severity: issue.getSeverity().toString(),
        };
    }
}
exports.Standard = Standard;
//# sourceMappingURL=standard.js.map

/***/ }),

/***/ "./build/src/formatters/total.js":
/*!***************************************!*\
  !*** ./build/src/formatters/total.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Total = void 0;
class Total {
    output(issues, fileCount) {
        return "abaplint: " + issues.length + " issue(s) found, " + fileCount + " file(s) analyzed\n";
    }
}
exports.Total = Total;
//# sourceMappingURL=total.js.map

/***/ }),

/***/ "./build/src/index.js":
/*!****************************!*\
  !*** ./build/src/index.js ***!
  \****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GENERIC_ERROR = void 0;
exports.run = run;
const fs = __webpack_require__(/*! fs */ "fs");
const os = __webpack_require__(/*! os */ "os");
const path = __webpack_require__(/*! path */ "path");
const ProgressBar = __webpack_require__(/*! progress */ "./node_modules/progress/index.js");
const childProcess = __webpack_require__(/*! child_process */ "child_process");
const JSON5 = __webpack_require__(/*! json5 */ "./node_modules/json5/dist/index.mjs");
const core_1 = __webpack_require__(/*! @abaplint/core */ "./node_modules/@abaplint/core/build/src/index.js");
const _format_1 = __webpack_require__(/*! ./formatters/_format */ "./build/src/formatters/_format.js");
const file_operations_1 = __webpack_require__(/*! ./file_operations */ "./build/src/file_operations.js");
const apack_dependency_provider_1 = __webpack_require__(/*! ./apack_dependency_provider */ "./build/src/apack_dependency_provider.js");
const fixes_1 = __webpack_require__(/*! ./fixes */ "./build/src/fixes.js");
const rename_1 = __webpack_require__(/*! ./rename */ "./build/src/rename.js");
exports.GENERIC_ERROR = "generic_error";
class Progress {
    set(total, _text) {
        this.bar = new ProgressBar(":percent - :elapseds - :text", { total, renderThrottle: 100 });
    }
    async tick(text) {
        this.bar.tick({ text });
        this.bar.render();
    }
    tickSync(text) {
        this.bar.tick({ text });
        this.bar.render();
    }
}
function loadConfig(filename) {
    // possible cases:
    // a) nothing specified, using abaplint.json from cwd
    // b) nothing specified, no abaplint.json in cwd
    // c) specified and found
    // d) specified and not found => use default
    // e) supplied but a directory => use default
    let f = "";
    if (filename === undefined) {
        f = process.cwd() + path.sep + "abaplint.json";
        if (fs.existsSync(f) === false) {
            f = process.cwd() + path.sep + "abaplint.jsonc";
        }
        if (fs.existsSync(f) === false) {
            f = process.cwd() + path.sep + "abaplint.json5";
        }
        if (fs.existsSync(f) === false) {
            process.stderr.write("Using default config\n");
            return { config: core_1.Config.getDefault(), base: "." };
        }
    }
    else {
        if (fs.existsSync(filename) === false) {
            process.stderr.write("ERROR: Specified abaplint configuration file does not exist, using default config\n");
            return { config: core_1.Config.getDefault(), base: "." };
        }
        else if (fs.statSync(filename).isDirectory() === true) {
            process.stderr.write("Supply filename, not directory, using default config\n");
            return { config: core_1.Config.getDefault(), base: "." };
        }
        f = filename;
    }
    // evil hack to get JSON5 working
    if (JSON5.parse === undefined) {
        // @ts-ignore
        JSON5.parse = JSON5.default.parse;
    }
    process.stderr.write("Using config: " + f + "\n");
    const json = fs.readFileSync(f, "utf8");
    const parsed = JSON5.parse(json);
    const vers = core_1.Version;
    if (Object.keys(core_1.Version).some(v => vers[v] === parsed.syntax.version) === false) {
        throw "Error: Unknown version in abaplint.json";
    }
    return {
        config: new core_1.Config(json),
        base: path.dirname(f) === process.cwd() ? "." : path.dirname(f),
    };
}
async function loadDependencies(config, compress, bar, base) {
    let files = [];
    const deps = config.get().dependencies || [];
    const useApack = config.get().global.useApackDependencies;
    if (useApack) {
        const apackPath = path.join(base, ".apack-manifest.xml");
        if (fs.existsSync(apackPath)) {
            const apackManifest = fs.readFileSync(apackPath, "utf8");
            deps.push(...apack_dependency_provider_1.ApackDependencyProvider.fromManifest(apackManifest));
        }
    }
    if (!deps) {
        return [];
    }
    for (const d of deps) {
        if (d.folder) {
            const g = base + d.folder + d.files;
            const names = file_operations_1.FileOperations.loadFileNames(g, false);
            if (names.length > 0) {
                process.stderr.write("Using dependency from: " + g + "\n");
                files = files.concat(await file_operations_1.FileOperations.loadFiles(compress, names, bar));
                continue;
            }
        }
        if (d.url) {
            process.stderr.write("Clone: " + d.url + "\n");
            const dir = fs.mkdtempSync(path.join(os.tmpdir(), "abaplint-"));
            childProcess.execSync("git clone --quiet --depth 1 " + d.url + " .", { cwd: dir, stdio: "inherit" });
            const names = file_operations_1.FileOperations.loadFileNames(dir + d.files);
            files = files.concat(await file_operations_1.FileOperations.loadFiles(compress, names, bar));
            file_operations_1.FileOperations.deleteFolderRecursive(dir);
        }
    }
    return files;
}
function displayHelp() {
    // follow https://docopt.org conventions,
    return "Usage:\n" +
        "  abaplint [<abaplint.json> -f <format> -c --outformat <format> --outfile <file> --fix --file <file>] \n" +
        "  abaplint -h | --help      show this help\n" +
        "  abaplint -v | --version   show version\n" +
        "  abaplint -d | --default   show default configuration\n" +
        "\n" +
        "Options:\n" +
        "  -f, --format <format>  output format (standard, total, json, summary, junit, codeframe, checkstyle)\n" +
        "  --outformat <format>   output format, use in combination with outfile\n" +
        "  --outfile <file>       output issues to file in format\n" +
        "  --fix                  apply quick fixes to files\n" +
        "  --rename               rename object according to rules in abaplint.json\n" +
        "  -p                     output performance information\n" +
        "  -c                     compress files in memory\n" +
        "  --file                 input file, glob format\n";
}
function out(issues, length, arg) {
    const output = _format_1.Formatter.format(issues, arg.format, length);
    if (arg.outFormat && arg.outFile) {
        const fileContents = _format_1.Formatter.format(issues, arg.outFormat, length);
        fs.writeFileSync(arg.outFile, fileContents, "utf-8");
    }
    return output;
}
async function run(arg) {
    var _a, _b;
    // evil hack to get JSON5 working
    if (JSON5.parse === undefined) {
        // @ts-ignore
        JSON5.parse = JSON5.default.parse;
    }
    if (JSON5.stringify === undefined) {
        // @ts-ignore
        JSON5.stringify = JSON5.default.stringify;
    }
    let output = "";
    let issues = [];
    let reg = undefined;
    const progress = new Progress();
    if (arg.showHelp === true) {
        output = output + displayHelp();
    }
    else if (arg.showVersion === true) {
        output = output + core_1.Registry.abaplintVersion() + "\n";
    }
    else if (arg.outputDefaultConfig === true) {
        output = output + JSON.stringify(core_1.Config.getDefault().get(), undefined, 2) + "\n";
    }
    else {
        process.stderr.write("abaplint " + core_1.Registry.abaplintVersion() + "\n");
        let loaded = [];
        let deps = [];
        const { config, base } = loadConfig(arg.configFilename);
        try {
            if (config.get().global.files === undefined) {
                throw "Error: Update abaplint configuration file to latest format";
            }
            if (arg.file) {
                const files = file_operations_1.FileOperations.loadFileNames(base + arg.file);
                loaded = await file_operations_1.FileOperations.loadFiles(arg.compress, files, progress);
            }
            else {
                const configFiles = config.get().global.files;
                const filesList = Array.isArray(configFiles) ? configFiles : [configFiles];
                for (const l of filesList) {
                    const files = file_operations_1.FileOperations.loadFileNames(base + l);
                    loaded.push(...await file_operations_1.FileOperations.loadFiles(arg.compress, files, progress));
                }
            }
            deps = await loadDependencies(config, arg.compress, progress, base);
            reg = new core_1.Registry(config);
            reg.addDependencies(deps);
            reg.addFiles(loaded); // if the object exists in repo, it should take precedence over deps
            await reg.parseAsync({ progress, outputPerformance: arg.performanceInformation });
            if (arg.runFix !== true) {
                issues = issues.concat(reg.findIssues({ progress, outputPerformance: arg.performanceInformation }));
                // require('v8').writeHeapSnapshot();
            }
        }
        catch (error) {
            const file = new core_1.MemoryFile("generic", "dummy");
            const message = error.toString() + " " + ((_b = (_a = error.stack) === null || _a === void 0 ? void 0 : _a.split("\n")[1]) === null || _b === void 0 ? void 0 : _b.trim());
            const issue = core_1.Issue.atPosition(file, new core_1.Position(1, 1), message, exports.GENERIC_ERROR);
            issues = [issue];
        }
        let extra = "";
        if (arg.runFix === true && reg) {
            await new fixes_1.ApplyFixes().applyFixes(reg, fs, { quiet: false, extraInfo: arg.performanceInformation });
            issues = [...reg.findIssues()]; // used in exercism ABAP test runner
            extra = "Fixes applied";
        }
        else if (arg.runRename === true && reg) {
            if (issues.length === 0) {
                new rename_1.Rename(reg).run(config.get(), base, fs);
                extra = "Renames applied";
            }
            else {
                extra = "Renames NOT applied, issues found";
            }
        }
        output = out(issues, loaded.length, arg) + extra;
    }
    return { output, issues, reg };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./build/src/rename.js":
/*!*****************************!*\
  !*** ./build/src/rename.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rename = void 0;
const abaplint = __webpack_require__(/*! @abaplint/core */ "./node_modules/@abaplint/core/build/src/index.js");
const path = __webpack_require__(/*! path */ "path");
const file_operations_1 = __webpack_require__(/*! ./file_operations */ "./build/src/file_operations.js");
class Rename {
    constructor(reg) {
        this.reg = reg;
        this.deletedFiles = new Set();
        this.addedFiles = new Set();
        this.updatedFiles = new Set();
    }
    run(config, base, fs, quiet) {
        const rconfig = config.rename;
        if (rconfig === undefined) {
            return;
        }
        this.skip(rconfig);
        this.rename(rconfig, quiet);
        if (rconfig.output === undefined || rconfig.output === "") {
            // write changes inline
            this.deletedFiles.forEach(f => {
                if (quiet !== true) {
                    console.log("rm " + f);
                }
                fs.rmSync(f);
            });
            this.addedFiles.forEach(f => {
                if (quiet !== true) {
                    console.log("write " + f);
                }
                const file = this.reg.getFileByName(f);
                if (file !== undefined) {
                    fs.writeFileSync(file.getFilename(), file.getRaw());
                }
            });
            this.updatedFiles.forEach(f => {
                if (quiet !== true) {
                    console.log("update " + f);
                }
                const file = this.reg.getFileByName(f);
                if (file !== undefined) {
                    fs.writeFileSync(file.getFilename(), file.getRaw());
                }
            });
        }
        else {
            // output full registry contents to output folder
            this.write(rconfig, base, fs);
        }
    }
    ////////////////////////
    write(rconfig, base, fs) {
        const outputFolder = base + path.sep + rconfig.output;
        console.log("Base: " + base);
        console.log("Output folder: " + outputFolder);
        file_operations_1.FileOperations.deleteFolderRecursive(outputFolder);
        for (const o of this.reg.getObjects()) {
            if (this.reg.isDependency(o) === true) {
                continue;
            }
            for (const f of o.getFiles()) {
                const n = outputFolder + f.getFilename().replace(base, "");
                console.log("Write " + n);
                fs.mkdirSync(path.dirname(n), { recursive: true });
                fs.writeFileSync(n, f.getRaw());
            }
        }
    }
    rename(rconfig, quiet) {
        const renamer = new abaplint.Rename(this.reg);
        for (const o of this.reg.getObjects()) {
            if (this.reg.isDependency(o) === true) {
                continue;
            }
            for (const p of rconfig.patterns || []) {
                if (!(o.getType().match(p.type))) {
                    continue;
                }
                const regex = new RegExp(p.oldName, "i");
                const match = regex.exec(o.getName());
                if (!match) {
                    continue;
                }
                const newStr = o.getName().replace(regex, p.newName);
                if (quiet !== true) {
                    console.log("Renaming " + o.getType() + " " + o.getName().padEnd(30, " ") + " -> " + newStr);
                }
                const result = renamer.rename(o.getType(), o.getName(), newStr);
                result.updatedFiles.forEach(f => { this.updatedFiles.add(f); });
                result.deletedFiles.forEach(f => { this.deletedFiles.add(f); });
                result.addedFiles.forEach(f => { this.addedFiles.add(f); });
            }
        }
    }
    skip(rconfig) {
        if (rconfig.skip) {
            for (const s of rconfig.skip) {
                const all = [];
                for (const f of this.reg.getFiles()) {
                    all.push(f);
                }
                for (const n of all) {
                    if (n.getFilename().match(s)) {
                        console.log(n.getFilename() + " skipped");
                        this.reg.removeFile(n);
                    }
                }
            }
            this.reg.parse();
        }
    }
}
exports.Rename = Rename;
//# sourceMappingURL=rename.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Lexer = void 0;
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const virtual_position_1 = __webpack_require__(/*! ../../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const tokens_1 = __webpack_require__(/*! ./tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const lexer_buffer_1 = __webpack_require__(/*! ./lexer_buffer */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_buffer.js");
const lexer_stream_1 = __webpack_require__(/*! ./lexer_stream */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_stream.js");
class Lexer {
    constructor() {
        this.ModeNormal = 1;
        this.ModePing = 2;
        this.ModeStr = 3;
        this.ModeTemplate = 4;
        this.ModeComment = 5;
        this.ModePragma = 6;
    }
    run(file, virtual) {
        this.virtual = virtual;
        this.tokens = [];
        this.m = this.ModeNormal;
        this.process(file.getRaw());
        return { file, tokens: this.tokens };
    }
    add() {
        const s = this.buffer.get().trim();
        if (s.length > 0) {
            const col = this.stream.getCol();
            const row = this.stream.getRow();
            let whiteBefore = false;
            if (this.stream.getOffset() - s.length >= 0) {
                const prev = this.stream.getRaw().substr(this.stream.getOffset() - s.length, 1);
                if (prev === " " || prev === "\n" || prev === "\t" || prev === ":") {
                    whiteBefore = true;
                }
            }
            let whiteAfter = false;
            const next = this.stream.nextChar();
            if (next === " " || next === "\n" || next === "\t" || next === ":" || next === "," || next === "." || next === "" || next === "\"") {
                whiteAfter = true;
            }
            let pos = new position_1.Position(row, col - s.length);
            if (this.virtual) {
                pos = new virtual_position_1.VirtualPosition(this.virtual, pos.getRow(), pos.getCol());
            }
            let tok = undefined;
            if (this.m === this.ModeComment) {
                tok = new tokens_1.Comment(pos, s);
            }
            else if (this.m === this.ModePing || this.m === this.ModeStr) {
                tok = new tokens_1.StringToken(pos, s);
            }
            else if (this.m === this.ModeTemplate) {
                const first = s.charAt(0);
                const last = s.charAt(s.length - 1);
                if (first === "|" && last === "|") {
                    tok = new tokens_1.StringTemplate(pos, s);
                }
                else if (first === "|" && last === "{" && whiteAfter === true) {
                    tok = new tokens_1.StringTemplateBegin(pos, s);
                }
                else if (first === "}" && last === "|" && whiteBefore === true) {
                    tok = new tokens_1.StringTemplateEnd(pos, s);
                }
                else if (first === "}" && last === "{" && whiteAfter === true && whiteBefore === true) {
                    tok = new tokens_1.StringTemplateMiddle(pos, s);
                }
                else {
                    tok = new tokens_1.Identifier(pos, s);
                }
            }
            else if (s.length > 2 && s.substr(0, 2) === "##") {
                tok = new tokens_1.Pragma(pos, s);
            }
            else if (s.length === 1) {
                if (s === "." || s === ",") {
                    tok = new tokens_1.Punctuation(pos, s);
                }
                else if (s === "[") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WBracketLeftW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WBracketLeft(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.BracketLeftW(pos, s);
                    }
                    else {
                        tok = new tokens_1.BracketLeft(pos, s);
                    }
                }
                else if (s === "(") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WParenLeftW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WParenLeft(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.ParenLeftW(pos, s);
                    }
                    else {
                        tok = new tokens_1.ParenLeft(pos, s);
                    }
                }
                else if (s === "]") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WBracketRightW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WBracketRight(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.BracketRightW(pos, s);
                    }
                    else {
                        tok = new tokens_1.BracketRight(pos, s);
                    }
                }
                else if (s === ")") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WParenRightW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WParenRight(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.ParenRightW(pos, s);
                    }
                    else {
                        tok = new tokens_1.ParenRight(pos, s);
                    }
                }
                else if (s === "-") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WDashW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WDash(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.DashW(pos, s);
                    }
                    else {
                        tok = new tokens_1.Dash(pos, s);
                    }
                }
                else if (s === "+") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WPlusW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WPlus(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.PlusW(pos, s);
                    }
                    else {
                        tok = new tokens_1.Plus(pos, s);
                    }
                }
                else if (s === "@") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WAtW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WAt(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.AtW(pos, s);
                    }
                    else {
                        tok = new tokens_1.At(pos, s);
                    }
                }
            }
            else if (s.length === 2) {
                if (s === "->") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WInstanceArrowW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WInstanceArrow(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.InstanceArrowW(pos, s);
                    }
                    else {
                        tok = new tokens_1.InstanceArrow(pos, s);
                    }
                }
                else if (s === "=>") {
                    if (whiteBefore === true && whiteAfter === true) {
                        tok = new tokens_1.WStaticArrowW(pos, s);
                    }
                    else if (whiteBefore === true) {
                        tok = new tokens_1.WStaticArrow(pos, s);
                    }
                    else if (whiteAfter === true) {
                        tok = new tokens_1.StaticArrowW(pos, s);
                    }
                    else {
                        tok = new tokens_1.StaticArrow(pos, s);
                    }
                }
            }
            if (tok === undefined) {
                tok = new tokens_1.Identifier(pos, s);
            }
            this.tokens.push(tok);
        }
        this.buffer.clear();
    }
    process(raw) {
        this.stream = new lexer_stream_1.LexerStream(raw.replace(/\r/g, ""));
        this.buffer = new lexer_buffer_1.LexerBuffer();
        const splits = {};
        splits[" "] = true;
        splits[":"] = true;
        splits["."] = true;
        splits[","] = true;
        splits["-"] = true;
        splits["+"] = true;
        splits["("] = true;
        splits[")"] = true;
        splits["["] = true;
        splits["]"] = true;
        splits["\t"] = true;
        splits["\n"] = true;
        const bufs = {};
        bufs["."] = true;
        bufs[","] = true;
        bufs[":"] = true;
        bufs["("] = true;
        bufs[")"] = true;
        bufs["["] = true;
        bufs["]"] = true;
        bufs["+"] = true;
        bufs["@"] = true;
        for (;;) {
            const current = this.stream.currentChar();
            const buf = this.buffer.add(current);
            const ahead = this.stream.nextChar();
            const aahead = this.stream.nextNextChar();
            if (this.m === this.ModeNormal) {
                if (splits[ahead]) {
                    this.add();
                }
                else if (ahead === "'") {
                    // start string
                    this.add();
                    this.m = this.ModeStr;
                }
                else if (ahead === "|" || ahead === "}") {
                    // start template
                    this.add();
                    this.m = this.ModeTemplate;
                }
                else if (ahead === "`") {
                    // start ping
                    this.add();
                    this.m = this.ModePing;
                }
                else if (aahead === "##") {
                    // start pragma
                    this.add();
                    this.m = this.ModePragma;
                }
                else if (ahead === "\""
                    || (ahead === "*" && current === "\n")) {
                    // start comment
                    this.add();
                    this.m = this.ModeComment;
                }
                else if (ahead === "@" && buf.trim().length === 0) {
                    this.add();
                }
                else if (aahead === "->"
                    || aahead === "=>") {
                    this.add();
                }
                else if (current === ">"
                    && ahead !== " "
                    && (this.stream.prevChar() === "-" || this.stream.prevChar() === "=")) {
                    // arrows
                    this.add();
                }
                else if (buf.length === 1
                    && (bufs[buf]
                        || (buf === "-" && ahead !== ">"))) {
                    this.add();
                }
            }
            else if (this.m === this.ModePragma && (ahead === "," || ahead === ":" || ahead === "." || ahead === " " || ahead === "\n")) {
                // end of pragma
                this.add();
                this.m = this.ModeNormal;
            }
            else if (this.m === this.ModePing
                && buf.length > 1
                && current === "`"
                && aahead !== "``"
                && ahead !== "`"
                && this.buffer.countIsEven("`")) {
                // end of ping
                this.add();
                if (ahead === `"`) {
                    this.m = this.ModeComment;
                }
                else {
                    this.m = this.ModeNormal;
                }
            }
            else if (this.m === this.ModeTemplate
                && buf.length > 1
                && (current === "|" || current === "{")
                && (this.stream.prevChar() !== "\\" || this.stream.prevPrevChar() === "\\\\")) {
                // end of template
                this.add();
                this.m = this.ModeNormal;
            }
            else if (this.m === this.ModeTemplate
                && ahead === "}"
                && current !== "\\") {
                this.add();
            }
            else if (this.m === this.ModeStr
                && current === "'"
                && buf.length > 1
                && aahead !== "''"
                && ahead !== "'"
                && this.buffer.countIsEven("'")) {
                // end of string
                this.add();
                if (ahead === "\"") {
                    this.m = this.ModeComment;
                }
                else {
                    this.m = this.ModeNormal;
                }
            }
            else if (ahead === "\n" && this.m !== this.ModeTemplate) {
                this.add();
                this.m = this.ModeNormal;
            }
            else if (this.m === this.ModeTemplate && current === "\n") {
                this.add();
            }
            if (!this.stream.advance()) {
                break;
            }
        }
        this.add();
    }
}
exports.Lexer = Lexer;
//# sourceMappingURL=lexer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_buffer.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_buffer.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LexerBuffer = void 0;
class LexerBuffer {
    constructor() {
        this.buf = "";
    }
    add(s) {
        this.buf = this.buf + s;
        return this.buf;
    }
    get() {
        return this.buf;
    }
    clear() {
        this.buf = "";
    }
    countIsEven(char) {
        let count = 0;
        for (let i = 0; i < this.buf.length; i += 1) {
            if (this.buf.charAt(i) === char) {
                count += 1;
            }
        }
        return count % 2 === 0;
    }
}
exports.LexerBuffer = LexerBuffer;
//# sourceMappingURL=lexer_buffer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer_stream.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LexerStream = void 0;
class LexerStream {
    constructor(raw) {
        this.offset = -1;
        this.raw = raw;
        this.row = 0;
        this.col = 0;
    }
    advance() {
        if (this.currentChar() === "\n") {
            this.col = 1;
            this.row = this.row + 1;
        }
        if (this.offset === this.raw.length) {
            this.col = this.col - 1;
            return false;
        }
        this.col = this.col + 1;
        this.offset = this.offset + 1;
        return true;
    }
    getCol() {
        return this.col;
    }
    getRow() {
        return this.row;
    }
    prevChar() {
        if (this.offset - 1 < 0) {
            return "";
        }
        return this.raw.substr(this.offset - 1, 1);
    }
    prevPrevChar() {
        if (this.offset - 2 < 0) {
            return "";
        }
        return this.raw.substr(this.offset - 2, 2);
    }
    currentChar() {
        if (this.offset < 0) {
            return "\n"; // simulate newline at start of file to handle star(*) comments
        }
        else if (this.offset >= this.raw.length) {
            return "";
        }
        return this.raw.substr(this.offset, 1);
    }
    nextChar() {
        if (this.offset + 2 > this.raw.length) {
            return "";
        }
        return this.raw.substr(this.offset + 1, 1);
    }
    nextNextChar() {
        if (this.offset + 3 > this.raw.length) {
            return this.nextChar();
        }
        return this.raw.substr(this.offset + 1, 2);
    }
    getRaw() {
        return this.raw;
    }
    getOffset() {
        return this.offset;
    }
}
exports.LexerStream = LexerStream;
//# sourceMappingURL=lexer_stream.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractToken = void 0;
const position_1 = __webpack_require__(/*! ../../../position */ "./node_modules/@abaplint/core/build/src/position.js");
class AbstractToken {
    constructor(start, str) {
        this.start = start;
        this.str = str;
    }
    // special function, for debugging purposes, see https://github.com/abaplint/abaplint/pull/3137
    [Symbol.for("debug.description")]() {
        return `${this.constructor.name} ${this.str}`;
    }
    getStr() {
        return this.str;
    }
    getRow() {
        return this.start.getRow();
    }
    getCol() {
        return this.start.getCol();
    }
    getStart() {
        return this.start;
    }
    getEnd() {
        return new position_1.Position(this.start.getRow(), this.start.getCol() + this.str.length);
    }
}
exports.AbstractToken = AbstractToken;
//# sourceMappingURL=abstract_token.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/at.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/at.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.At = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class At extends abstract_token_1.AbstractToken {
    static railroad() {
        return "@";
    }
}
exports.At = At;
//# sourceMappingURL=at.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/atw.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/atw.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class AtW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "@ ";
    }
}
exports.AtW = AtW;
//# sourceMappingURL=atw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_left.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_left.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BracketLeft = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class BracketLeft extends abstract_token_1.AbstractToken {
    static railroad() {
        return "[";
    }
}
exports.BracketLeft = BracketLeft;
//# sourceMappingURL=bracket_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_leftw.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_leftw.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BracketLeftW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class BracketLeftW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "[ ";
    }
}
exports.BracketLeftW = BracketLeftW;
//# sourceMappingURL=bracket_leftw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_right.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_right.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BracketRight = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class BracketRight extends abstract_token_1.AbstractToken {
    static railroad() {
        return "]";
    }
}
exports.BracketRight = BracketRight;
//# sourceMappingURL=bracket_right.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_rightw.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_rightw.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BracketRightW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class BracketRightW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "] ";
    }
}
exports.BracketRightW = BracketRightW;
//# sourceMappingURL=bracket_rightw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/colon.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/colon.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Colon = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Colon extends abstract_token_1.AbstractToken {
}
exports.Colon = Colon;
//# sourceMappingURL=colon.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/comment.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/comment.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Comment = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Comment extends abstract_token_1.AbstractToken {
}
exports.Comment = Comment;
//# sourceMappingURL=comment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dash.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dash.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dash = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Dash extends abstract_token_1.AbstractToken {
    static railroad() {
        return "-";
    }
}
exports.Dash = Dash;
//# sourceMappingURL=dash.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dashw.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dashw.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DashW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class DashW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "- ";
    }
}
exports.DashW = DashW;
//# sourceMappingURL=dashw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Identifier = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Identifier extends abstract_token_1.AbstractToken {
}
exports.Identifier = Identifier;
//# sourceMappingURL=identifier.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./at */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/at.js"), exports);
__exportStar(__webpack_require__(/*! ./atw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/atw.js"), exports);
__exportStar(__webpack_require__(/*! ./wat */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wat.js"), exports);
__exportStar(__webpack_require__(/*! ./watw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/watw.js"), exports);
__exportStar(__webpack_require__(/*! ./bracket_left */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_left.js"), exports);
__exportStar(__webpack_require__(/*! ./wbracket_left */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_left.js"), exports);
__exportStar(__webpack_require__(/*! ./bracket_leftw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_leftw.js"), exports);
__exportStar(__webpack_require__(/*! ./wbracket_leftw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_leftw.js"), exports);
__exportStar(__webpack_require__(/*! ./bracket_right */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_right.js"), exports);
__exportStar(__webpack_require__(/*! ./wbracket_right */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_right.js"), exports);
__exportStar(__webpack_require__(/*! ./bracket_rightw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/bracket_rightw.js"), exports);
__exportStar(__webpack_require__(/*! ./wbracket_rightw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_rightw.js"), exports);
__exportStar(__webpack_require__(/*! ./instance_arrow */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arrow.js"), exports);
__exportStar(__webpack_require__(/*! ./winstance_arrow */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arrow.js"), exports);
__exportStar(__webpack_require__(/*! ./instance_arroww */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arroww.js"), exports);
__exportStar(__webpack_require__(/*! ./winstance_arroww */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arroww.js"), exports);
__exportStar(__webpack_require__(/*! ./paren_left */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_left.js"), exports);
__exportStar(__webpack_require__(/*! ./wparen_left */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_left.js"), exports);
__exportStar(__webpack_require__(/*! ./paren_leftw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_leftw.js"), exports);
__exportStar(__webpack_require__(/*! ./wparen_leftw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_leftw.js"), exports);
__exportStar(__webpack_require__(/*! ./paren_right */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_right.js"), exports);
__exportStar(__webpack_require__(/*! ./wparen_right */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_right.js"), exports);
__exportStar(__webpack_require__(/*! ./paren_rightw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_rightw.js"), exports);
__exportStar(__webpack_require__(/*! ./wparen_rightw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_rightw.js"), exports);
__exportStar(__webpack_require__(/*! ./dash */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dash.js"), exports);
__exportStar(__webpack_require__(/*! ./wdash */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdash.js"), exports);
__exportStar(__webpack_require__(/*! ./dashw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dashw.js"), exports);
__exportStar(__webpack_require__(/*! ./wdashw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdashw.js"), exports);
__exportStar(__webpack_require__(/*! ./plus */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plus.js"), exports);
__exportStar(__webpack_require__(/*! ./wplus */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplus.js"), exports);
__exportStar(__webpack_require__(/*! ./plusw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plusw.js"), exports);
__exportStar(__webpack_require__(/*! ./wplusw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplusw.js"), exports);
__exportStar(__webpack_require__(/*! ./static_arrow */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arrow.js"), exports);
__exportStar(__webpack_require__(/*! ./wstatic_arrow */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arrow.js"), exports);
__exportStar(__webpack_require__(/*! ./static_arroww */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arroww.js"), exports);
__exportStar(__webpack_require__(/*! ./wstatic_arroww */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arroww.js"), exports);
__exportStar(__webpack_require__(/*! ./string */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template_begin */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template_end */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_end.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template_middle */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_middle.js"), exports);
__exportStar(__webpack_require__(/*! ./colon */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/colon.js"), exports);
__exportStar(__webpack_require__(/*! ./comment */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/comment.js"), exports);
__exportStar(__webpack_require__(/*! ./identifier */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js"), exports);
__exportStar(__webpack_require__(/*! ./pragma */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/pragma.js"), exports);
__exportStar(__webpack_require__(/*! ./punctuation */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/punctuation.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arrow.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arrow.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceArrow = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class InstanceArrow extends abstract_token_1.AbstractToken {
    static railroad() {
        return "->";
    }
}
exports.InstanceArrow = InstanceArrow;
//# sourceMappingURL=instance_arrow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arroww.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/instance_arroww.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InstanceArrowW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class InstanceArrowW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "-> ";
    }
}
exports.InstanceArrowW = InstanceArrowW;
//# sourceMappingURL=instance_arroww.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_left.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_left.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParenLeft = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class ParenLeft extends abstract_token_1.AbstractToken {
    static railroad() {
        return "(";
    }
}
exports.ParenLeft = ParenLeft;
//# sourceMappingURL=paren_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_leftw.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_leftw.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParenLeftW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class ParenLeftW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "( ";
    }
}
exports.ParenLeftW = ParenLeftW;
//# sourceMappingURL=paren_leftw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_right.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_right.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParenRight = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class ParenRight extends abstract_token_1.AbstractToken {
    static railroad() {
        return ")";
    }
}
exports.ParenRight = ParenRight;
//# sourceMappingURL=paren_right.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_rightw.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/paren_rightw.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParenRightW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class ParenRightW extends abstract_token_1.AbstractToken {
    static railroad() {
        return ") ";
    }
}
exports.ParenRightW = ParenRightW;
//# sourceMappingURL=paren_rightw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plus.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plus.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Plus = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Plus extends abstract_token_1.AbstractToken {
    static railroad() {
        return "+";
    }
}
exports.Plus = Plus;
//# sourceMappingURL=plus.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plusw.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/plusw.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PlusW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class PlusW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "+ ";
    }
}
exports.PlusW = PlusW;
//# sourceMappingURL=plusw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/pragma.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/pragma.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pragma = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Pragma extends abstract_token_1.AbstractToken {
}
exports.Pragma = Pragma;
//# sourceMappingURL=pragma.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/punctuation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/punctuation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Punctuation = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class Punctuation extends abstract_token_1.AbstractToken {
}
exports.Punctuation = Punctuation;
//# sourceMappingURL=punctuation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arrow.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arrow.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticArrow = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StaticArrow extends abstract_token_1.AbstractToken {
    static railroad() {
        return "=>";
    }
}
exports.StaticArrow = StaticArrow;
//# sourceMappingURL=static_arrow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arroww.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/static_arroww.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticArrowW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StaticArrowW extends abstract_token_1.AbstractToken {
    static railroad() {
        return "=> ";
    }
}
exports.StaticArrowW = StaticArrowW;
//# sourceMappingURL=static_arroww.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringToken = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StringToken extends abstract_token_1.AbstractToken {
}
exports.StringToken = StringToken;
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplate = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StringTemplate extends abstract_token_1.AbstractToken {
}
exports.StringTemplate = StringTemplate;
//# sourceMappingURL=string_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_begin.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_begin.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateBegin = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StringTemplateBegin extends abstract_token_1.AbstractToken {
}
exports.StringTemplateBegin = StringTemplateBegin;
//# sourceMappingURL=string_template_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_end.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_end.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateEnd = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StringTemplateEnd extends abstract_token_1.AbstractToken {
}
exports.StringTemplateEnd = StringTemplateEnd;
//# sourceMappingURL=string_template_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_middle.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_middle.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateMiddle = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class StringTemplateMiddle extends abstract_token_1.AbstractToken {
}
exports.StringTemplateMiddle = StringTemplateMiddle;
//# sourceMappingURL=string_template_middle.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wat.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wat.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WAt = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WAt extends abstract_token_1.AbstractToken {
    static railroad() {
        return " @";
    }
}
exports.WAt = WAt;
//# sourceMappingURL=wat.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/watw.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/watw.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WAtW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WAtW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " @ ";
    }
}
exports.WAtW = WAtW;
//# sourceMappingURL=watw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_left.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_left.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WBracketLeft = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WBracketLeft extends abstract_token_1.AbstractToken {
    static railroad() {
        return " [";
    }
}
exports.WBracketLeft = WBracketLeft;
//# sourceMappingURL=wbracket_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_leftw.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_leftw.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WBracketLeftW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WBracketLeftW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " [ ";
    }
}
exports.WBracketLeftW = WBracketLeftW;
//# sourceMappingURL=wbracket_leftw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_right.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_right.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WBracketRight = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WBracketRight extends abstract_token_1.AbstractToken {
    static railroad() {
        return " ]";
    }
}
exports.WBracketRight = WBracketRight;
//# sourceMappingURL=wbracket_right.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_rightw.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wbracket_rightw.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WBracketRightW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WBracketRightW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " ] ";
    }
}
exports.WBracketRightW = WBracketRightW;
//# sourceMappingURL=wbracket_rightw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdash.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdash.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WDash = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WDash extends abstract_token_1.AbstractToken {
    static railroad() {
        return " -";
    }
}
exports.WDash = WDash;
//# sourceMappingURL=wdash.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdashw.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wdashw.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WDashW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WDashW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " - ";
    }
}
exports.WDashW = WDashW;
//# sourceMappingURL=wdashw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arrow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arrow.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WInstanceArrow = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WInstanceArrow extends abstract_token_1.AbstractToken {
    static railroad() {
        return " ->";
    }
}
exports.WInstanceArrow = WInstanceArrow;
//# sourceMappingURL=winstance_arrow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arroww.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/winstance_arroww.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WInstanceArrowW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WInstanceArrowW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " -> ";
    }
}
exports.WInstanceArrowW = WInstanceArrowW;
//# sourceMappingURL=winstance_arroww.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_left.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_left.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WParenLeft = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WParenLeft extends abstract_token_1.AbstractToken {
    static railroad() {
        return " (";
    }
}
exports.WParenLeft = WParenLeft;
//# sourceMappingURL=wparen_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_leftw.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_leftw.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WParenLeftW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WParenLeftW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " ( ";
    }
}
exports.WParenLeftW = WParenLeftW;
//# sourceMappingURL=wparen_leftw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_right.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_right.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WParenRight = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WParenRight extends abstract_token_1.AbstractToken {
    static railroad() {
        return " )";
    }
}
exports.WParenRight = WParenRight;
//# sourceMappingURL=wparen_right.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_rightw.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_rightw.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WParenRightW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WParenRightW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " ) ";
    }
}
exports.WParenRightW = WParenRightW;
//# sourceMappingURL=wparen_rightw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplus.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplus.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WPlus = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WPlus extends abstract_token_1.AbstractToken {
    static railroad() {
        return " +";
    }
}
exports.WPlus = WPlus;
//# sourceMappingURL=wplus.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplusw.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wplusw.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WPlusW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WPlusW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " + ";
    }
}
exports.WPlusW = WPlusW;
//# sourceMappingURL=wplusw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arrow.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arrow.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WStaticArrow = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WStaticArrow extends abstract_token_1.AbstractToken {
    static railroad() {
        return " =>";
    }
}
exports.WStaticArrow = WStaticArrow;
//# sourceMappingURL=wstatic_arrow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arroww.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wstatic_arroww.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WStaticArrowW = void 0;
const abstract_token_1 = __webpack_require__(/*! ./abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
class WStaticArrowW extends abstract_token_1.AbstractToken {
    static railroad() {
        return " => ";
    }
}
exports.WStaticArrowW = WStaticArrowW;
//# sourceMappingURL=wstatic_arroww.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Combi = exports.Expression = void 0;
exports.str = str;
exports.regex = regex;
exports.tok = tok;
exports.seq = seq;
exports.alt = alt;
exports.altPrio = altPrio;
exports.opt = opt;
exports.optPrio = optPrio;
exports.per = per;
exports.star = star;
exports.starPrio = starPrio;
exports.plus = plus;
exports.plusPrio = plusPrio;
exports.ver = ver;
exports.verNot = verNot;
exports.failCombinator = failCombinator;
exports.failStar = failStar;
const Tokens = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const version_1 = __webpack_require__(/*! ../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const result_1 = __webpack_require__(/*! ./result */ "./node_modules/@abaplint/core/build/src/abap/2_statements/result.js");
class Regex {
    constructor(r) {
        this.regexp = r;
    }
    listKeywords() {
        return [];
    }
    getUsing() {
        return [];
    }
    run(r) {
        const result = [];
        for (const input of r) {
            if (input.remainingLength() === 0) {
                continue;
            }
            const token = input.peek();
            if (this.regexp.test(token.getStr()) === true) {
                result.push(input.shift(new nodes_1.TokenNodeRegex(token)));
            }
        }
        return result;
    }
    railroad() {
        return "Railroad.Terminal(\"" + this.regexp.source.replace(/\\/g, "\\\\") + "\")";
    }
    toStr() {
        return this.regexp.toString();
    }
    first() {
        return [""];
    }
}
class Word {
    constructor(s) {
        this.s = s.toUpperCase();
    }
    listKeywords() {
        return [this.s];
    }
    getUsing() {
        return [];
    }
    run(r) {
        const result = [];
        for (const input of r) {
            if (input.remainingLength() !== 0
                && input.peek().getStr().toUpperCase() === this.s) {
                //        console.log("match, " + this.s + result.length);
                result.push(input.shift(new nodes_1.TokenNode(input.peek())));
            }
        }
        return result;
    }
    railroad() {
        return "Railroad.Terminal('\"" + this.s + "\"')";
    }
    toStr() {
        return "\"" + this.s + "\"";
    }
    first() {
        return [this.s];
    }
}
class Token {
    constructor(s) {
        this.name = s.toUpperCase();
    }
    listKeywords() {
        return [];
    }
    getUsing() {
        return [];
    }
    run(r) {
        const result = [];
        for (const input of r) {
            if (input.remainingLength() !== 0
                && input.peek().constructor.name.toUpperCase() === this.name) {
                result.push(input.shift(new nodes_1.TokenNode(input.peek())));
            }
        }
        return result;
    }
    railroad() {
        let text = this.name;
        const toke = Tokens;
        for (const token in Tokens) {
            if (token.toUpperCase() === this.name && toke[token].railroad) {
                text = toke[token].railroad();
                break;
            }
        }
        return "Railroad.Terminal('!\"" + text + "\"')";
    }
    toStr() {
        return "Token \"" + this.name + "\"";
    }
    first() {
        return [""];
    }
}
class Vers {
    constructor(version, runnable, or) {
        this.version = version;
        this.runnable = runnable;
        this.or = or;
    }
    listKeywords() {
        return this.runnable.listKeywords();
    }
    run(r) {
        const targetVersion = Combi.getVersion();
        if (this.or && targetVersion === this.or) {
            return this.runnable.run(r);
        }
        else if (targetVersion === version_1.Version.OpenABAP) {
            if (this.version > version_1.Version.v702) {
                return [];
            }
            else {
                return this.runnable.run(r);
            }
        }
        else if (targetVersion >= this.version || targetVersion === version_1.Version.Cloud) {
            return this.runnable.run(r);
        }
        else {
            return [];
        }
    }
    getUsing() {
        return this.runnable.getUsing();
    }
    railroad() {
        let text = this.version;
        if (this.or) {
            text += " or " + this.or;
        }
        return "Railroad.Sequence(Railroad.Comment(\"" +
            text +
            "\", {}), " +
            this.runnable.railroad() +
            ")";
    }
    toStr() {
        return "Version(" + this.runnable.toStr() + ")";
    }
    first() {
        return this.runnable.first();
    }
}
class VersNot {
    constructor(version, runnable) {
        this.version = version;
        this.runnable = runnable;
    }
    listKeywords() {
        return this.runnable.listKeywords();
    }
    getUsing() {
        return this.runnable.getUsing();
    }
    run(r) {
        if (Combi.getVersion() !== this.version) {
            return this.runnable.run(r);
        }
        else {
            return [];
        }
    }
    railroad() {
        return "Railroad.Sequence(Railroad.Comment(\"not " +
            this.version +
            "\", {}), " +
            this.runnable.railroad() +
            ")";
    }
    toStr() {
        return "VersionNot(" + this.runnable.toStr() + ")";
    }
    first() {
        return this.runnable.first();
    }
}
class OptionalPriority {
    constructor(optional) {
        this.optional = optional;
    }
    listKeywords() {
        return this.optional.listKeywords();
    }
    getUsing() {
        return this.optional.getUsing();
    }
    run(r) {
        const result = [];
        for (const input of r) {
            const res = this.optional.run([input]);
            if (res.length > 1) {
                result.push(...res);
            }
            else if (res.length === 0) {
                result.push(input);
            }
            else if (res[0].remainingLength() < input.remainingLength()) {
                result.push(...res);
            }
            else {
                result.push(input);
            }
        }
        return result;
    }
    railroad() {
        return "Railroad.Optional(" + this.optional.railroad() + ")";
    }
    toStr() {
        return "opt(" + this.optional.toStr() + ")";
    }
    first() {
        return [""];
    }
}
class Optional {
    constructor(optional) {
        this.optional = optional;
    }
    listKeywords() {
        return this.optional.listKeywords();
    }
    getUsing() {
        return this.optional.getUsing();
    }
    run(r) {
        const result = [];
        for (const input of r) {
            result.push(input);
            const res = this.optional.run([input]);
            result.push(...res);
        }
        return result;
    }
    railroad() {
        return "Railroad.Optional(" + this.optional.railroad() + ")";
    }
    toStr() {
        return "opt(" + this.optional.toStr() + ")";
    }
    first() {
        return [""];
    }
}
class Star {
    constructor(sta) {
        this.sta = sta;
    }
    listKeywords() {
        return this.sta.listKeywords();
    }
    getUsing() {
        return this.sta.getUsing();
    }
    run(r) {
        let result = r;
        try {
            let res = r;
            let input = [];
            for (;;) {
                input = res;
                res = this.sta.run(input);
                if (res.length === 0) {
                    break;
                }
                if (res.length > 1000) {
                    // avoid stack overflow
                    result = result.concat(res);
                }
                else {
                    result.push(...res);
                }
            }
        }
        catch (err) {
            if (err instanceof FailStarError) {
                return result;
            }
            throw err;
        }
        //    console.dir(result);
        return result;
    }
    railroad() {
        return "Railroad.ZeroOrMore(" + this.sta.railroad() + ")";
    }
    toStr() {
        return "star(" + this.sta.toStr() + ")";
    }
    first() {
        return [""];
    }
}
class StarPriority {
    constructor(sta) {
        this.sta = sta;
    }
    listKeywords() {
        return this.sta.listKeywords();
    }
    getUsing() {
        return this.sta.getUsing();
    }
    run(r) {
        let result = r;
        let res = r;
        //    let input: Result[] = [];
        let prev;
        for (;;) {
            //      input = res;
            res = this.sta.run(res);
            if (res.length === 0) {
                if (prev !== undefined) {
                    //          console.log("star length: " + prev.length);
                    let best = Number.MAX_SAFE_INTEGER;
                    for (const p of prev) {
                        if (p.remainingLength() < best) {
                            result = [p];
                            best = p.remainingLength();
                        }
                    }
                }
                break;
            }
            prev = res;
        }
        return result;
    }
    railroad() {
        return "Railroad.ZeroOrMore(" + this.sta.railroad() + ")";
    }
    toStr() {
        return "star(" + this.sta.toStr() + ")";
    }
    first() {
        return [""];
    }
}
class Plus {
    constructor(plu) {
        this.plu = plu;
        this.sub = new Sequence([this.plu, new Star(this.plu)]);
    }
    listKeywords() {
        return this.plu.listKeywords();
    }
    getUsing() {
        return this.plu.getUsing();
    }
    run(r) {
        return this.sub.run(r);
    }
    railroad() {
        return "Railroad.OneOrMore(" + this.plu.railroad() + ")";
    }
    toStr() {
        return "plus(" + this.plu.toStr() + ")";
    }
    first() {
        return this.plu.first();
    }
}
class PlusPriority {
    constructor(plu) {
        this.plu = plu;
        this.sub = new Sequence([this.plu, new StarPriority(this.plu)]);
    }
    listKeywords() {
        return this.plu.listKeywords();
    }
    getUsing() {
        return this.plu.getUsing();
    }
    run(r) {
        return this.sub.run(r);
    }
    railroad() {
        return "Railroad.OneOrMore(" + this.plu.railroad() + ")";
    }
    toStr() {
        return "plus(" + this.plu.toStr() + ")";
    }
    first() {
        return this.plu.first();
    }
}
class Sequence {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Sequence, length error");
        }
        this.list = list;
    }
    listKeywords() {
        const ret = [];
        for (const i of this.list) {
            ret.push(...i.listKeywords());
        }
        return ret;
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    run(r) {
        let result = [];
        for (const input of r) {
            let temp = [input];
            let match = true;
            for (const sequence of this.list) {
                temp = sequence.run(temp);
                if (temp.length === 0) {
                    match = false;
                    break;
                }
            }
            if (match === true) {
                if (temp.length > 1000) {
                    // avoid stack overflow
                    result = result.concat(temp);
                }
                else {
                    result.push(...temp);
                }
            }
        }
        return result;
    }
    railroad() {
        const children = this.list.map((e) => { return e.railroad(); });
        return "Railroad.Sequence(" + children.join() + ")";
    }
    toStr() {
        let ret = "";
        for (const i of this.list) {
            ret = ret + i.toStr() + ",";
        }
        return "seq(" + ret + ")";
    }
    first() {
        return this.list[0].first();
    }
}
class WordSequence {
    constructor(stri) {
        this.words = [];
        this.stri = stri;
        const foo = this.stri.replace(/-/g, " - ");
        const split = foo.split(" ");
        for (const st of split) {
            // todo, use Dash token
            this.words.push(new Word(st));
        }
        this.seq = new Sequence(this.words);
    }
    listKeywords() {
        return [this.stri.toString()];
    }
    getUsing() {
        return [];
    }
    run(r) {
        return this.seq.run(r);
    }
    railroad() {
        return "Railroad.Terminal('\"" + this.stri + "\"')";
    }
    toStr() {
        return "str(" + this.stri + ")";
    }
    first() {
        return this.words[0].first();
    }
}
class Expression {
    constructor() {
        this.runnable = undefined;
    }
    run(r) {
        const results = [];
        if (this.runnable === undefined) {
            this.runnable = this.getRunnable();
        }
        for (const input of r) {
            const temp = this.runnable.run([input]);
            for (const t of temp) {
                let consumed = input.remainingLength() - t.remainingLength();
                if (consumed > 0) {
                    const originalLength = t.getNodes().length;
                    const children = [];
                    while (consumed > 0) {
                        const sub = t.popNode();
                        if (sub) {
                            children.push(sub);
                            consumed = consumed - sub.countTokens();
                        }
                    }
                    const re = new nodes_1.ExpressionNode(this);
                    re.setChildren(children.reverse());
                    const n = t.getNodes().slice(0, originalLength - consumed);
                    n.push(re);
                    t.setNodes(n);
                }
                results.push(t);
            }
        }
        //    console.dir(results);
        return results;
    }
    listKeywords() {
        // do not recurse, all Expressions are evaluated only on first level
        return [];
    }
    getUsing() {
        return ["expression/" + this.getName()];
    }
    getName() {
        return this.constructor.name;
    }
    railroad() {
        return "Railroad.NonTerminal('" + this.getName() + "', {href: '#/expression/" + this.getName() + "'})";
    }
    toStr() {
        return "expression(" + this.getName() + ")";
    }
    first() {
        return this.getRunnable().first();
    }
}
exports.Expression = Expression;
class Permutation {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Permutation, length error, got " + list.length);
        }
        this.list = list;
    }
    listKeywords() {
        const ret = [];
        for (const i of this.list) {
            ret.push(...i.listKeywords());
        }
        return ret;
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    run(r) {
        const result = [];
        const copy = this.list.slice();
        for (let index = 0; index < this.list.length; index++) {
            const temp = this.list[index].run(r);
            if (temp.length !== 0) {
                // match
                result.push(...temp);
                const left = copy;
                left.splice(index, 1);
                if (left.length === 1) {
                    result.push(...left[0].run(temp));
                }
                else {
                    result.push(...new Permutation(left).run(temp));
                }
            }
        }
        return result;
    }
    railroad() {
        const children = this.list.map((e) => { return e.railroad(); });
        return "Railroad.MultipleChoice(0, 'any'," + children.join() + ")";
    }
    toStr() {
        const children = this.list.map((e) => { return e.toStr(); });
        return "per(" + children.join() + ")";
    }
    first() {
        return [""];
    }
}
class FailCombinatorError extends Error {
}
class FailStarError extends Error {
}
class FailCombinator {
    listKeywords() {
        return [];
    }
    getUsing() {
        return [];
    }
    run(_r) {
        throw new FailCombinatorError();
    }
    railroad() {
        return "Railroad.Terminal('!FailCombinator')";
    }
    toStr() {
        return "fail()";
    }
    first() {
        return [];
    }
}
// Note that Plus is implemented with Star
class FailStar {
    listKeywords() {
        return [];
    }
    getUsing() {
        return [];
    }
    run(_r) {
        throw new FailStarError();
    }
    railroad() {
        return "Railroad.Terminal('!FailStar')";
    }
    toStr() {
        return "fail()";
    }
    first() {
        return [];
    }
}
class Alternative {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Alternative, length error");
        }
        this.list = list;
    }
    listKeywords() {
        const ret = [];
        for (const i of this.list) {
            ret.push(...i.listKeywords());
        }
        return ret;
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    run(r) {
        const result = [];
        for (const sequ of this.list) {
            const temp = sequ.run(r);
            result.push(...temp);
        }
        return result;
    }
    railroad() {
        const children = this.list.map((e) => { return e.railroad(); });
        return "Railroad.Choice(0, " + children.join() + ")";
    }
    toStr() {
        let ret = "";
        for (const i of this.list) {
            ret = ret + i.toStr() + ",";
        }
        return "alt(" + ret + ")";
    }
    first() {
        if (this.list.length !== 2) {
            return [""];
        }
        const f1 = this.list[0].first();
        const f2 = this.list[1].first();
        if (f1.length === 1 && f1[0] === "") {
            return f1;
        }
        if (f2.length === 1 && f2[0] === "") {
            return f2;
        }
        if (f1.length === 1 && f2.length === 1 && f1[0] === f2[0]) {
            return f1;
        }
        f1.push(...f2);
        return f1;
    }
}
// prioritized alternative, skip others if match found
class AlternativePriority {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Alternative, length error");
        }
        this.list = list;
    }
    listKeywords() {
        const ret = [];
        for (const i of this.list) {
            ret.push(...i.listKeywords());
        }
        return ret;
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    run(r) {
        const result = [];
        for (const sequ of this.list) {
            //      console.log(seq.toStr());
            const temp = sequ.run(r);
            if (temp.length > 0) {
                result.push(...temp);
                break;
            }
        }
        return result;
    }
    railroad() {
        const children = this.list.map((e) => { return e.railroad(); });
        return "Railroad.Choice(0, " + children.join() + ")";
    }
    toStr() {
        let ret = "";
        for (const i of this.list) {
            ret = ret + i.toStr() + ",";
        }
        return "alt(" + ret + ")";
    }
    first() {
        if (this.list.length !== 2) {
            return [""];
        }
        const f1 = this.list[0].first();
        const f2 = this.list[1].first();
        if (f1.length === 1 && f1[0] === "") {
            return f1;
        }
        if (f2.length === 1 && f2[0] === "") {
            return f2;
        }
        if (f1.length === 1 && f2.length === 1 && f1[0] === f2[0]) {
            return f1;
        }
        f1.push(...f2);
        return f1;
    }
}
class Combi {
    static railroad(runnable, complex = false) {
        // todo, move method to graph.js?
        let type = "Railroad.Diagram(";
        if (complex === true) {
            type = "Railroad.ComplexDiagram(";
        }
        const result = "Railroad.Diagram.INTERNAL_ALIGNMENT = 'left';\n" +
            type +
            runnable.railroad() +
            ").toString();";
        return result;
    }
    static listKeywords(runnable) {
        // todo, move these walkers of the syntax tree to some abstraction?
        let res = runnable.listKeywords();
        // remove duplicates
        res = res.filter((x, i, a) => { return a.indexOf(x) === i; });
        return res;
    }
    // assumption: no pragmas supplied in tokens input
    static run(runnable, tokens, version) {
        this.ver = version;
        const input = new result_1.Result(tokens, 0);
        try {
            const result = runnable.run([input]);
            /*
                console.log("res: " + result.length);
                for (const res of result) {
                  console.dir(res.getNodes().map(n => n.get().constructor.name));
                  console.dir(res.getNodes().map(n => n.concatTokens()));
                }
            */
            for (const res of result) {
                if (res.remainingLength() === 0) {
                    return res.getNodes();
                }
            }
        }
        catch (err) {
            if (err instanceof FailCombinatorError) {
                return undefined;
            }
            throw err;
        }
        return undefined;
    }
    static getVersion() {
        return this.ver;
    }
}
exports.Combi = Combi;
// -----------------------------------------------------------------------------
function str(s) {
    if (s.indexOf(" ") > 0 || s.indexOf("-") > 0) {
        return new WordSequence(s);
    }
    else {
        return new Word(s);
    }
}
function regex(r) {
    return new Regex(r);
}
function tok(t) {
    return new Token(t.name);
}
const expressionSingletons = {};
const stringSingletons = {};
function map(s) {
    const type = typeof s;
    if (type === "string") {
        if (stringSingletons[s] === undefined) {
            stringSingletons[s] = str(s);
        }
        return stringSingletons[s];
    }
    else if (type === "function") {
        // @ts-ignore
        const name = s.name;
        if (expressionSingletons[name] === undefined) {
            // @ts-ignore
            expressionSingletons[name] = new s();
        }
        return expressionSingletons[name];
    }
    else {
        return s;
    }
}
function seq(first, second, ...rest) {
    const list = [map(first), map(second)];
    list.push(...rest.map(map));
    return new Sequence(list);
}
function alt(first, second, ...rest) {
    const list = [map(first), map(second)];
    list.push(...rest.map(map));
    return new Alternative(list);
}
function altPrio(first, second, ...rest) {
    const list = [map(first), map(second)];
    list.push(...rest.map(map));
    return new AlternativePriority(list);
}
function opt(first) {
    return new Optional(map(first));
}
function optPrio(first) {
    return new OptionalPriority(map(first));
}
function per(first, second, ...rest) {
    const list = [map(first), map(second)];
    list.push(...rest.map(map));
    return new Permutation(list);
}
function star(first) {
    return new Star(map(first));
}
function starPrio(first) {
    return new StarPriority(map(first));
}
function plus(first) {
    return new Plus(map(first));
}
function plusPrio(first) {
    return new PlusPriority(map(first));
}
function ver(version, first, or) {
    return new Vers(version, map(first), or);
}
function verNot(version, first) {
    return new VersNot(version, map(first));
}
function failCombinator() {
    return new FailCombinator();
}
function failStar() {
    return new FailStar();
}
//# sourceMappingURL=combi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expand_macros.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expand_macros.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpandMacros = void 0;
const Statements = __webpack_require__(/*! ./statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ./expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Tokens = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _statement_1 = __webpack_require__(/*! ./statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const statement_node_1 = __webpack_require__(/*! ../nodes/statement_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/statement_node.js");
const token_node_1 = __webpack_require__(/*! ../nodes/token_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js");
const statement_parser_1 = __webpack_require__(/*! ./statement_parser */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statement_parser.js");
const memory_file_1 = __webpack_require__(/*! ../../files/memory_file */ "./node_modules/@abaplint/core/build/src/files/memory_file.js");
const lexer_1 = __webpack_require__(/*! ../1_lexer/lexer */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer.js");
const virtual_position_1 = __webpack_require__(/*! ../../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
class Macros {
    constructor(globalMacros) {
        this.macros = {};
        for (const m of globalMacros) {
            this.macros[m.toUpperCase()] = {
                statements: [],
                filename: undefined,
            };
        }
    }
    addMacro(name, contents, filename) {
        if (this.isMacro(name)) {
            return;
        }
        this.macros[name.toUpperCase()] = {
            statements: contents,
            filename: filename,
        };
    }
    getContents(name) {
        return this.macros[name.toUpperCase()].statements;
    }
    listMacroNames() {
        return Object.keys(this.macros);
    }
    isMacro(name) {
        if (this.macros[name.toUpperCase()]) {
            return true;
        }
        return false;
    }
    getMacroFilename(name) {
        return this.macros[name.toUpperCase()].filename;
    }
}
class ExpandMacros {
    // "reg" must be supplied if there are cross object macros via INCLUDE
    constructor(globalMacros, version, reg) {
        this.macros = new Macros(globalMacros);
        this.version = version;
        this.globalMacros = globalMacros;
        this.reg = reg;
    }
    find(statements, file, clear = true) {
        var _a, _b, _c;
        let nameToken = undefined;
        let start = undefined;
        let contents = [];
        const macroReferences = (_a = this.reg) === null || _a === void 0 ? void 0 : _a.getMacroReferences();
        if (clear) {
            macroReferences === null || macroReferences === void 0 ? void 0 : macroReferences.clear(file.getFilename());
        }
        for (let i = 0; i < statements.length; i++) {
            const statement = statements[i];
            const type = statement.get();
            if (type instanceof Statements.Define) {
                // todo, will this break if first token is a pragma?
                nameToken = statement.getTokens()[1];
                start = statement.getFirstToken().getStart();
                contents = [];
            }
            else if (type instanceof Statements.Include) {
                const includeName = (_b = statement.findDirectExpression(Expressions.IncludeName)) === null || _b === void 0 ? void 0 : _b.concatTokens();
                // todo, this does not take function module includes into account
                // todo, workaround for cyclic includes?
                const prog = (_c = this.reg) === null || _c === void 0 ? void 0 : _c.getObject("PROG", includeName);
                if (prog) {
                    prog.parse(this.version, this.globalMacros, this.reg);
                    const includeMainFile = prog.getMainABAPFile();
                    if (includeMainFile) {
                        // slow, this copies everything,
                        this.find([...includeMainFile.getStatements()], includeMainFile, false);
                    }
                }
            }
            else if (nameToken) {
                if (type instanceof Statements.EndOfDefinition) {
                    this.macros.addMacro(nameToken.getStr(), contents, file.getFilename());
                    macroReferences === null || macroReferences === void 0 ? void 0 : macroReferences.addDefinition({ filename: file.getFilename(), token: nameToken }, start, statement.getLastToken().getEnd());
                    nameToken = undefined;
                }
                else if (!(type instanceof _statement_1.Comment)) {
                    statements[i] = new statement_node_1.StatementNode(new _statement_1.MacroContent()).setChildren(this.tokensToNodes(statement.getTokens()));
                    contents.push(statements[i]);
                }
            }
        }
    }
    handleMacros(statements, file) {
        var _a;
        const result = [];
        let containsUnknown = false;
        const macroReferences = (_a = this.reg) === null || _a === void 0 ? void 0 : _a.getMacroReferences();
        for (const statement of statements) {
            const type = statement.get();
            if (type instanceof _statement_1.Unknown || type instanceof _statement_1.MacroCall) {
                const macroName = this.findName(statement.getTokens());
                if (macroName && this.macros.isMacro(macroName)) {
                    const filename = this.macros.getMacroFilename(macroName);
                    if (filename) {
                        macroReferences === null || macroReferences === void 0 ? void 0 : macroReferences.addReference({
                            filename: filename,
                            token: statement.getFirstToken(),
                        });
                    }
                    result.push(new statement_node_1.StatementNode(new _statement_1.MacroCall(), statement.getColon()).setChildren(this.tokensToNodes(statement.getTokens())));
                    const expanded = this.expandContents(macroName, statement);
                    const handled = this.handleMacros(expanded, file);
                    for (const e of handled.statements) {
                        result.push(e);
                    }
                    if (handled.containsUnknown === true) {
                        containsUnknown = true;
                    }
                    continue;
                }
                else {
                    containsUnknown = true;
                }
            }
            result.push(statement);
        }
        return { statements: result, containsUnknown };
    }
    //////////////
    expandContents(name, statement) {
        const contents = this.macros.getContents(name);
        if (contents === undefined || contents.length === 0) {
            return [];
        }
        let str = "";
        for (const c of contents) {
            let concat = c.concatTokens();
            if (c.getTerminator() === ",") {
                // workaround for chained statements
                concat = concat.replace(/,$/, ".");
            }
            str += concat + "\n";
        }
        const inputs = this.buildInput(statement);
        let i = 1;
        for (const input of inputs) {
            const search = "&" + i;
            const reg = new RegExp(search, "g");
            str = str.replace(reg, input);
            i++;
        }
        const file = new memory_file_1.MemoryFile("expand_macros.abap.prog", str);
        const lexerResult = new lexer_1.Lexer().run(file, statement.getFirstToken().getStart());
        const result = new statement_parser_1.StatementParser(this.version, this.reg).run([lexerResult], this.macros.listMacroNames());
        return result[0].statements;
    }
    buildInput(statement) {
        const result = [];
        const tokens = statement.getTokens();
        let build = "";
        for (let i = 1; i < tokens.length - 1; i++) {
            const now = tokens[i];
            let next = tokens[i + 1];
            if (i + 2 === tokens.length) {
                next = undefined; // dont take the punctuation
            }
            // argh, macros is a nightmare
            let end = now.getStart();
            if (end instanceof virtual_position_1.VirtualPosition) {
                end = new virtual_position_1.VirtualPosition(end, end.vrow, end.vcol + now.getStr().length);
            }
            else {
                end = now.getEnd();
            }
            if (next && next.getStart().equals(end)) {
                build += now.getStr();
            }
            else {
                build += now.getStr();
                result.push(build);
                build = "";
            }
        }
        return result;
    }
    findName(tokens) {
        let macroName = undefined;
        let previous = undefined;
        for (const i of tokens) {
            if (previous && (previous === null || previous === void 0 ? void 0 : previous.getEnd().getCol()) !== i.getStart().getCol()) {
                break;
            }
            else if (i instanceof Tokens.Identifier || i.getStr() === "-") {
                if (macroName === undefined) {
                    macroName = i.getStr();
                }
                else {
                    macroName += i.getStr();
                }
            }
            else if (i instanceof Tokens.Pragma) {
                continue;
            }
            else {
                break;
            }
            previous = i;
        }
        return macroName;
    }
    tokensToNodes(tokens) {
        const ret = [];
        for (const t of tokens) {
            ret.push(new token_node_1.TokenNode(t));
        }
        return ret;
    }
}
exports.ExpandMacros = ExpandMacros;
//# sourceMappingURL=expand_macros.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Abstract = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Abstract extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.str)("ABSTRACT");
    }
}
exports.Abstract = Abstract;
//# sourceMappingURL=abstract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract_methods.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract_methods.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractMethods = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const method_name_1 = __webpack_require__(/*! ./method_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_name.js");
class AbstractMethods extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("ABSTRACT METHODS", (0, combi_1.plusPrio)(method_name_1.MethodName));
    }
}
exports.AbstractMethods = AbstractMethods;
//# sourceMappingURL=abstract_methods.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/and_return.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/and_return.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AndReturn = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class AndReturn extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.str)("AND RETURN");
    }
}
exports.AndReturn = AndReturn;
//# sourceMappingURL=and_return.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arith_operator.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arith_operator.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArithOperator = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class ArithOperator extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WPlusW), (0, combi_1.tok)(tokens_1.WDashW), "*", "**", "/", "BIT-XOR", "BIT-AND", "BIT-OR", "DIV", "MOD");
        return ret;
    }
}
exports.ArithOperator = ArithOperator;
//# sourceMappingURL=arith_operator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Arrow = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Arrow extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.InstanceArrow), (0, combi_1.tok)(tokens_1.StaticArrow));
    }
}
exports.Arrow = Arrow;
//# sourceMappingURL=arrow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow_or_dash.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow_or_dash.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArrowOrDash = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class ArrowOrDash extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.InstanceArrow), (0, combi_1.tok)(tokens_1.StaticArrow), (0, combi_1.tok)(tokens_1.Dash));
    }
}
exports.ArrowOrDash = ArrowOrDash;
//# sourceMappingURL=arrow_or_dash.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/assign_source.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/assign_source.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssignSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const field_1 = __webpack_require__(/*! ./field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js");
const simple_source3_1 = __webpack_require__(/*! ./simple_source3 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class AssignSource extends combi_1.Expression {
    getRunnable() {
        const component = (0, combi_1.seq)("COMPONENT", (0, combi_1.alt)(simple_source3_1.SimpleSource3, (0, combi_1.ver)(version_1.Version.v740sp02, source_1.Source)), "OF STRUCTURE", source_1.Source);
        const tableField = (0, combi_1.seq)("TABLE FIELD", (0, combi_1.alt)(source_1.Source, dynamic_1.Dynamic));
        const arrow = (0, combi_1.alt)((0, combi_1.tok)(tokens_1.InstanceArrow), (0, combi_1.tok)(tokens_1.StaticArrow));
        const source = (0, combi_1.alt)((0, combi_1.seq)(source_1.Source, (0, combi_1.opt)((0, combi_1.seq)(arrow, dynamic_1.Dynamic))), component, tableField, (0, combi_1.seq)(dynamic_1.Dynamic, (0, combi_1.opt)((0, combi_1.seq)(arrow, (0, combi_1.alt)(field_1.Field, dynamic_1.Dynamic)))));
        return source;
    }
}
exports.AssignSource = AssignSource;
//# sourceMappingURL=assign_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/association_name.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/association_name.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssociationName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class AssociationName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\\_[\w]+$/);
    }
}
exports.AssociationName = AssociationName;
//# sourceMappingURL=association_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_chain.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_chain.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttributeChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const table_body_1 = __webpack_require__(/*! ./table_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js");
class AttributeChain extends combi_1.Expression {
    getRunnable() {
        const chain = (0, combi_1.seq)(_1.AttributeName, (0, combi_1.starPrio)((0, combi_1.altPrio)((0, combi_1.seq)(_1.ArrowOrDash, (0, combi_1.altPrio)("*", _1.ComponentName)), _1.TableExpression)));
        const ret = (0, combi_1.seq)(chain, (0, combi_1.optPrio)(table_body_1.TableBody), (0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength));
        return ret;
    }
}
exports.AttributeChain = AttributeChain;
//# sourceMappingURL=attribute_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttributeName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class AttributeName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(\/\w+\/)?(?!\*)[\w\d_\*\~%]+$/);
    }
}
exports.AttributeName = AttributeName;
//# sourceMappingURL=attribute_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/behavior_definition_name.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/behavior_definition_name.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BehaviorDefinitionName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class BehaviorDefinitionName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^((\w*\/\w+\/)|(\w*\/\w+\/)?[\w\*$%]+)$/);
    }
}
exports.BehaviorDefinitionName = BehaviorDefinitionName;
//# sourceMappingURL=behavior_definition_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/block_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/block_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BlockName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class BlockName extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.regex)(/^[\w%\$\*]+$/), (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^[\w%\$\*]+$/))));
        return ret;
    }
}
exports.BlockName = BlockName;
//# sourceMappingURL=block_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_options.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_options.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransformationOptions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const field_1 = __webpack_require__(/*! ./field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class CallTransformationOptions extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.seq)((0, combi_1.alt)(field_1.Field, integer_1.Integer), "=", source_1.Source);
        return (0, combi_1.plus)(field);
    }
}
exports.CallTransformationOptions = CallTransformationOptions;
//# sourceMappingURL=call_transformation_options.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_parameters.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_parameters.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransformationParameters = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const field_1 = __webpack_require__(/*! ./field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js");
class CallTransformationParameters extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.seq)((0, combi_1.alt)(field_1.Field, integer_1.Integer), "=", _1.SimpleSource3);
        return (0, combi_1.alt)((0, combi_1.plus)(field), dynamic_1.Dynamic);
    }
}
exports.CallTransformationParameters = CallTransformationParameters;
//# sourceMappingURL=call_transformation_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cast.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cast.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cast = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/let.js");
class Cast extends combi_1.Expression {
    getRunnable() {
        const rparen = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.WParenRight));
        const cast = (0, combi_1.seq)("CAST", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), (0, combi_1.optPrio)(let_1.Let), _1.Source, rparen);
        return (0, combi_1.ver)(version_1.Version.v740sp02, cast);
    }
}
exports.Cast = Cast;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_final.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_final.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassFinal = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ClassFinal extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.str)("FINAL");
    }
}
exports.ClassFinal = ClassFinal;
//# sourceMappingURL=class_final.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_friends.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_friends.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassFriends = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const class_name_1 = __webpack_require__(/*! ./class_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_name.js");
class ClassFriends extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.optPrio)("GLOBAL"), "FRIENDS", (0, combi_1.plus)(class_name_1.ClassName));
    }
}
exports.ClassFriends = ClassFriends;
//# sourceMappingURL=class_friends.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_global.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_global.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassGlobal = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ClassGlobal extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.str)("PUBLIC");
    }
}
exports.ClassGlobal = ClassGlobal;
//# sourceMappingURL=class_global.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ClassName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\w*(\/\w{3,}\/)?\w+$/);
    }
}
exports.ClassName = ClassName;
//# sourceMappingURL=class_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/color.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/color.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Color = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class Color extends combi_1.Expression {
    getRunnable() {
        const eq = (0, combi_1.seq)("=", source_1.Source);
        const integers = (0, combi_1.altPrio)("1", "2", "3", "4", "5", "6", "7");
        const texts = (0, combi_1.altPrio)("COL_BACKGROUND", "COL_HEADING", "COL_NORMAL", "COL_TOTAL", "COL_KEY", "COL_POSITIVE", "COL_NEGATIVE", "COL_GROUP");
        const value = (0, combi_1.alt)(eq, (0, combi_1.altPrio)("ON", "OFF", (0, combi_1.altPrio)(integers, texts)));
        const toggle = (0, combi_1.altPrio)("ON", "OFF");
        return (0, combi_1.seq)("COLOR", value, (0, combi_1.opt)(toggle));
    }
}
exports.Color = Color;
//# sourceMappingURL=color.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compare = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Compare extends combi_1.Expression {
    getRunnable() {
        const val = (0, combi_1.altPrio)(_1.FieldSub, _1.Constant);
        const list = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeft), val, (0, combi_1.plus)((0, combi_1.seq)(",", val)), (0, combi_1.tok)(tokens_1.ParenRightW));
        const inn = (0, combi_1.seq)((0, combi_1.optPrio)("NOT"), "IN", (0, combi_1.altPrio)(_1.Source, list));
        const sopt = (0, combi_1.seq)("IS", (0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)("SUPPLIED", "BOUND", (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("INSTANCE OF", _1.ClassName), version_1.Version.OpenABAP), "REQUESTED", "INITIAL"));
        const between = (0, combi_1.seq)((0, combi_1.optPrio)("NOT"), "BETWEEN", _1.Source, "AND", _1.Source);
        const predicate = (0, combi_1.ver)(version_1.Version.v740sp08, _1.MethodCallChain);
        const rett = (0, combi_1.seq)(_1.Source, (0, combi_1.altPrio)((0, combi_1.seq)(_1.CompareOperator, _1.Source), inn, between, sopt));
        const fsassign = (0, combi_1.seq)(_1.SourceFieldSymbolChain, "IS", (0, combi_1.optPrio)("NOT"), "ASSIGNED");
        const ret = (0, combi_1.seq)((0, combi_1.opt)("NOT"), (0, combi_1.altPrio)(rett, predicate, fsassign));
        return ret;
    }
}
exports.Compare = Compare;
//# sourceMappingURL=compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare_operator.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare_operator.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompareOperator = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CompareOperator extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.altPrio)("=", "<>", "><", "<", ">", "<=", ">=", "=>", "=<", "CA", "CO", "CP", "EQ", "NE", "CN", "GE", "GT", "LT", "LE", "CS", "NS", "NA", "NP", "BYTE-CO", "BYTE-CA", "BYTE-CS", "BYTE-CN", "BYTE-NA", "BYTE-NS", "O", // hex comparison operator
        "Z", // hex comparison operator
        "M");
        return operator;
    }
}
exports.CompareOperator = CompareOperator;
//# sourceMappingURL=compare_operator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const table_body_1 = __webpack_require__(/*! ./table_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js");
class ComponentChain extends combi_1.Expression {
    getRunnable() {
        const chain = (0, combi_1.seq)(_1.ComponentName, (0, combi_1.star)((0, combi_1.altPrio)((0, combi_1.seq)(_1.ArrowOrDash, (0, combi_1.altPrio)("*", _1.ComponentName)), _1.TableExpression)));
        const ret = (0, combi_1.seq)(chain, (0, combi_1.optPrio)(table_body_1.TableBody), (0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength));
        return ret;
    }
}
exports.ComponentChain = ComponentChain;
//# sourceMappingURL=component_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain_simple.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain_simple.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentChainSimple = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ComponentChainSimple extends combi_1.Expression {
    getRunnable() {
        const chain = (0, combi_1.seq)(_1.ComponentName, (0, combi_1.starPrio)((0, combi_1.seq)(_1.ArrowOrDash, _1.ComponentName)));
        const ret = (0, combi_1.seq)(chain, (0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength));
        return ret;
    }
}
exports.ComponentChainSimple = ComponentChainSimple;
//# sourceMappingURL=component_chain_simple.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCompare = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ComponentCompare extends combi_1.Expression {
    getRunnable() {
        const val = (0, combi_1.alt)(_1.FieldSub, _1.Constant);
        const list = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeft), val, (0, combi_1.plus)((0, combi_1.seq)(",", val)), (0, combi_1.tok)(tokens_1.ParenRightW));
        const inn = (0, combi_1.seq)((0, combi_1.opt)("NOT"), "IN", (0, combi_1.altPrio)(_1.Source, list));
        const sopt = (0, combi_1.seq)("IS", (0, combi_1.opt)("NOT"), (0, combi_1.altPrio)("SUPPLIED", "BOUND", (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("INSTANCE OF", _1.Source)), "REQUESTED", "ASSIGNED", "INITIAL"));
        const between = (0, combi_1.seq)((0, combi_1.opt)("NOT"), "BETWEEN", _1.Source, "AND", _1.Source);
        const rett = (0, combi_1.seq)(_1.ComponentChainSimple, (0, combi_1.altPrio)((0, combi_1.seq)(_1.CompareOperator, _1.Source), inn, between, sopt));
        const ret = (0, combi_1.seq)((0, combi_1.opt)("NOT"), rett);
        return ret;
    }
}
exports.ComponentCompare = ComponentCompare;
//# sourceMappingURL=component_compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_simple.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_simple.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCompareSimple = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const component_chain_simple_1 = __webpack_require__(/*! ./component_chain_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain_simple.js");
class ComponentCompareSimple extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)(component_chain_simple_1.ComponentChainSimple, _1.Dynamic), "=", _1.Source);
        return (0, combi_1.plus)(ret);
    }
}
exports.ComponentCompareSimple = ComponentCompareSimple;
//# sourceMappingURL=component_compare_simple.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_single.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_single.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCompareSingle = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const component_chain_simple_1 = __webpack_require__(/*! ./component_chain_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain_simple.js");
class ComponentCompareSingle extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)(component_chain_simple_1.ComponentChainSimple, _1.Dynamic), "=", _1.Source);
        return ret;
    }
}
exports.ComponentCompareSingle = ComponentCompareSingle;
//# sourceMappingURL=component_compare_single.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCond = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ComponentCond extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.alt)("AND", "OR");
        const cnd = (0, combi_1.alt)(_1.ComponentCompare, _1.ComponentCondSub);
        const ret = (0, combi_1.seq)(cnd, (0, combi_1.star)((0, combi_1.seq)(operator, cnd)));
        return ret;
    }
}
exports.ComponentCond = ComponentCond;
//# sourceMappingURL=component_cond.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond_sub.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond_sub.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCondSub = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ComponentCondSub extends combi_1.Expression {
    getRunnable() {
        const another = (0, combi_1.seq)((0, combi_1.opt)("NOT"), (0, combi_1.tok)(tokens_1.WParenLeftW), _1.ComponentCond, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRightW)));
        return another;
    }
}
exports.ComponentCondSub = ComponentCondSub;
//# sourceMappingURL=component_cond_sub.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ComponentName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(\/\w+\/)?[\w\d_%$\*\~]+$/);
    }
}
exports.ComponentName = ComponentName;
//# sourceMappingURL=component_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/concatenated_constant.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/concatenated_constant.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConcatenatedConstant = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ConcatenatedConstant extends combi_1.Expression {
    getRunnable() {
        const str = (0, combi_1.seq)((0, combi_1.regex)(/^`.*`$/), (0, combi_1.plusPrio)((0, combi_1.seq)("&", (0, combi_1.regex)(/^`.*`$/))));
        const char = (0, combi_1.seq)((0, combi_1.regex)(/^'.*'$/), (0, combi_1.plusPrio)((0, combi_1.seq)("&", (0, combi_1.regex)(/^'.*'$/))));
        return (0, combi_1.altPrio)(str, char);
    }
}
exports.ConcatenatedConstant = ConcatenatedConstant;
//# sourceMappingURL=concatenated_constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cond = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const cond_sub_1 = __webpack_require__(/*! ./cond_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_sub.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Cond extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.altPrio)("AND", "OR", (0, combi_1.ver)(version_1.Version.v702, "EQUIV"));
        const cnd = (0, combi_1.altPrio)(_1.Compare, cond_sub_1.CondSub);
        const ret = (0, combi_1.seq)(cnd, (0, combi_1.starPrio)((0, combi_1.seq)(operator, cnd)));
        return ret;
    }
}
exports.Cond = Cond;
//# sourceMappingURL=cond.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_body.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_body.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CondBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class CondBody extends combi_1.Expression {
    getRunnable() {
        const when = (0, combi_1.seq)("WHEN", (0, combi_1.altPrio)(_1.Cond, _1.Source), "THEN", (0, combi_1.altPrio)(_1.Throw, _1.Source));
        const elsee = (0, combi_1.seq)("ELSE", (0, combi_1.altPrio)(_1.Throw, _1.Source));
        return (0, combi_1.seq)((0, combi_1.optPrio)(_1.Let), (0, combi_1.plusPrio)(when), (0, combi_1.optPrio)(elsee));
    }
}
exports.CondBody = CondBody;
//# sourceMappingURL=cond_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_sub.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_sub.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CondSub = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class CondSub extends combi_1.Expression {
    getRunnable() {
        // rule ParserMissingSpace makes sure the whitespace is correct
        const another = (0, combi_1.seq)((0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenLeftW), (0, combi_1.tok)(tokens_1.WParenLeft)), _1.Cond, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRightW)));
        return another;
    }
}
exports.CondSub = CondSub;
//# sourceMappingURL=cond_sub.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constant = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Constant extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)(_1.TextElementString, _1.ConcatenatedConstant, _1.ConstantString, _1.Integer);
    }
}
exports.Constant = Constant;
//# sourceMappingURL=constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_field_length.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_field_length.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantFieldLength = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ConstantFieldLength extends combi_1.Expression {
    getRunnable() {
        const length = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.altPrio)(_1.Integer, _1.SimpleFieldChain), (0, combi_1.tok)(tokens_1.ParenRightW));
        return length;
    }
}
exports.ConstantFieldLength = ConstantFieldLength;
//# sourceMappingURL=constant_field_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_string.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_string.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantString = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ConstantString extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^('.*')|(`.*`)$/);
    }
}
exports.ConstantString = ConstantString;
//# sourceMappingURL=constant_string.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/conv_body.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/conv_body.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConvBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ConvBody extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.optPrio)(_1.Let), _1.Source);
    }
}
exports.ConvBody = ConvBody;
//# sourceMappingURL=conv_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/corresponding_body.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/corresponding_body.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CorrespondingBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const component_chain_1 = __webpack_require__(/*! ./component_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain.js");
class CorrespondingBody extends combi_1.Expression {
    getRunnable() {
        const mapping = (0, combi_1.seq)("MAPPING", (0, combi_1.plus)((0, combi_1.seq)(_1.ComponentName, "=", component_chain_1.ComponentChain)));
        const baseParen = (0, combi_1.seq)("BASE", (0, combi_1.tok)(tokens_1.WParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const discarding = (0, combi_1.ver)(version_1.Version.v751, "DISCARDING DUPLICATES");
        return (0, combi_1.seq)((0, combi_1.optPrio)("DEEP"), (0, combi_1.optPrio)(baseParen), _1.Source, (0, combi_1.optPrio)(discarding), (0, combi_1.optPrio)(mapping), (0, combi_1.optPrio)((0, combi_1.seq)("EXCEPT", (0, combi_1.alt)((0, combi_1.plus)(_1.Field), "*"))));
    }
}
exports.CorrespondingBody = CorrespondingBody;
//# sourceMappingURL=corresponding_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/data_definition.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/data_definition.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class DataDefinition extends combi_1.Expression {
    getRunnable() {
        const simple = (0, combi_1.opt)((0, combi_1.per)("READ-ONLY", Expressions.Type, Expressions.Length, Expressions.Decimals, Expressions.Value));
        const table = (0, combi_1.seq)(Expressions.TypeTable, (0, combi_1.optPrio)("READ-ONLY"));
        return (0, combi_1.seq)(Expressions.DefinitionName, (0, combi_1.optPrio)(Expressions.ConstantFieldLength), (0, combi_1.alt)(simple, table, Expressions.TypeStructure));
    }
}
exports.DataDefinition = DataDefinition;
//# sourceMappingURL=data_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_connection.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_connection.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseConnection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class DatabaseConnection extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.regex)(/[\w\/]+/);
        return (0, combi_1.seq)("CONNECTION", (0, combi_1.altPrio)(name, _1.Dynamic));
    }
}
exports.DatabaseConnection = DatabaseConnection;
//# sourceMappingURL=database_connection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_table.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_table.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseTable = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
class DatabaseTable extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)(dynamic_1.Dynamic, (0, combi_1.regex)(/^\*?(\/\w+\/)?\w+$/));
    }
}
exports.DatabaseTable = DatabaseTable;
//# sourceMappingURL=database_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/decimals.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/decimals.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Decimals = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Decimals extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)("DECIMALS", _1.Integer);
        return ret;
    }
}
exports.Decimals = Decimals;
//# sourceMappingURL=decimals.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/default.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/default.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Default extends combi_1.Expression {
    getRunnable() {
        // todo, DEFAULT is only valid for definitions in relation to method parameters
        const def = (0, combi_1.seq)("DEFAULT", (0, combi_1.altPrio)(_1.Constant, _1.FieldChain));
        return def;
    }
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/definition_name.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/definition_name.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class DefinitionName extends combi_1.Expression {
    getRunnable() {
        const r = (0, combi_1.regex)(/^((\w*\/\w+\/)|(\w*\/\w+\/)?[\w\*$%]+)$/);
        return (0, combi_1.seq)(r, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.optPrio)(r))), (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.DashW)));
    }
}
exports.DefinitionName = DefinitionName;
//# sourceMappingURL=definition_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dereference = void 0;
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Dereference extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), "*");
    }
}
exports.Dereference = Dereference;
//# sourceMappingURL=dereference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/destination.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/destination.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Destination = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Destination extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("DESTINATION", (0, combi_1.optPrio)("IN GROUP"), (0, combi_1.altPrio)("DEFAULT", _1.Source));
    }
}
exports.Destination = Destination;
//# sourceMappingURL=destination.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dynamic = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Dynamic extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenLeft), (0, combi_1.tok)(tokens_1.ParenLeft)), (0, combi_1.altPrio)(_1.FieldChain, _1.Constant), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.ParenRight)));
        return ret;
    }
}
exports.Dynamic = Dynamic;
//# sourceMappingURL=dynamic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/entity_association.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/entity_association.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EntityAssociation = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EntityAssociation extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[\w]+\\_[\w]+$/);
    }
}
exports.EntityAssociation = EntityAssociation;
//# sourceMappingURL=entity_association.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_handler.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_handler.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventHandler = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class EventHandler extends combi_1.Expression {
    getRunnable() {
        const event = (0, combi_1.seq)("FOR EVENT", _1.EventName, "OF", _1.ClassName, (0, combi_1.optPrio)((0, combi_1.seq)("IMPORTING", (0, combi_1.plusPrio)(_1.MethodParamName))));
        return event;
    }
}
exports.EventHandler = EventHandler;
//# sourceMappingURL=event_handler.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EventName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[&_!]?\*?\w*(\/\w+\/)?\d*[a-zA-Z_%\$][\w\*%\$\?#]*(~\w+)?$/);
    }
}
exports.EventName = EventName;
//# sourceMappingURL=event_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/exception_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/exception_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExceptionName = void 0;
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const field_1 = __webpack_require__(/*! ./field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js");
/** non class based exception name */
class ExceptionName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(field_1.Field, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), field_1.Field)));
    }
}
exports.ExceptionName = ExceptionName;
//# sourceMappingURL=exception_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Field = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Field extends combi_1.Expression {
    getRunnable() {
        // "&1" can be used for almost anything(field names, method names etc.) in macros
        // field names with only digits should not be possible
        return (0, combi_1.regex)(/^[&_!]?\*?\w*(\/\w+\/)?\d*[a-zA-Z_%\$][\w\*%\$\?#]*(~\w+)?$/);
    }
}
exports.Field = Field;
//# sourceMappingURL=field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_all.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_all.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldAll = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class FieldAll extends combi_1.Expression {
    getRunnable() {
        // "&1" can be used for almost anything(field names, method names etc.) in macros
        // field names with only digits should not be possible
        return (0, combi_1.regex)(/^&?\*?(\/\w+\/)?[\w\*\$]+(~\w+)?$/);
    }
}
exports.FieldAll = FieldAll;
//# sourceMappingURL=field_all.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_assignment.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_assignment.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldAssignment = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const field_sub_1 = __webpack_require__(/*! ./field_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_sub.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class FieldAssignment extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)(field_sub_1.FieldSub, "=", source_1.Source);
        return ret;
    }
}
exports.FieldAssignment = FieldAssignment;
//# sourceMappingURL=field_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FieldChain extends combi_1.Expression {
    getRunnable() {
        const attr = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), _1.AttributeName);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.optPrio)(_1.ComponentName));
        const chain = (0, combi_1.star)((0, combi_1.altPrio)(_1.Dereference, attr, comp, _1.TableExpression));
        const clas = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow), _1.AttributeName);
        const start = (0, combi_1.altPrio)(clas, _1.SourceField, _1.SourceFieldSymbol);
        const after = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.DashW), (0, combi_1.seq)((0, combi_1.optPrio)(_1.TableBody), (0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength)));
        const ret = (0, combi_1.seq)(start, chain, after);
        return ret;
    }
}
exports.FieldChain = FieldChain;
//# sourceMappingURL=field_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_length.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_length.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldLength = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FieldLength extends combi_1.Expression {
    getRunnable() {
        const normal = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.Plus)), (0, combi_1.altPrio)((0, combi_1.regex)(/^\d+$/), _1.SimpleFieldChain2));
        const length = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.altPrio)(normal, "*"), (0, combi_1.tok)(tokens_1.ParenRightW));
        return length;
    }
}
exports.FieldLength = FieldLength;
//# sourceMappingURL=field_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_offset.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_offset.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldOffset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FieldOffset extends combi_1.Expression {
    getRunnable() {
        const offset = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Plus), (0, combi_1.altPrio)((0, combi_1.regex)(/^\d+$/), _1.SimpleFieldChain2));
        return offset;
    }
}
exports.FieldOffset = FieldOffset;
//# sourceMappingURL=field_offset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_sub.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_sub.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldSub = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const table_body_1 = __webpack_require__(/*! ./table_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js");
class FieldSub extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.regex)(/^\*?!?(\/\w+\/)?[a-zA-Z_%$][\w%$\$\*]*$/), (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^[\w%$\$\*]+$/))), (0, combi_1.opt)(table_body_1.TableBody));
        return ret;
    }
}
exports.FieldSub = FieldSub;
//# sourceMappingURL=field_sub.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_symbol.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_symbol.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldSymbol = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FieldSymbol extends combi_1.Expression {
    getRunnable() {
        // todo, this only allows one dash in the name
        const dashes = (0, combi_1.seq)((0, combi_1.regex)(/^<[\w\/%$\*]+$/), (0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^[\w\/%$\*]+>$/));
        return (0, combi_1.altPrio)((0, combi_1.regex)(/^<[\w\/%$\*]+>$/), dashes);
    }
}
exports.FieldSymbol = FieldSymbol;
//# sourceMappingURL=field_symbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/filter_body.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/filter_body.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FilterBody extends combi_1.Expression {
    getRunnable() {
        const inn = (0, combi_1.seq)("IN", _1.Source);
        const using = (0, combi_1.seq)("USING KEY", _1.SimpleName);
        return (0, combi_1.seq)(_1.Source, (0, combi_1.optPrio)("EXCEPT"), (0, combi_1.optPrio)((0, combi_1.per)(inn, using)), (0, combi_1.seq)("WHERE", _1.ComponentCond));
    }
}
exports.FilterBody = FilterBody;
//# sourceMappingURL=filter_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/final_methods.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/final_methods.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FinalMethods = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const method_name_1 = __webpack_require__(/*! ./method_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_name.js");
class FinalMethods extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("FINAL METHODS", (0, combi_1.plus)(method_name_1.MethodName));
    }
}
exports.FinalMethods = FinalMethods;
//# sourceMappingURL=final_methods.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/find_type.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/find_type.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FindType = void 0;
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class FindType extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.opt)((0, combi_1.alt)("REGEX", "SUBSTRING", (0, combi_1.ver)(version_1.Version.v755, "PCRE", version_1.Version.OpenABAP)));
    }
}
exports.FindType = FindType;
//# sourceMappingURL=find_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/for.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/for.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.For = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js");
class For extends combi_1.Expression {
    getRunnable() {
        const where = (0, combi_1.seq)("WHERE (", _1.ComponentCond, ")");
        const from = (0, combi_1.seq)("FROM", _1.Source);
        const to = (0, combi_1.seq)("TO", _1.Source);
        const inn = (0, combi_1.seq)(_1.InlineLoopDefinition, (0, combi_1.optPrio)(from), (0, combi_1.optPrio)(to), (0, combi_1.optPrio)(where));
        const then = (0, combi_1.seq)("THEN", _1.Source);
        const whil = (0, combi_1.seq)((0, combi_1.altPrio)("UNTIL", "WHILE"), _1.Cond);
        const itera = (0, combi_1.seq)(_1.InlineFieldDefinition, (0, combi_1.opt)(then), whil);
        const groupBy = (0, combi_1.seq)("GROUP BY", (0, combi_1.alt)(field_chain_1.FieldChain, (0, combi_1.seq)("(", (0, combi_1.plus)(_1.LoopGroupByComponent), ")")), (0, combi_1.opt)((0, combi_1.seq)((0, combi_1.alt)("ASCENDING", "DESCENDING"), (0, combi_1.opt)("AS TEXT"))), (0, combi_1.opt)("WITHOUT MEMBERS"));
        const t = (0, combi_1.alt)(_1.TargetField, _1.TargetFieldSymbol);
        const groups = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.seq)("GROUPS", t, "OF", t, "IN", _1.Source, (0, combi_1.optPrio)(groupBy)));
        const f = (0, combi_1.seq)("FOR", (0, combi_1.alt)(itera, inn, groups), (0, combi_1.optPrio)(_1.Let));
        return (0, combi_1.ver)(version_1.Version.v740sp05, f);
    }
}
exports.For = For;
//# sourceMappingURL=for.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_changing.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_changing.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormChanging = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormChanging extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("CHANGING", (0, combi_1.plus)(_1.FormParam));
    }
}
exports.FormChanging = FormChanging;
//# sourceMappingURL=form_changing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_name.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_name.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FormName extends combi_1.Expression {
    getRunnable() {
        // todo, does not handle namespaces properly
        return (0, combi_1.seq)((0, combi_1.regex)(/^[\w%$\*\/\?]+$/), (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.optPrio)((0, combi_1.regex)(/^\w+$/)))), (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.DashW)));
    }
}
exports.FormName = FormName;
//# sourceMappingURL=form_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormParam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormParam extends combi_1.Expression {
    getRunnable() {
        const stru = (0, combi_1.seq)("STRUCTURE", _1.SimpleFieldChain);
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)(_1.PassByValue, _1.FormParamName), (0, combi_1.optPrio)((0, combi_1.altPrio)(_1.FormParamType, stru)));
        return ret;
    }
}
exports.FormParam = FormParam;
//# sourceMappingURL=form_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_name.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_name.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormParamName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FormParamName extends combi_1.Expression {
    getRunnable() {
        const r = (0, combi_1.regex)(/^[\w$&\*%\/]+$/);
        // dashes in form parameter names allowed, intention is not to support this
        // but avoid the structural errors
        return (0, combi_1.seq)(r, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), r)));
    }
}
exports.FormParamName = FormParamName;
//# sourceMappingURL=form_param_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_type.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_type.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormParamType = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormParamType extends combi_1.Expression {
    getRunnable() {
        const def = (0, combi_1.seq)("DEFAULT", (0, combi_1.alt)(_1.Constant, _1.FieldChain));
        const table = (0, combi_1.seq)((0, combi_1.alt)("STANDARD", "HASHED", "INDEX", "SORTED", "ANY"), "TABLE");
        const tabseq = (0, combi_1.seq)(table, (0, combi_1.optPrio)((0, combi_1.seq)("OF", _1.TypeName)));
        const ret = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.alt)("REF TO", "LINE OF")), _1.TypeName, (0, combi_1.opt)(def));
        const like = (0, combi_1.seq)("LIKE", (0, combi_1.optPrio)((0, combi_1.alt)("REF TO", "LINE OF")), _1.FieldChain);
        return (0, combi_1.alt)((0, combi_1.seq)("TYPE", (0, combi_1.altPrio)(tabseq, ret)), like);
    }
}
exports.FormParamType = FormParamType;
//# sourceMappingURL=form_param_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_raising.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_raising.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormRaising = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FormRaising extends combi_1.Expression {
    getRunnable() {
        const resume = (0, combi_1.seq)("RESUMABLE", (0, combi_1.tok)(tokens_1.ParenLeft), _1.ClassName, (0, combi_1.tok)(tokens_1.ParenRightW));
        const raising = (0, combi_1.seq)("RAISING", (0, combi_1.plus)((0, combi_1.alt)(_1.ClassName, resume)));
        return raising;
    }
}
exports.FormRaising = FormRaising;
//# sourceMappingURL=form_raising.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_tables.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_tables.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormTables = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormTables extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("TABLES", (0, combi_1.plus)(_1.FormParam));
    }
}
exports.FormTables = FormTables;
//# sourceMappingURL=form_tables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_using.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_using.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormUsing = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormUsing extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("USING", (0, combi_1.plus)(_1.FormParam));
    }
}
exports.FormUsing = FormUsing;
//# sourceMappingURL=form_using.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/fstarget.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/fstarget.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FSTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FSTarget extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)(_1.InlineFS, _1.TargetFieldSymbol);
    }
}
exports.FSTarget = FSTarget;
//# sourceMappingURL=fstarget.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionExporting = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FunctionExporting extends combi_1.Expression {
    getRunnable() {
        const exp = (0, combi_1.plusPrio)(_1.FunctionExportingParameter);
        return exp;
    }
}
exports.FunctionExporting = FunctionExporting;
//# sourceMappingURL=function_exporting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting_parameter.js":
/*!*************************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting_parameter.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionExportingParameter = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const parameter_name_1 = __webpack_require__(/*! ./parameter_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_name.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const simple_source3_1 = __webpack_require__(/*! ./simple_source3 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js");
class FunctionExportingParameter extends combi_1.Expression {
    getRunnable() {
        const s = (0, combi_1.altPrio)((0, combi_1.ver)(version_1.Version.v740sp02, source_1.Source), simple_source3_1.SimpleSource3);
        const exp = (0, combi_1.seq)(parameter_name_1.ParameterName, "=", s);
        return exp;
    }
}
exports.FunctionExportingParameter = FunctionExportingParameter;
//# sourceMappingURL=function_exporting_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_name.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_name.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FunctionName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)(_1.Constant, _1.FieldChain);
    }
}
exports.FunctionName = FunctionName;
//# sourceMappingURL=function_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_parameters.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_parameters.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionParameters = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FunctionParameters extends combi_1.Expression {
    getRunnable() {
        const exporting = (0, combi_1.seq)("EXPORTING", _1.FunctionExporting);
        const importing = (0, combi_1.seq)("IMPORTING", _1.ParameterListT);
        const changing = (0, combi_1.seq)("CHANGING", _1.ParameterListT);
        const tables = (0, combi_1.seq)("TABLES", _1.ParameterListT);
        const exceptions = (0, combi_1.seq)("EXCEPTIONS", (0, combi_1.optPrio)((0, combi_1.altPrio)(_1.ParameterListExceptions, _1.Field)));
        const long = (0, combi_1.seq)((0, combi_1.optPrio)(exporting), (0, combi_1.optPrio)(importing), (0, combi_1.optPrio)(tables), (0, combi_1.optPrio)(changing), (0, combi_1.optPrio)(exceptions));
        return long;
    }
}
exports.FunctionParameters = FunctionParameters;
//# sourceMappingURL=function_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/include_name.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/include_name.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncludeName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class IncludeName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.regex)(/^<?(\/\w+\/)?[\w%]+(~\w+)?>?$/), (0, combi_1.optPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^\w+$/))));
    }
}
exports.IncludeName = IncludeName;
//# sourceMappingURL=include_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./abstract_methods */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract_methods.js"), exports);
__exportStar(__webpack_require__(/*! ./abstract */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/abstract.js"), exports);
__exportStar(__webpack_require__(/*! ./and_return */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/and_return.js"), exports);
__exportStar(__webpack_require__(/*! ./arith_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arith_operator.js"), exports);
__exportStar(__webpack_require__(/*! ./arrow_or_dash */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow_or_dash.js"), exports);
__exportStar(__webpack_require__(/*! ./arrow */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/arrow.js"), exports);
__exportStar(__webpack_require__(/*! ./assign_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/assign_source.js"), exports);
__exportStar(__webpack_require__(/*! ./association_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/association_name.js"), exports);
__exportStar(__webpack_require__(/*! ./attribute_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js"), exports);
__exportStar(__webpack_require__(/*! ./behavior_definition_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/behavior_definition_name.js"), exports);
__exportStar(__webpack_require__(/*! ./block_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/block_name.js"), exports);
__exportStar(__webpack_require__(/*! ./call_transformation_options */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_options.js"), exports);
__exportStar(__webpack_require__(/*! ./call_transformation_parameters */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/call_transformation_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./cast */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cast.js"), exports);
__exportStar(__webpack_require__(/*! ./class_final */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_final.js"), exports);
__exportStar(__webpack_require__(/*! ./class_friends */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_friends.js"), exports);
__exportStar(__webpack_require__(/*! ./class_global */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_global.js"), exports);
__exportStar(__webpack_require__(/*! ./class_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_name.js"), exports);
__exportStar(__webpack_require__(/*! ./color */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/color.js"), exports);
__exportStar(__webpack_require__(/*! ./compare_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare_operator.js"), exports);
__exportStar(__webpack_require__(/*! ./compare */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/compare.js"), exports);
__exportStar(__webpack_require__(/*! ./component_chain_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain_simple.js"), exports);
__exportStar(__webpack_require__(/*! ./component_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./component_compare_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_simple.js"), exports);
__exportStar(__webpack_require__(/*! ./component_compare_single */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_single.js"), exports);
__exportStar(__webpack_require__(/*! ./component_compare */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare.js"), exports);
__exportStar(__webpack_require__(/*! ./component_cond_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond_sub.js"), exports);
__exportStar(__webpack_require__(/*! ./component_cond */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_cond.js"), exports);
__exportStar(__webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_name.js"), exports);
__exportStar(__webpack_require__(/*! ./concatenated_constant */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/concatenated_constant.js"), exports);
__exportStar(__webpack_require__(/*! ./cond_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_body.js"), exports);
__exportStar(__webpack_require__(/*! ./cond_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond_sub.js"), exports);
__exportStar(__webpack_require__(/*! ./cond */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/cond.js"), exports);
__exportStar(__webpack_require__(/*! ./constant_field_length */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_field_length.js"), exports);
__exportStar(__webpack_require__(/*! ./constant_string */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_string.js"), exports);
__exportStar(__webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant.js"), exports);
__exportStar(__webpack_require__(/*! ./conv_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/conv_body.js"), exports);
__exportStar(__webpack_require__(/*! ./corresponding_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/corresponding_body.js"), exports);
__exportStar(__webpack_require__(/*! ./data_definition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/data_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./database_connection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_connection.js"), exports);
__exportStar(__webpack_require__(/*! ./database_table */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/database_table.js"), exports);
__exportStar(__webpack_require__(/*! ./decimals */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/decimals.js"), exports);
__exportStar(__webpack_require__(/*! ./default */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/default.js"), exports);
__exportStar(__webpack_require__(/*! ./definition_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/definition_name.js"), exports);
__exportStar(__webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js"), exports);
__exportStar(__webpack_require__(/*! ./destination */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/destination.js"), exports);
__exportStar(__webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js"), exports);
__exportStar(__webpack_require__(/*! ./entity_association */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/entity_association.js"), exports);
__exportStar(__webpack_require__(/*! ./entity_association */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/entity_association.js"), exports);
__exportStar(__webpack_require__(/*! ./event_handler */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_handler.js"), exports);
__exportStar(__webpack_require__(/*! ./event_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/event_name.js"), exports);
__exportStar(__webpack_require__(/*! ./exception_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/exception_name.js"), exports);
__exportStar(__webpack_require__(/*! ./field_all */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_all.js"), exports);
__exportStar(__webpack_require__(/*! ./field_assignment */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_assignment.js"), exports);
__exportStar(__webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./field_length */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_length.js"), exports);
__exportStar(__webpack_require__(/*! ./field_offset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_offset.js"), exports);
__exportStar(__webpack_require__(/*! ./field_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_sub.js"), exports);
__exportStar(__webpack_require__(/*! ./field_symbol */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_symbol.js"), exports);
__exportStar(__webpack_require__(/*! ./field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field.js"), exports);
__exportStar(__webpack_require__(/*! ./filter_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/filter_body.js"), exports);
__exportStar(__webpack_require__(/*! ./final_methods */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/final_methods.js"), exports);
__exportStar(__webpack_require__(/*! ./find_type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/find_type.js"), exports);
__exportStar(__webpack_require__(/*! ./for */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/for.js"), exports);
__exportStar(__webpack_require__(/*! ./form_changing */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_changing.js"), exports);
__exportStar(__webpack_require__(/*! ./form_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_name.js"), exports);
__exportStar(__webpack_require__(/*! ./form_param_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_name.js"), exports);
__exportStar(__webpack_require__(/*! ./form_param_type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param_type.js"), exports);
__exportStar(__webpack_require__(/*! ./form_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_param.js"), exports);
__exportStar(__webpack_require__(/*! ./form_raising */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_raising.js"), exports);
__exportStar(__webpack_require__(/*! ./form_tables */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_tables.js"), exports);
__exportStar(__webpack_require__(/*! ./form_using */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/form_using.js"), exports);
__exportStar(__webpack_require__(/*! ./fstarget */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/fstarget.js"), exports);
__exportStar(__webpack_require__(/*! ./function_exporting_parameter */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting_parameter.js"), exports);
__exportStar(__webpack_require__(/*! ./function_exporting */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_exporting.js"), exports);
__exportStar(__webpack_require__(/*! ./function_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_name.js"), exports);
__exportStar(__webpack_require__(/*! ./function_parameters */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/function_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./include_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/include_name.js"), exports);
__exportStar(__webpack_require__(/*! ./inline_field_definition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./inline_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field.js"), exports);
__exportStar(__webpack_require__(/*! ./inline_loop_definition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_loop_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./inlinedata */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinedata.js"), exports);
__exportStar(__webpack_require__(/*! ./inlinefs */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinefs.js"), exports);
__exportStar(__webpack_require__(/*! ./integer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/interface_name.js"), exports);
__exportStar(__webpack_require__(/*! ./kernel_id */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/kernel_id.js"), exports);
__exportStar(__webpack_require__(/*! ./language */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/language.js"), exports);
__exportStar(__webpack_require__(/*! ./length */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/length.js"), exports);
__exportStar(__webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/let.js"), exports);
__exportStar(__webpack_require__(/*! ./lob_handle */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/lob_handle.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_group_by_component */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_component.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_group_by_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_target.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_group_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_target.js"), exports);
__exportStar(__webpack_require__(/*! ./macro_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/macro_name.js"), exports);
__exportStar(__webpack_require__(/*! ./message_class */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_class.js"), exports);
__exportStar(__webpack_require__(/*! ./message_number */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_number.js"), exports);
__exportStar(__webpack_require__(/*! ./message_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_source.js"), exports);
__exportStar(__webpack_require__(/*! ./message_type_and_number */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_type_and_number.js"), exports);
__exportStar(__webpack_require__(/*! ./method_call_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_body.js"), exports);
__exportStar(__webpack_require__(/*! ./method_call_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./method_call_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_param.js"), exports);
__exportStar(__webpack_require__(/*! ./method_call */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_changing */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_changing.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_exceptions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exceptions.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_exporting */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exporting.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_importing */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_importing.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_raising */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_raising.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def_returning */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_returning.js"), exports);
__exportStar(__webpack_require__(/*! ./method_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_name.js"), exports);
__exportStar(__webpack_require__(/*! ./method_param_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_name.js"), exports);
__exportStar(__webpack_require__(/*! ./method_param_optional */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_optional.js"), exports);
__exportStar(__webpack_require__(/*! ./method_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param.js"), exports);
__exportStar(__webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./method_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_source.js"), exports);
__exportStar(__webpack_require__(/*! ./modif */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/modif.js"), exports);
__exportStar(__webpack_require__(/*! ./namespace_simple_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/namespace_simple_name.js"), exports);
__exportStar(__webpack_require__(/*! ./new_object */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/new_object.js"), exports);
__exportStar(__webpack_require__(/*! ./ole_exporting */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/ole_exporting.js"), exports);
__exportStar(__webpack_require__(/*! ./or */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/or.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_exception */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_exception.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_list_exceptions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_exceptions.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_list_s */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_s.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_list_t */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_t.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_name.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_s */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_s.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter_t */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_t.js"), exports);
__exportStar(__webpack_require__(/*! ./pass_by_value */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/pass_by_value.js"), exports);
__exportStar(__webpack_require__(/*! ./perform_changing */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_changing.js"), exports);
__exportStar(__webpack_require__(/*! ./perform_tables */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_tables.js"), exports);
__exportStar(__webpack_require__(/*! ./perform_using */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_using.js"), exports);
__exportStar(__webpack_require__(/*! ./radio_group_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/radio_group_name.js"), exports);
__exportStar(__webpack_require__(/*! ./raise_with */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/raise_with.js"), exports);
__exportStar(__webpack_require__(/*! ./read_table_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/read_table_target.js"), exports);
__exportStar(__webpack_require__(/*! ./receive_parameters */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/receive_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./redefinition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/redefinition.js"), exports);
__exportStar(__webpack_require__(/*! ./reduce_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_body.js"), exports);
__exportStar(__webpack_require__(/*! ./reduce_next */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_next.js"), exports);
__exportStar(__webpack_require__(/*! ./report_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/report_name.js"), exports);
__exportStar(__webpack_require__(/*! ./select_loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select_loop.js"), exports);
__exportStar(__webpack_require__(/*! ./select */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_field_chain2 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain2.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_name.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_source1 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source1.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_source2 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source2.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_source3 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_source4 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source4.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_target.js"), exports);
__exportStar(__webpack_require__(/*! ./source_field_symbol_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol_chain.js"), exports);
__exportStar(__webpack_require__(/*! ./source_field_symbol */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol.js"), exports);
__exportStar(__webpack_require__(/*! ./source_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field.js"), exports);
__exportStar(__webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_aggregation */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_aggregation.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_alias_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_alias_field.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_arithmetic_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetic_operator.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_arithmetics */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetics.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_as_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_as_name.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_case */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_case.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_cds_parameters */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cds_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_client */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_client.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_compare_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare_operator.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_compare */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_cond */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cond.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_field_and_value */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_and_value.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_field_list_loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list_loop.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_field_list */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_fields */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_fields.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_for_all_entries */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_for_all_entries.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_from_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from_source.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_from */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_function */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_function.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_group_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_group_by.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_having */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_having.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_hints */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_hints.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_in */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_in.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_into_list */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_list.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_into_structure */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_into_table */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_table.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_join */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_join.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_order_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_order_by.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_path */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_path.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_source_no_space */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_no_space.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_source_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_simple.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_target.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_up_to */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_up_to.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template_formatting */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_formatting.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_source.js"), exports);
__exportStar(__webpack_require__(/*! ./string_template */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template.js"), exports);
__exportStar(__webpack_require__(/*! ./super_class_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/super_class_name.js"), exports);
__exportStar(__webpack_require__(/*! ./switch_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/switch_body.js"), exports);
__exportStar(__webpack_require__(/*! ./table_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js"), exports);
__exportStar(__webpack_require__(/*! ./table_expression */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_expression.js"), exports);
__exportStar(__webpack_require__(/*! ./target_field_symbol */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field_symbol.js"), exports);
__exportStar(__webpack_require__(/*! ./target_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field.js"), exports);
__exportStar(__webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js"), exports);
__exportStar(__webpack_require__(/*! ./test_seam_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/test_seam_name.js"), exports);
__exportStar(__webpack_require__(/*! ./text_element_key */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_key.js"), exports);
__exportStar(__webpack_require__(/*! ./text_element_string */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_string.js"), exports);
__exportStar(__webpack_require__(/*! ./text_element */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element.js"), exports);
__exportStar(__webpack_require__(/*! ./throw */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/throw.js"), exports);
__exportStar(__webpack_require__(/*! ./transporting_fields */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/transporting_fields.js"), exports);
__exportStar(__webpack_require__(/*! ./type_name_or_infer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name_or_infer.js"), exports);
__exportStar(__webpack_require__(/*! ./type_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name.js"), exports);
__exportStar(__webpack_require__(/*! ./type_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_param.js"), exports);
__exportStar(__webpack_require__(/*! ./type_structure */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./type_table_key */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table_key.js"), exports);
__exportStar(__webpack_require__(/*! ./type_table */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table.js"), exports);
__exportStar(__webpack_require__(/*! ./type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type.js"), exports);
__exportStar(__webpack_require__(/*! ./value_body_line */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_line.js"), exports);
__exportStar(__webpack_require__(/*! ./value_body_lines */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_lines.js"), exports);
__exportStar(__webpack_require__(/*! ./value_body */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body.js"), exports);
__exportStar(__webpack_require__(/*! ./value */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value.js"), exports);
__exportStar(__webpack_require__(/*! ./with_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/with_name.js"), exports);
__exportStar(__webpack_require__(/*! ./write_offset_length */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/write_offset_length.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineField = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InlineField extends combi_1.Expression {
    getRunnable() {
        return new _1.Field();
    }
}
exports.InlineField = InlineField;
//# sourceMappingURL=inline_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field_definition.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_field_definition.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineFieldDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InlineFieldDefinition extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)((0, combi_1.seq)(_1.Field, "=", _1.Source), (0, combi_1.seq)(_1.Field, "TYPE", _1.TypeName));
    }
}
exports.InlineFieldDefinition = InlineFieldDefinition;
//# sourceMappingURL=inline_field_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_loop_definition.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inline_loop_definition.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineLoopDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InlineLoopDefinition extends combi_1.Expression {
    getRunnable() {
        const index = (0, combi_1.seq)("INDEX INTO", _1.TargetField);
        return (0, combi_1.seq)((0, combi_1.altPrio)(_1.TargetFieldSymbol, _1.TargetField), "IN", (0, combi_1.opt)("GROUP"), _1.Source, (0, combi_1.optPrio)(index));
    }
}
exports.InlineLoopDefinition = InlineLoopDefinition;
//# sourceMappingURL=inline_loop_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinedata.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinedata.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineData = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class InlineData extends combi_1.Expression {
    getRunnable() {
        const right = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.ParenRight));
        const left = (0, combi_1.tok)(tokens_1.ParenLeft);
        const data = (0, combi_1.seq)("DATA", left, _1.TargetField, right);
        const final = (0, combi_1.seq)("FINAL", left, _1.TargetField, right);
        return (0, combi_1.altPrio)((0, combi_1.ver)(version_1.Version.v740sp02, data), (0, combi_1.ver)(version_1.Version.v757, final));
    }
}
exports.InlineData = InlineData;
//# sourceMappingURL=inlinedata.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinefs.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/inlinefs.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineFS = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class InlineFS extends combi_1.Expression {
    getRunnable() {
        const right = (0, combi_1.tok)(tokens_1.ParenRightW);
        const left = (0, combi_1.tok)(tokens_1.ParenLeft);
        const fs = (0, combi_1.seq)("FIELD-SYMBOL", left, _1.TargetFieldSymbol, right);
        return (0, combi_1.ver)(version_1.Version.v740sp02, fs);
    }
}
exports.InlineFS = InlineFS;
//# sourceMappingURL=inlinefs.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Integer extends combi_1.Expression {
    getRunnable() {
        const modifier = (0, combi_1.optPrio)((0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WDash), (0, combi_1.tok)(tokens_1.WDashW), (0, combi_1.tok)(tokens_1.WPlus)));
        return (0, combi_1.seq)(modifier, (0, combi_1.regex)(/^\d+$/));
    }
}
exports.Integer = Integer;
//# sourceMappingURL=integer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/interface_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/interface_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class InterfaceName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\w*(\/\w{3,}\/)?\w+$/);
    }
}
exports.InterfaceName = InterfaceName;
//# sourceMappingURL=interface_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/kernel_id.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/kernel_id.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KernelId = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class KernelId extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.seq)("ID", source_1.Source, "FIELD", source_1.Source);
        return field;
    }
}
exports.KernelId = KernelId;
//# sourceMappingURL=kernel_id.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/language.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/language.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Language = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Language extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("LANGUAGE", (0, combi_1.altPrio)("SQLSCRIPT", "SQL", "GRAPH"));
    }
}
exports.Language = Language;
//# sourceMappingURL=language.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/length.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/length.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Length = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Length extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)("LENGTH", (0, combi_1.altPrio)(_1.Integer, _1.ConstantString, _1.SimpleFieldChain));
        return ret;
    }
}
exports.Length = Length;
//# sourceMappingURL=length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/let.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/let.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Let = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Let extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("LET", (0, combi_1.plusPrio)(_1.InlineFieldDefinition), "IN");
    }
}
exports.Let = Let;
//# sourceMappingURL=let.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/lob_handle.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/lob_handle.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LOBHandle = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class LOBHandle extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("WRITER FOR COLUMNS", Expressions.Field);
    }
}
exports.LOBHandle = LOBHandle;
//# sourceMappingURL=lob_handle.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopGroupBy = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
const loop_group_by_target_1 = __webpack_require__(/*! ./loop_group_by_target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_target.js");
const loop_group_by_component_1 = __webpack_require__(/*! ./loop_group_by_component */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_component.js");
class LoopGroupBy extends combi_1.Expression {
    getRunnable() {
        const components = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), (0, combi_1.plus)(loop_group_by_component_1.LoopGroupByComponent), (0, combi_1.tok)(tokens_1.WParenRightW));
        const ret = (0, combi_1.seq)((0, combi_1.alt)(source_1.Source, components), (0, combi_1.optPrio)("ASCENDING"), (0, combi_1.optPrio)("WITHOUT MEMBERS"), loop_group_by_target_1.LoopGroupByTarget);
        return ret;
    }
}
exports.LoopGroupBy = LoopGroupBy;
//# sourceMappingURL=loop_group_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_component.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_component.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopGroupByComponent = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const component_name_1 = __webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_name.js");
const component_compare_single_1 = __webpack_require__(/*! ./component_compare_single */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/component_compare_single.js");
class LoopGroupByComponent extends combi_1.Expression {
    getRunnable() {
        const groupSize = (0, combi_1.seq)(component_name_1.ComponentName, "=", "GROUP SIZE");
        const groupIndex = (0, combi_1.seq)(component_name_1.ComponentName, "=", "GROUP INDEX");
        const components = (0, combi_1.alt)(component_compare_single_1.ComponentCompareSingle, groupSize, groupIndex);
        return components;
    }
}
exports.LoopGroupByComponent = LoopGroupByComponent;
//# sourceMappingURL=loop_group_by_component.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_target.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by_target.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopGroupByTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js");
const fstarget_1 = __webpack_require__(/*! ./fstarget */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/fstarget.js");
class LoopGroupByTarget extends combi_1.Expression {
    getRunnable() {
        const into = (0, combi_1.seq)((0, combi_1.opt)("REFERENCE"), "INTO", target_1.Target);
        const assigning = (0, combi_1.seq)("ASSIGNING", fstarget_1.FSTarget);
        return (0, combi_1.optPrio)((0, combi_1.alt)(into, assigning));
    }
}
exports.LoopGroupByTarget = LoopGroupByTarget;
//# sourceMappingURL=loop_group_by_target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_target.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_target.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class LoopTarget extends combi_1.Expression {
    getRunnable() {
        const into = (0, combi_1.seq)((0, combi_1.opt)("REFERENCE"), "INTO", _1.Target);
        const assigning = (0, combi_1.seq)("ASSIGNING", _1.FSTarget);
        const target = (0, combi_1.alt)((0, combi_1.seq)((0, combi_1.alt)(into, assigning), (0, combi_1.optPrio)("CASTING")), "TRANSPORTING NO FIELDS");
        return target;
    }
}
exports.LoopTarget = LoopTarget;
//# sourceMappingURL=loop_target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/macro_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/macro_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MacroName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class MacroName extends combi_1.Expression {
    getRunnable() {
        const r = /^(\/\w+\/)?[\w\*%\?$&]+>?$/;
        return (0, combi_1.seq)((0, combi_1.regex)(r), (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(r))));
    }
}
exports.MacroName = MacroName;
//# sourceMappingURL=macro_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_class.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_class.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageClass = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class MessageClass extends combi_1.Expression {
    getRunnable() {
        // "&1" can be used for almost anything(field names, method names etc.) in macros
        return (0, combi_1.regex)(/^>?[\w\/]+#?@?\/?!?&?>?\$?$/);
    }
}
exports.MessageClass = MessageClass;
//# sourceMappingURL=message_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_number.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_number.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageNumber = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class MessageNumber extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\d\d\d$/i);
    }
}
exports.MessageNumber = MessageNumber;
//# sourceMappingURL=message_number.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_source.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_source.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MessageSource extends combi_1.Expression {
    getRunnable() {
        const msgid = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), _1.MessageClass, (0, combi_1.tok)(tokens_1.ParenRightW));
        const simple = (0, combi_1.seq)(_1.MessageTypeAndNumber, (0, combi_1.opt)(msgid));
        const mess1 = (0, combi_1.seq)("ID", _1.Source, "TYPE", _1.Source, "NUMBER", (0, combi_1.altPrio)(_1.MessageNumber, _1.Source));
        return (0, combi_1.altPrio)(simple, mess1);
    }
}
exports.MessageSource = MessageSource;
//# sourceMappingURL=message_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_type_and_number.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/message_type_and_number.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageTypeAndNumber = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class MessageTypeAndNumber extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[iweaxs]\d\d\d$/i);
    }
}
exports.MessageTypeAndNumber = MessageTypeAndNumber;
//# sourceMappingURL=message_type_and_number.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCall = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_call_param_1 = __webpack_require__(/*! ./method_call_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_param.js");
class MethodCall extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)(_1.MethodName, method_call_param_1.MethodCallParam);
        return ret;
    }
}
exports.MethodCall = MethodCall;
//# sourceMappingURL=method_call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_body.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_body.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_call_param_1 = __webpack_require__(/*! ./method_call_param */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_param.js");
class MethodCallBody extends combi_1.Expression {
    getRunnable() {
        const dynamicPar = (0, combi_1.seq)("PARAMETER-TABLE", _1.Source);
        const dynamicExc = (0, combi_1.seq)("EXCEPTION-TABLE", _1.Source);
        const dynamic = (0, combi_1.seq)(dynamicPar, (0, combi_1.optPrio)(dynamicExc));
        return (0, combi_1.alt)(method_call_param_1.MethodCallParam, _1.MethodParameters, dynamic);
    }
}
exports.MethodCallBody = MethodCallBody;
//# sourceMappingURL=method_call_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_chain.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_chain.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodCallChain extends combi_1.Expression {
    getRunnable() {
        const attr = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), _1.AttributeName);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName);
        const fields = (0, combi_1.star)((0, combi_1.altPrio)(attr, comp));
        const after = (0, combi_1.star)((0, combi_1.seq)(fields, (0, combi_1.tok)(tokens_1.InstanceArrow), _1.MethodCall));
        const localVariable = (0, combi_1.seq)(_1.FieldChain, (0, combi_1.tok)(tokens_1.InstanceArrow));
        const staticClass = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow));
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)((0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.altPrio)(localVariable, staticClass)), _1.MethodCall), _1.NewObject, _1.Cast), after);
        return ret;
    }
}
exports.MethodCallChain = MethodCallChain;
//# sourceMappingURL=method_call_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_param.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_param.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallParam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const constant_string_1 = __webpack_require__(/*! ./constant_string */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant_string.js");
class MethodCallParam extends combi_1.Expression {
    getRunnable() {
        const param = (0, combi_1.alt)(_1.Source, _1.ParameterListS, _1.MethodParameters);
        // rule ParserMissingSpace makes sure the whitespace is correct
        const right1 = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRight), (0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRight), (0, combi_1.tok)(tokens_1.ParenRightW));
        const right2 = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRight), (0, combi_1.tok)(tokens_1.WParenRightW));
        // note: make sure this does not overlap with FieldLength expression
        const ret = (0, combi_1.altPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), param, right1), (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), param, right2), (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), constant_string_1.ConstantString, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRight), (0, combi_1.tok)(tokens_1.ParenRightW))));
        return ret;
    }
}
exports.MethodCallParam = MethodCallParam;
//# sourceMappingURL=method_call_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_changing.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_changing.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefChanging = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodDefChanging extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("CHANGING", (0, combi_1.plus)(_1.MethodParamOptional));
    }
}
exports.MethodDefChanging = MethodDefChanging;
//# sourceMappingURL=method_def_changing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exceptions.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exceptions.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefExceptions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodDefExceptions extends combi_1.Expression {
    getRunnable() {
        const exceptions = (0, combi_1.seq)("EXCEPTIONS", (0, combi_1.plusPrio)(_1.NamespaceSimpleName));
        return exceptions;
    }
}
exports.MethodDefExceptions = MethodDefExceptions;
//# sourceMappingURL=method_def_exceptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exporting.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_exporting.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefExporting = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodDefExporting extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("EXPORTING", (0, combi_1.plus)(_1.MethodParam));
    }
}
exports.MethodDefExporting = MethodDefExporting;
//# sourceMappingURL=method_def_exporting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_importing.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_importing.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefImporting = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodDefImporting extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.regex)(/^!?(\/\w+\/)?\w+$/);
        return (0, combi_1.seq)("IMPORTING", (0, combi_1.plus)(_1.MethodParamOptional), (0, combi_1.optPrio)((0, combi_1.seq)("PREFERRED PARAMETER", field)));
    }
}
exports.MethodDefImporting = MethodDefImporting;
//# sourceMappingURL=method_def_importing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_raising.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_raising.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefRaising = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const class_name_1 = __webpack_require__(/*! ./class_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/class_name.js");
class MethodDefRaising extends combi_1.Expression {
    getRunnable() {
        const resumable = (0, combi_1.seq)("RESUMABLE", (0, combi_1.tok)(tokens_1.ParenLeft), class_name_1.ClassName, (0, combi_1.tok)(tokens_1.ParenRightW));
        const raising = (0, combi_1.seq)("RAISING", (0, combi_1.plus)((0, combi_1.altPrio)(resumable, class_name_1.ClassName)));
        return raising;
    }
}
exports.MethodDefRaising = MethodDefRaising;
//# sourceMappingURL=method_def_raising.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_returning.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_def_returning.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefReturning = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class MethodDefReturning extends combi_1.Expression {
    getRunnable() {
        const value = (0, combi_1.seq)("VALUE", (0, combi_1.tok)(tokens_1.ParenLeft), Expressions.MethodParamName, (0, combi_1.tok)(tokens_1.ParenRightW));
        return (0, combi_1.seq)("RETURNING", value, Expressions.TypeParam);
    }
}
exports.MethodDefReturning = MethodDefReturning;
//# sourceMappingURL=method_def_returning.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_name.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_name.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class MethodName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(\/\w+\/)?\w+(~\w+)?$/);
    }
}
exports.MethodName = MethodName;
//# sourceMappingURL=method_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class MethodParam extends combi_1.Expression {
    getRunnable() {
        const ref = (0, combi_1.seq)("REFERENCE", (0, combi_1.tok)(tokens_1.ParenLeft), Expressions.MethodParamName, (0, combi_1.tok)(tokens_1.ParenRightW));
        const value = (0, combi_1.seq)("VALUE", (0, combi_1.tok)(tokens_1.ParenLeft), Expressions.MethodParamName, (0, combi_1.tok)(tokens_1.ParenRightW));
        const fieldsOrValue = (0, combi_1.seq)((0, combi_1.altPrio)(value, ref, Expressions.MethodParamName), Expressions.TypeParam);
        return fieldsOrValue;
    }
}
exports.MethodParam = MethodParam;
//# sourceMappingURL=method_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_name.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_name.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParamName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class MethodParamName extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.regex)(/^!?\w*(\/\w+\/)?\w+$/);
        return field;
    }
}
exports.MethodParamName = MethodParamName;
//# sourceMappingURL=method_param_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_optional.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_param_optional.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParamOptional = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodParamOptional extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(_1.MethodParam, (0, combi_1.optPrio)("OPTIONAL"));
    }
}
exports.MethodParamOptional = MethodParamOptional;
//# sourceMappingURL=method_param_optional.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_parameters.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_parameters.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParameters = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodParameters extends combi_1.Expression {
    getRunnable() {
        const exporting = (0, combi_1.seq)("EXPORTING", _1.ParameterListS);
        const importing = (0, combi_1.seq)("IMPORTING", _1.ParameterListT);
        const changing = (0, combi_1.seq)("CHANGING", _1.ParameterListT);
        const receiving = (0, combi_1.seq)("RECEIVING", _1.ParameterT);
        const exceptions = (0, combi_1.seq)("EXCEPTIONS", _1.ParameterListExceptions);
        const long = (0, combi_1.seq)((0, combi_1.optPrio)(exporting), (0, combi_1.optPrio)(importing), (0, combi_1.optPrio)(changing), (0, combi_1.optPrio)(receiving), (0, combi_1.optPrio)(exceptions));
        return long;
    }
}
exports.MethodParameters = MethodParameters;
//# sourceMappingURL=method_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_source.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_source.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodSource extends combi_1.Expression {
    getRunnable() {
        // note: AttributeName can be both an attribute and a method name, the syntax check will tell
        // note: its allowed to end with MethodCall, however if this is done it will give a syntax error via syntax check
        const afterArrow = (0, combi_1.alt)(_1.AttributeName, _1.MethodCall, _1.Dynamic);
        const arrow = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.InstanceArrow), (0, combi_1.tok)(tokens_1.StaticArrow));
        const attr = (0, combi_1.seq)(arrow, afterArrow);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName);
        const attrOrComp = (0, combi_1.altPrio)(attr, comp);
        const staticClass = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow));
        const clas = (0, combi_1.seq)(staticClass, afterArrow);
        const start = (0, combi_1.seq)((0, combi_1.altPrio)(clas, _1.SourceField, _1.SourceFieldSymbol, _1.Dynamic), (0, combi_1.star)(attrOrComp));
        return start;
    }
}
exports.MethodSource = MethodSource;
//# sourceMappingURL=method_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/modif.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/modif.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Modif = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Modif extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[\w\*]{1,3}$/);
    }
}
exports.Modif = Modif;
//# sourceMappingURL=modif.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/namespace_simple_name.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/namespace_simple_name.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamespaceSimpleName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class NamespaceSimpleName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^((\w*\/\w+\/)|(\w*\/\w+\/)?[\w\*$%]+)$/);
    }
}
exports.NamespaceSimpleName = NamespaceSimpleName;
//# sourceMappingURL=namespace_simple_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/new_object.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/new_object.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewObject = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const field_assignment_1 = __webpack_require__(/*! ./field_assignment */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_assignment.js");
// note: this can also be new data reference
class NewObject extends combi_1.Expression {
    getRunnable() {
        const lines = (0, combi_1.plus)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const linesFields = (0, combi_1.plus)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), (0, combi_1.plus)(field_assignment_1.FieldAssignment), (0, combi_1.tok)(tokens_1.WParenRightW)));
        const neww = (0, combi_1.seq)("NEW", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), (0, combi_1.optPrio)((0, combi_1.alt)(_1.Source, _1.ParameterListS, lines, linesFields)), ")");
        return (0, combi_1.ver)(version_1.Version.v740sp02, neww);
    }
}
exports.NewObject = NewObject;
//# sourceMappingURL=new_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/ole_exporting.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/ole_exporting.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OLEExporting = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class OLEExporting extends combi_1.Expression {
    getRunnable() {
        const fields = (0, combi_1.seq)((0, combi_1.regex)(/^[&_!#\*]?[\w\d\*%\$\?#]+$/), "=", _1.Source);
        return (0, combi_1.seq)("EXPORTING", (0, combi_1.plus)(fields));
    }
}
exports.OLEExporting = OLEExporting;
//# sourceMappingURL=ole_exporting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/or.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/or.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Or = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Or extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("OR", _1.Source);
    }
}
exports.Or = Or;
//# sourceMappingURL=or.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_exception.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_exception.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterException = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterException extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.altPrio)("OTHERS", _1.ParameterName);
        return (0, combi_1.seq)(name, "=", (0, combi_1.altPrio)(_1.Integer, _1.SimpleFieldChain), (0, combi_1.optPrio)((0, combi_1.seq)("MESSAGE", _1.Target)));
    }
}
exports.ParameterException = ParameterException;
//# sourceMappingURL=parameter_exception.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_exceptions.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_exceptions.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterListExceptions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterListExceptions extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.plus)(_1.ParameterException);
    }
}
exports.ParameterListExceptions = ParameterListExceptions;
//# sourceMappingURL=parameter_list_exceptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_s.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_s.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterListS = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterListS extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.plus)(_1.ParameterS);
    }
}
exports.ParameterListS = ParameterListS;
//# sourceMappingURL=parameter_list_s.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_t.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_list_t.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterListT = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterListT extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.plus)(_1.ParameterT);
    }
}
exports.ParameterListT = ParameterListT;
//# sourceMappingURL=parameter_list_t.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class ParameterName extends combi_1.Expression {
    getRunnable() {
        // todo, think this can be reduced,
        return (0, combi_1.regex)(/^[&_!]?\*?\w*(\/\w+\/)?\d*[a-zA-Z_%\$][\w\*%\$\?]*(~\w+)?$/);
    }
}
exports.ParameterName = ParameterName;
//# sourceMappingURL=parameter_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_s.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_s.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterS = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterS extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(_1.ParameterName, "=", _1.Source);
    }
}
exports.ParameterS = ParameterS;
//# sourceMappingURL=parameter_s.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_t.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/parameter_t.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParameterT = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ParameterT extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(_1.ParameterName, "=", _1.Target);
    }
}
exports.ParameterT = ParameterT;
//# sourceMappingURL=parameter_t.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/pass_by_value.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/pass_by_value.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PassByValue = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class PassByValue extends combi_1.Expression {
    getRunnable() {
        const value = (0, combi_1.seq)("VALUE", (0, combi_1.tok)(tokens_1.ParenLeft), _1.FormParamName, (0, combi_1.tok)(tokens_1.ParenRightW));
        return value;
    }
}
exports.PassByValue = PassByValue;
//# sourceMappingURL=pass_by_value.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_changing.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_changing.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformChanging = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js");
class PerformChanging extends combi_1.Expression {
    getRunnable() {
        const changing = (0, combi_1.seq)("CHANGING", (0, combi_1.plus)(target_1.Target));
        return changing;
    }
}
exports.PerformChanging = PerformChanging;
//# sourceMappingURL=perform_changing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_tables.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_tables.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformTables = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class PerformTables extends combi_1.Expression {
    getRunnable() {
        const tables = (0, combi_1.seq)("TABLES", (0, combi_1.plus)(source_1.Source));
        return tables;
    }
}
exports.PerformTables = PerformTables;
//# sourceMappingURL=perform_tables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_using.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/perform_using.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PerformUsing = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
class PerformUsing extends combi_1.Expression {
    getRunnable() {
        const using = (0, combi_1.seq)("USING", (0, combi_1.plus)(source_1.Source));
        return using;
    }
}
exports.PerformUsing = PerformUsing;
//# sourceMappingURL=perform_using.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/radio_group_name.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/radio_group_name.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RadioGroupName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class RadioGroupName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[\w\d%]+$/);
    }
}
exports.RadioGroupName = RadioGroupName;
//# sourceMappingURL=radio_group_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/raise_with.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/raise_with.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaiseWith = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class RaiseWith extends combi_1.Expression {
    getRunnable() {
        const wit = (0, combi_1.seq)("WITH", _1.SimpleSource1, (0, combi_1.opt)(_1.SimpleSource1), (0, combi_1.opt)(_1.SimpleSource1), (0, combi_1.opt)(_1.SimpleSource1));
        return wit;
    }
}
exports.RaiseWith = RaiseWith;
//# sourceMappingURL=raise_with.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/read_table_target.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/read_table_target.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadTableTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const fstarget_1 = __webpack_require__(/*! ./fstarget */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/fstarget.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js");
class ReadTableTarget extends combi_1.Expression {
    getRunnable() {
        const target = (0, combi_1.altPrio)((0, combi_1.seq)("ASSIGNING", fstarget_1.FSTarget), (0, combi_1.seq)((0, combi_1.optPrio)("REFERENCE"), "INTO", target_1.Target), "TRANSPORTING NO FIELDS");
        return target;
    }
}
exports.ReadTableTarget = ReadTableTarget;
//# sourceMappingURL=read_table_target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/receive_parameters.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/receive_parameters.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReceiveParameters = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ReceiveParameters extends combi_1.Expression {
    getRunnable() {
        const importing = (0, combi_1.seq)("IMPORTING", _1.ParameterListT);
        const tables = (0, combi_1.seq)("TABLES", _1.ParameterListT);
        const changing = (0, combi_1.seq)("CHANGING", _1.ParameterListT);
        const exceptions = (0, combi_1.seq)("EXCEPTIONS", (0, combi_1.opt)(_1.ParameterListExceptions), (0, combi_1.opt)(_1.Field));
        const long = (0, combi_1.seq)((0, combi_1.opt)(importing), (0, combi_1.opt)(changing), (0, combi_1.opt)(tables), (0, combi_1.opt)(exceptions));
        return long;
    }
}
exports.ReceiveParameters = ReceiveParameters;
//# sourceMappingURL=receive_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/redefinition.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/redefinition.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Redefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Redefinition extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.opt)("FINAL"), "REDEFINITION");
    }
}
exports.Redefinition = Redefinition;
//# sourceMappingURL=redefinition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_body.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_body.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const reduce_next_1 = __webpack_require__(/*! ./reduce_next */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_next.js");
class ReduceBody extends combi_1.Expression {
    getRunnable() {
        const init = (0, combi_1.seq)("INIT", (0, combi_1.plus)(_1.InlineFieldDefinition));
        return (0, combi_1.seq)((0, combi_1.opt)(_1.Let), init, (0, combi_1.plus)(_1.For), reduce_next_1.ReduceNext);
    }
}
exports.ReduceBody = ReduceBody;
//# sourceMappingURL=reduce_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_next.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/reduce_next.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceNext = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ReduceNext extends combi_1.Expression {
    getRunnable() {
        const calcAssign = (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.alt)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.WPlus), "="), (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WDash), "="), "/=", "*=", "&&="));
        const fields = (0, combi_1.seq)(_1.SimpleTarget, (0, combi_1.altPrio)("=", calcAssign), _1.Source);
        return (0, combi_1.seq)("NEXT", (0, combi_1.plus)(fields));
    }
}
exports.ReduceNext = ReduceNext;
//# sourceMappingURL=reduce_next.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/report_name.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/report_name.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReportName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class ReportName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.regex)(/^[\w/$%]+$/), (0, combi_1.star)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^\w+$/))));
    }
}
exports.ReportName = ReportName;
//# sourceMappingURL=report_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Select = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const sql_group_by_1 = __webpack_require__(/*! ./sql_group_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_group_by.js");
const sql_into_structure_1 = __webpack_require__(/*! ./sql_into_structure */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
const sql_up_to_1 = __webpack_require__(/*! ./sql_up_to */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_up_to.js");
class Select extends combi_1.Expression {
    getRunnable() {
        const into = (0, combi_1.altPrio)(_1.SQLIntoTable, sql_into_structure_1.SQLIntoStructure, _1.SQLIntoList);
        const where = (0, combi_1.seq)("WHERE", _1.SQLCond);
        const offset = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("OFFSET", _1.SQLSource));
        const bypass = (0, combi_1.str)("BYPASSING BUFFER");
        const fields = (0, combi_1.ver)(version_1.Version.v750, _1.SQLFields);
        // todo, HINTS cannot be anywhere, need an expression dedicated for strict sql
        const perm = (0, combi_1.per)(_1.SQLFrom, into, _1.SQLForAllEntries, where, _1.SQLOrderBy, sql_up_to_1.SQLUpTo, offset, _1.SQLClient, _1.SQLHaving, bypass, sql_group_by_1.SQLGroupBy, fields, _1.DatabaseConnection, _1.SQLHints);
        const permSingle = (0, combi_1.per)(_1.SQLFrom, (0, combi_1.altPrio)(sql_into_structure_1.SQLIntoStructure, _1.SQLIntoList), where, _1.SQLClient, bypass, sql_group_by_1.SQLGroupBy, fields, _1.DatabaseConnection, _1.SQLHints);
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), sql_field_name_1.SQLFieldName, (0, combi_1.tok)(tokens_1.WParenRightW));
        const fieldList = (0, combi_1.optPrio)((0, combi_1.altPrio)(_1.SQLFieldList, paren));
        const single = (0, combi_1.seq)("SINGLE", (0, combi_1.optPrio)("FOR UPDATE"), fieldList, permSingle);
        const other = (0, combi_1.seq)((0, combi_1.optPrio)("DISTINCT"), fieldList, perm);
        const ret = (0, combi_1.seq)("SELECT", (0, combi_1.altPrio)(single, other));
        return ret;
    }
}
exports.Select = Select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select_loop.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/select_loop.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectLoop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const sql_order_by_1 = __webpack_require__(/*! ./sql_order_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_order_by.js");
const sql_having_1 = __webpack_require__(/*! ./sql_having */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_having.js");
const sql_into_structure_1 = __webpack_require__(/*! ./sql_into_structure */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js");
const sql_hints_1 = __webpack_require__(/*! ./sql_hints */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_hints.js");
const sql_field_list_loop_1 = __webpack_require__(/*! ./sql_field_list_loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list_loop.js");
const sql_up_to_1 = __webpack_require__(/*! ./sql_up_to */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_up_to.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SelectLoop extends combi_1.Expression {
    getRunnable() {
        const where = (0, combi_1.seq)("WHERE", _1.SQLCond);
        const bypass = "BYPASSING BUFFER";
        const pack = (0, combi_1.seq)("PACKAGE SIZE", _1.SQLSource);
        const tab = (0, combi_1.seq)(_1.SQLIntoTable, (0, combi_1.alt)(pack, (0, combi_1.seq)(_1.SQLFrom, pack), (0, combi_1.seq)(pack, _1.SQLFrom)));
        const packTab = (0, combi_1.seq)(pack, _1.SQLIntoTable);
        const into = (0, combi_1.altPrio)(sql_into_structure_1.SQLIntoStructure, _1.SQLIntoList);
        const perm = (0, combi_1.per)(_1.SQLFrom, where, sql_up_to_1.SQLUpTo, sql_order_by_1.SQLOrderBy, sql_having_1.SQLHaving, _1.SQLClient, bypass, _1.SQLGroupBy, _1.SQLForAllEntries, (0, combi_1.alt)(tab, into, packTab));
        const strict = (0, combi_1.seq)(_1.SQLFrom, (0, combi_1.ver)(version_1.Version.v750, _1.SQLFields), (0, combi_1.optPrio)((0, combi_1.seq)(where, into, sql_up_to_1.SQLUpTo)));
        const ret = (0, combi_1.seq)("SELECT", (0, combi_1.altPrio)((0, combi_1.seq)((0, combi_1.optPrio)("DISTINCT"), sql_field_list_loop_1.SQLFieldListLoop, perm), strict), (0, combi_1.optPrio)(sql_hints_1.SQLHints));
        return ret;
    }
}
exports.SelectLoop = SelectLoop;
//# sourceMappingURL=select_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFieldChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js");
class SimpleFieldChain extends combi_1.Expression {
    getRunnable() {
        const chain = (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName));
        const clas = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow), attribute_name_1.AttributeName);
        const start = (0, combi_1.altPrio)(clas, _1.Field);
        const ret = (0, combi_1.seq)(start, chain);
        return ret;
    }
}
exports.SimpleFieldChain = SimpleFieldChain;
//# sourceMappingURL=simple_field_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain2.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain2.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleFieldChain2 = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js");
class SimpleFieldChain2 extends combi_1.Expression {
    getRunnable() {
        const attr = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), attribute_name_1.AttributeName);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName);
        const chain = (0, combi_1.star)((0, combi_1.altPrio)(attr, comp));
        const clas = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow), attribute_name_1.AttributeName);
        const start = (0, combi_1.altPrio)(clas, _1.SourceField, _1.SourceFieldSymbol);
        const ret = (0, combi_1.seq)(start, chain);
        return ret;
    }
}
exports.SimpleFieldChain2 = SimpleFieldChain2;
//# sourceMappingURL=simple_field_chain2.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_name.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_name.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class SimpleName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^[\w$%]+$/);
    }
}
exports.SimpleName = SimpleName;
//# sourceMappingURL=simple_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source1.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source1.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSource1 = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SimpleSource1 extends combi_1.Expression {
    getRunnable() {
        const concat = (0, combi_1.seq)("&&", _1.StringTemplate);
        const template = (0, combi_1.seq)(_1.StringTemplate, (0, combi_1.star)(concat));
        return (0, combi_1.alt)(_1.Constant, _1.TextElement, _1.MethodCallChain, template, _1.FieldChain);
    }
}
exports.SimpleSource1 = SimpleSource1;
//# sourceMappingURL=simple_source1.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source2.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source2.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSource2 = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
/** Reduced version of SimpleSource, omits MethodCallChains. */
class SimpleSource2 extends combi_1.Expression {
    getRunnable() {
        const concat = (0, combi_1.seq)("&&", _1.StringTemplate);
        const template = (0, combi_1.seq)(_1.StringTemplate, (0, combi_1.star)(concat));
        return (0, combi_1.altPrio)(_1.Constant, _1.TextElement, template, _1.FieldChain);
    }
}
exports.SimpleSource2 = SimpleSource2;
//# sourceMappingURL=simple_source2.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSource3 = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SimpleSource3 extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)(_1.Constant, _1.TextElement, _1.FieldChain);
    }
}
exports.SimpleSource3 = SimpleSource3;
//# sourceMappingURL=simple_source3.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source4.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source4.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleSource4 = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_call_chain_1 = __webpack_require__(/*! ./method_call_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/method_call_chain.js");
class SimpleSource4 extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.alt)(_1.Constant, _1.TextElement, _1.FieldChain, method_call_chain_1.MethodCallChain);
    }
}
exports.SimpleSource4 = SimpleSource4;
//# sourceMappingURL=simple_source4.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_target.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_target.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js");
const dereference_1 = __webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js");
class SimpleTarget extends combi_1.Expression {
    getRunnable() {
        const attr = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), attribute_name_1.AttributeName);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName);
        const something = (0, combi_1.starPrio)((0, combi_1.altPrio)(dereference_1.Dereference, attr, comp, _1.TableExpression));
        const cast = (0, combi_1.seq)((0, combi_1.altPrio)(_1.Cast, _1.NewObject), _1.Arrow, _1.FieldAll);
        const clas = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow), attribute_name_1.AttributeName);
        const start = (0, combi_1.altPrio)(cast, clas, _1.TargetField, _1.TargetFieldSymbol);
        const fields = (0, combi_1.seq)((0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength));
        const optional = (0, combi_1.altPrio)(_1.TableBody, fields);
        return (0, combi_1.seq)(start, something, optional);
    }
}
exports.SimpleTarget = SimpleTarget;
//# sourceMappingURL=simple_target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Source = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const text_element_1 = __webpack_require__(/*! ./text_element */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element.js");
const attribute_chain_1 = __webpack_require__(/*! ./attribute_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_chain.js");
const dereference_1 = __webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js");
// todo, COND and SWITCH are quite similar?
// this class is used quite often, so its nice to have the differentiating tokens part of it
class Source extends combi_1.Expression {
    getRunnable() {
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentChain);
        const attr = (0, combi_1.seq)(_1.Arrow, attribute_chain_1.AttributeChain);
        const deref = (0, combi_1.optPrio)((0, combi_1.ver)(version_1.Version.v756, dereference_1.Dereference));
        const method = (0, combi_1.seq)(_1.MethodCallChain, (0, combi_1.optPrio)((0, combi_1.altPrio)(attr, comp)), deref);
        const rparen = (0, combi_1.tok)(tokens_1.WParenRightW);
        const rparenNoSpace = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.WParenRightW));
        const lparenNoSpace = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW));
        // paren used for eg. "( 2 + 1 ) * 4"
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), Source, rparen);
        const after = (0, combi_1.seq)((0, combi_1.altPrio)("&", "&&", _1.ArithOperator), Source);
        const bool = (0, combi_1.seq)((0, combi_1.altPrio)((0, combi_1.ver)(version_1.Version.v702, (0, combi_1.regex)(/^BOOLC$/i)), (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.regex)(/^XSDBOOL$/i))), (0, combi_1.tok)(tokens_1.ParenLeftW), _1.Cond, ")");
        const prefix = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WPlus), "BIT-NOT");
        const old = (0, combi_1.seq)((0, combi_1.optPrio)(prefix), (0, combi_1.altPrio)(_1.Constant, _1.StringTemplate, text_element_1.TextElement, bool, method, (0, combi_1.seq)(_1.FieldChain, deref), paren), (0, combi_1.optPrio)(after));
        const corr = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)("CORRESPONDING", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.CorrespondingBody, rparen, (0, combi_1.optPrio)(after)));
        const conv = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("CONV", _1.TypeNameOrInfer, lparenNoSpace, _1.ConvBody, rparenNoSpace, (0, combi_1.optPrio)(after)));
        const swit = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("SWITCH", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.SwitchBody, rparenNoSpace, (0, combi_1.optPrio)(after)));
        const value = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("VALUE", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.ValueBody, rparenNoSpace, (0, combi_1.optPrio)(after)));
        const cond = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("COND", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.CondBody, rparenNoSpace, (0, combi_1.optPrio)(after)));
        const reff = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("REF", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), Source, (0, combi_1.optPrio)("OPTIONAL"), rparen));
        const exact = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("EXACT", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), Source, rparen, (0, combi_1.optPrio)(after)));
        const filter = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.seq)("FILTER", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.FilterBody, rparen));
        const reduce = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.seq)("REDUCE", _1.TypeNameOrInfer, (0, combi_1.tok)(tokens_1.ParenLeftW), _1.ReduceBody, rparen, (0, combi_1.optPrio)(after)));
        const prefix1 = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WDashW), (0, combi_1.tok)(tokens_1.WPlusW));
        const ret = (0, combi_1.seq)((0, combi_1.starPrio)(prefix1), (0, combi_1.altPrio)(filter, reff, corr, conv, value, cond, exact, swit, reduce, old));
        return ret;
    }
}
exports.Source = Source;
//# sourceMappingURL=source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceField = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SourceField extends combi_1.Expression {
    getRunnable() {
        return new _1.Field();
    }
}
exports.SourceField = SourceField;
//# sourceMappingURL=source_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceFieldSymbol = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SourceFieldSymbol extends combi_1.Expression {
    getRunnable() {
        return new _1.FieldSymbol();
    }
}
exports.SourceFieldSymbol = SourceFieldSymbol;
//# sourceMappingURL=source_field_symbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol_chain.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source_field_symbol_chain.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceFieldSymbolChain = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SourceFieldSymbolChain extends combi_1.Expression {
    getRunnable() {
        const chain = (0, combi_1.seq)(new _1.ArrowOrDash(), _1.ComponentName);
        return (0, combi_1.seq)(_1.FieldSymbol, (0, combi_1.starPrio)(chain));
    }
}
exports.SourceFieldSymbolChain = SourceFieldSymbolChain;
//# sourceMappingURL=source_field_symbol_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_aggregation.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_aggregation.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLAggregation = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const sql_arithmetics_1 = __webpack_require__(/*! ./sql_arithmetics */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetics.js");
class SQLAggregation extends combi_1.Expression {
    getRunnable() {
        const f = (0, combi_1.seq)((0, combi_1.optPrio)("DISTINCT"), (0, combi_1.altPrio)(sql_arithmetics_1.SQLArithmetics, dynamic_1.Dynamic, _1.SQLFunction));
        const fparen = (0, combi_1.seq)("(", _1.Field, ")");
        const count = (0, combi_1.seq)("COUNT", (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW)), (0, combi_1.optPrio)("DISTINCT"), (0, combi_1.altPrio)("*", _1.Field, fparen), ")");
        const max = (0, combi_1.seq)("MAX", (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW)), f, ")");
        const min = (0, combi_1.seq)("MIN", (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW)), f, ")");
        const sum = (0, combi_1.seq)("SUM", (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW)), f, ")");
        const avg = (0, combi_1.seq)("AVG", (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.ParenLeftW)), f, ")");
        return (0, combi_1.altPrio)(count, max, min, sum, avg);
    }
}
exports.SQLAggregation = SQLAggregation;
//# sourceMappingURL=sql_aggregation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_alias_field.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_alias_field.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLAliasField = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class SQLAliasField extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(\/\w+\/)?\w+~\w+$/);
    }
}
exports.SQLAliasField = SQLAliasField;
//# sourceMappingURL=sql_alias_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetic_operator.js":
/*!********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetic_operator.js ***!
  \********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLArithmeticOperator = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class SQLArithmeticOperator extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WPlusW), (0, combi_1.tok)(tokens_1.WDashW), "*", "/");
        return operator;
    }
}
exports.SQLArithmeticOperator = SQLArithmeticOperator;
//# sourceMappingURL=sql_arithmetic_operator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetics.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetics.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLArithmetics = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const sql_arithmetic_operator_1 = __webpack_require__(/*! ./sql_arithmetic_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetic_operator.js");
class SQLArithmetics extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.alt)(_1.SQLFieldName, _1.SQLFunction);
        return (0, combi_1.seq)(field, (0, combi_1.starPrio)((0, combi_1.seq)(sql_arithmetic_operator_1.SQLArithmeticOperator, field)));
    }
}
exports.SQLArithmetics = SQLArithmetics;
//# sourceMappingURL=sql_arithmetics.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_as_name.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_as_name.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLAsName = void 0;
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class SQLAsName extends combi_1.Expression {
    getRunnable() {
        // todo, below allows too much?
        const field = (0, combi_1.regex)(/^[&_!]?\*?\w*(\/\w+\/)?\d*[a-zA-Z_%\$][\w\*%\$\?]*(~\w+)?$/);
        return (0, combi_1.seq)(field, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), field)));
    }
}
exports.SQLAsName = SQLAsName;
//# sourceMappingURL=sql_as_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_case.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_case.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCase = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant.js");
const sql_cond_1 = __webpack_require__(/*! ./sql_cond */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cond.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js");
class SQLCase extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.altPrio)(_1.SQLAggregation, SQLCase, _1.SQLFunction, _1.SQLPath, sql_field_name_1.SQLFieldName, constant_1.Constant);
        const sub = (0, combi_1.seq)((0, combi_1.altPrio)("+", "-", "*", "/", "&&"), (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenLeftW)), field, (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenRightW)));
        const sourc = (0, combi_1.altPrio)(SQLCase, _1.SQLAggregation, _1.SQLFunction, sql_source_1.SQLSource);
        const when = (0, combi_1.seq)("WHEN", (0, combi_1.altPrio)(sql_cond_1.SQLCond, constant_1.Constant), "THEN", sourc, (0, combi_1.starPrio)(sub));
        const els = (0, combi_1.seq)("ELSE", sourc);
        return (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)("CASE", (0, combi_1.opt)(sql_field_name_1.SQLFieldName), (0, combi_1.plusPrio)(when), (0, combi_1.optPrio)(els), "END"));
    }
}
exports.SQLCase = SQLCase;
//# sourceMappingURL=sql_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cds_parameters.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cds_parameters.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCDSParameters = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js");
class SQLCDSParameters extends combi_1.Expression {
    getRunnable() {
        const param = (0, combi_1.seq)(_1.Field, "=", (0, combi_1.alt)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), field_chain_1.FieldChain), _1.Constant));
        return (0, combi_1.seq)("(", param, (0, combi_1.starPrio)((0, combi_1.seq)(",", param)), ")");
    }
}
exports.SQLCDSParameters = SQLCDSParameters;
//# sourceMappingURL=sql_cds_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_client.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_client.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLClient = void 0;
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const sql_source_simple_1 = __webpack_require__(/*! ./sql_source_simple */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_simple.js");
class SQLClient extends combi_1.Expression {
    getRunnable() {
        const client = (0, combi_1.alt)((0, combi_1.verNot)(version_1.Version.Cloud, "CLIENT SPECIFIED"), (0, combi_1.seq)("USING", (0, combi_1.alt)((0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)("CLIENT", sql_source_simple_1.SQLSourceSimple)), (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.seq)("CLIENTS IN", (0, combi_1.alt)(sql_source_simple_1.SQLSourceSimple, "T000"))), (0, combi_1.ver)(version_1.Version.v754, "ALL CLIENTS"))));
        return client;
    }
}
exports.SQLClient = SQLClient;
//# sourceMappingURL=sql_client.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCompare = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class SQLCompare extends combi_1.Expression {
    getRunnable() {
        const subSelect = (0, combi_1.seq)("(", _1.Select, ")");
        const subSelectDouble = (0, combi_1.seq)("(", "(", _1.Select, ")", ")");
        const between = (0, combi_1.seq)("BETWEEN", _1.SQLSource, "AND", _1.SQLSource);
        const like = (0, combi_1.seq)("LIKE", _1.SQLSource, (0, combi_1.optPrio)((0, combi_1.seq)("ESCAPE", _1.SQLSource)));
        const nul = (0, combi_1.seq)("IS", (0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)("NULL", (0, combi_1.ver)(version_1.Version.v753, "INITIAL")));
        const source = new _1.SQLSource();
        const sub = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.altPrio)("ALL", "ANY", "SOME")), (0, combi_1.altPrio)(subSelect, subSelectDouble));
        const arith = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.plusPrio)((0, combi_1.seq)((0, combi_1.altPrio)("+", "-", "*", "/"), _1.SQLFieldName)));
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), (0, combi_1.altPrio)(_1.SimpleSource3, paren)));
        const rett = (0, combi_1.seq)((0, combi_1.altPrio)(_1.SQLFunction, (0, combi_1.seq)((0, combi_1.altPrio)(_1.SQLPath, _1.SQLFieldName), (0, combi_1.optPrio)(arith)), at), (0, combi_1.altPrio)((0, combi_1.seq)(_1.SQLCompareOperator, (0, combi_1.altPrio)(sub, source)), (0, combi_1.seq)((0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)(_1.SQLIn, like, between)), nul));
        const exists = (0, combi_1.seq)("EXISTS", subSelect);
        return (0, combi_1.altPrio)(exists, _1.Dynamic, rett);
    }
}
exports.SQLCompare = SQLCompare;
//# sourceMappingURL=sql_compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare_operator.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_compare_operator.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCompareOperator = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class SQLCompareOperator extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.altPrio)("=", "<>", "<", ">", "<=", ">=", "EQ", "NE", "GE", "GT", "LT", "LE", "><", "=>", "=<");
        return operator;
    }
}
exports.SQLCompareOperator = SQLCompareOperator;
//# sourceMappingURL=sql_compare_operator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cond.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_cond.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCond = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLCond extends combi_1.Expression {
    getRunnable() {
        const operator = (0, combi_1.altPrio)("AND", "OR");
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), SQLCond, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRightW)));
        const cnd = (0, combi_1.seq)((0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)(_1.SQLCompare, paren));
        const ret = (0, combi_1.seq)(cnd, (0, combi_1.starPrio)((0, combi_1.seq)(operator, cnd)));
        return ret;
    }
}
exports.SQLCond = SQLCond;
//# sourceMappingURL=sql_cond.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLField = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const sql_function_1 = __webpack_require__(/*! ./sql_function */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_function.js");
const simple_field_chain_1 = __webpack_require__(/*! ./simple_field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain.js");
const sql_path_1 = __webpack_require__(/*! ./sql_path */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_path.js");
class SQLField extends combi_1.Expression {
    getRunnable() {
        const abap = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), simple_field_chain_1.SimpleFieldChain));
        const as = (0, combi_1.seq)("AS", _1.SQLAsName);
        const field = (0, combi_1.altPrio)(_1.SQLAggregation, _1.SQLCase, sql_function_1.SQLFunction, sql_path_1.SQLPath, _1.SQLFieldName, abap, _1.Constant);
        const sub = (0, combi_1.plusPrio)((0, combi_1.seq)((0, combi_1.altPrio)("+", "-", "*", "/", "&&"), (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenLeftW)), field, (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenRightW))));
        const arith = (0, combi_1.ver)(version_1.Version.v740sp05, sub);
        return (0, combi_1.seq)(field, (0, combi_1.optPrio)(arith), (0, combi_1.optPrio)(as));
    }
}
exports.SQLField = SQLField;
//# sourceMappingURL=sql_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_and_value.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_and_value.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFieldAndValue = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js");
const sql_arithmetic_operator_1 = __webpack_require__(/*! ./sql_arithmetic_operator */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_arithmetic_operator.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js");
class SQLFieldAndValue extends combi_1.Expression {
    getRunnable() {
        const opt1 = (0, combi_1.seq)((0, combi_1.altPrio)(integer_1.Integer, sql_field_name_1.SQLFieldName), sql_arithmetic_operator_1.SQLArithmeticOperator, sql_source_1.SQLSource);
        const param = (0, combi_1.seq)(sql_field_name_1.SQLFieldName, "=", (0, combi_1.altPrio)(opt1, sql_source_1.SQLSource));
        return param;
    }
}
exports.SQLFieldAndValue = SQLFieldAndValue;
//# sourceMappingURL=sql_field_and_value.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFieldList = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SQLFieldList extends combi_1.Expression {
    getRunnable() {
        const nev = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.starPrio)((0, combi_1.seq)(",", _1.SQLField)));
        const old = (0, combi_1.starPrio)(_1.SQLField);
        return (0, combi_1.altPrio)("*", _1.Dynamic, (0, combi_1.seq)(_1.SQLField, (0, combi_1.alt)(nev, old)));
    }
}
exports.SQLFieldList = SQLFieldList;
//# sourceMappingURL=sql_field_list.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list_loop.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_list_loop.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFieldListLoop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const sql_path_1 = __webpack_require__(/*! ./sql_path */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_path.js");
// loop must include one field from the database table
class SQLFieldListLoop extends combi_1.Expression {
    getRunnable() {
        const comma = (0, combi_1.opt)((0, combi_1.ver)(version_1.Version.v740sp05, ","));
        const as = (0, combi_1.seq)("AS", _1.SQLAsName);
        const someField = (0, combi_1.seq)(_1.SQLField, comma);
        const fieldList = (0, combi_1.seq)((0, combi_1.star)(someField), (0, combi_1.alt)(_1.SQLFieldName, sql_path_1.SQLPath, _1.Constant), (0, combi_1.optPrio)(as), comma, (0, combi_1.star)(someField));
        const fields = (0, combi_1.alt)("*", _1.Dynamic, fieldList);
        return fields;
    }
}
exports.SQLFieldListLoop = SQLFieldListLoop;
//# sourceMappingURL=sql_field_list_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFieldName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class SQLFieldName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(?!(?:SINGLE|INTO|DISTINCT|AS|WHERE|FOR|HAVING|APPENDING|UP|FROM)$)(\/\w+\/)?(\w+~(\w+|\*)|\w+)$/i);
    }
}
exports.SQLFieldName = SQLFieldName;
//# sourceMappingURL=sql_field_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_fields.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_fields.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFields = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLFields extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("FIELDS", (0, combi_1.opt)("DISTINCT"), _1.SQLFieldList);
    }
}
exports.SQLFields = SQLFields;
//# sourceMappingURL=sql_fields.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_for_all_entries.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_for_all_entries.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLForAllEntries = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js");
class SQLForAllEntries extends combi_1.Expression {
    getRunnable() {
        const forAll = (0, combi_1.seq)("FOR ALL ENTRIES IN", sql_source_1.SQLSource);
        return forAll;
    }
}
exports.SQLForAllEntries = SQLForAllEntries;
//# sourceMappingURL=sql_for_all_entries.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFrom = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLFrom extends combi_1.Expression {
    getRunnable() {
        const from = (0, combi_1.seq)("FROM", (0, combi_1.starPrio)((0, combi_1.tok)(tokens_1.WParenLeftW)), _1.SQLFromSource);
        const source = (0, combi_1.seq)(from, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenRightW)), _1.SQLJoin, (0, combi_1.optPrio)((0, combi_1.tok)(tokens_1.WParenRightW)))));
        return source;
    }
}
exports.SQLFrom = SQLFrom;
//# sourceMappingURL=sql_from.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from_source.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_from_source.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFromSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const with_name_1 = __webpack_require__(/*! ./with_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/with_name.js");
class SQLFromSource extends combi_1.Expression {
    getRunnable() {
        // https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abennews-752-open_sql.htm#!ABAP_MODIFICATION_1@1@
        const tab = (0, combi_1.ver)(version_1.Version.v752, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), _1.FieldChain));
        const aas = (0, combi_1.seq)("AS", _1.SQLAsName);
        return (0, combi_1.seq)((0, combi_1.altPrio)(with_name_1.WithName, (0, combi_1.seq)(_1.DatabaseTable, (0, combi_1.optPrio)(_1.SQLCDSParameters)), tab), (0, combi_1.optPrio)((0, combi_1.ver)(version_1.Version.v752, "WITH PRIVILEGED ACCESS")), (0, combi_1.optPrio)(aas));
    }
}
exports.SQLFromSource = SQLFromSource;
//# sourceMappingURL=sql_from_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_function.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_function.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFunction = void 0;
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/constant.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const integer_1 = __webpack_require__(/*! ./integer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/integer.js");
const sql_alias_field_1 = __webpack_require__(/*! ./sql_alias_field */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_alias_field.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
const simple_source3_1 = __webpack_require__(/*! ./simple_source3 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source3.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
const sql_aggregation_1 = __webpack_require__(/*! ./sql_aggregation */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_aggregation.js");
class SQLFunction extends combi_1.Expression {
    getRunnable() {
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), source_1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), (0, combi_1.altPrio)(simple_source3_1.SimpleSource3, paren)));
        const param = (0, combi_1.altPrio)(SQLFunction, sql_aggregation_1.SQLAggregation, sql_field_name_1.SQLFieldName, sql_alias_field_1.SQLAliasField, constant_1.Constant, at);
        const castTypes = (0, combi_1.altPrio)((0, combi_1.seq)("CHAR", (0, combi_1.tok)(tokens_1.ParenLeftW), integer_1.Integer, (0, combi_1.tok)(tokens_1.WParenRightW)), (0, combi_1.seq)("DEC", (0, combi_1.tok)(tokens_1.ParenLeftW), integer_1.Integer, ",", integer_1.Integer, (0, combi_1.tok)(tokens_1.WParenRightW)), "FLTP", "NUMC", "INT8");
        const commaParam = (0, combi_1.seq)(",", param);
        // note: the function names are not keywords, they are usually in lower case
        const abs = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^abs$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const cast = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)((0, combi_1.regex)(/^cast$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, "AS", castTypes, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const ceil = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^ceil$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const coalesce = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^coalesce$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, (0, combi_1.optPrio)(commaParam), (0, combi_1.tok)(tokens_1.WParenRightW)));
        const concat = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)((0, combi_1.regex)(/^concat$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const div = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^div$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const floor = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^floor$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const length = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)((0, combi_1.regex)(/^length$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const lower = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)((0, combi_1.regex)(/^lower$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const mod = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.regex)(/^mod$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const replace = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)((0, combi_1.regex)(/^replace$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, commaParam, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const round = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)((0, combi_1.regex)(/^round$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, commaParam, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const upper = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)((0, combi_1.regex)(/^upper$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), param, (0, combi_1.tok)(tokens_1.WParenRightW)));
        const uuid = (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.seq)((0, combi_1.regex)(/^uuid$/i), (0, combi_1.tok)(tokens_1.ParenLeftW), (0, combi_1.tok)(tokens_1.WParenRightW)));
        return (0, combi_1.altPrio)(uuid, abs, ceil, floor, cast, div, mod, coalesce, concat, replace, length, lower, upper, round);
    }
}
exports.SQLFunction = SQLFunction;
//# sourceMappingURL=sql_function.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_group_by.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_group_by.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLGroupBy = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
class SQLGroupBy extends combi_1.Expression {
    getRunnable() {
        const f = (0, combi_1.alt)(sql_field_name_1.SQLFieldName, dynamic_1.Dynamic);
        const strict = (0, combi_1.seq)((0, combi_1.plus)((0, combi_1.seq)(f, ",")), f);
        const group = (0, combi_1.seq)("GROUP BY", (0, combi_1.altPrio)(strict, (0, combi_1.plus)(f)));
        return group;
    }
}
exports.SQLGroupBy = SQLGroupBy;
//# sourceMappingURL=sql_group_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_having.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_having.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLHaving = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
class SQLHaving extends combi_1.Expression {
    getRunnable() {
        const having = (0, combi_1.seq)("HAVING", dynamic_1.Dynamic);
        return having;
    }
}
exports.SQLHaving = SQLHaving;
//# sourceMappingURL=sql_having.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_hints.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_hints.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLHints = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLHints extends combi_1.Expression {
    getRunnable() {
        const type = (0, combi_1.altPrio)("ORACLE", "ADABAS", "AS400", "DB2", "HDB", "MSSQLNT", "SYBASE", "DB6");
        const ret = (0, combi_1.seq)("%_HINTS", (0, combi_1.plus)((0, combi_1.seq)(type, _1.Constant)));
        return ret;
    }
}
exports.SQLHints = SQLHints;
//# sourceMappingURL=sql_hints.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_in.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_in.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLIn = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SQLIn extends combi_1.Expression {
    getRunnable() {
        const val = new _1.SQLSource();
        const short = new _1.SQLSourceNoSpace();
        const listOld = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeft), (0, combi_1.alt)((0, combi_1.ver)(version_1.Version.v740sp05, short), val), (0, combi_1.starPrio)((0, combi_1.seq)(",", val)), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRight), (0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.WParenRightW)));
        const listNew = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), val, (0, combi_1.starPrio)((0, combi_1.seq)(",", (0, combi_1.altPrio)(short, val))), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRight), (0, combi_1.tok)(tokens_1.WParenRightW)));
        const list = (0, combi_1.alt)(listOld, (0, combi_1.ver)(version_1.Version.v740sp02, listNew)); // version is a guess, https://github.com/abaplint/abaplint/issues/2530
        const subSelect = (0, combi_1.seq)("(", _1.Select, ")");
        const inn = (0, combi_1.seq)("IN", (0, combi_1.altPrio)(_1.SQLSource, list, subSelect));
        return inn;
    }
}
exports.SQLIn = SQLIn;
//# sourceMappingURL=sql_in.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_list.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_list.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLIntoList = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const wparen_leftw_1 = __webpack_require__(/*! ../../1_lexer/tokens/wparen_leftw */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_leftw.js");
const wparen_left_1 = __webpack_require__(/*! ../../1_lexer/tokens/wparen_left */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/wparen_left.js");
class SQLIntoList extends combi_1.Expression {
    getRunnable() {
        const intoList = (0, combi_1.seq)((0, combi_1.altPrio)((0, combi_1.tok)(wparen_left_1.WParenLeft), (0, combi_1.tok)(wparen_leftw_1.WParenLeftW)), (0, combi_1.starPrio)((0, combi_1.seq)(_1.SQLTarget, ",")), _1.SQLTarget, ")");
        return (0, combi_1.seq)("INTO", intoList);
    }
}
exports.SQLIntoList = SQLIntoList;
//# sourceMappingURL=sql_into_list.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLIntoStructure = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLIntoStructure extends combi_1.Expression {
    getRunnable() {
        const intoSimple = (0, combi_1.seq)((0, combi_1.optPrio)("CORRESPONDING FIELDS OF"), _1.SQLTarget);
        return (0, combi_1.seq)("INTO", intoSimple);
    }
}
exports.SQLIntoStructure = SQLIntoStructure;
//# sourceMappingURL=sql_into_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_table.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_table.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLIntoTable = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLIntoTable extends combi_1.Expression {
    getRunnable() {
        const into = (0, combi_1.seq)((0, combi_1.altPrio)("INTO", "APPENDING"), (0, combi_1.optPrio)("CORRESPONDING FIELDS OF"), "TABLE", _1.SQLTarget);
        return into;
    }
}
exports.SQLIntoTable = SQLIntoTable;
//# sourceMappingURL=sql_into_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_join.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_join.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLJoin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLJoin extends combi_1.Expression {
    getRunnable() {
        const joinType = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.altPrio)("INNER", "LEFT OUTER", "LEFT", "RIGHT OUTER", "RIGHT")), "JOIN");
        const join = (0, combi_1.seq)(joinType, _1.SQLFromSource, "ON", _1.SQLCond);
        return join;
    }
}
exports.SQLJoin = SQLJoin;
//# sourceMappingURL=sql_join.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_order_by.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_order_by.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLOrderBy = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const sql_field_name_1 = __webpack_require__(/*! ./sql_field_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_field_name.js");
class SQLOrderBy extends combi_1.Expression {
    getRunnable() {
        const ding = (0, combi_1.alt)("ASCENDING", "DESCENDING");
        const ofields = (0, combi_1.plus)((0, combi_1.seq)(sql_field_name_1.SQLFieldName, (0, combi_1.opt)(ding), (0, combi_1.opt)(",")));
        const order = (0, combi_1.seq)("ORDER BY", (0, combi_1.altPrio)("PRIMARY KEY", dynamic_1.Dynamic, ofields));
        return order;
    }
}
exports.SQLOrderBy = SQLOrderBy;
//# sourceMappingURL=sql_order_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_path.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_path.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLPath = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class SQLPath extends combi_1.Expression {
    getRunnable() {
        // todo, only from version?
        const ret = (0, combi_1.seq)((0, combi_1.regex)(/\\_\w+/), (0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/\w+/));
        return ret;
    }
}
exports.SQLPath = SQLPath;
//# sourceMappingURL=sql_path.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLSource extends combi_1.Expression {
    getRunnable() {
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), (0, combi_1.altPrio)(_1.SimpleSource3, paren)));
        return (0, combi_1.alt)(_1.SQLAliasField, _1.SimpleSource3, at);
    }
}
exports.SQLSource = SQLSource;
//# sourceMappingURL=sql_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_no_space.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_no_space.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLSourceNoSpace = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLSourceNoSpace extends combi_1.Expression {
    getRunnable() {
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.At), (0, combi_1.altPrio)(_1.SimpleSource3, paren)));
        return (0, combi_1.alt)(_1.SQLAliasField, _1.SimpleSource3, at);
    }
}
exports.SQLSourceNoSpace = SQLSourceNoSpace;
//# sourceMappingURL=sql_source_no_space.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_simple.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source_simple.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLSourceSimple = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
// todo, delete this expression, its the same as SQLSource?
class SQLSourceSimple extends combi_1.Expression {
    getRunnable() {
        const paren = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeftW), _1.Source, (0, combi_1.tok)(tokens_1.WParenRightW));
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WAt), (0, combi_1.alt)(_1.SimpleSource3, paren)));
        return (0, combi_1.alt)(_1.SimpleSource3, at);
    }
}
exports.SQLSourceSimple = SQLSourceSimple;
//# sourceMappingURL=sql_source_simple.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_target.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_target.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLTarget = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SQLTarget extends combi_1.Expression {
    getRunnable() {
        const n = (0, combi_1.ver)(version_1.Version.v754, "NEW");
        const at = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)((0, combi_1.opt)(n), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WAt), (0, combi_1.tok)(tokens_1.At)), _1.Target));
        return (0, combi_1.altPrio)(at, _1.Target);
    }
}
exports.SQLTarget = SQLTarget;
//# sourceMappingURL=sql_target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_up_to.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_up_to.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLUpTo = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_source.js");
class SQLUpTo extends combi_1.Expression {
    getRunnable() {
        const up = (0, combi_1.seq)("UP TO", sql_source_1.SQLSource, "ROWS");
        return up;
    }
}
exports.SQLUpTo = SQLUpTo;
//# sourceMappingURL=sql_up_to.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplate = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Tokens = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class StringTemplate extends combi_1.Expression {
    getRunnable() {
        const nest = (0, combi_1.seq)((0, combi_1.tok)(Tokens.StringTemplateBegin), _1.StringTemplateSource, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(Tokens.StringTemplateMiddle), _1.StringTemplateSource)), (0, combi_1.tok)(Tokens.StringTemplateEnd));
        return (0, combi_1.ver)(version_1.Version.v702, (0, combi_1.altPrio)(nest, (0, combi_1.tok)(Tokens.StringTemplate)));
    }
}
exports.StringTemplate = StringTemplate;
//# sourceMappingURL=string_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_formatting.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_formatting.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateFormatting = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
class StringTemplateFormatting extends combi_1.Expression {
    getRunnable() {
        // https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abapcompute_string_format_options.htm
        const alphaOptions = (0, combi_1.altPrio)("OUT", "RAW", "IN", _1.Source);
        const alignOptions = (0, combi_1.altPrio)("LEFT", "RIGHT", "CENTER", _1.Source);
        const dateTimeOptions = (0, combi_1.altPrio)("RAW", "ISO", "USER", "ENVIRONMENT", _1.Source, dynamic_1.Dynamic);
        const timeStampOptions = (0, combi_1.altPrio)("SPACE", "ISO", "USER", "ENVIRONMENT", _1.Source);
        const numberOptions = (0, combi_1.altPrio)("RAW", "USER", "ENVIRONMENT", _1.Source);
        const signOptions = (0, combi_1.altPrio)("LEFT", "LEFTPLUS", "LEFTSPACE", "RIGHT", "RIGHTPLUS", "RIGHTSPACE", _1.Source);
        const caseOptions = (0, combi_1.altPrio)("RAW", "UPPER", "LOWER", _1.Source, dynamic_1.Dynamic);
        const zeroXSDOptions = (0, combi_1.altPrio)("YES", "NO", _1.Source);
        const styleOptions = (0, combi_1.altPrio)("SIMPLE", "SIGN_AS_POSTFIX", "SCALE_PRESERVING", "SCIENTIFIC", "SCIENTIFIC_WITH_LEADING_ZERO", "SCALE_PRESERVING_SCIENTIFIC", "ENGINEERING", _1.Source);
        const width = (0, combi_1.seq)("WIDTH =", _1.Source);
        const align = (0, combi_1.seq)("ALIGN =", alignOptions);
        const timezone = (0, combi_1.seq)("TIMEZONE =", _1.Source);
        const timestamp = (0, combi_1.seq)("TIMESTAMP =", timeStampOptions);
        const pad = (0, combi_1.seq)("PAD =", _1.Source);
        const number = (0, combi_1.seq)("NUMBER =", numberOptions);
        const sign = (0, combi_1.seq)("SIGN =", signOptions);
        const decimals = (0, combi_1.seq)("DECIMALS =", _1.Source);
        const alpha = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("ALPHA =", alphaOptions));
        const xsd = (0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.seq)("XSD =", zeroXSDOptions));
        const formatting = (0, combi_1.altPrio)((0, combi_1.seq)("TIME =", dateTimeOptions), (0, combi_1.seq)("DATE =", dateTimeOptions), (0, combi_1.seq)("CASE =", caseOptions), (0, combi_1.seq)("EXPONENT", _1.Source), (0, combi_1.seq)("ZERO =", zeroXSDOptions), xsd, (0, combi_1.seq)("STYLE =", styleOptions), (0, combi_1.seq)("CURRENCY =", _1.Source), (0, combi_1.seq)("COUNTRY =", _1.Source), (0, combi_1.per)(sign, number, decimals, width, pad, alpha, align), (0, combi_1.per)(timezone, timestamp));
        return formatting;
    }
}
exports.StringTemplateFormatting = StringTemplateFormatting;
//# sourceMappingURL=string_template_formatting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_source.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/string_template_source.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplateSource = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class StringTemplateSource extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)(_1.Source, (0, combi_1.optPrio)(_1.StringTemplateFormatting));
        return ret;
    }
}
exports.StringTemplateSource = StringTemplateSource;
//# sourceMappingURL=string_template_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/super_class_name.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/super_class_name.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuperClassName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SuperClassName extends combi_1.Expression {
    getRunnable() {
        return new _1.ClassName();
    }
}
exports.SuperClassName = SuperClassName;
//# sourceMappingURL=super_class_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/switch_body.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/switch_body.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwitchBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SwitchBody extends combi_1.Expression {
    getRunnable() {
        const or = (0, combi_1.seq)("OR", _1.Source);
        const swhen = (0, combi_1.seq)("WHEN", _1.Source, (0, combi_1.star)(or), "THEN", (0, combi_1.alt)(_1.Source, _1.Throw));
        return (0, combi_1.seq)((0, combi_1.opt)(_1.Let), _1.Source, (0, combi_1.plus)(swhen), (0, combi_1.opt)((0, combi_1.seq)("ELSE", (0, combi_1.alt)(_1.Source, _1.Throw))));
    }
}
exports.SwitchBody = SwitchBody;
//# sourceMappingURL=switch_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_body.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class TableBody extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.BracketLeft), (0, combi_1.tok)(tokens_1.BracketRightW));
        return ret;
    }
}
exports.TableBody = TableBody;
//# sourceMappingURL=table_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_expression.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/table_expression.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableExpression = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TableExpression extends combi_1.Expression {
    getRunnable() {
        const fields = (0, combi_1.plus)((0, combi_1.seq)((0, combi_1.altPrio)(_1.ComponentChainSimple, _1.Dynamic), "=", _1.Source));
        const key = (0, combi_1.seq)("KEY", _1.SimpleName);
        const index = (0, combi_1.seq)("INDEX", _1.Source);
        const ret = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.BracketLeftW), (0, combi_1.alt)(_1.Source, (0, combi_1.seq)((0, combi_1.optPrio)(key), (0, combi_1.opt)("COMPONENTS"), (0, combi_1.altPrio)(fields, index))), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WBracketRight), (0, combi_1.tok)(tokens_1.WBracketRightW)));
        return (0, combi_1.ver)(version_1.Version.v740sp02, ret);
    }
}
exports.TableExpression = TableExpression;
//# sourceMappingURL=table_expression.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Target = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/attribute_name.js");
const dereference_1 = __webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dereference.js");
class Target extends combi_1.Expression {
    getRunnable() {
        const attr = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.InstanceArrow), attribute_name_1.AttributeName);
        const comp = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), _1.ComponentName);
        const something = (0, combi_1.starPrio)((0, combi_1.altPrio)(dereference_1.Dereference, attr, comp, _1.TableExpression));
        const clas = (0, combi_1.seq)(_1.ClassName, (0, combi_1.tok)(tokens_1.StaticArrow), attribute_name_1.AttributeName);
        const start = (0, combi_1.altPrio)(_1.Cast, _1.NewObject, clas, _1.TargetField, _1.TargetFieldSymbol);
        const fields = (0, combi_1.seq)((0, combi_1.optPrio)(_1.FieldOffset), (0, combi_1.optPrio)(_1.FieldLength));
        const optional = (0, combi_1.altPrio)(_1.TableBody, fields);
        return (0, combi_1.altPrio)(_1.InlineData, _1.InlineFS, (0, combi_1.seq)(start, something, optional));
    }
}
exports.Target = Target;
//# sourceMappingURL=target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TargetField = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TargetField extends combi_1.Expression {
    getRunnable() {
        return new _1.Field();
    }
}
exports.TargetField = TargetField;
//# sourceMappingURL=target_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field_symbol.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target_field_symbol.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TargetFieldSymbol = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TargetFieldSymbol extends combi_1.Expression {
    getRunnable() {
        return new _1.FieldSymbol();
    }
}
exports.TargetFieldSymbol = TargetFieldSymbol;
//# sourceMappingURL=target_field_symbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/test_seam_name.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/test_seam_name.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSeamName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class TestSeamName extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)((0, combi_1.regex)(/^[\w%\$\*]+$/), (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), (0, combi_1.regex)(/^[\w%\$\*]+$/))));
        return ret;
    }
}
exports.TestSeamName = TestSeamName;
//# sourceMappingURL=test_seam_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElement = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TextElement extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("TEXT", (0, combi_1.tok)(tokens_1.Dash), _1.TextElementKey);
    }
}
exports.TextElement = TextElement;
//# sourceMappingURL=text_element.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_key.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_key.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementKey = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class TextElementKey extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\w{3}$/);
    }
}
exports.TextElementKey = TextElementKey;
//# sourceMappingURL=text_element_key.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_string.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/text_element_string.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TextElementString = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TextElementString extends combi_1.Expression {
    getRunnable() {
        const text = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), _1.TextElementKey, (0, combi_1.tok)(tokens_1.ParenRightW));
        const stri = (0, combi_1.seq)((0, combi_1.regex)(/^('.*')|(`.*`)$/), text);
        return stri;
    }
}
exports.TextElementString = TextElementString;
//# sourceMappingURL=text_element_string.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/throw.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/throw.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Throw = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Throw extends combi_1.Expression {
    getRunnable() {
        // todo, MESSAGE
        return (0, combi_1.seq)("THROW", (0, combi_1.opt)("RESUMABLE"), _1.ClassName, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeftW), (0, combi_1.tok)(tokens_1.ParenLeft)), (0, combi_1.opt)((0, combi_1.alt)(_1.Source, _1.ParameterListS)), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRightW)));
    }
}
exports.Throw = Throw;
//# sourceMappingURL=throw.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/transporting_fields.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/transporting_fields.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransportingFields = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/dynamic.js");
const field_sub_1 = __webpack_require__(/*! ./field_sub */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_sub.js");
class TransportingFields extends combi_1.Expression {
    getRunnable() {
        const fields = (0, combi_1.plus)((0, combi_1.alt)((0, combi_1.seq)("INTO", (0, combi_1.failStar)()), field_sub_1.FieldSub));
        return (0, combi_1.altPrio)(dynamic_1.Dynamic, fields);
    }
}
exports.TransportingFields = TransportingFields;
//# sourceMappingURL=transporting_fields.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Type extends combi_1.Expression {
    getRunnable() {
        const typeType = (0, combi_1.seq)(_1.TypeName, (0, combi_1.optPrio)(_1.Default));
        const like = (0, combi_1.altPrio)((0, combi_1.seq)("LINE OF", _1.FieldChain), (0, combi_1.seq)("REF TO", _1.FieldChain), _1.FieldChain);
        const type = (0, combi_1.altPrio)((0, combi_1.seq)("LINE OF", typeType), (0, combi_1.seq)("REF TO", typeType), (0, combi_1.seq)(typeType, (0, combi_1.optPrio)(_1.LOBHandle)));
        const ret = (0, combi_1.altPrio)((0, combi_1.seq)("LIKE", like), (0, combi_1.seq)("TYPE", type));
        return ret;
    }
}
exports.Type = Type;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeName = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
// todo, can this be replaced with one of the FieldChain expressions?
class TypeName extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.regex)(/^[\w~\/%$]+$/);
        const cla = (0, combi_1.seq)(name, (0, combi_1.alt)((0, combi_1.tok)(tokens_1.StaticArrow), (0, combi_1.tok)(tokens_1.InstanceArrow)));
        const field = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.Dash), name);
        return (0, combi_1.seq)((0, combi_1.opt)(cla), name, (0, combi_1.starPrio)(field));
    }
}
exports.TypeName = TypeName;
//# sourceMappingURL=type_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name_or_infer.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_name_or_infer.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeNameOrInfer = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TypeNameOrInfer extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.altPrio)("#", _1.TypeName);
    }
}
exports.TypeNameOrInfer = TypeNameOrInfer;
//# sourceMappingURL=type_name_or_infer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_param.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_param.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeParam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TypeParam extends combi_1.Expression {
    getRunnable() {
        const table = (0, combi_1.seq)((0, combi_1.altPrio)("STANDARD", "HASHED", "INDEX", "SORTED", "ANY"), "TABLE");
        const foo = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.seq)(table, "OF")), (0, combi_1.optPrio)("REF TO"));
        const typeLine = "LINE OF";
        const ret = (0, combi_1.seq)((0, combi_1.alt)(foo, typeLine), _1.TypeNameOrInfer, (0, combi_1.opt)(_1.Default));
        const like = (0, combi_1.seq)("LIKE", (0, combi_1.opt)("LINE OF"), _1.FieldChain, (0, combi_1.optPrio)(_1.Default));
        return (0, combi_1.alt)((0, combi_1.seq)("TYPE", (0, combi_1.alt)(table, ret)), like);
    }
}
exports.TypeParam = TypeParam;
//# sourceMappingURL=type_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_structure.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_structure.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeStructure = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TypeStructure extends combi_1.Expression {
    getRunnable() {
        // todo, add version,
        const hier = (0, combi_1.seq)("HIERARCHY", _1.NamespaceSimpleName);
        const evt = (0, combi_1.seq)("EVENT", _1.EventName);
        return (0, combi_1.seq)("TYPE STRUCTURE FOR", (0, combi_1.altPrio)(hier, evt));
    }
}
exports.TypeStructure = TypeStructure;
//# sourceMappingURL=type_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeTable = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/field_chain.js");
const type_table_key_1 = __webpack_require__(/*! ./type_table_key */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table_key.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeTable extends combi_1.Expression {
    getRunnable() {
        const header = "WITH HEADER LINE";
        const initial = (0, combi_1.seq)("INITIAL SIZE", _1.Constant);
        const generic = (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.alt)("STANDARD", "HASHED", "INDEX", "SORTED", "ANY")), "TABLE");
        const normal1 = (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.alt)("STANDARD", "HASHED", "INDEX", "SORTED", "ANY")), "TABLE OF", (0, combi_1.optPrio)("REF TO"), _1.TypeName);
        const likeType = (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.alt)("STANDARD", "HASHED", "INDEX", "SORTED", "ANY")), "TABLE OF", (0, combi_1.optPrio)("REF TO"), (0, combi_1.opt)(field_chain_1.FieldChain), (0, combi_1.opt)((0, combi_1.per)(header, initial, (0, combi_1.plusPrio)(type_table_key_1.TypeTableKey))));
        const rangeType = (0, combi_1.seq)("RANGE OF", _1.TypeName, (0, combi_1.optPrio)(header), (0, combi_1.optPrio)(initial), (0, combi_1.optPrio)("VALUE IS INITIAL"));
        const rangeLike = (0, combi_1.seq)("RANGE OF", field_chain_1.FieldChain, (0, combi_1.optPrio)(header), (0, combi_1.optPrio)(initial), (0, combi_1.optPrio)("VALUE IS INITIAL"));
        // a maximum of 15 secondary table keys can be defined
        // "WITH" is not allowed as a field name in keys
        const typetable = (0, combi_1.alt)(generic, (0, combi_1.seq)(normal1, (0, combi_1.alt)((0, combi_1.opt)((0, combi_1.per)(header, initial, (0, combi_1.plusPrio)(type_table_key_1.TypeTableKey))), (0, combi_1.seq)((0, combi_1.plus)(type_table_key_1.TypeTableKey), (0, combi_1.optPrio)(initial)))));
        const occurs = (0, combi_1.seq)("OCCURS", _1.Integer);
        const derived = (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.seq)("TABLE FOR", (0, combi_1.altPrio)("ACTION IMPORT", "ACTION RESULT", "CREATE", "EVENT", "FAILED", "LOCK", "READ RESULT", "UPDATE"), _1.TypeName));
        const oldType = (0, combi_1.seq)((0, combi_1.opt)("REF TO"), _1.TypeName, (0, combi_1.alt)((0, combi_1.seq)(occurs, (0, combi_1.opt)(header)), header));
        const oldLike = (0, combi_1.seq)((0, combi_1.opt)("REF TO"), field_chain_1.FieldChain, (0, combi_1.alt)((0, combi_1.seq)(occurs, (0, combi_1.opt)(header)), header));
        const ret = (0, combi_1.altPrio)((0, combi_1.seq)(occurs, (0, combi_1.opt)(header)), (0, combi_1.seq)("LIKE", (0, combi_1.alt)(oldLike, likeType, rangeLike)), (0, combi_1.seq)("TYPE", (0, combi_1.alt)(oldType, typetable, rangeType, derived)));
        return ret;
    }
}
exports.TypeTable = TypeTable;
//# sourceMappingURL=type_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table_key.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/type_table_key.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeTableKey = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeTableKey extends combi_1.Expression {
    getRunnable() {
        const uniqueness = (0, combi_1.alt)("NON-UNIQUE", "UNIQUE");
        const defaultKey = "DEFAULT KEY";
        const emptyKey = (0, combi_1.ver)(version_1.Version.v740sp02, "EMPTY KEY");
        const components = (0, combi_1.plus)((0, combi_1.alt)((0, combi_1.seq)("WITH", (0, combi_1.failStar)()), _1.FieldSub));
        const further = (0, combi_1.seq)((0, combi_1.alt)("WITHOUT", "WITH"), "FURTHER SECONDARY KEYS");
        const key = (0, combi_1.seq)("WITH", (0, combi_1.opt)(uniqueness), (0, combi_1.altPrio)(defaultKey, emptyKey, (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.alt)("SORTED", "HASHED")), "KEY", (0, combi_1.alt)((0, combi_1.seq)(_1.Field, "COMPONENTS", components), components))), (0, combi_1.optPrio)(further), (0, combi_1.optPrio)("READ-ONLY"));
        return key;
    }
}
exports.TypeTableKey = TypeTableKey;
//# sourceMappingURL=type_table_key.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Value = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Value extends combi_1.Expression {
    getRunnable() {
        const ret = (0, combi_1.seq)("VALUE", (0, combi_1.alt)(_1.Constant, _1.SimpleFieldChain, "IS INITIAL"));
        return ret;
    }
}
exports.Value = Value;
//# sourceMappingURL=value.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueBody = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ValueBody extends combi_1.Expression {
    getRunnable() {
        const base = (0, combi_1.seq)("BASE", _1.Source);
        const strucOrTab = (0, combi_1.seq)((0, combi_1.optPrio)(_1.Let), (0, combi_1.optPrio)(base), (0, combi_1.star)(_1.For), (0, combi_1.plusPrio)((0, combi_1.altPrio)(_1.FieldAssignment, _1.ValueBodyLine)));
        const tabdef = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.altPrio)("OPTIONAL", (0, combi_1.seq)("DEFAULT", _1.Source)));
        return (0, combi_1.optPrio)((0, combi_1.altPrio)(strucOrTab, (0, combi_1.seq)(_1.Source, (0, combi_1.optPrio)(tabdef))));
    }
}
exports.ValueBody = ValueBody;
//# sourceMappingURL=value_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_line.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_line.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueBodyLine = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const value_body_lines_1 = __webpack_require__(/*! ./value_body_lines */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_lines.js");
class ValueBodyLine extends combi_1.Expression {
    getRunnable() {
        // missing spaces caught by rule "parser_missing_space"
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenLeftW), (0, combi_1.tok)(tokens_1.WParenLeft)), (0, combi_1.optPrio)((0, combi_1.altPrio)((0, combi_1.plusPrio)(_1.FieldAssignment), value_body_lines_1.ValueBodyLines, _1.Source)), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.WParenRightW), (0, combi_1.tok)(tokens_1.ParenRightW)));
        return ret;
    }
}
exports.ValueBodyLine = ValueBodyLine;
//# sourceMappingURL=value_body_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_lines.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/value_body_lines.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueBodyLines = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ValueBodyLines extends combi_1.Expression {
    getRunnable() {
        const range = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.seq)("FROM", _1.Source)), (0, combi_1.optPrio)((0, combi_1.seq)("TO", _1.Source)));
        const lines = (0, combi_1.seq)("LINES OF", _1.Source, range);
        return lines;
    }
}
exports.ValueBodyLines = ValueBodyLines;
//# sourceMappingURL=value_body_lines.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/with_name.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/with_name.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WithName = void 0;
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class WithName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WPlus), (0, combi_1.regex)(/^\w+$/));
    }
}
exports.WithName = WithName;
//# sourceMappingURL=with_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/write_offset_length.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/write_offset_length.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WriteOffsetLength = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const simple_field_chain2_1 = __webpack_require__(/*! ./simple_field_chain2 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_field_chain2.js");
class WriteOffsetLength extends combi_1.Expression {
    getRunnable() {
        const post = (0, combi_1.seq)((0, combi_1.alt)(simple_field_chain2_1.SimpleFieldChain2, (0, combi_1.regex)(/^[\d]+$/), (0, combi_1.regex)(/^\*$/)), (0, combi_1.alt)((0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.ParenRight)));
        const wlength = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeft), post);
        const length = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), post);
        const complex = (0, combi_1.alt)(wlength, (0, combi_1.seq)((0, combi_1.alt)(simple_field_chain2_1.SimpleFieldChain2, (0, combi_1.regex)(/^\/?[\w\d]+$/), "/"), (0, combi_1.opt)(length)));
        const at = (0, combi_1.seq)((0, combi_1.opt)("AT"), complex);
        return at;
    }
}
exports.WriteOffsetLength = WriteOffsetLength;
//# sourceMappingURL=write_offset_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/result.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/result.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Result = void 0;
class Result {
    constructor(tokens, tokenIndex, nodes) {
        // tokens: all tokens, from the tokenIndex = not yet matched
        // nodes: matched tokens
        this.tokens = tokens;
        this.tokenIndex = tokenIndex;
        this.nodes = nodes;
        if (this.nodes === undefined) {
            this.nodes = [];
        }
    }
    peek() {
        return this.tokens[this.tokenIndex];
    }
    shift(node) {
        const cp = this.nodes.slice();
        cp.push(node);
        return new Result(this.tokens, this.tokenIndex + 1, cp);
    }
    popNode() {
        return this.nodes.pop();
    }
    getNodes() {
        return this.nodes;
    }
    setNodes(n) {
        this.nodes = n;
    }
    remainingLength() {
        return this.tokens.length - this.tokenIndex;
    }
}
exports.Result = Result;
//# sourceMappingURL=result.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statement_parser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statement_parser.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatementParser = exports.STATEMENT_MAX_TOKENS = void 0;
const Statements = __webpack_require__(/*! ./statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ./expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Tokens = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const artifacts_1 = __webpack_require__(/*! ../artifacts */ "./node_modules/@abaplint/core/build/src/abap/artifacts.js");
const combi_1 = __webpack_require__(/*! ./combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const _statement_1 = __webpack_require__(/*! ./statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const expand_macros_1 = __webpack_require__(/*! ./expand_macros */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expand_macros.js");
const tokens_1 = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
exports.STATEMENT_MAX_TOKENS = 1000;
class StatementMap {
    constructor() {
        this.map = {};
        for (const stat of artifacts_1.ArtifactsABAP.getStatements()) {
            const f = stat.getMatcher().first();
            if (f.length === 0) {
                throw new Error("StatementMap, first must have contents");
            }
            for (const first of f) {
                if (this.map[first]) {
                    this.map[first].push({ statement: stat });
                }
                else {
                    this.map[first] = [{ statement: stat }];
                }
            }
        }
    }
    lookup(str) {
        const res = this.map[str.toUpperCase()];
        if (res === undefined) {
            return [];
        }
        if (res[0].matcher === undefined) {
            for (const r of res) {
                r.matcher = r.statement.getMatcher();
            }
        }
        return res;
    }
}
class WorkArea {
    constructor(file, tokens) {
        this.file = file;
        this.tokens = tokens;
        this.statements = [];
    }
    addUnknown(pre, post, colon) {
        const st = new nodes_1.StatementNode(new _statement_1.Unknown(), colon);
        st.setChildren(this.tokensToNodes(pre, post));
        this.statements.push(st);
    }
    toResult() {
        return { file: this.file, tokens: this.tokens, statements: this.statements };
    }
    tokensToNodes(tokens1, tokens2) {
        const ret = [];
        for (const t of tokens1) {
            ret.push(new nodes_1.TokenNode(t));
        }
        for (const t of tokens2) {
            ret.push(new nodes_1.TokenNode(t));
        }
        return ret;
    }
}
class StatementParser {
    constructor(version, reg) {
        if (!StatementParser.map) {
            StatementParser.map = new StatementMap();
        }
        this.version = version;
        this.reg = reg;
    }
    /** input is one full object */
    run(input, globalMacros) {
        const macros = new expand_macros_1.ExpandMacros(globalMacros, this.version, this.reg);
        const wa = input.map(i => new WorkArea(i.file, i.tokens));
        for (const w of wa) {
            this.process(w);
            this.categorize(w);
            macros.find(w.statements, w.file);
        }
        for (const w of wa) {
            const res = macros.handleMacros(w.statements, w.file);
            w.statements = res.statements;
            if (res.containsUnknown === true) {
                this.lazyUnknown(w);
            }
            this.nativeSQL(w);
        }
        return wa.map(w => w.toResult());
    }
    // todo, refactor, remove method here and only have in WorkArea class
    tokensToNodes(tokens) {
        const ret = [];
        for (const t of tokens) {
            ret.push(new nodes_1.TokenNode(t));
        }
        return ret;
    }
    // tries to split Unknown statements by newlines, when adding/writing a new statement
    // in an editor, adding the statement terminator is typically the last thing to do
    // note: this will not work if the second statement is a macro call, guess this is okay
    lazyUnknown(wa) {
        const result = [];
        for (let statement of wa.statements) {
            // dont use CALL METHOD, when executing lazy, it easily gives a Move for the last statment if lazy logic is evaluated
            if (statement.get() instanceof _statement_1.Unknown) {
                const concat = statement.concatTokens().toUpperCase();
                if (concat.startsWith("CALL METHOD ") === false
                    && concat.startsWith("RAISE EXCEPTION TYPE ") === false
                    && concat.startsWith("READ TABLE ") === false
                    && concat.startsWith("LOOP AT ") === false
                    && concat.startsWith("CALL FUNCTION ") === false) {
                    for (const { first, second } of this.buildSplits(statement.getTokens())) {
                        if (second.length === 1) {
                            continue; // probably punctuation
                        }
                        const s = this.categorizeStatement(new nodes_1.StatementNode(new _statement_1.Unknown()).setChildren(this.tokensToNodes(second)));
                        if (!(s.get() instanceof _statement_1.Unknown) && !(s.get() instanceof _statement_1.Empty)) {
                            result.push(new nodes_1.StatementNode(new _statement_1.Unknown()).setChildren(this.tokensToNodes(first)));
                            statement = s;
                            break;
                        }
                    }
                }
            }
            result.push(statement);
        }
        wa.statements = result;
    }
    buildSplits(tokens) {
        const res = [];
        const before = [];
        let prevRow = tokens[0].getRow();
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].getRow() !== prevRow) {
                res.push({ first: [...before], second: [...tokens].splice(i) });
            }
            prevRow = tokens[i].getRow();
            before.push(tokens[i]);
        }
        return res;
    }
    nativeSQL(wa) {
        let sql = false;
        for (let i = 0; i < wa.statements.length; i++) {
            const statement = wa.statements[i];
            const type = statement.get();
            if (type instanceof Statements.ExecSQL
                || (type instanceof Statements.MethodImplementation && statement.findDirectExpression(Expressions.Language))) {
                sql = true;
            }
            else if (sql === true) {
                if (type instanceof Statements.EndExec
                    || type instanceof Statements.EndMethod) {
                    sql = false;
                }
                else if (!(type instanceof _statement_1.Comment)) {
                    wa.statements[i] = new nodes_1.StatementNode(new _statement_1.NativeSQL()).setChildren(this.tokensToNodes(statement.getTokens()));
                }
            }
        }
    }
    // for each statement, run statement matchers to figure out which kind of statement it is
    categorize(wa) {
        const result = [];
        for (const statement of wa.statements) {
            result.push(this.categorizeStatement(statement));
        }
        wa.statements = result;
    }
    categorizeStatement(input) {
        let statement = input;
        const length = input.getChildren().length;
        const lastToken = input.getLastToken();
        const isPunctuation = lastToken instanceof Tokens.Punctuation;
        if (length === 1 && isPunctuation) {
            const tokens = statement.getTokens();
            statement = new nodes_1.StatementNode(new _statement_1.Empty()).setChildren(this.tokensToNodes(tokens));
        }
        else if (statement.get() instanceof _statement_1.Unknown) {
            if (isPunctuation) {
                statement = this.match(statement);
            }
            else if (length > exports.STATEMENT_MAX_TOKENS) {
                // if the statement contains more than STATEMENT_MAX_TOKENS tokens, just give up
                statement = input;
            }
            else if (length === 1 && lastToken instanceof tokens_1.Pragma) {
                statement = new nodes_1.StatementNode(new _statement_1.Empty(), undefined, [lastToken]);
            }
        }
        return statement;
    }
    removePragma(tokens) {
        const result = [];
        const pragmas = [];
        // skip the last token as it is the punctuation
        for (let i = 0; i < tokens.length - 1; i++) {
            const t = tokens[i];
            if (t instanceof Tokens.Pragma) {
                pragmas.push(t);
            }
            else {
                result.push(t);
            }
        }
        return { tokens: result, pragmas: pragmas };
    }
    match(statement) {
        const tokens = statement.getTokens();
        const { tokens: filtered, pragmas } = this.removePragma(tokens);
        if (filtered.length === 0) {
            return new nodes_1.StatementNode(new _statement_1.Empty()).setChildren(this.tokensToNodes(tokens));
        }
        for (const st of StatementParser.map.lookup(filtered[0].getStr())) {
            const match = combi_1.Combi.run(st.matcher, filtered, this.version);
            if (match) {
                const last = tokens[tokens.length - 1];
                match.push(new nodes_1.TokenNode(last));
                return new nodes_1.StatementNode(st.statement, statement.getColon(), pragmas).setChildren(match);
            }
        }
        // next try the statements without specific keywords
        for (const st of StatementParser.map.lookup("")) {
            const match = combi_1.Combi.run(st.matcher, filtered, this.version);
            if (match) {
                const last = tokens[tokens.length - 1];
                match.push(new nodes_1.TokenNode(last));
                return new nodes_1.StatementNode(st.statement, statement.getColon(), pragmas).setChildren(match);
            }
        }
        return statement;
    }
    // takes care of splitting tokens into statements, also handles chained statements
    // statements are split by "," or "."
    // additional colons/chaining after the first colon are ignored
    process(wa) {
        let add = [];
        let pre = [];
        let colon = undefined;
        for (const token of wa.tokens) {
            if (token instanceof Tokens.Comment) {
                wa.statements.push(new nodes_1.StatementNode(new _statement_1.Comment()).setChildren(this.tokensToNodes([token])));
                continue;
            }
            add.push(token);
            const str = token.getStr();
            if (str.length === 1) {
                if (str === ".") {
                    wa.addUnknown(pre, add, colon);
                    add = [];
                    pre = [];
                    colon = undefined;
                }
                else if (str === "," && pre.length > 0) {
                    wa.addUnknown(pre, add, colon);
                    add = [];
                }
                else if (str === ":" && colon === undefined) {
                    colon = token;
                    add.pop(); // do not add colon token to statement
                    pre.push(...add);
                    add = [];
                }
                else if (str === ":") {
                    add.pop(); // do not add colon token to statement
                }
            }
        }
        if (add.length > 0) {
            wa.addUnknown(pre, add, colon);
        }
    }
}
exports.StatementParser = StatementParser;
//# sourceMappingURL=statement_parser.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NativeSQL = exports.MacroContent = exports.MacroCall = exports.Empty = exports.Comment = exports.Unknown = void 0;
class Unknown {
    getMatcher() {
        throw new Error("Unknown Statement, get_matcher");
    }
}
exports.Unknown = Unknown;
class Comment {
    getMatcher() {
        throw new Error("Comment Statement, get_matcher");
    }
}
exports.Comment = Comment;
class Empty {
    getMatcher() {
        throw new Error("Empty Statement, get_matcher");
    }
}
exports.Empty = Empty;
class MacroCall {
    getMatcher() {
        throw new Error("MacroCall Statement, get_matcher");
    }
}
exports.MacroCall = MacroCall;
class MacroContent {
    getMatcher() {
        throw new Error("MacroContent Statement, get_matcher");
    }
}
exports.MacroContent = MacroContent;
class NativeSQL {
    getMatcher() {
        throw new Error("NativeSQL Statement, get_matcher");
    }
}
exports.NativeSQL = NativeSQL;
//# sourceMappingURL=_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Add = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Add {
    getMatcher() {
        const to = (0, combi_1.seq)("TO", expressions_1.Target);
        const then = (0, combi_1.seq)("THEN", expressions_1.FieldSub, "UNTIL", expressions_1.FieldSub, "GIVING", expressions_1.FieldSub);
        const ret = (0, combi_1.seq)("ADD", expressions_1.Source, (0, combi_1.altPrio)(to, then));
        return ret;
    }
}
exports.Add = Add;
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add_corresponding.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add_corresponding.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddCorresponding = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class AddCorresponding {
    getMatcher() {
        const ret = (0, combi_1.seq)("ADD-CORRESPONDING", expressions_1.Source, "TO", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.AddCorresponding = AddCorresponding;
//# sourceMappingURL=add_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/aliases.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/aliases.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Aliases = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Aliases {
    getMatcher() {
        return (0, combi_1.seq)("ALIASES", expressions_1.SimpleName, "FOR", expressions_1.Field);
    }
}
exports.Aliases = Aliases;
//# sourceMappingURL=aliases.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/append.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/append.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Append = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Append {
    getMatcher() {
        const assigning = (0, combi_1.seq)("ASSIGNING", expressions_1.FSTarget);
        const reference = (0, combi_1.seq)("REFERENCE INTO", expressions_1.Target);
        const sorted = (0, combi_1.seq)("SORTED BY", expressions_1.Field);
        const fromIndex = (0, combi_1.seq)("FROM", expressions_1.Source);
        const toIndex = (0, combi_1.seq)("TO", expressions_1.Source);
        const toTarget = (0, combi_1.seq)("TO", expressions_1.Target);
        const src = (0, combi_1.alt)(expressions_1.SimpleSource4, (0, combi_1.ver)(version_1.Version.v740sp02, expressions_1.Source));
        return (0, combi_1.seq)("APPEND", (0, combi_1.altPrio)("INITIAL LINE", (0, combi_1.seq)((0, combi_1.optPrio)("LINES OF"), src)), (0, combi_1.optPrio)(fromIndex), (0, combi_1.opt)((0, combi_1.alt)((0, combi_1.seq)(toIndex, toTarget), toTarget)), (0, combi_1.opt)((0, combi_1.altPrio)(assigning, reference)), (0, combi_1.optPrio)("CASTING"), (0, combi_1.optPrio)(sorted));
    }
}
exports.Append = Append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assert.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assert.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Assert = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Assert {
    getMatcher() {
        const fields = (0, combi_1.seq)("FIELDS", (0, combi_1.plus)(expressions_1.Source));
        const subkey = (0, combi_1.seq)("SUBKEY", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.NamespaceSimpleName);
        return (0, combi_1.seq)("ASSERT", (0, combi_1.optPrio)(id), (0, combi_1.optPrio)(subkey), (0, combi_1.opt)(fields), (0, combi_1.optPrio)("CONDITION"), expressions_1.Cond);
    }
}
exports.Assert = Assert;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Assign = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Assign {
    getMatcher() {
        const type = (0, combi_1.seq)("TYPE", (0, combi_1.altPrio)(expressions_1.Dynamic, expressions_1.TypeName));
        const like = (0, combi_1.seq)("LIKE", (0, combi_1.altPrio)(expressions_1.Dynamic, expressions_1.Source));
        const handle = (0, combi_1.seq)("TYPE HANDLE", expressions_1.Source);
        const range = (0, combi_1.seq)("RANGE", expressions_1.Source);
        const decimals = (0, combi_1.seq)("DECIMALS", expressions_1.Source);
        const casting = (0, combi_1.seq)("CASTING", (0, combi_1.opt)((0, combi_1.alt)(like, handle, (0, combi_1.per)(type, decimals))));
        const obsoleteType = (0, combi_1.seq)("TYPE", expressions_1.Source, (0, combi_1.optPrio)(decimals));
        const ret = (0, combi_1.seq)("ASSIGN", (0, combi_1.opt)((0, combi_1.seq)(expressions_1.Target, "INCREMENT")), expressions_1.AssignSource, "TO", expressions_1.FSTarget, (0, combi_1.opt)((0, combi_1.altPrio)(casting, obsoleteType)), (0, combi_1.opt)(range), (0, combi_1.opt)((0, combi_1.ver)(version_1.Version.v757, "ELSE UNASSIGN")));
        return ret;
    }
}
exports.Assign = Assign;
//# sourceMappingURL=assign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign_local_copy.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign_local_copy.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssignLocalCopy = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class AssignLocalCopy {
    getMatcher() {
        const ret = (0, combi_1.seq)("ASSIGN LOCAL COPY OF", (0, combi_1.opt)((0, combi_1.seq)("INITIAL", (0, combi_1.opt)("LINE OF"))), (0, combi_1.alt)(expressions_1.Source, expressions_1.Dynamic), "TO", expressions_1.TargetFieldSymbol);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.AssignLocalCopy = AssignLocalCopy;
//# sourceMappingURL=assign_local_copy.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.At = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class At {
    getMatcher() {
        const field = (0, combi_1.alt)((0, combi_1.seq)(expressions_1.FieldSub, (0, combi_1.opt)(expressions_1.FieldOffset), (0, combi_1.opt)(expressions_1.FieldLength)), expressions_1.Dynamic, expressions_1.SourceFieldSymbol);
        const atNew = (0, combi_1.seq)("NEW", field);
        const atEnd = (0, combi_1.seq)("END OF", field);
        const group = (0, combi_1.regex)(/^\w+$/);
        const ret = (0, combi_1.seq)("AT", (0, combi_1.altPrio)(atNew, atEnd, group));
        return ret;
    }
}
exports.At = At;
//# sourceMappingURL=at.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_first.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_first.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtFirst = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class AtFirst {
    getMatcher() {
        return (0, combi_1.str)("AT FIRST");
    }
}
exports.AtFirst = AtFirst;
//# sourceMappingURL=at_first.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_last.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_last.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtLast = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class AtLast {
    getMatcher() {
        return (0, combi_1.str)("AT LAST");
    }
}
exports.AtLast = AtLast;
//# sourceMappingURL=at_last.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_line_selection.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_line_selection.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtLineSelection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class AtLineSelection {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "AT LINE-SELECTION");
    }
}
exports.AtLineSelection = AtLineSelection;
//# sourceMappingURL=at_line_selection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_selection_screen.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_selection_screen.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtSelectionScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class AtSelectionScreen {
    getMatcher() {
        const output = "OUTPUT";
        const value = (0, combi_1.seq)("ON VALUE-REQUEST FOR", expressions_1.FieldSub);
        const exit = "ON EXIT-COMMAND";
        const field = (0, combi_1.seq)("ON", expressions_1.FieldSub);
        const end = (0, combi_1.seq)("ON END OF", expressions_1.Field);
        const radio = (0, combi_1.seq)("ON RADIOBUTTON GROUP", expressions_1.Field);
        const block = (0, combi_1.seq)("ON BLOCK", (0, combi_1.regex)(/^\w+$/));
        const help = (0, combi_1.seq)("ON HELP-REQUEST FOR", expressions_1.FieldSub);
        const ret = (0, combi_1.seq)("AT SELECTION-SCREEN", (0, combi_1.opt)((0, combi_1.alt)(output, value, radio, exit, field, end, help, block)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.AtSelectionScreen = AtSelectionScreen;
//# sourceMappingURL=at_selection_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_user_command.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_user_command.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtUserCommand = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class AtUserCommand {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "AT USER-COMMAND");
    }
}
exports.AtUserCommand = AtUserCommand;
//# sourceMappingURL=at_user_command.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/authority_check.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/authority_check.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorityCheck = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class AuthorityCheck {
    getMatcher() {
        const field = (0, combi_1.seq)("FIELD", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.Source, (0, combi_1.alt)(field, "DUMMY"));
        const ret = (0, combi_1.seq)("AUTHORITY-CHECK OBJECT", expressions_1.Source, (0, combi_1.opt)((0, combi_1.seq)("FOR USER", expressions_1.Source)), (0, combi_1.plus)(id));
        return ret;
    }
}
exports.AuthorityCheck = AuthorityCheck;
//# sourceMappingURL=authority_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/back.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/back.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Back = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Back {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "BACK");
    }
}
exports.Back = Back;
//# sourceMappingURL=back.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Break = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Break {
    getMatcher() {
        const next = (0, combi_1.str)("AT NEXT APPLICATION STATEMENT");
        const ret = (0, combi_1.altPrio)((0, combi_1.seq)("BREAK-POINT", (0, combi_1.optPrio)((0, combi_1.altPrio)(next, expressions_1.Source))), (0, combi_1.seq)("BREAK", expressions_1.FieldSub));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Break = Break;
//# sourceMappingURL=break.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break_id.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break_id.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BreakId = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class BreakId {
    getMatcher() {
        const id = (0, combi_1.seq)("ID", expressions_1.Field);
        const ret = (0, combi_1.seq)("BREAK-POINT", id);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.BreakId = BreakId;
//# sourceMappingURL=break_id.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Call = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
// method call
class Call {
    getMatcher() {
        const call = (0, combi_1.seq)("CALL METHOD", expressions_1.MethodSource, expressions_1.MethodCallBody);
        return (0, combi_1.altPrio)(call, expressions_1.MethodCallChain);
    }
}
exports.Call = Call;
//# sourceMappingURL=call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_badi.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_badi.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallBadi = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallBadi {
    getMatcher() {
        const call = (0, combi_1.seq)("CALL", "BADI", expressions_1.MethodSource, expressions_1.MethodCallBody);
        return (0, combi_1.verNot)(version_1.Version.Cloud, call);
    }
}
exports.CallBadi = CallBadi;
//# sourceMappingURL=call_badi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_database.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_database.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallDatabase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallDatabase {
    getMatcher() {
        const exporting = (0, combi_1.seq)("EXPORTING", expressions_1.ParameterListS);
        const importing = (0, combi_1.seq)("IMPORTING", expressions_1.ParameterListT);
        const expl = (0, combi_1.seq)((0, combi_1.opt)(exporting), (0, combi_1.opt)(importing));
        const tab = (0, combi_1.seq)("PARAMETER-TABLE", expressions_1.Source);
        const ret = (0, combi_1.seq)("CALL DATABASE PROCEDURE", expressions_1.Dynamic, (0, combi_1.opt)(expressions_1.DatabaseConnection), (0, combi_1.alt)(expl, tab));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallDatabase = CallDatabase;
//# sourceMappingURL=call_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_dialog.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_dialog.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallDialog = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallDialog {
    getMatcher() {
        const from = (0, combi_1.seq)(expressions_1.FieldSub, (0, combi_1.optPrio)((0, combi_1.seq)("FROM", expressions_1.Source)));
        const exporting = (0, combi_1.seq)("EXPORTING", (0, combi_1.plus)(from));
        const to = (0, combi_1.seq)(expressions_1.Field, (0, combi_1.optPrio)((0, combi_1.seq)("TO", expressions_1.Field)));
        const importing = (0, combi_1.seq)("IMPORTING", (0, combi_1.plus)(to));
        const ret = (0, combi_1.seq)("CALL DIALOG", expressions_1.Constant, (0, combi_1.opt)(exporting), (0, combi_1.opt)(importing));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallDialog = CallDialog;
//# sourceMappingURL=call_dialog.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_function.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_function.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallFunction = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallFunction {
    getMatcher() {
        const starting = (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.seq)("STARTING NEW TASK", expressions_1.SimpleSource2));
        const update = (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.str)("IN UPDATE TASK"));
        const unit = (0, combi_1.seq)("UNIT", expressions_1.Source);
        const background = (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.seq)("IN BACKGROUND", (0, combi_1.altPrio)("TASK", unit)));
        const calling = (0, combi_1.seq)("CALLING", expressions_1.MethodSource, "ON END OF TASK");
        const performing = (0, combi_1.seq)("PERFORMING", expressions_1.FormName, "ON END OF TASK");
        const separate = (0, combi_1.str)("AS SEPARATE UNIT");
        const keeping = (0, combi_1.str)("KEEPING LOGICAL UNIT OF WORK");
        const options = (0, combi_1.per)(starting, update, background, expressions_1.Destination, calling, performing, separate, keeping);
        const dynamic = (0, combi_1.seq)("PARAMETER-TABLE", expressions_1.Source, (0, combi_1.opt)((0, combi_1.seq)("EXCEPTION-TABLE", expressions_1.Source)));
        const call = (0, combi_1.seq)("CALL", (0, combi_1.altPrio)("FUNCTION", (0, combi_1.verNot)(version_1.Version.Cloud, "CUSTOMER-FUNCTION")), expressions_1.FunctionName, (0, combi_1.opt)(options), (0, combi_1.alt)(expressions_1.FunctionParameters, dynamic));
        return call;
    }
}
exports.CallFunction = CallFunction;
//# sourceMappingURL=call_function.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_kernel.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_kernel.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallKernel = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallKernel {
    getMatcher() {
        const ret = (0, combi_1.seq)("CALL", (0, combi_1.altPrio)(expressions_1.Constant, expressions_1.Field), (0, combi_1.starPrio)(expressions_1.KernelId));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallKernel = CallKernel;
//# sourceMappingURL=call_kernel.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_ole.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_ole.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallOLE = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallOLE {
    getMatcher() {
        const rc = (0, combi_1.seq)("=", expressions_1.Target);
        const ret = (0, combi_1.seq)("CALL METHOD OF", expressions_1.Source, expressions_1.Source, (0, combi_1.opt)(rc), (0, combi_1.opt)("NO FLUSH"), (0, combi_1.opt)("QUEUEONLY"), (0, combi_1.opt)(expressions_1.OLEExporting));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallOLE = CallOLE;
//# sourceMappingURL=call_ole.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_screen.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_screen.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallScreen {
    getMatcher() {
        const starting = (0, combi_1.seq)("STARTING AT", expressions_1.Source, expressions_1.Source);
        const ending = (0, combi_1.seq)("ENDING AT", expressions_1.Source, expressions_1.Source);
        const ret = (0, combi_1.seq)("CALL SCREEN", expressions_1.Source, (0, combi_1.optPrio)((0, combi_1.seq)(starting, (0, combi_1.optPrio)(ending))));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallScreen = CallScreen;
//# sourceMappingURL=call_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_selection_screen.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_selection_screen.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallSelectionScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallSelectionScreen {
    getMatcher() {
        const ending = (0, combi_1.seq)("ENDING AT", expressions_1.Source, expressions_1.Source);
        const starting = (0, combi_1.seq)("STARTING AT", expressions_1.Source, expressions_1.Source);
        const using = (0, combi_1.seq)("USING SELECTION-SET", expressions_1.Source);
        const at = (0, combi_1.seq)(starting, (0, combi_1.opt)(ending));
        const ret = (0, combi_1.seq)("CALL SELECTION-SCREEN", expressions_1.Source, (0, combi_1.opt)(at), (0, combi_1.opt)(using));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallSelectionScreen = CallSelectionScreen;
//# sourceMappingURL=call_selection_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transaction.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transaction.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransaction = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallTransaction {
    getMatcher() {
        const options = (0, combi_1.seq)("OPTIONS FROM", expressions_1.Source);
        const messages = (0, combi_1.seq)("MESSAGES INTO", expressions_1.Target);
        const auth = (0, combi_1.seq)((0, combi_1.altPrio)("WITH", "WITHOUT"), "AUTHORITY-CHECK");
        const perm = (0, combi_1.per)((0, combi_1.seq)("UPDATE", expressions_1.Source), "AND SKIP FIRST SCREEN", options, messages, (0, combi_1.seq)("MODE", expressions_1.Source));
        const ret = (0, combi_1.seq)("CALL TRANSACTION", expressions_1.Source, (0, combi_1.optPrio)(auth), (0, combi_1.optPrio)((0, combi_1.seq)("USING", expressions_1.Source)), (0, combi_1.opt)(perm));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CallTransaction = CallTransaction;
//# sourceMappingURL=call_transaction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transformation.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transformation.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransformation = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class CallTransformation {
    getMatcher() {
        const options = (0, combi_1.seq)("OPTIONS", expressions_1.CallTransformationOptions);
        const parameters = (0, combi_1.seq)("PARAMETERS", expressions_1.CallTransformationParameters);
        const objects = (0, combi_1.seq)("OBJECTS", expressions_1.CallTransformationParameters);
        const source2 = (0, combi_1.seq)("XML", expressions_1.SimpleSource3);
        const source = (0, combi_1.seq)("SOURCE", (0, combi_1.alt)(expressions_1.CallTransformationParameters, source2));
        const result2 = (0, combi_1.seq)("XML", expressions_1.Target);
        const result = (0, combi_1.seq)("RESULT", (0, combi_1.alt)(expressions_1.CallTransformationParameters, result2));
        const call = (0, combi_1.seq)("CALL TRANSFORMATION", (0, combi_1.alt)(expressions_1.NamespaceSimpleName, expressions_1.Dynamic), (0, combi_1.per)(options, parameters, objects, source, result));
        return call;
    }
}
exports.CallTransformation = CallTransformation;
//# sourceMappingURL=call_transformation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Case = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Case {
    getMatcher() {
        return (0, combi_1.seq)("CASE", expressions_1.Source);
    }
}
exports.Case = Case;
//# sourceMappingURL=case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case_type.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case_type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CaseType = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class CaseType {
    getMatcher() {
        return (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("CASE TYPE OF", expressions_1.Source), version_1.Version.OpenABAP);
    }
}
exports.CaseType = CaseType;
//# sourceMappingURL=case_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Catch = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Catch {
    getMatcher() {
        return (0, combi_1.seq)("CATCH", (0, combi_1.optPrio)("BEFORE UNWIND"), (0, combi_1.plus)(expressions_1.ClassName), (0, combi_1.opt)((0, combi_1.seq)("INTO", expressions_1.Target)));
    }
}
exports.Catch = Catch;
//# sourceMappingURL=catch.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch_system_exceptions.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch_system_exceptions.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CatchSystemExceptions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CatchSystemExceptions {
    getMatcher() {
        const ret = (0, combi_1.seq)("CATCH SYSTEM-EXCEPTIONS", (0, combi_1.plus)((0, combi_1.seq)(expressions_1.Field, "=", expressions_1.Source)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CatchSystemExceptions = CatchSystemExceptions;
//# sourceMappingURL=catch_system_exceptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Check = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Check {
    getMatcher() {
        const ret = (0, combi_1.seq)("CHECK", (0, combi_1.altPrio)(expressions_1.Cond, expressions_1.Field));
        return ret;
    }
}
exports.Check = Check;
//# sourceMappingURL=check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check_select_options.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check_select_options.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckSelectOptions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CheckSelectOptions {
    getMatcher() {
        const ret = "CHECK SELECT-OPTIONS";
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CheckSelectOptions = CheckSelectOptions;
//# sourceMappingURL=check_select_options.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassData = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassData {
    getMatcher() {
        return (0, combi_1.seq)("CLASS-DATA", expressions_1.DataDefinition);
    }
}
exports.ClassData = ClassData;
//# sourceMappingURL=class_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_begin.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_begin.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDataBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassDataBegin {
    getMatcher() {
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Integer);
        const structure = (0, combi_1.seq)("BEGIN OF", (0, combi_1.optPrio)("COMMON PART"), expressions_1.NamespaceSimpleName, (0, combi_1.optPrio)("READ-ONLY"), (0, combi_1.optPrio)(occurs));
        return (0, combi_1.seq)("CLASS-DATA", structure);
    }
}
exports.ClassDataBegin = ClassDataBegin;
//# sourceMappingURL=class_data_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_end.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_end.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDataEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassDataEnd {
    getMatcher() {
        const common = (0, combi_1.seq)("COMMON PART", (0, combi_1.optPrio)(expressions_1.NamespaceSimpleName));
        const structure = (0, combi_1.seq)("END OF", (0, combi_1.altPrio)(common, expressions_1.NamespaceSimpleName));
        return (0, combi_1.seq)("CLASS-DATA", structure);
    }
}
exports.ClassDataEnd = ClassDataEnd;
//# sourceMappingURL=class_data_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_deferred.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_deferred.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDeferred = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassDeferred {
    getMatcher() {
        return (0, combi_1.seq)("CLASS", expressions_1.ClassName, "DEFINITION DEFERRED", (0, combi_1.optPrio)("PUBLIC"));
    }
}
exports.ClassDeferred = ClassDeferred;
//# sourceMappingURL=class_deferred.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ClassDefinition {
    getMatcher() {
        const create = (0, combi_1.seq)("CREATE", (0, combi_1.altPrio)("PUBLIC", "PROTECTED", "PRIVATE"));
        const level = (0, combi_1.altPrio)("CRITICAL", "HARMLESS", "DANGEROUS");
        const risk = (0, combi_1.seq)("RISK LEVEL", level);
        const time = (0, combi_1.altPrio)("LONG", "MEDIUM", "SHORT");
        const duration = (0, combi_1.seq)("DURATION", time);
        const blah = (0, combi_1.per)(expressions_1.ClassGlobal, expressions_1.ClassFinal, "ABSTRACT", (0, combi_1.seq)("INHERITING FROM", expressions_1.SuperClassName), create, "FOR TESTING", risk, "SHARED MEMORY ENABLED", duration, (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.seq)("FOR BEHAVIOR OF", expressions_1.BehaviorDefinitionName)), expressions_1.ClassFriends);
        const def = (0, combi_1.seq)("DEFINITION", (0, combi_1.optPrio)(blah));
        return (0, combi_1.seq)("CLASS", expressions_1.ClassName, def);
    }
}
exports.ClassDefinition = ClassDefinition;
//# sourceMappingURL=class_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition_load.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition_load.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDefinitionLoad = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassDefinitionLoad {
    getMatcher() {
        return (0, combi_1.seq)("CLASS", expressions_1.ClassName, "DEFINITION LOAD");
    }
}
exports.ClassDefinitionLoad = ClassDefinitionLoad;
//# sourceMappingURL=class_definition_load.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_implementation.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_implementation.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassImplementation = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassImplementation {
    getMatcher() {
        return (0, combi_1.seq)("CLASS", expressions_1.ClassName, "IMPLEMENTATION");
    }
}
exports.ClassImplementation = ClassImplementation;
//# sourceMappingURL=class_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_local_friends.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_local_friends.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassLocalFriends = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassLocalFriends {
    getMatcher() {
        return (0, combi_1.seq)("CLASS", expressions_1.ClassName, "DEFINITION LOCAL FRIENDS", (0, combi_1.plusPrio)(expressions_1.ClassName));
    }
}
exports.ClassLocalFriends = ClassLocalFriends;
//# sourceMappingURL=class_local_friends.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/cleanup.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/cleanup.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cleanup = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Cleanup {
    getMatcher() {
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        return (0, combi_1.seq)("CLEANUP", (0, combi_1.opt)(into));
    }
}
exports.Cleanup = Cleanup;
//# sourceMappingURL=cleanup.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/clear.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/clear.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Clear = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Clear {
    getMatcher() {
        const wit = (0, combi_1.seq)("WITH", expressions_1.Source);
        const mode = (0, combi_1.altPrio)("IN CHARACTER MODE", "IN BYTE MODE");
        return (0, combi_1.seq)("CLEAR", expressions_1.Target, (0, combi_1.optPrio)(wit), (0, combi_1.optPrio)(mode));
    }
}
exports.Clear = Clear;
//# sourceMappingURL=clear.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_cursor.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_cursor.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseCursor = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CloseCursor {
    getMatcher() {
        const ret = (0, combi_1.seq)("CLOSE CURSOR", expressions_1.SQLSourceSimple);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CloseCursor = CloseCursor;
//# sourceMappingURL=close_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_dataset.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_dataset.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CloseDataset {
    getMatcher() {
        const ret = (0, combi_1.seq)("CLOSE DATASET", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CloseDataset = CloseDataset;
//# sourceMappingURL=close_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/collect.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/collect.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collect = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Collect {
    getMatcher() {
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const assigning = (0, combi_1.seq)("ASSIGNING", expressions_1.FSTarget);
        return (0, combi_1.seq)("COLLECT", expressions_1.Source, (0, combi_1.opt)(into), (0, combi_1.opt)(assigning));
    }
}
exports.Collect = Collect;
//# sourceMappingURL=collect.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Commit = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Commit {
    getMatcher() {
        const work = (0, combi_1.seq)("WORK", (0, combi_1.opt)("AND WAIT"));
        return (0, combi_1.seq)("COMMIT", (0, combi_1.alt)(work, expressions_1.DatabaseConnection));
    }
}
exports.Commit = Commit;
//# sourceMappingURL=commit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit_entities.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit_entities.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommitEntities = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CommitEntities {
    getMatcher() {
        const s = (0, combi_1.seq)("COMMIT ENTITIES", (0, combi_1.optPrio)("IN SIMULATION MODE"), (0, combi_1.star)((0, combi_1.seq)("RESPONSE OF", expressions_1.NamespaceSimpleName, "FAILED", expressions_1.Target, "REPORTED", expressions_1.Target)));
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.CommitEntities = CommitEntities;
//# sourceMappingURL=commit_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/communication.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/communication.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Communication = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Communication {
    getMatcher() {
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Target);
        const init = (0, combi_1.seq)("INIT ID", expressions_1.Source, "DESTINATION", expressions_1.Target);
        const allocate = (0, combi_1.seq)("ALLOCATE ID", expressions_1.Source);
        const send = (0, combi_1.seq)("SEND ID", expressions_1.Source, "BUFFER", expressions_1.Target, (0, combi_1.opt)(length));
        const deallocate = (0, combi_1.seq)("DEALLOCATE ID", expressions_1.Source);
        const accept = (0, combi_1.seq)("ACCEPT ID", expressions_1.Source);
        const receive = (0, combi_1.seq)("RECEIVE ID", expressions_1.Source, "BUFFER", expressions_1.Source, (0, combi_1.opt)(length), "DATAINFO", expressions_1.Target, "STATUSINFO", expressions_1.Target, "RECEIVED", expressions_1.Target);
        const ret = (0, combi_1.seq)("COMMUNICATION", (0, combi_1.alt)(init, allocate, send, deallocate, receive, accept));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Communication = Communication;
//# sourceMappingURL=communication.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/compute.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/compute.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compute = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Compute {
    getMatcher() {
        const ret = (0, combi_1.seq)("COMPUTE", (0, combi_1.opt)("EXACT"), expressions_1.Target, "=", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Compute = Compute;
//# sourceMappingURL=compute.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/concatenate.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/concatenate.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Concatenate = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Concatenate {
    getMatcher() {
        const mode = (0, combi_1.seq)("IN", (0, combi_1.altPrio)("BYTE", "CHARACTER"), "MODE");
        const blanks = (0, combi_1.str)("RESPECTING BLANKS");
        const sep = (0, combi_1.seq)("SEPARATED BY", expressions_1.SimpleSource3);
        const options = (0, combi_1.per)(mode, blanks, sep);
        const sourc = (0, combi_1.seq)(expressions_1.SimpleSource3, (0, combi_1.plus)(expressions_1.SimpleSource3));
        const lines = (0, combi_1.seq)("LINES OF", expressions_1.Source);
        return (0, combi_1.seq)("CONCATENATE", (0, combi_1.altPrio)(lines, sourc), "INTO", expressions_1.Target, (0, combi_1.optPrio)(options));
    }
}
exports.Concatenate = Concatenate;
//# sourceMappingURL=concatenate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/condense.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/condense.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Condense = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Condense {
    getMatcher() {
        return (0, combi_1.seq)("CONDENSE", expressions_1.Target, (0, combi_1.opt)("NO-GAPS"));
    }
}
exports.Condense = Condense;
//# sourceMappingURL=condense.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constant = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Constant {
    getMatcher() {
        const def = (0, combi_1.seq)(expressions_1.DefinitionName, (0, combi_1.opt)(expressions_1.ConstantFieldLength), (0, combi_1.per)(expressions_1.Type, expressions_1.Value, expressions_1.Decimals, expressions_1.Length));
        const ret = (0, combi_1.seq)((0, combi_1.alt)("CONSTANT", "CONSTANTS"), def, (0, combi_1.optPrio)("%_PREDEFINED"));
        return ret;
    }
}
exports.Constant = Constant;
//# sourceMappingURL=constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_begin.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_begin.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ConstantBegin {
    getMatcher() {
        const ret = (0, combi_1.seq)("CONSTANTS BEGIN OF", expressions_1.DefinitionName, (0, combi_1.optPrio)("%_PREDEFINED"));
        return ret;
    }
}
exports.ConstantBegin = ConstantBegin;
//# sourceMappingURL=constant_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_end.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_end.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ConstantEnd {
    getMatcher() {
        const ret = (0, combi_1.seq)("CONSTANTS", "END", "OF", expressions_1.DefinitionName);
        return ret;
    }
}
exports.ConstantEnd = ConstantEnd;
//# sourceMappingURL=constant_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/contexts.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/contexts.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Contexts = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Contexts {
    getMatcher() {
        const ret = (0, combi_1.seq)("CONTEXTS", expressions_1.Field);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Contexts = Contexts;
//# sourceMappingURL=contexts.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/continue.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/continue.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Continue = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Continue {
    getMatcher() {
        return (0, combi_1.str)("CONTINUE");
    }
}
exports.Continue = Continue;
//# sourceMappingURL=continue.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/controls.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/controls.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Controls = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Controls {
    getMatcher() {
        const tableview = (0, combi_1.seq)("TABLEVIEW USING SCREEN", expressions_1.Source);
        const type = (0, combi_1.seq)("TYPE", (0, combi_1.alt)(tableview, "TABSTRIP"));
        const ret = (0, combi_1.seq)("CONTROLS", expressions_1.NamespaceSimpleName, type);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Controls = Controls;
//# sourceMappingURL=controls.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Convert = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Convert {
    getMatcher() {
        const intoTime = (0, combi_1.seq)("TIME", expressions_1.Target);
        const intoDate = (0, combi_1.seq)("DATE", expressions_1.Target);
        const into = (0, combi_1.seq)("INTO", (0, combi_1.per)(intoTime, intoDate));
        const daylight = (0, combi_1.seq)("DAYLIGHT SAVING TIME", expressions_1.Source);
        const zone = (0, combi_1.seq)("TIME ZONE", expressions_1.Source);
        const time = (0, combi_1.seq)("TIME STAMP", expressions_1.Source, (0, combi_1.per)(zone, into, daylight));
        const dat = (0, combi_1.seq)("DATE", expressions_1.Source);
        const tim = (0, combi_1.seq)("TIME", expressions_1.Source);
        const stamp = (0, combi_1.seq)("INTO TIME STAMP", expressions_1.Target);
        const invert = (0, combi_1.seq)("INTO INVERTED-DATE", expressions_1.Target);
        const date = (0, combi_1.seq)((0, combi_1.per)(dat, tim), (0, combi_1.per)(daylight, stamp, zone, invert));
        const inv = (0, combi_1.seq)("INVERTED-DATE", expressions_1.Source, "INTO DATE", expressions_1.Target);
        return (0, combi_1.seq)("CONVERT", (0, combi_1.alt)(time, date, inv));
    }
}
exports.Convert = Convert;
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert_text.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert_text.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConvertText = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ConvertText {
    getMatcher() {
        return (0, combi_1.seq)("CONVERT TEXT", expressions_1.Source, "INTO SORTABLE CODE", expressions_1.Target);
    }
}
exports.ConvertText = ConvertText;
//# sourceMappingURL=convert_text.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_data.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_data.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateData = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
// todo, similar to DATA or TYPES?
class CreateData {
    getMatcher() {
        const areaHandle = (0, combi_1.seq)("AREA HANDLE", expressions_1.Source);
        const typeHandle = (0, combi_1.seq)("TYPE HANDLE", expressions_1.Source);
        const type = (0, combi_1.seq)((0, combi_1.alt)("TYPE", "TYPE REF TO", "TYPE TABLE OF", "TYPE TABLE OF REF TO", "TYPE SORTED TABLE OF", "TYPE HASHED TABLE OF", "TYPE STANDARD TABLE OF", "TYPE LINE OF"), (0, combi_1.alt)(expressions_1.TypeName, expressions_1.Dynamic));
        const like = (0, combi_1.seq)((0, combi_1.alt)("LIKE", "LIKE HASHED TABLE OF", "LIKE LINE OF", "LIKE STANDARD TABLE OF", "LIKE SORTED TABLE OF", "LIKE TABLE OF"), (0, combi_1.alt)(expressions_1.Source, expressions_1.Dynamic));
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Source);
        const initial = (0, combi_1.seq)("INITIAL SIZE", expressions_1.Source);
        const decimals = (0, combi_1.seq)("DECIMALS", expressions_1.Source);
        const uniq = (0, combi_1.alt)("UNIQUE", "NON-UNIQUE");
        const emptyKey = (0, combi_1.ver)(version_1.Version.v740sp02, "EMPTY KEY");
        const def = (0, combi_1.seq)((0, combi_1.opt)(uniq), (0, combi_1.alt)("DEFAULT KEY", emptyKey));
        const kdef = (0, combi_1.seq)((0, combi_1.opt)(uniq), "KEY", (0, combi_1.alt)((0, combi_1.plus)(expressions_1.Field), expressions_1.Dynamic));
        const key = (0, combi_1.seq)("WITH", (0, combi_1.alt)(def, kdef));
        const specified = (0, combi_1.seq)((0, combi_1.alt)(type, like), (0, combi_1.opt)(key), (0, combi_1.opt)(initial), (0, combi_1.opt)(length), (0, combi_1.opt)(decimals));
        const ret = (0, combi_1.seq)("CREATE DATA", expressions_1.Target, (0, combi_1.opt)((0, combi_1.alt)(typeHandle, (0, combi_1.seq)((0, combi_1.opt)(areaHandle), specified))));
        return ret;
    }
}
exports.CreateData = CreateData;
//# sourceMappingURL=create_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_object.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_object.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateObject = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class CreateObject {
    getMatcher() {
        const exporting = (0, combi_1.seq)("EXPORTING", expressions_1.ParameterListS);
        const exceptions = (0, combi_1.seq)("EXCEPTIONS", expressions_1.ParameterListExceptions);
        const ptable = (0, combi_1.seq)("PARAMETER-TABLE", expressions_1.Source);
        const etable = (0, combi_1.seq)("EXCEPTION-TABLE", expressions_1.Source);
        const area = (0, combi_1.seq)("AREA HANDLE", expressions_1.Source);
        const type = (0, combi_1.seq)("TYPE", (0, combi_1.altPrio)(expressions_1.ClassName, expressions_1.Dynamic));
        const ret = (0, combi_1.seq)("CREATE OBJECT", expressions_1.Target, (0, combi_1.optPrio)((0, combi_1.per)(type, area)), (0, combi_1.optPrio)((0, combi_1.altPrio)(exporting, ptable)), (0, combi_1.optPrio)((0, combi_1.altPrio)(exceptions, etable)));
        return ret;
    }
}
exports.CreateObject = CreateObject;
//# sourceMappingURL=create_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_ole.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_ole.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateOLE = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CreateOLE {
    getMatcher() {
        const ret = (0, combi_1.seq)("CREATE OBJECT", expressions_1.Target, expressions_1.Source, (0, combi_1.opt)("NO FLUSH"), (0, combi_1.opt)("QUEUE-ONLY"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.CreateOLE = CreateOLE;
//# sourceMappingURL=create_ole.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Data = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Data {
    getMatcher() {
        return (0, combi_1.seq)("DATA", expressions_1.DataDefinition, (0, combi_1.optPrio)("%_PREDEFINED"));
    }
}
exports.Data = Data;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_begin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_begin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class DataBegin {
    getMatcher() {
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Integer);
        const structure = (0, combi_1.seq)("BEGIN OF", (0, combi_1.opt)("COMMON PART"), expressions_1.DefinitionName, (0, combi_1.opt)("READ-ONLY"), (0, combi_1.opt)(occurs));
        return (0, combi_1.seq)("DATA", structure);
    }
}
exports.DataBegin = DataBegin;
//# sourceMappingURL=data_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_end.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_end.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class DataEnd {
    getMatcher() {
        const common = (0, combi_1.seq)("COMMON PART", (0, combi_1.optPrio)(expressions_1.DefinitionName));
        const structure = (0, combi_1.seq)("END OF", (0, combi_1.altPrio)(common, expressions_1.DefinitionName));
        const valid = (0, combi_1.seq)("VALID BETWEEN", expressions_1.ComponentName, "AND", expressions_1.ComponentName);
        return (0, combi_1.seq)("DATA", structure, (0, combi_1.optPrio)(valid));
    }
}
exports.DataEnd = DataEnd;
//# sourceMappingURL=data_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/define.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/define.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Define = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Define {
    getMatcher() {
        const ret = (0, combi_1.seq)("DEFINE", expressions_1.MacroName);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Define = Define;
//# sourceMappingURL=define.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_cluster.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_cluster.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteCluster = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteCluster {
    getMatcher() {
        const client = (0, combi_1.seq)("CLIENT", expressions_1.Source);
        const ret = (0, combi_1.seq)("DELETE FROM DATABASE", expressions_1.NamespaceSimpleName, (0, combi_1.tok)(tokens_1.ParenLeft), expressions_1.SimpleName, (0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.opt)(client), "ID", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteCluster = DeleteCluster;
//# sourceMappingURL=delete_cluster.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_database.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_database.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDatabase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const sql_client_1 = __webpack_require__(/*! ../expressions/sql_client */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_client.js");
class DeleteDatabase {
    getMatcher() {
        const where = (0, combi_1.seq)("WHERE", (0, combi_1.altPrio)(expressions_1.SQLCond, expressions_1.Dynamic));
        const from = (0, combi_1.seq)("FROM", expressions_1.DatabaseTable, (0, combi_1.optPrio)(sql_client_1.SQLClient), (0, combi_1.optPrio)(expressions_1.DatabaseConnection), (0, combi_1.opt)(where));
        const table = (0, combi_1.seq)(expressions_1.DatabaseTable, (0, combi_1.optPrio)(sql_client_1.SQLClient), (0, combi_1.optPrio)(expressions_1.DatabaseConnection), "FROM", (0, combi_1.opt)("TABLE"), expressions_1.SQLSourceSimple);
        const ret = (0, combi_1.seq)("DELETE", (0, combi_1.altPrio)(from, table));
        return ret;
    }
}
exports.DeleteDatabase = DeleteDatabase;
//# sourceMappingURL=delete_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dataset.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dataset.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteDataset {
    getMatcher() {
        const ret = (0, combi_1.seq)("DELETE DATASET", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteDataset = DeleteDataset;
//# sourceMappingURL=delete_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dynpro.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dynpro.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDynpro = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteDynpro {
    getMatcher() {
        const ret = (0, combi_1.seq)("DELETE DYNPRO", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteDynpro = DeleteDynpro;
//# sourceMappingURL=delete_dynpro.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_internal.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_internal.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteInternal = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class DeleteInternal {
    getMatcher() {
        // todo, is READ and DELETE similar? something can be reused?
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const keyName = (0, combi_1.altPrio)(expressions_1.SimpleName, expressions_1.Dynamic);
        const using = (0, combi_1.seq)("USING KEY", keyName);
        const from = (0, combi_1.optPrio)((0, combi_1.seq)("FROM", expressions_1.Source));
        const fromTo = (0, combi_1.seq)(from, (0, combi_1.optPrio)((0, combi_1.seq)("TO", expressions_1.Source)));
        const where = (0, combi_1.seq)("WHERE", (0, combi_1.alt)(expressions_1.ComponentCond, expressions_1.Dynamic));
        const key = (0, combi_1.seq)("WITH TABLE KEY", (0, combi_1.opt)((0, combi_1.seq)(keyName, "COMPONENTS")), (0, combi_1.plus)(expressions_1.ComponentCompare));
        const table = (0, combi_1.seq)("TABLE", expressions_1.Target, (0, combi_1.alt)((0, combi_1.per)(index, using), from, key));
        const other = (0, combi_1.seq)(expressions_1.Target, (0, combi_1.alt)((0, combi_1.per)(index, using), fromTo, key), (0, combi_1.opt)(where));
        const f = (0, combi_1.seq)(expressions_1.FieldSub, (0, combi_1.optPrio)(expressions_1.FieldOffset), (0, combi_1.optPrio)(expressions_1.FieldLength));
        const adjacent = (0, combi_1.seq)("ADJACENT DUPLICATES FROM", expressions_1.Target, (0, combi_1.optPrio)(using), (0, combi_1.opt)((0, combi_1.seq)("COMPARING", (0, combi_1.altPrio)("ALL FIELDS", (0, combi_1.plus)((0, combi_1.altPrio)(f, expressions_1.Dynamic))))), (0, combi_1.optPrio)(using));
        return (0, combi_1.seq)("DELETE", (0, combi_1.alt)(table, adjacent, other));
    }
}
exports.DeleteInternal = DeleteInternal;
//# sourceMappingURL=delete_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_memory.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_memory.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteMemory = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteMemory {
    getMatcher() {
        const memory = (0, combi_1.seq)("MEMORY ID", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.Source);
        const client = (0, combi_1.seq)("CLIENT", expressions_1.Source);
        const shared = (0, combi_1.seq)("SHARED MEMORY", expressions_1.Field, "(", expressions_1.Field, ")", (0, combi_1.optPrio)(client), id);
        const ret = (0, combi_1.seq)("DELETE FROM", (0, combi_1.alt)(memory, shared));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteMemory = DeleteMemory;
//# sourceMappingURL=delete_memory.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_report.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_report.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteReport = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteReport {
    getMatcher() {
        const state = (0, combi_1.seq)("STATE", expressions_1.Source);
        const ret = (0, combi_1.seq)("DELETE REPORT", expressions_1.Source, (0, combi_1.optPrio)(state));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteReport = DeleteReport;
//# sourceMappingURL=delete_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_textpool.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_textpool.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteTextpool = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class DeleteTextpool {
    getMatcher() {
        const language = (0, combi_1.seq)("LANGUAGE", expressions_1.Source);
        const state = (0, combi_1.seq)("STATE", expressions_1.Source);
        const ret = (0, combi_1.seq)("DELETE TEXTPOOL", expressions_1.Source, (0, combi_1.opt)(language), (0, combi_1.opt)(state));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.DeleteTextpool = DeleteTextpool;
//# sourceMappingURL=delete_textpool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/demand.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/demand.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Demand = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Demand {
    getMatcher() {
        const field = (0, combi_1.seq)(expressions_1.Field, "=", expressions_1.Target);
        const messages = (0, combi_1.seq)("MESSAGES INTO", expressions_1.Target);
        const ret = (0, combi_1.seq)("DEMAND", (0, combi_1.plus)(field), "FROM CONTEXT", expressions_1.Field, (0, combi_1.opt)(messages));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Demand = Demand;
//# sourceMappingURL=demand.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/describe.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/describe.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Describe = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Describe {
    getMatcher() {
        const tlines = (0, combi_1.seq)("LINES", expressions_1.Target);
        const kind = (0, combi_1.seq)("KIND", expressions_1.Target);
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Target);
        const table = (0, combi_1.seq)("TABLE", expressions_1.FieldChain, (0, combi_1.opt)((0, combi_1.per)(tlines, kind, occurs)));
        const mode = (0, combi_1.seq)("IN", (0, combi_1.alt)("BYTE", "CHARACTER"), "MODE");
        const field = (0, combi_1.seq)("FIELD", expressions_1.Source, (0, combi_1.per)((0, combi_1.seq)("TYPE", expressions_1.Target), (0, combi_1.seq)("COMPONENTS", expressions_1.Target), (0, combi_1.seq)("LENGTH", expressions_1.Target, (0, combi_1.opt)(mode)), (0, combi_1.seq)("DECIMALS", expressions_1.Target), (0, combi_1.seq)("HELP-ID", expressions_1.Target), (0, combi_1.seq)("OUTPUT-LENGTH", expressions_1.Target), (0, combi_1.seq)("EDIT MASK", expressions_1.Target), (0, combi_1.seq)("INTO", expressions_1.Target)));
        const distance = (0, combi_1.seq)("DISTANCE BETWEEN", expressions_1.Source, "AND", expressions_1.Source, "INTO", expressions_1.Target, mode);
        const lines = (0, combi_1.seq)("NUMBER OF LINES", expressions_1.Target);
        const line = (0, combi_1.seq)("LINE", expressions_1.Source);
        const page = (0, combi_1.seq)("PAGE", expressions_1.Source);
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const top = (0, combi_1.seq)("TOP-LINES", expressions_1.Target);
        const lineSize = (0, combi_1.seq)("LINE-SIZE", expressions_1.Target);
        const first = (0, combi_1.seq)("FIRST-LINE", expressions_1.Target);
        const list = (0, combi_1.seq)("LIST", (0, combi_1.per)(lines, index, line, page, top, first, lineSize));
        const ret = (0, combi_1.seq)("DESCRIBE", (0, combi_1.altPrio)(table, field, distance, list));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Describe = Describe;
//# sourceMappingURL=describe.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/detail.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/detail.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Detail = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Detail {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "DETAIL");
    }
}
exports.Detail = Detail;
//# sourceMappingURL=detail.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/divide.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/divide.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Divide = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Divide {
    getMatcher() {
        const ret = (0, combi_1.seq)("DIVIDE", expressions_1.Target, "BY", expressions_1.Source);
        return ret;
    }
}
exports.Divide = Divide;
//# sourceMappingURL=divide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/do.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/do.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Do = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Do {
    getMatcher() {
        const range = (0, combi_1.seq)("RANGE", expressions_1.Source);
        const vary = (0, combi_1.seq)("VARYING", expressions_1.Target, "FROM", expressions_1.Source, "NEXT", expressions_1.Source, (0, combi_1.optPrio)(range));
        const times = (0, combi_1.seq)(expressions_1.Source, "TIMES");
        return (0, combi_1.seq)("DO", (0, combi_1.optPrio)((0, combi_1.per)((0, combi_1.plus)(vary), times)));
    }
}
exports.Do = Do;
//# sourceMappingURL=do.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/editor_call.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/editor_call.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorCall = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EditorCall {
    getMatcher() {
        const title = (0, combi_1.seq)("TITLE", expressions_1.SimpleSource3);
        const options = (0, combi_1.per)("DISPLAY-MODE", title);
        const ret = (0, combi_1.seq)("EDITOR-CALL FOR", (0, combi_1.optPrio)("REPORT"), expressions_1.Source, (0, combi_1.optPrio)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EditorCall = EditorCall;
//# sourceMappingURL=editor_call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/else.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/else.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Else = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Else {
    getMatcher() {
        return (0, combi_1.str)("ELSE");
    }
}
exports.Else = Else;
//# sourceMappingURL=else.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/elseif.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/elseif.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElseIf = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ElseIf {
    getMatcher() {
        return (0, combi_1.seq)("ELSEIF", expressions_1.Cond);
    }
}
exports.ElseIf = ElseIf;
//# sourceMappingURL=elseif.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndEnhancement = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndEnhancement {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "ENDENHANCEMENT");
    }
}
exports.EndEnhancement = EndEnhancement;
//# sourceMappingURL=end_enhancement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement_section.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement_section.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndEnhancementSection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndEnhancementSection {
    getMatcher() {
        const ret = (0, combi_1.str)("END-ENHANCEMENT-SECTION");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EndEnhancementSection = EndEnhancementSection;
//# sourceMappingURL=end_enhancement_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_page.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_page.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndOfPage = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndOfPage {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "END-OF-PAGE");
    }
}
exports.EndOfPage = EndOfPage;
//# sourceMappingURL=end_of_page.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_selection.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_selection.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndOfSelection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndOfSelection {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "END-OF-SELECTION");
    }
}
exports.EndOfSelection = EndOfSelection;
//# sourceMappingURL=end_of_selection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_injection.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_injection.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndTestInjection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndTestInjection {
    getMatcher() {
        return (0, combi_1.str)("END-TEST-INJECTION");
    }
}
exports.EndTestInjection = EndTestInjection;
//# sourceMappingURL=end_test_injection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_seam.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_seam.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndTestSeam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndTestSeam {
    getMatcher() {
        return (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.str)("END-TEST-SEAM"));
    }
}
exports.EndTestSeam = EndTestSeam;
//# sourceMappingURL=end_test_seam.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endat.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endat.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndAt = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndAt {
    getMatcher() {
        const ret = (0, combi_1.str)("ENDAT");
        return ret;
    }
}
exports.EndAt = EndAt;
//# sourceMappingURL=endat.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcase.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcase.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndCase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndCase {
    getMatcher() {
        return (0, combi_1.str)("ENDCASE");
    }
}
exports.EndCase = EndCase;
//# sourceMappingURL=endcase.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcatch.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcatch.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndCatch = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndCatch {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "ENDCATCH");
    }
}
exports.EndCatch = EndCatch;
//# sourceMappingURL=endcatch.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endclass.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endclass.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndClass = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndClass {
    getMatcher() {
        return (0, combi_1.str)("ENDCLASS");
    }
}
exports.EndClass = EndClass;
//# sourceMappingURL=endclass.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddefine.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddefine.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndOfDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndOfDefinition {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "END-OF-DEFINITION");
    }
}
exports.EndOfDefinition = EndOfDefinition;
//# sourceMappingURL=enddefine.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddo.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddo.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndDo = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndDo {
    getMatcher() {
        return (0, combi_1.str)("ENDDO");
    }
}
exports.EndDo = EndDo;
//# sourceMappingURL=enddo.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endexec.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endexec.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndExec = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndExec {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "ENDEXEC");
    }
}
exports.EndExec = EndExec;
//# sourceMappingURL=endexec.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endform.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endform.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndForm = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndForm {
    getMatcher() {
        const ret = (0, combi_1.str)("ENDFORM");
        return ret;
    }
}
exports.EndForm = EndForm;
//# sourceMappingURL=endform.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endfunction.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endfunction.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndFunction = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndFunction {
    getMatcher() {
        return (0, combi_1.str)("ENDFUNCTION");
    }
}
exports.EndFunction = EndFunction;
//# sourceMappingURL=endfunction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endif.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endif.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndIf = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndIf {
    getMatcher() {
        return (0, combi_1.str)("ENDIF");
    }
}
exports.EndIf = EndIf;
//# sourceMappingURL=endif.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endinterface.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endinterface.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndInterface = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndInterface {
    getMatcher() {
        return (0, combi_1.str)("ENDINTERFACE");
    }
}
exports.EndInterface = EndInterface;
//# sourceMappingURL=endinterface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endloop.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endloop.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndLoop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndLoop {
    getMatcher() {
        return (0, combi_1.str)("ENDLOOP");
    }
}
exports.EndLoop = EndLoop;
//# sourceMappingURL=endloop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmethod.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmethod.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndMethod = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndMethod {
    getMatcher() {
        return (0, combi_1.str)("ENDMETHOD");
    }
}
exports.EndMethod = EndMethod;
//# sourceMappingURL=endmethod.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmodule.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmodule.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndModule = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndModule {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "ENDMODULE");
    }
}
exports.EndModule = EndModule;
//# sourceMappingURL=endmodule.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endon.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endon.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndOn = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndOn {
    getMatcher() {
        const ret = (0, combi_1.str)("ENDON");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EndOn = EndOn;
//# sourceMappingURL=endon.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endprovide.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endprovide.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndProvide = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndProvide {
    getMatcher() {
        const ret = (0, combi_1.str)("ENDPROVIDE");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EndProvide = EndProvide;
//# sourceMappingURL=endprovide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endselect.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endselect.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndSelect = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndSelect {
    getMatcher() {
        return (0, combi_1.str)("ENDSELECT");
    }
}
exports.EndSelect = EndSelect;
//# sourceMappingURL=endselect.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endtry.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endtry.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndTry = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndTry {
    getMatcher() {
        return (0, combi_1.str)("ENDTRY");
    }
}
exports.EndTry = EndTry;
//# sourceMappingURL=endtry.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwhile.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwhile.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndWhile = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class EndWhile {
    getMatcher() {
        return (0, combi_1.str)("ENDWHILE");
    }
}
exports.EndWhile = EndWhile;
//# sourceMappingURL=endwhile.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwith.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwith.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EndWith = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EndWith {
    getMatcher() {
        return (0, combi_1.ver)(version_1.Version.v751, "ENDWITH");
    }
}
exports.EndWith = EndWith;
//# sourceMappingURL=endwith.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enhancement = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const namespace_simple_name_1 = __webpack_require__(/*! ../expressions/namespace_simple_name */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/namespace_simple_name.js");
class Enhancement {
    getMatcher() {
        const ret = (0, combi_1.seq)("ENHANCEMENT", (0, combi_1.plus)(namespace_simple_name_1.NamespaceSimpleName));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Enhancement = Enhancement;
//# sourceMappingURL=enhancement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_point.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_point.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancementPoint = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class EnhancementPoint {
    getMatcher() {
        const ret = (0, combi_1.seq)("ENHANCEMENT-POINT", expressions_1.FieldSub, "SPOTS", expressions_1.Field, (0, combi_1.opt)("STATIC"), (0, combi_1.opt)("INCLUDE BOUND"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EnhancementPoint = EnhancementPoint;
//# sourceMappingURL=enhancement_point.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_section.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_section.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancementSection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const dash_1 = __webpack_require__(/*! ../../1_lexer/tokens/dash */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/dash.js");
class EnhancementSection {
    getMatcher() {
        const ret = (0, combi_1.seq)("ENHANCEMENT-SECTION", (0, combi_1.seq)(expressions_1.Field, (0, combi_1.starPrio)((0, combi_1.seq)((0, combi_1.tok)(dash_1.Dash), expressions_1.Field))), "SPOTS", expressions_1.Field, (0, combi_1.opt)("STATIC"), (0, combi_1.opt)("INCLUDE BOUND"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.EnhancementSection = EnhancementSection;
//# sourceMappingURL=enhancement_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/events.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/events.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Events = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Events {
    getMatcher() {
        const exporting = (0, combi_1.seq)("EXPORTING", (0, combi_1.plus)(expressions_1.MethodParamOptional));
        return (0, combi_1.seq)((0, combi_1.altPrio)("CLASS-EVENTS", "EVENTS"), expressions_1.EventName, (0, combi_1.optPrio)(exporting));
    }
}
exports.Events = Events;
//# sourceMappingURL=events.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exec_sql.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exec_sql.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecSQL = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ExecSQL {
    getMatcher() {
        const performing = (0, combi_1.seq)("PERFORMING", expressions_1.SimpleName);
        const ret = (0, combi_1.seq)("EXEC SQL", (0, combi_1.opt)(performing));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ExecSQL = ExecSQL;
//# sourceMappingURL=exec_sql.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exit.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exit.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Exit = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Exit {
    getMatcher() {
        return (0, combi_1.seq)("EXIT", (0, combi_1.opt)((0, combi_1.alt)("FROM SQL", "FROM STEP-LOOP")));
    }
}
exports.Exit = Exit;
//# sourceMappingURL=exit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Export = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
// todo, cloud, split?
class Export {
    getMatcher() {
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const client = (0, combi_1.seq)("CLIENT", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.Source);
        const using = (0, combi_1.seq)("USING", expressions_1.Source);
        const cluster = (0, combi_1.seq)(expressions_1.NamespaceSimpleName, (0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.regex)(/^[\w$%\^]{2}$/), (0, combi_1.tok)(tokens_1.ParenRightW));
        const buffer = (0, combi_1.seq)("DATA BUFFER", expressions_1.Target);
        const memory = (0, combi_1.seq)("MEMORY", (0, combi_1.opt)((0, combi_1.seq)("ID", expressions_1.Source)));
        const table = (0, combi_1.seq)("INTERNAL TABLE", expressions_1.Target);
        const shared = (0, combi_1.seq)((0, combi_1.alt)("SHARED MEMORY", "SHARED BUFFER"), cluster, (0, combi_1.per)(from, client, id));
        const database = (0, combi_1.seq)("DATABASE", cluster, (0, combi_1.per)(from, client, id, using));
        const target = (0, combi_1.alt)(buffer, memory, database, table, shared);
        const left = (0, combi_1.alt)(expressions_1.FieldSub, expressions_1.FieldSymbol);
        const source = (0, combi_1.alt)((0, combi_1.plus)((0, combi_1.altPrio)(expressions_1.ParameterS, (0, combi_1.seq)(left, from), left)), expressions_1.Dynamic);
        const compression = (0, combi_1.seq)("COMPRESSION", (0, combi_1.alt)("ON", "OFF"));
        const hint = (0, combi_1.seq)("CODE PAGE HINT", expressions_1.Source);
        return (0, combi_1.seq)("EXPORT", source, "TO", target, (0, combi_1.opt)(compression), (0, combi_1.opt)(hint));
    }
}
exports.Export = Export;
//# sourceMappingURL=export.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export_dynpro.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export_dynpro.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExportDynpro = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ExportDynpro {
    getMatcher() {
        const ret = (0, combi_1.seq)("EXPORT DYNPRO", expressions_1.Source, expressions_1.Source, expressions_1.Source, expressions_1.Source, "ID", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ExportDynpro = ExportDynpro;
//# sourceMappingURL=export_dynpro.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/extract.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/extract.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Extract = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Extract {
    getMatcher() {
        const ret = (0, combi_1.seq)("EXTRACT", (0, combi_1.opt)(expressions_1.Field));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Extract = Extract;
//# sourceMappingURL=extract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fetch_next_cursor.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fetch_next_cursor.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FetchNextCursor = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const sql_into_structure_1 = __webpack_require__(/*! ../expressions/sql_into_structure */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/sql_into_structure.js");
class FetchNextCursor {
    getMatcher() {
        const size = (0, combi_1.seq)("PACKAGE SIZE", expressions_1.SQLSourceSimple);
        const ret = (0, combi_1.seq)("FETCH NEXT CURSOR", expressions_1.SQLSourceSimple, (0, combi_1.alt)(sql_into_structure_1.SQLIntoStructure, expressions_1.SQLIntoTable, expressions_1.SQLIntoList), (0, combi_1.optPrio)(size));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.FetchNextCursor = FetchNextCursor;
//# sourceMappingURL=fetch_next_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/field_group.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/field_group.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldGroup = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class FieldGroup {
    getMatcher() {
        const ret = (0, combi_1.seq)("FIELD-GROUPS", (0, combi_1.plus)(expressions_1.Field));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.FieldGroup = FieldGroup;
//# sourceMappingURL=field_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fields.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fields.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Fields = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Fields {
    getMatcher() {
        const ret = (0, combi_1.seq)("FIELDS", expressions_1.FieldSub);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Fields = Fields;
//# sourceMappingURL=fields.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fieldsymbol.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fieldsymbol.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldSymbol = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FieldSymbol {
    getMatcher() {
        const stru = (0, combi_1.seq)("STRUCTURE", expressions_1.TypeName, "DEFAULT", expressions_1.Field);
        return (0, combi_1.seq)("FIELD-SYMBOLS", expressions_1.FieldSymbol, (0, combi_1.opt)((0, combi_1.alt)(expressions_1.Type, expressions_1.TypeTable, stru)));
    }
}
exports.FieldSymbol = FieldSymbol;
//# sourceMappingURL=fieldsymbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/find.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/find.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Find = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Find {
    getMatcher() {
        // SUBMATCHES handling is a workaround
        const options = (0, combi_1.per)("IGNORING CASE", "RESPECTING CASE", "IN BYTE MODE", "IN CHARACTER MODE", (0, combi_1.seq)("OF", expressions_1.Source), (0, combi_1.seq)("FROM", expressions_1.Source), (0, combi_1.seq)("TO", expressions_1.Source), (0, combi_1.seq)("MATCH OFFSET", expressions_1.Target), (0, combi_1.seq)("MATCH LINE", expressions_1.Target), (0, combi_1.seq)("MATCH COUNT", expressions_1.Target), (0, combi_1.seq)("MATCH LENGTH", expressions_1.Target), (0, combi_1.seq)("LENGTH", expressions_1.Source), (0, combi_1.seq)("RESULTS", expressions_1.Target), (0, combi_1.seq)("SUBMATCHES", expressions_1.Target), (0, combi_1.seq)("SUBMATCHES", expressions_1.Target, expressions_1.Target), (0, combi_1.seq)("SUBMATCHES", (0, combi_1.plus)(expressions_1.Target)));
        const sectionLength = (0, combi_1.seq)("SECTION LENGTH", expressions_1.Source, "OF");
        const before = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.altPrio)("TABLE", "SECTION OFFSET", sectionLength)), expressions_1.Source);
        const ret = (0, combi_1.seq)("FIND", (0, combi_1.opt)((0, combi_1.altPrio)("FIRST OCCURRENCE OF", "ALL OCCURRENCES OF")), expressions_1.FindType, expressions_1.Source, "IN", before, (0, combi_1.opt)(options));
        return ret;
    }
}
exports.Find = Find;
//# sourceMappingURL=find.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Form = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Form {
    getMatcher() {
        const parameters = (0, combi_1.seq)((0, combi_1.opt)(expressions_1.FormTables), (0, combi_1.opt)(expressions_1.FormUsing), (0, combi_1.opt)(expressions_1.FormChanging), (0, combi_1.opt)(expressions_1.FormRaising));
        const ret = (0, combi_1.seq)("FORM", expressions_1.FormName, (0, combi_1.alt)("IMPLEMENTATION", parameters));
        return ret;
    }
}
exports.Form = Form;
//# sourceMappingURL=form.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form_definition.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form_definition.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormDefinition = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FormDefinition {
    getMatcher() {
        const ret = (0, combi_1.seq)("FORM", expressions_1.FormName, "DEFINITION", (0, combi_1.opt)(expressions_1.FormTables), (0, combi_1.opt)(expressions_1.FormUsing), (0, combi_1.opt)(expressions_1.FormChanging), (0, combi_1.opt)(expressions_1.FormRaising));
        return ret;
    }
}
exports.FormDefinition = FormDefinition;
//# sourceMappingURL=form_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/format.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/format.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Format = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Format {
    getMatcher() {
        const eq = (0, combi_1.seq)("=", expressions_1.Source);
        const value = (0, combi_1.altPrio)(eq, "ON", "OFF");
        const options = (0, combi_1.per)("RESET", (0, combi_1.seq)("INTENSIFIED", (0, combi_1.opt)(value)), (0, combi_1.seq)("INVERSE", (0, combi_1.opt)(value)), (0, combi_1.seq)("HOTSPOT", (0, combi_1.opt)(value)), (0, combi_1.seq)("FRAMES", value), (0, combi_1.seq)("INPUT", value), expressions_1.Color);
        const ret = (0, combi_1.seq)("FORMAT", options);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Format = Format;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Free = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Free {
    getMatcher() {
        const ret = (0, combi_1.seq)("FREE", expressions_1.Target);
        return ret;
    }
}
exports.Free = Free;
//# sourceMappingURL=free.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_memory.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_memory.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FreeMemory = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class FreeMemory {
    getMatcher() {
        const ret = (0, combi_1.seq)("FREE MEMORY", (0, combi_1.optPrio)((0, combi_1.seq)("ID", expressions_1.Source)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.FreeMemory = FreeMemory;
//# sourceMappingURL=free_memory.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_object.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_object.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FreeObject = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class FreeObject {
    getMatcher() {
        const ret = (0, combi_1.seq)("FREE OBJECT", expressions_1.Target, (0, combi_1.opt)("NO FLUSH"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.FreeObject = FreeObject;
//# sourceMappingURL=free_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_module.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_module.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionModule = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FunctionModule {
    getMatcher() {
        return (0, combi_1.seq)("FUNCTION", expressions_1.Field);
    }
}
exports.FunctionModule = FunctionModule;
//# sourceMappingURL=function_module.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_pool.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_pool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionPool = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class FunctionPool {
    getMatcher() {
        const message = (0, combi_1.seq)("MESSAGE-ID", expressions_1.MessageClass);
        const line = (0, combi_1.seq)("LINE-SIZE", expressions_1.Integer);
        const no = (0, combi_1.str)("NO STANDARD PAGE HEADING");
        return (0, combi_1.seq)("FUNCTION-POOL", expressions_1.Field, (0, combi_1.opt)((0, combi_1.per)(message, line, no)));
    }
}
exports.FunctionPool = FunctionPool;
//# sourceMappingURL=function_pool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_dynpro.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_dynpro.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateDynpro = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GenerateDynpro {
    getMatcher() {
        const line = (0, combi_1.seq)("LINE", expressions_1.Target);
        const word = (0, combi_1.seq)("WORD", expressions_1.Target);
        const ret = (0, combi_1.seq)("GENERATE DYNPRO", expressions_1.Source, expressions_1.Source, expressions_1.Source, expressions_1.Source, "ID", expressions_1.Source, "MESSAGE", expressions_1.Target, (0, combi_1.per)(line, word));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GenerateDynpro = GenerateDynpro;
//# sourceMappingURL=generate_dynpro.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_report.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_report.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateReport = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GenerateReport {
    getMatcher() {
        const without = (0, combi_1.str)("WITHOUT SELECTION-SCREEN");
        const message = (0, combi_1.seq)("MESSAGE", expressions_1.Target);
        const include = (0, combi_1.seq)("INCLUDE", expressions_1.Target);
        const line = (0, combi_1.seq)("LINE", expressions_1.Target);
        const word = (0, combi_1.seq)("WORD", expressions_1.Target);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Target);
        const headers = (0, combi_1.str)("WITH PRECOMPILED HEADERS");
        const test = (0, combi_1.str)("WITH TEST CODE");
        const messageid = (0, combi_1.seq)("MESSAGE-ID", expressions_1.Target);
        const trace = (0, combi_1.seq)("TRACE-FILE", expressions_1.Target);
        const shortdumpid = (0, combi_1.seq)("SHORTDUMP-ID", expressions_1.Target);
        const directory = (0, combi_1.seq)("DIRECTORY ENTRY", expressions_1.Target);
        const options = (0, combi_1.per)(without, message, include, trace, line, word, offset, headers, test, messageid, shortdumpid, directory);
        const ret = (0, combi_1.seq)("GENERATE REPORT", expressions_1.Source, (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GenerateReport = GenerateReport;
//# sourceMappingURL=generate_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_subroutine.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_subroutine.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenerateSubroutine = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GenerateSubroutine {
    getMatcher() {
        const name = (0, combi_1.seq)("NAME", expressions_1.Source);
        const message = (0, combi_1.seq)("MESSAGE", expressions_1.Target);
        const messageid = (0, combi_1.seq)("MESSAGE-ID", expressions_1.Target);
        const line = (0, combi_1.seq)("LINE", expressions_1.Target);
        const word = (0, combi_1.seq)("WORD", expressions_1.Target);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Target);
        const short = (0, combi_1.seq)("SHORTDUMP-ID", expressions_1.Target);
        const include = (0, combi_1.seq)("INCLUDE", expressions_1.Target);
        const ret = (0, combi_1.seq)("GENERATE SUBROUTINE POOL", expressions_1.Source, (0, combi_1.per)(name, message, line, word, include, offset, messageid, short));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GenerateSubroutine = GenerateSubroutine;
//# sourceMappingURL=generate_subroutine.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Get = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Get {
    getMatcher() {
        const fields = (0, combi_1.seq)("FIELDS", (0, combi_1.plus)(expressions_1.Field));
        const options = (0, combi_1.per)("LATE", fields);
        const ret = (0, combi_1.seq)("GET", expressions_1.Target, (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Get = Get;
//# sourceMappingURL=get.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_badi.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_badi.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBadi = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetBadi {
    getMatcher() {
        const filters = (0, combi_1.seq)("FILTERS", expressions_1.ParameterListS);
        const context = (0, combi_1.seq)("CONTEXT", expressions_1.Source);
        const type = (0, combi_1.seq)("TYPE", expressions_1.Dynamic);
        const ret = (0, combi_1.seq)("GET BADI", expressions_1.Target, (0, combi_1.opt)(type), (0, combi_1.opt)(filters), (0, combi_1.opt)(context));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetBadi = GetBadi;
//# sourceMappingURL=get_badi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_bit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_bit.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBit = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class GetBit {
    getMatcher() {
        const ret = (0, combi_1.seq)("GET BIT", expressions_1.Source, "OF", expressions_1.Source, "INTO", expressions_1.Target);
        return ret;
    }
}
exports.GetBit = GetBit;
//# sourceMappingURL=get_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_cursor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_cursor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCursor = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetCursor {
    getMatcher() {
        const line = (0, combi_1.seq)("LINE", expressions_1.Target);
        const field = (0, combi_1.seq)("FIELD", expressions_1.Target);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Target);
        const value = (0, combi_1.seq)("VALUE", expressions_1.Target);
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Target);
        const area = (0, combi_1.seq)("AREA", expressions_1.Target);
        const ret = (0, combi_1.seq)("GET CURSOR", (0, combi_1.per)(line, (0, combi_1.opt)("DISPLAY"), field, offset, value, length, area));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetCursor = GetCursor;
//# sourceMappingURL=get_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_dataset.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_dataset.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetDataset {
    getMatcher() {
        const position = (0, combi_1.seq)("POSITION", expressions_1.Target);
        const attr = (0, combi_1.seq)("ATTRIBUTES", expressions_1.Target);
        const ret = (0, combi_1.seq)("GET DATASET", expressions_1.Target, (0, combi_1.opt)((0, combi_1.per)(position, attr)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetDataset = GetDataset;
//# sourceMappingURL=get_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_locale.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_locale.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLocale = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetLocale {
    getMatcher() {
        const country = (0, combi_1.seq)("COUNTRY", expressions_1.Target);
        const modifier = (0, combi_1.seq)("MODIFIER", expressions_1.Target);
        const ret = (0, combi_1.seq)("GET LOCALE LANGUAGE", expressions_1.Target, country, modifier);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetLocale = GetLocale;
//# sourceMappingURL=get_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_parameter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_parameter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetParameter = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetParameter {
    getMatcher() {
        const ret = (0, combi_1.seq)("GET PARAMETER ID", expressions_1.Source, "FIELD", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetParameter = GetParameter;
//# sourceMappingURL=get_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_permissions.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_permissions.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPermissions = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetPermissions {
    getMatcher() {
        const s = (0, combi_1.seq)("GET PERMISSIONS ONLY GLOBAL AUTHORIZATION ENTITY", expressions_1.SimpleName, "REQUEST", expressions_1.Source, "RESULT", expressions_1.Target, "FAILED", expressions_1.Target, "REPORTED", expressions_1.Target);
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.GetPermissions = GetPermissions;
//# sourceMappingURL=get_permissions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_pf_status.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_pf_status.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetPFStatus = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetPFStatus {
    getMatcher() {
        const program = (0, combi_1.seq)("PROGRAM", expressions_1.Source);
        const excl = (0, combi_1.seq)("EXCLUDING", expressions_1.Source);
        const ret = (0, combi_1.seq)("GET PF-STATUS", expressions_1.Target, (0, combi_1.opt)(program), (0, combi_1.opt)(excl));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetPFStatus = GetPFStatus;
//# sourceMappingURL=get_pf_status.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetProperty = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetProperty {
    getMatcher() {
        const ret = (0, combi_1.seq)("GET PROPERTY OF", expressions_1.FieldSub, expressions_1.Source, "=", expressions_1.Source, (0, combi_1.opt)("NO FLUSH"), (0, combi_1.opt)(expressions_1.OLEExporting));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetProperty = GetProperty;
//# sourceMappingURL=get_property.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_reference.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_reference.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetReference = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class GetReference {
    getMatcher() {
        const ret = (0, combi_1.seq)("GET REFERENCE OF", expressions_1.Source, "INTO", expressions_1.Target);
        return ret;
    }
}
exports.GetReference = GetReference;
//# sourceMappingURL=get_reference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_run_time.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_run_time.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRunTime = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class GetRunTime {
    getMatcher() {
        const ret = (0, combi_1.seq)("GET RUN TIME FIELD", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.GetRunTime = GetRunTime;
//# sourceMappingURL=get_run_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_time.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_time.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetTime = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class GetTime {
    getMatcher() {
        const options = (0, combi_1.seq)((0, combi_1.alt)("STAMP FIELD", "FIELD"), expressions_1.Target);
        return (0, combi_1.seq)("GET TIME", (0, combi_1.opt)(options));
    }
}
exports.GetTime = GetTime;
//# sourceMappingURL=get_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/hide.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/hide.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hide = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Hide {
    getMatcher() {
        const ret = (0, combi_1.seq)("HIDE", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Hide = Hide;
//# sourceMappingURL=hide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/if.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/if.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.If = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class If {
    getMatcher() {
        return (0, combi_1.seq)("IF", expressions_1.Cond);
    }
}
exports.If = If;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Import {
    getMatcher() {
        const dto = (0, combi_1.seq)("TO", expressions_1.Target);
        const client = (0, combi_1.seq)("CLIENT", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.Source);
        const using = (0, combi_1.seq)("USING", expressions_1.Source);
        const cluster = (0, combi_1.seq)(expressions_1.NamespaceSimpleName, (0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.regex)(/^[\w$%\^]{2}$/), (0, combi_1.tok)(tokens_1.ParenRightW));
        const buffer = (0, combi_1.seq)("DATA BUFFER", expressions_1.Source);
        const memory = (0, combi_1.seq)("MEMORY ID", expressions_1.Source);
        const table = (0, combi_1.seq)("INTERNAL TABLE", expressions_1.Source);
        const shared = (0, combi_1.seq)((0, combi_1.alt)("SHARED MEMORY", "SHARED BUFFER"), cluster, (0, combi_1.per)(dto, client, id));
        const database = (0, combi_1.seq)("DATABASE", cluster, (0, combi_1.per)(dto, client, id, using));
        const source = (0, combi_1.alt)(buffer, memory, database, table, shared);
        const to = (0, combi_1.plus)((0, combi_1.seq)(expressions_1.ComponentChainSimple, (0, combi_1.alt)("TO", "INTO"), expressions_1.Target));
        const toeq = (0, combi_1.plus)((0, combi_1.seq)((0, combi_1.alt)(expressions_1.ComponentChainSimple, expressions_1.FieldSymbol), "=", expressions_1.Target));
        const target = (0, combi_1.alt)(toeq, to, expressions_1.Dynamic, (0, combi_1.plus)(expressions_1.Target));
        const options = (0, combi_1.per)("ACCEPTING PADDING", "IGNORING CONVERSION ERRORS", "IN CHAR-TO-HEX MODE", "IGNORING STRUCTURE BOUNDARIES", "ACCEPTING TRUNCATION", (0, combi_1.seq)("REPLACEMENT CHARACTER", expressions_1.Source), (0, combi_1.seq)("CODE PAGE INTO", expressions_1.Source), (0, combi_1.seq)("ENDIAN INTO", expressions_1.Source));
        const ret = (0, combi_1.seq)("IMPORT", target, "FROM", source, (0, combi_1.opt)(options));
        return ret;
    }
}
exports.Import = Import;
//# sourceMappingURL=import.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_dynpro.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_dynpro.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImportDynpro = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ImportDynpro {
    getMatcher() {
        const ret = (0, combi_1.seq)("IMPORT DYNPRO", expressions_1.Target, expressions_1.Target, expressions_1.Target, expressions_1.Target, "ID", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ImportDynpro = ImportDynpro;
//# sourceMappingURL=import_dynpro.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_nametab.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_nametab.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImportNametab = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ImportNametab {
    getMatcher() {
        const ret = (0, combi_1.seq)("IMPORT NAMETAB", expressions_1.Target, expressions_1.Target, "ID", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ImportNametab = ImportNametab;
//# sourceMappingURL=import_nametab.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Include = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Include {
    getMatcher() {
        const ret = (0, combi_1.seq)("INCLUDE", expressions_1.IncludeName, (0, combi_1.opt)("IF FOUND"));
        return ret;
    }
}
exports.Include = Include;
//# sourceMappingURL=include.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include_type.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include_type.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncludeType = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class IncludeType {
    getMatcher() {
        const tas = (0, combi_1.seq)("AS", Expressions.Field);
        const renaming = (0, combi_1.seq)("RENAMING WITH SUFFIX", Expressions.ComponentName);
        const ret = (0, combi_1.seq)("INCLUDE", (0, combi_1.alt)("TYPE", "STRUCTURE"), Expressions.TypeName, (0, combi_1.opt)(tas), (0, combi_1.opt)(renaming));
        return ret;
    }
}
exports.IncludeType = IncludeType;
//# sourceMappingURL=include_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
// do not include statement.ts in this file.
// this file only contains "real" statements
// sequence of exports is optimized for parsing and precedence
// see statement.ts for Unknown, Empty, Macro and Comment statements
__exportStar(__webpack_require__(/*! ./data */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data.js"), exports);
__exportStar(__webpack_require__(/*! ./report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/report.js"), exports);
__exportStar(__webpack_require__(/*! ./write */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/write.js"), exports);
__exportStar(__webpack_require__(/*! ./endmethod */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmethod.js"), exports);
__exportStar(__webpack_require__(/*! ./method_implementation */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./endform */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endform.js"), exports);
__exportStar(__webpack_require__(/*! ./form */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form.js"), exports);
__exportStar(__webpack_require__(/*! ./import_nametab */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_nametab.js"), exports);
__exportStar(__webpack_require__(/*! ./check_select_options */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check_select_options.js"), exports);
__exportStar(__webpack_require__(/*! ./call_badi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_badi.js"), exports);
__exportStar(__webpack_require__(/*! ./class_data */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data.js"), exports);
__exportStar(__webpack_require__(/*! ./class_data_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./class_data_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_data_end.js"), exports);
__exportStar(__webpack_require__(/*! ./select_loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select_loop.js"), exports);
__exportStar(__webpack_require__(/*! ./do */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/do.js"), exports);
__exportStar(__webpack_require__(/*! ./break_id */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break_id.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_deferred */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_deferred.js"), exports);
__exportStar(__webpack_require__(/*! ./while */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/while.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_at_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop_at_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop.js"), exports);
__exportStar(__webpack_require__(/*! ./check */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/check.js"), exports);
__exportStar(__webpack_require__(/*! ./endprovide */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endprovide.js"), exports);
__exportStar(__webpack_require__(/*! ./if */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/if.js"), exports);
__exportStar(__webpack_require__(/*! ./convert_text */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert_text.js"), exports);
__exportStar(__webpack_require__(/*! ./log_point */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/log_point.js"), exports);
__exportStar(__webpack_require__(/*! ./window */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/window.js"), exports);
__exportStar(__webpack_require__(/*! ./endif */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endif.js"), exports);
__exportStar(__webpack_require__(/*! ./type_enum */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum.js"), exports);
__exportStar(__webpack_require__(/*! ./type_enum_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./type_enum_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_end.js"), exports);
__exportStar(__webpack_require__(/*! ./set_run_time */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_run_time.js"), exports);
__exportStar(__webpack_require__(/*! ./field_group */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/field_group.js"), exports);
__exportStar(__webpack_require__(/*! ./print_control */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/print_control.js"), exports);
__exportStar(__webpack_require__(/*! ./extract */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/extract.js"), exports);
__exportStar(__webpack_require__(/*! ./sum */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sum.js"), exports);
__exportStar(__webpack_require__(/*! ./end_of_page */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_page.js"), exports);
__exportStar(__webpack_require__(/*! ./generate_report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_report.js"), exports);
__exportStar(__webpack_require__(/*! ./elseif */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/elseif.js"), exports);
__exportStar(__webpack_require__(/*! ./else */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/else.js"), exports);
__exportStar(__webpack_require__(/*! ./perform */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/perform.js"), exports);
__exportStar(__webpack_require__(/*! ./append */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/append.js"), exports);
__exportStar(__webpack_require__(/*! ./clear */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/clear.js"), exports);
__exportStar(__webpack_require__(/*! ./concatenate */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/concatenate.js"), exports);
__exportStar(__webpack_require__(/*! ./enddo */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddo.js"), exports);
__exportStar(__webpack_require__(/*! ./endclass */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endclass.js"), exports);
__exportStar(__webpack_require__(/*! ./try */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/try.js"), exports);
__exportStar(__webpack_require__(/*! ./endtry */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endtry.js"), exports);
__exportStar(__webpack_require__(/*! ./assert */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assert.js"), exports);
__exportStar(__webpack_require__(/*! ./return */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/return.js"), exports);
__exportStar(__webpack_require__(/*! ./endwhile */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwhile.js"), exports);
__exportStar(__webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant.js"), exports);
__exportStar(__webpack_require__(/*! ./catch */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch.js"), exports);
__exportStar(__webpack_require__(/*! ./infotypes */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/infotypes.js"), exports);
__exportStar(__webpack_require__(/*! ./message */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/message.js"), exports);
__exportStar(__webpack_require__(/*! ./read_table */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_table.js"), exports);
__exportStar(__webpack_require__(/*! ./endloop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endloop.js"), exports);
__exportStar(__webpack_require__(/*! ./case */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case.js"), exports);
__exportStar(__webpack_require__(/*! ./create_object */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_object.js"), exports);
__exportStar(__webpack_require__(/*! ./select */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select.js"), exports);
__exportStar(__webpack_require__(/*! ./call */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call.js"), exports);
__exportStar(__webpack_require__(/*! ./class_local_friends */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_local_friends.js"), exports);
__exportStar(__webpack_require__(/*! ./class_deferred */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_deferred.js"), exports);
__exportStar(__webpack_require__(/*! ./fieldsymbol */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fieldsymbol.js"), exports);
__exportStar(__webpack_require__(/*! ./class_definition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./class_implementation */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./translate */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/translate.js"), exports);
__exportStar(__webpack_require__(/*! ./exit */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exit.js"), exports);
__exportStar(__webpack_require__(/*! ./endcase */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcase.js"), exports);
__exportStar(__webpack_require__(/*! ./constant_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./constant_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/constant_end.js"), exports);
__exportStar(__webpack_require__(/*! ./when_others */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_others.js"), exports);
__exportStar(__webpack_require__(/*! ./when */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when.js"), exports);
__exportStar(__webpack_require__(/*! ./continue */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/continue.js"), exports);
__exportStar(__webpack_require__(/*! ./assign */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign.js"), exports);
__exportStar(__webpack_require__(/*! ./get_badi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_badi.js"), exports);
__exportStar(__webpack_require__(/*! ./suppress_dialog */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/suppress_dialog.js"), exports);
__exportStar(__webpack_require__(/*! ./type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type.js"), exports);
__exportStar(__webpack_require__(/*! ./hide */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/hide.js"), exports);
__exportStar(__webpack_require__(/*! ./get_locale */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_locale.js"), exports);
__exportStar(__webpack_require__(/*! ./set_locale */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locale.js"), exports);
__exportStar(__webpack_require__(/*! ./commit */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./commit_entities */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/commit_entities.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_entities */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_entities.js"), exports);
__exportStar(__webpack_require__(/*! ./read_entities */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_entities.js"), exports);
__exportStar(__webpack_require__(/*! ./rollback_entities */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback_entities.js"), exports);
__exportStar(__webpack_require__(/*! ./summary */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/summary.js"), exports);
__exportStar(__webpack_require__(/*! ./on_change */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/on_change.js"), exports);
__exportStar(__webpack_require__(/*! ./at_user_command */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_user_command.js"), exports);
__exportStar(__webpack_require__(/*! ./position */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/position.js"), exports);
__exportStar(__webpack_require__(/*! ./resume */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/resume.js"), exports);
__exportStar(__webpack_require__(/*! ./stop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/stop.js"), exports);
__exportStar(__webpack_require__(/*! ./get_pf_status */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_pf_status.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_report.js"), exports);
__exportStar(__webpack_require__(/*! ./controls */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/controls.js"), exports);
__exportStar(__webpack_require__(/*! ./at_line_selection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_line_selection.js"), exports);
__exportStar(__webpack_require__(/*! ./new_page */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_page.js"), exports);
__exportStar(__webpack_require__(/*! ./set_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./get_property */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_property.js"), exports);
__exportStar(__webpack_require__(/*! ./scroll_list */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scroll_list.js"), exports);
__exportStar(__webpack_require__(/*! ./load_of_program */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_of_program.js"), exports);
__exportStar(__webpack_require__(/*! ./top_of_page */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/top_of_page.js"), exports);
__exportStar(__webpack_require__(/*! ./truncate_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/truncate_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./set_update_task */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_update_task.js"), exports);
__exportStar(__webpack_require__(/*! ./set_user_command */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_user_command.js"), exports);
__exportStar(__webpack_require__(/*! ./rollback */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_internal */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_internal.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_database */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_database.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./free_memory */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_memory.js"), exports);
__exportStar(__webpack_require__(/*! ./catch_system_exceptions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/catch_system_exceptions.js"), exports);
__exportStar(__webpack_require__(/*! ./endcatch */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endcatch.js"), exports);
__exportStar(__webpack_require__(/*! ./assign_local_copy */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/assign_local_copy.js"), exports);
__exportStar(__webpack_require__(/*! ./set_extended_check */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_extended_check.js"), exports);
__exportStar(__webpack_require__(/*! ./split */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/split.js"), exports);
__exportStar(__webpack_require__(/*! ./new_line */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_line.js"), exports);
__exportStar(__webpack_require__(/*! ./free_object */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free_object.js"), exports);
__exportStar(__webpack_require__(/*! ./sort */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort.js"), exports);
__exportStar(__webpack_require__(/*! ./replace */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/replace.js"), exports);
__exportStar(__webpack_require__(/*! ./with_loop */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with_loop.js"), exports);
__exportStar(__webpack_require__(/*! ./with */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with.js"), exports);
__exportStar(__webpack_require__(/*! ./endwith */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endwith.js"), exports);
__exportStar(__webpack_require__(/*! ./condense */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/condense.js"), exports);
__exportStar(__webpack_require__(/*! ./insert_internal */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_internal.js"), exports);
__exportStar(__webpack_require__(/*! ./insert_database */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_database.js"), exports);
__exportStar(__webpack_require__(/*! ./insert_field_group */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_field_group.js"), exports);
__exportStar(__webpack_require__(/*! ./update_database */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/update_database.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_database */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_database.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_internal */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_internal.js"), exports);
__exportStar(__webpack_require__(/*! ./raise */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise.js"), exports);
__exportStar(__webpack_require__(/*! ./define */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/define.js"), exports);
__exportStar(__webpack_require__(/*! ./enddefine */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enddefine.js"), exports);
__exportStar(__webpack_require__(/*! ./find */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/find.js"), exports);
__exportStar(__webpack_require__(/*! ./move */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move.js"), exports);
__exportStar(__webpack_require__(/*! ./move_corresponding */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move_corresponding.js"), exports);
__exportStar(__webpack_require__(/*! ./get_time */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_time.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement_point */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_point.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement_section */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement_section.js"), exports);
__exportStar(__webpack_require__(/*! ./end_enhancement_section */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement_section.js"), exports);
__exportStar(__webpack_require__(/*! ./set_handler */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_handler.js"), exports);
__exportStar(__webpack_require__(/*! ./set_left */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_left.js"), exports);
__exportStar(__webpack_require__(/*! ./pack */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/pack.js"), exports);
__exportStar(__webpack_require__(/*! ./case_type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/case_type.js"), exports);
__exportStar(__webpack_require__(/*! ./when_type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_type.js"), exports);
__exportStar(__webpack_require__(/*! ./exec_sql */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/exec_sql.js"), exports);
__exportStar(__webpack_require__(/*! ./open_cursor */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_cursor.js"), exports);
__exportStar(__webpack_require__(/*! ./communication */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/communication.js"), exports);
__exportStar(__webpack_require__(/*! ./generate_subroutine */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_subroutine.js"), exports);
__exportStar(__webpack_require__(/*! ./reject */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reject.js"), exports);
__exportStar(__webpack_require__(/*! ./load_report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_report.js"), exports);
__exportStar(__webpack_require__(/*! ./private */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/private.js"), exports);
__exportStar(__webpack_require__(/*! ./system_call */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/system_call.js"), exports);
__exportStar(__webpack_require__(/*! ./set_language */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_language.js"), exports);
__exportStar(__webpack_require__(/*! ./call_dialog */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_dialog.js"), exports);
__exportStar(__webpack_require__(/*! ./protected */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/protected.js"), exports);
__exportStar(__webpack_require__(/*! ./public */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/public.js"), exports);
__exportStar(__webpack_require__(/*! ./nodes */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/nodes.js"), exports);
__exportStar(__webpack_require__(/*! ./demand */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/demand.js"), exports);
__exportStar(__webpack_require__(/*! ./supply */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/supply.js"), exports);
__exportStar(__webpack_require__(/*! ./fields */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fields.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_cluster */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_cluster.js"), exports);
__exportStar(__webpack_require__(/*! ./set_margin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_margin.js"), exports);
__exportStar(__webpack_require__(/*! ./call_database */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_database.js"), exports);
__exportStar(__webpack_require__(/*! ./contexts */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/contexts.js"), exports);
__exportStar(__webpack_require__(/*! ./interface */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface.js"), exports);
__exportStar(__webpack_require__(/*! ./endinterface */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endinterface.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/parameter.js"), exports);
__exportStar(__webpack_require__(/*! ./include */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include.js"), exports);
__exportStar(__webpack_require__(/*! ./collect */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/collect.js"), exports);
__exportStar(__webpack_require__(/*! ./ranges */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/ranges.js"), exports);
__exportStar(__webpack_require__(/*! ./events */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/events.js"), exports);
__exportStar(__webpack_require__(/*! ./receive */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/receive.js"), exports);
__exportStar(__webpack_require__(/*! ./back */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/back.js"), exports);
__exportStar(__webpack_require__(/*! ./add_corresponding */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add_corresponding.js"), exports);
__exportStar(__webpack_require__(/*! ./subtract_corresponding */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract_corresponding.js"), exports);
__exportStar(__webpack_require__(/*! ./static_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./static_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_end.js"), exports);
__exportStar(__webpack_require__(/*! ./get_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./tables */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/tables.js"), exports);
__exportStar(__webpack_require__(/*! ./local */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/local.js"), exports);
__exportStar(__webpack_require__(/*! ./add */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/add.js"), exports);
__exportStar(__webpack_require__(/*! ./describe */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/describe.js"), exports);
__exportStar(__webpack_require__(/*! ./submit */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/submit.js"), exports);
__exportStar(__webpack_require__(/*! ./scan */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scan.js"), exports);
__exportStar(__webpack_require__(/*! ./export */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export.js"), exports);
__exportStar(__webpack_require__(/*! ./import */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import.js"), exports);
__exportStar(__webpack_require__(/*! ./at_first */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_first.js"), exports);
__exportStar(__webpack_require__(/*! ./at_last */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_last.js"), exports);
__exportStar(__webpack_require__(/*! ./at */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at.js"), exports);
__exportStar(__webpack_require__(/*! ./put */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/put.js"), exports);
__exportStar(__webpack_require__(/*! ./endat */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endat.js"), exports);
__exportStar(__webpack_require__(/*! ./endselect */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endselect.js"), exports);
__exportStar(__webpack_require__(/*! ./refresh */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh.js"), exports);
__exportStar(__webpack_require__(/*! ./shift */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/shift.js"), exports);
__exportStar(__webpack_require__(/*! ./type_mesh */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh.js"), exports);
__exportStar(__webpack_require__(/*! ./transfer */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/transfer.js"), exports);
__exportStar(__webpack_require__(/*! ./subtract */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract.js"), exports);
__exportStar(__webpack_require__(/*! ./unassign */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unassign.js"), exports);
__exportStar(__webpack_require__(/*! ./open_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./close_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_load */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_load.js"), exports);
__exportStar(__webpack_require__(/*! ./close_cursor */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/close_cursor.js"), exports);
__exportStar(__webpack_require__(/*! ./leave */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/leave.js"), exports);
__exportStar(__webpack_require__(/*! ./class_definition_load */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/class_definition_load.js"), exports);
__exportStar(__webpack_require__(/*! ./initialization */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/initialization.js"), exports);
__exportStar(__webpack_require__(/*! ./start_of_selection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/start_of_selection.js"), exports);
__exportStar(__webpack_require__(/*! ./set_blank */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_blank.js"), exports);
__exportStar(__webpack_require__(/*! ./export_dynpro */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/export_dynpro.js"), exports);
__exportStar(__webpack_require__(/*! ./end_of_selection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_of_selection.js"), exports);
__exportStar(__webpack_require__(/*! ./search */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/search.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_line */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_line.js"), exports);
__exportStar(__webpack_require__(/*! ./selectionscreen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectionscreen.js"), exports);
__exportStar(__webpack_require__(/*! ./free */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/free.js"), exports);
__exportStar(__webpack_require__(/*! ./endon */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endon.js"), exports);
__exportStar(__webpack_require__(/*! ./fetch_next_cursor */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/fetch_next_cursor.js"), exports);
__exportStar(__webpack_require__(/*! ./reserve */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reserve.js"), exports);
__exportStar(__webpack_require__(/*! ./raise_entity_event */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_entity_event.js"), exports);
__exportStar(__webpack_require__(/*! ./refresh_control */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh_control.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_dynpro */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_dynpro.js"), exports);
__exportStar(__webpack_require__(/*! ./generate_dynpro */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/generate_dynpro.js"), exports);
__exportStar(__webpack_require__(/*! ./detail */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/detail.js"), exports);
__exportStar(__webpack_require__(/*! ./editor_call */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/editor_call.js"), exports);
__exportStar(__webpack_require__(/*! ./break */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/break.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_textpool */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_textpool.js"), exports);
__exportStar(__webpack_require__(/*! ./get */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get.js"), exports);
__exportStar(__webpack_require__(/*! ./selectoption */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectoption.js"), exports);
__exportStar(__webpack_require__(/*! ./convert */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/convert.js"), exports);
__exportStar(__webpack_require__(/*! ./static */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static.js"), exports);
__exportStar(__webpack_require__(/*! ./compute */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/compute.js"), exports);
__exportStar(__webpack_require__(/*! ./multiply */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/multiply.js"), exports);
__exportStar(__webpack_require__(/*! ./divide */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/divide.js"), exports);
__exportStar(__webpack_require__(/*! ./format */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/format.js"), exports);
__exportStar(__webpack_require__(/*! ./syntax_check */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/syntax_check.js"), exports);
__exportStar(__webpack_require__(/*! ./aliases */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/aliases.js"), exports);
__exportStar(__webpack_require__(/*! ./method_def */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_def.js"), exports);
__exportStar(__webpack_require__(/*! ./type_mesh_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./type_mesh_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_end.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_def */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_def.js"), exports);
__exportStar(__webpack_require__(/*! ./at_selection_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/at_selection_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./include_type */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/include_type.js"), exports);
__exportStar(__webpack_require__(/*! ./import_dynpro */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/import_dynpro.js"), exports);
__exportStar(__webpack_require__(/*! ./call_function */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_function.js"), exports);
__exportStar(__webpack_require__(/*! ./call_selection_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_selection_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./call_transformation */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transformation.js"), exports);
__exportStar(__webpack_require__(/*! ./read_line */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_line.js"), exports);
__exportStar(__webpack_require__(/*! ./read_textpool */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_textpool.js"), exports);
__exportStar(__webpack_require__(/*! ./read_report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_report.js"), exports);
__exportStar(__webpack_require__(/*! ./read_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./get_bit */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_bit.js"), exports);
__exportStar(__webpack_require__(/*! ./get_reference */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_reference.js"), exports);
__exportStar(__webpack_require__(/*! ./insert_report */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_report.js"), exports);
__exportStar(__webpack_require__(/*! ./insert_textpool */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_textpool.js"), exports);
__exportStar(__webpack_require__(/*! ./set_bit */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_bit.js"), exports);
__exportStar(__webpack_require__(/*! ./get_run_time */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_run_time.js"), exports);
__exportStar(__webpack_require__(/*! ./get_parameter */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_parameter.js"), exports);
__exportStar(__webpack_require__(/*! ./create_data */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_data.js"), exports);
__exportStar(__webpack_require__(/*! ./set_country */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_country.js"), exports);
__exportStar(__webpack_require__(/*! ./function_module */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_module.js"), exports);
__exportStar(__webpack_require__(/*! ./type_pools */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pools.js"), exports);
__exportStar(__webpack_require__(/*! ./type_pool */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pool.js"), exports);
__exportStar(__webpack_require__(/*! ./wait */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/wait.js"), exports);
__exportStar(__webpack_require__(/*! ./overlay */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/overlay.js"), exports);
__exportStar(__webpack_require__(/*! ./set_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./set_cursor */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_cursor.js"), exports);
__exportStar(__webpack_require__(/*! ./call_screen */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./set_pf_status */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_pf_status.js"), exports);
__exportStar(__webpack_require__(/*! ./set_titlebar */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_titlebar.js"), exports);
__exportStar(__webpack_require__(/*! ./program */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/program.js"), exports);
__exportStar(__webpack_require__(/*! ./function_pool */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/function_pool.js"), exports);
__exportStar(__webpack_require__(/*! ./module */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/module.js"), exports);
__exportStar(__webpack_require__(/*! ./endmodule */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endmodule.js"), exports);
__exportStar(__webpack_require__(/*! ./endfunction */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endfunction.js"), exports);
__exportStar(__webpack_require__(/*! ./retry */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/retry.js"), exports);
__exportStar(__webpack_require__(/*! ./authority_check */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/authority_check.js"), exports);
__exportStar(__webpack_require__(/*! ./set_parameter */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_parameter.js"), exports);
__exportStar(__webpack_require__(/*! ./get_cursor */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_cursor.js"), exports);
__exportStar(__webpack_require__(/*! ./call_kernel */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_kernel.js"), exports);
__exportStar(__webpack_require__(/*! ./call_transaction */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_transaction.js"), exports);
__exportStar(__webpack_require__(/*! ./unpack */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unpack.js"), exports);
__exportStar(__webpack_require__(/*! ./skip */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/skip.js"), exports);
__exportStar(__webpack_require__(/*! ./uline */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/uline.js"), exports);
__exportStar(__webpack_require__(/*! ./data_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./data_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/data_end.js"), exports);
__exportStar(__webpack_require__(/*! ./type_begin */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_begin.js"), exports);
__exportStar(__webpack_require__(/*! ./type_end */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_end.js"), exports);
__exportStar(__webpack_require__(/*! ./raise_event */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_event.js"), exports);
__exportStar(__webpack_require__(/*! ./cleanup */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/cleanup.js"), exports);
__exportStar(__webpack_require__(/*! ./create_ole */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/create_ole.js"), exports);
__exportStar(__webpack_require__(/*! ./call_ole */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/call_ole.js"), exports);
__exportStar(__webpack_require__(/*! ./set_property */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_property.js"), exports);
__exportStar(__webpack_require__(/*! ./test_injection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_injection.js"), exports);
__exportStar(__webpack_require__(/*! ./end_test_injection */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_injection.js"), exports);
__exportStar(__webpack_require__(/*! ./test_seam */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_seam.js"), exports);
__exportStar(__webpack_require__(/*! ./end_test_seam */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_test_seam.js"), exports);
__exportStar(__webpack_require__(/*! ./delete_memory */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/delete_memory.js"), exports);
__exportStar(__webpack_require__(/*! ./provide */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/provide.js"), exports);
__exportStar(__webpack_require__(/*! ./endexec */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/endexec.js"), exports);
__exportStar(__webpack_require__(/*! ./sort_dataset */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort_dataset.js"), exports);
__exportStar(__webpack_require__(/*! ./get_permissions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/get_permissions.js"), exports);
__exportStar(__webpack_require__(/*! ./set_locks */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locks.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/enhancement.js"), exports);
__exportStar(__webpack_require__(/*! ./end_enhancement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/end_enhancement.js"), exports);
__exportStar(__webpack_require__(/*! ./form_definition */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/form_definition.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/infotypes.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/infotypes.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Infotypes = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Infotypes {
    getMatcher() {
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Constant);
        const name = (0, combi_1.seq)("NAME", expressions_1.Field);
        const ret = (0, combi_1.seq)("INFOTYPES", expressions_1.Constant, (0, combi_1.optPrio)(occurs), (0, combi_1.optPrio)(name));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Infotypes = Infotypes;
//# sourceMappingURL=infotypes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/initialization.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/initialization.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Initialization = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Initialization {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "INITIALIZATION");
    }
}
exports.Initialization = Initialization;
//# sourceMappingURL=initialization.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_database.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_database.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertDatabase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class InsertDatabase {
    getMatcher() {
        const sub = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WParenLeftW), expressions_1.Select, (0, combi_1.tok)(tokens_1.WParenRightW));
        const f = (0, combi_1.seq)((0, combi_1.opt)(expressions_1.SQLClient), (0, combi_1.opt)(expressions_1.DatabaseConnection), "FROM", (0, combi_1.opt)("TABLE"), (0, combi_1.alt)(expressions_1.SQLSource, sub), (0, combi_1.opt)("ACCEPTING DUPLICATE KEYS"));
        const from = (0, combi_1.seq)(expressions_1.DatabaseTable, (0, combi_1.opt)((0, combi_1.alt)(f, expressions_1.SQLClient, expressions_1.DatabaseConnection)));
        const into = (0, combi_1.seq)("INTO", expressions_1.DatabaseTable, (0, combi_1.opt)(expressions_1.SQLClient), (0, combi_1.opt)(expressions_1.DatabaseConnection), "VALUES", expressions_1.SQLSource);
        return (0, combi_1.seq)("INSERT", (0, combi_1.alt)(from, into));
    }
}
exports.InsertDatabase = InsertDatabase;
//# sourceMappingURL=insert_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_field_group.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_field_group.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertFieldGroup = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InsertFieldGroup {
    getMatcher() {
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const src = (0, combi_1.alt)((0, combi_1.ver)(version_1.Version.v740sp02, (0, combi_1.plus)(expressions_1.Source)), (0, combi_1.plus)(expressions_1.SimpleSource1));
        const ret = (0, combi_1.seq)("INSERT", src, into);
        return ret;
    }
}
exports.InsertFieldGroup = InsertFieldGroup;
//# sourceMappingURL=insert_field_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_internal.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_internal.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertInternal = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InsertInternal {
    getMatcher() {
        const target = (0, combi_1.altPrio)(expressions_1.Source, expressions_1.Dynamic);
        const assigning = (0, combi_1.seq)("ASSIGNING", expressions_1.FSTarget);
        const ref = (0, combi_1.seq)("REFERENCE INTO", expressions_1.Target);
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const initial = (0, combi_1.str)("INITIAL LINE");
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const intoTable = (0, combi_1.seq)("INTO TABLE", expressions_1.Target, (0, combi_1.opt)((0, combi_1.alt)(ref, assigning)));
        const to = (0, combi_1.seq)("TO", expressions_1.Source);
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const fromTo = (0, combi_1.opt)((0, combi_1.per)(from, to));
        const foo = (0, combi_1.alt)(intoTable, (0, combi_1.seq)(into, (0, combi_1.opt)((0, combi_1.per)(index, (0, combi_1.alt)(ref, assigning)))), (0, combi_1.per)(index, (0, combi_1.alt)(ref, assigning)));
        const lines = (0, combi_1.seq)("LINES OF", target, (0, combi_1.opt)(fromTo));
        const src = (0, combi_1.alt)(expressions_1.SimpleSource4, (0, combi_1.ver)(version_1.Version.v740sp02, expressions_1.Source));
        const tab = (0, combi_1.seq)("TABLE", expressions_1.Source);
        const ret = (0, combi_1.seq)("INSERT", (0, combi_1.altPrio)(tab, (0, combi_1.seq)((0, combi_1.altPrio)(initial, lines, src), foo)));
        return ret;
    }
}
exports.InsertInternal = InsertInternal;
//# sourceMappingURL=insert_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_report.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_report.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertReport = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class InsertReport {
    getMatcher() {
        const options = (0, combi_1.per)((0, combi_1.seq)("STATE", expressions_1.Source), (0, combi_1.seq)("EXTENSION TYPE", expressions_1.Source), (0, combi_1.seq)("DIRECTORY ENTRY", expressions_1.Source), (0, combi_1.seq)("UNICODE ENABLING", expressions_1.Source), (0, combi_1.seq)("PROGRAM TYPE", expressions_1.Source), (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("VERSION", expressions_1.Source)), (0, combi_1.seq)("FIXED-POINT ARITHMETIC", expressions_1.Source), "KEEPING DIRECTORY ENTRY");
        const ret = (0, combi_1.seq)("INSERT REPORT", expressions_1.Source, "FROM", expressions_1.Source, (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.InsertReport = InsertReport;
//# sourceMappingURL=insert_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_textpool.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/insert_textpool.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertTextpool = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class InsertTextpool {
    getMatcher() {
        const state = (0, combi_1.seq)("STATE", expressions_1.Source);
        const language = (0, combi_1.seq)("LANGUAGE", expressions_1.Source);
        const ret = (0, combi_1.seq)("INSERT TEXTPOOL", expressions_1.Source, "FROM", expressions_1.Source, (0, combi_1.opt)(language), (0, combi_1.opt)(state));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.InsertTextpool = InsertTextpool;
//# sourceMappingURL=insert_textpool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Interface {
    getMatcher() {
        return (0, combi_1.seq)("INTERFACE", expressions_1.InterfaceName, (0, combi_1.opt)(expressions_1.ClassGlobal));
    }
}
exports.Interface = Interface;
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_def.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_def.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceDef = void 0;
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InterfaceDef {
    getMatcher() {
        const val = (0, combi_1.seq)(expressions_1.AttributeName, "=", expressions_1.Source);
        const dataValues = (0, combi_1.seq)("DATA VALUES", (0, combi_1.plus)(val));
        const options = (0, combi_1.alt)(expressions_1.AbstractMethods, expressions_1.FinalMethods, "ALL METHODS ABSTRACT", "ALL METHODS FINAL", (0, combi_1.ver)(version_1.Version.v740sp02, "PARTIALLY IMPLEMENTED"));
        return (0, combi_1.seq)("INTERFACES", expressions_1.InterfaceName, (0, combi_1.opt)(options), (0, combi_1.opt)(dataValues));
    }
}
exports.InterfaceDef = InterfaceDef;
//# sourceMappingURL=interface_def.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_deferred.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_deferred.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceDeferred = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InterfaceDeferred {
    getMatcher() {
        return (0, combi_1.seq)("INTERFACE", expressions_1.InterfaceName, "DEFERRED", (0, combi_1.opt)("PUBLIC"));
    }
}
exports.InterfaceDeferred = InterfaceDeferred;
//# sourceMappingURL=interface_deferred.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_load.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/interface_load.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceLoad = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InterfaceLoad {
    getMatcher() {
        return (0, combi_1.seq)("INTERFACE", expressions_1.InterfaceName, "LOAD");
    }
}
exports.InterfaceLoad = InterfaceLoad;
//# sourceMappingURL=interface_load.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/leave.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/leave.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Leave = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Leave {
    getMatcher() {
        const retu = (0, combi_1.seq)(expressions_1.AndReturn, "TO SCREEN", expressions_1.Source);
        const transaction = (0, combi_1.seq)("TO TRANSACTION", expressions_1.Source, (0, combi_1.opt)("AND SKIP FIRST SCREEN"));
        const ret = (0, combi_1.seq)("LEAVE", (0, combi_1.opt)((0, combi_1.alt)("TO CURRENT TRANSACTION", (0, combi_1.seq)((0, combi_1.opt)("TO"), "LIST-PROCESSING", (0, combi_1.opt)(retu)), "LIST-PROCESSING", "SCREEN", transaction, "PROGRAM", (0, combi_1.seq)("TO SCREEN", expressions_1.Source))));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Leave = Leave;
//# sourceMappingURL=leave.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_of_program.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_of_program.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadOfProgram = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class LoadOfProgram {
    getMatcher() {
        const ret = (0, combi_1.str)("LOAD-OF-PROGRAM");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.LoadOfProgram = LoadOfProgram;
//# sourceMappingURL=load_of_program.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_report.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/load_report.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoadReport = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class LoadReport {
    getMatcher() {
        const ret = (0, combi_1.seq)("LOAD REPORT", expressions_1.Source, "PART", expressions_1.Source, "INTO", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.LoadReport = LoadReport;
//# sourceMappingURL=load_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/local.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/local.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Local = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Local {
    getMatcher() {
        const ret = (0, combi_1.seq)("LOCAL", expressions_1.FieldSub, (0, combi_1.opt)(expressions_1.TableBody));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Local = Local;
//# sourceMappingURL=local.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/log_point.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/log_point.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogPoint = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class LogPoint {
    getMatcher() {
        const subkey = (0, combi_1.seq)("SUBKEY", expressions_1.Source);
        const fields = (0, combi_1.seq)("FIELDS", (0, combi_1.plus)(expressions_1.Source));
        const ret = (0, combi_1.seq)("LOG-POINT ID", expressions_1.NamespaceSimpleName, (0, combi_1.opt)(subkey), (0, combi_1.opt)(fields));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.LogPoint = LogPoint;
//# sourceMappingURL=log_point.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Loop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const simple_source2_1 = __webpack_require__(/*! ../expressions/simple_source2 */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/simple_source2.js");
const loop_group_by_1 = __webpack_require__(/*! ../expressions/loop_group_by */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/loop_group_by.js");
class Loop {
    getMatcher() {
        const where = (0, combi_1.seq)("WHERE", (0, combi_1.alt)(expressions_1.ComponentCond, expressions_1.Dynamic));
        const group = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.seq)("GROUP BY", loop_group_by_1.LoopGroupBy));
        const step = (0, combi_1.ver)(version_1.Version.v757, (0, combi_1.seq)("STEP", expressions_1.Source));
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const to = (0, combi_1.seq)("TO", expressions_1.Source);
        const usingKey = (0, combi_1.seq)("USING KEY", (0, combi_1.altPrio)(expressions_1.SimpleName, expressions_1.Dynamic));
        const options = (0, combi_1.per)(expressions_1.LoopTarget, from, to, where, usingKey, group, step);
        const at = (0, combi_1.seq)("AT", (0, combi_1.opt)((0, combi_1.seq)("SCREEN", (0, combi_1.failCombinator)())), (0, combi_1.opt)((0, combi_1.ver)(version_1.Version.v740sp08, "GROUP")), (0, combi_1.alt)(simple_source2_1.SimpleSource2, (0, combi_1.ver)(version_1.Version.v740sp02, expressions_1.Source)), (0, combi_1.opt)(options));
        return (0, combi_1.seq)("LOOP", (0, combi_1.opt)(at));
    }
}
exports.Loop = Loop;
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop_at_screen.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/loop_at_screen.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopAtScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class LoopAtScreen {
    getMatcher() {
        const l = (0, combi_1.seq)("LOOP AT SCREEN", (0, combi_1.opt)((0, combi_1.seq)("INTO", expressions_1.Target)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, l);
    }
}
exports.LoopAtScreen = LoopAtScreen;
//# sourceMappingURL=loop_at_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/message.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/message.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Message {
    getMatcher() {
        const s = (0, combi_1.alt)((0, combi_1.ver)(version_1.Version.v740sp02, expressions_1.Source), expressions_1.SimpleSource3);
        const like = (0, combi_1.seq)("DISPLAY LIKE", expressions_1.Source);
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const raising = (0, combi_1.seq)("RAISING", expressions_1.ExceptionName);
        const options = (0, combi_1.per)(like, into, raising);
        const type = (0, combi_1.seq)("TYPE", expressions_1.Source);
        const sou = (0, combi_1.altPrio)(options, s);
        const sourc = (0, combi_1.alt)(sou, (0, combi_1.seq)(s, sou), (0, combi_1.seq)(s, s, sou), (0, combi_1.seq)(s, s, s, options));
        const mwith = (0, combi_1.seq)("WITH", s, (0, combi_1.opt)(sourc));
        const foo = (0, combi_1.seq)(expressions_1.MessageSource, (0, combi_1.opt)(options), (0, combi_1.opt)(mwith));
        const text = (0, combi_1.seq)(s, type, (0, combi_1.optPrio)(like), (0, combi_1.optPrio)(raising));
        const cloud1 = (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.seq)("WITH", expressions_1.Source, (0, combi_1.opt)(expressions_1.Source), (0, combi_1.opt)(expressions_1.Source), (0, combi_1.opt)(expressions_1.Source))), (0, combi_1.altPrio)(into, raising));
        const cloud2 = (0, combi_1.seq)((0, combi_1.altPrio)(into, raising), (0, combi_1.opt)((0, combi_1.seq)("WITH", expressions_1.Source, (0, combi_1.opt)(expressions_1.Source), (0, combi_1.opt)(expressions_1.Source), (0, combi_1.opt)(expressions_1.Source))));
        const cloud = (0, combi_1.seq)(expressions_1.MessageSource, (0, combi_1.alt)(cloud1, cloud2));
        const ret = (0, combi_1.seq)("MESSAGE", (0, combi_1.altPrio)((0, combi_1.verNot)(version_1.Version.Cloud, foo), (0, combi_1.verNot)(version_1.Version.Cloud, text), (0, combi_1.ver)(version_1.Version.Cloud, cloud)));
        return ret;
    }
}
exports.Message = Message;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_def.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_def.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDef = void 0;
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodDef {
    getMatcher() {
        const def = (0, combi_1.ver)(version_1.Version.v740sp08, (0, combi_1.seq)("DEFAULT", (0, combi_1.altPrio)("FAIL", "IGNORE")));
        const parameters = (0, combi_1.seq)((0, combi_1.optPrio)((0, combi_1.altPrio)("FINAL", def, expressions_1.Abstract)), (0, combi_1.optPrio)(expressions_1.MethodDefImporting), (0, combi_1.optPrio)(expressions_1.MethodDefExporting), (0, combi_1.optPrio)(expressions_1.MethodDefChanging), (0, combi_1.optPrio)(expressions_1.MethodDefReturning), (0, combi_1.optPrio)((0, combi_1.altPrio)(expressions_1.MethodDefRaising, expressions_1.MethodDefExceptions)));
        const testing = (0, combi_1.seq)((0, combi_1.optPrio)(expressions_1.Abstract), "FOR TESTING", (0, combi_1.optPrio)((0, combi_1.altPrio)(expressions_1.MethodDefRaising, expressions_1.MethodDefExceptions)));
        // todo, this is only from version something
        const tableFunction = (0, combi_1.seq)("TABLE FUNCTION", (0, combi_1.regex)(/^\w+?$/));
        // todo, this is only from version something
        const ddl = "DDL OBJECT OPTIONS CDS SESSION CLIENT REQUIRED";
        const result = (0, combi_1.seq)("RESULT", expressions_1.MethodParamName);
        const link = (0, combi_1.seq)("LINK", expressions_1.MethodParamName);
        const full = (0, combi_1.seq)("FULL", expressions_1.MethodParamName);
        const modify = (0, combi_1.alt)((0, combi_1.seq)("FOR ACTION", expressions_1.TypeName, (0, combi_1.optPrio)(result)), (0, combi_1.seq)("FOR CREATE", (0, combi_1.alt)(expressions_1.TypeName, expressions_1.EntityAssociation)), (0, combi_1.seq)("FOR DELETE", expressions_1.TypeName), (0, combi_1.seq)("FOR UPDATE", expressions_1.TypeName));
        const behavior = (0, combi_1.altPrio)((0, combi_1.seq)("VALIDATE ON SAVE IMPORTING", expressions_1.MethodParamName, "FOR", expressions_1.TypeName), (0, combi_1.seq)("MODIFY IMPORTING", expressions_1.MethodParamName, modify), (0, combi_1.seq)("READ IMPORTING", expressions_1.MethodParamName, "FOR READ", (0, combi_1.alt)(expressions_1.TypeName, expressions_1.EntityAssociation), (0, combi_1.optPrio)(full), result, (0, combi_1.optPrio)(link)), (0, combi_1.seq)("FEATURES IMPORTING", expressions_1.MethodParamName, "REQUEST", expressions_1.NamespaceSimpleName, "FOR", expressions_1.NamespaceSimpleName, result), (0, combi_1.seq)("BEHAVIOR IMPORTING", expressions_1.MethodParamName, "FOR CREATE", expressions_1.TypeName, expressions_1.MethodParamName, "FOR UPDATE", expressions_1.TypeName, expressions_1.MethodParamName, "FOR DELETE", expressions_1.TypeName), (0, combi_1.seq)("BEHAVIOR IMPORTING", expressions_1.MethodParamName, "FOR READ", expressions_1.TypeName, result), (0, combi_1.seq)((0, combi_1.alt)("BEHAVIOR", "LOCK"), "IMPORTING", expressions_1.MethodParamName, "FOR LOCK", expressions_1.TypeName), (0, combi_1.seq)("DETERMINE", (0, combi_1.alt)("ON MODIFY", "ON SAVE"), "IMPORTING", expressions_1.MethodParamName, "FOR", expressions_1.TypeName), (0, combi_1.seq)("GLOBAL AUTHORIZATION IMPORTING REQUEST", expressions_1.MethodParamName, "FOR", expressions_1.TypeName, result), (0, combi_1.seq)("INSTANCE AUTHORIZATION IMPORTING", expressions_1.MethodParamName, "REQUEST", expressions_1.MethodParamName, "FOR", expressions_1.TypeName, result));
        // todo, this is only from version something
        const amdp = (0, combi_1.seq)("AMDP OPTIONS CDS SESSION CLIENT CURRENT", (0, combi_1.optPrio)(expressions_1.MethodDefImporting), (0, combi_1.optPrio)(expressions_1.MethodDefExporting), (0, combi_1.optPrio)(expressions_1.MethodDefRaising));
        const ret = (0, combi_1.seq)((0, combi_1.altPrio)("CLASS-METHODS", "METHODS"), expressions_1.MethodName, (0, combi_1.alt)((0, combi_1.seq)((0, combi_1.optPrio)(expressions_1.Abstract), expressions_1.EventHandler), parameters, testing, (0, combi_1.seq)("FOR", (0, combi_1.alt)(tableFunction, ddl, behavior)), amdp, "NOT AT END OF MODE", (0, combi_1.optPrio)(expressions_1.Redefinition)));
        return ret;
    }
}
exports.MethodDef = MethodDef;
//# sourceMappingURL=method_def.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_implementation.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_implementation.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodImplementation = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodImplementation {
    getMatcher() {
        const name = (0, combi_1.regex)(/[\w~]+/);
        const kernel = (0, combi_1.seq)("KERNEL MODULE", (0, combi_1.plus)(name), (0, combi_1.optPrio)((0, combi_1.altPrio)("FAIL", "IGNORE")));
        const using = (0, combi_1.seq)("USING", (0, combi_1.plus)(expressions_1.SimpleFieldChain));
        const database = (0, combi_1.seq)("DATABASE", (0, combi_1.alt)("PROCEDURE", "FUNCTION", "GRAPH WORKSPACE"), "FOR HDB", expressions_1.Language, (0, combi_1.opt)("OPTIONS READ-ONLY"), (0, combi_1.opt)(using));
        const by = (0, combi_1.seq)("BY", (0, combi_1.alt)(kernel, database));
        return (0, combi_1.seq)("METHOD", expressions_1.MethodName, (0, combi_1.optPrio)(by));
    }
}
exports.MethodImplementation = MethodImplementation;
//# sourceMappingURL=method_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_database.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_database.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyDatabase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ModifyDatabase {
    getMatcher() {
        const from = (0, combi_1.seq)("FROM", (0, combi_1.opt)("TABLE"), expressions_1.SQLSource);
        const options = (0, combi_1.per)(expressions_1.DatabaseConnection, from, expressions_1.SQLClient);
        return (0, combi_1.seq)("MODIFY", expressions_1.DatabaseTable, options);
    }
}
exports.ModifyDatabase = ModifyDatabase;
//# sourceMappingURL=modify_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_entities.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_entities.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyEntities = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ModifyEntities {
    getMatcher() {
        const fieldsWith = (0, combi_1.seq)("FIELDS (", (0, combi_1.plus)(expressions_1.SimpleName), ") WITH", expressions_1.Source);
        const operation = (0, combi_1.alt)((0, combi_1.seq)("UPDATE SET FIELDS WITH", expressions_1.Source), (0, combi_1.seq)("CREATE SET FIELDS WITH", expressions_1.Source), (0, combi_1.seq)("UPDATE", fieldsWith), (0, combi_1.seq)("DELETE FROM", expressions_1.Source), (0, combi_1.seq)("EXECUTE", expressions_1.SimpleName, "FROM", expressions_1.Source), (0, combi_1.seq)("CREATE", (0, combi_1.optPrio)("AUTO FILL CID"), fieldsWith));
        const s = (0, combi_1.seq)("MODIFY ENTITIES OF", expressions_1.NamespaceSimpleName, (0, combi_1.opt)("IN LOCAL MODE"), "ENTITY", expressions_1.SimpleName, operation, (0, combi_1.per)((0, combi_1.seq)("FAILED", expressions_1.Target), (0, combi_1.seq)("RESULT", expressions_1.Target), (0, combi_1.seq)("MAPPED", expressions_1.Target), (0, combi_1.seq)("REPORTED", expressions_1.Target)));
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.ModifyEntities = ModifyEntities;
//# sourceMappingURL=modify_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_internal.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_internal.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyInternal = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ModifyInternal {
    getMatcher() {
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const transporting = (0, combi_1.seq)("TRANSPORTING", (0, combi_1.plus)((0, combi_1.alt)(expressions_1.ComponentChainSimple, expressions_1.Dynamic)));
        const where = (0, combi_1.seq)("WHERE", expressions_1.ComponentCond);
        const assigning = (0, combi_1.seq)("ASSIGNING", expressions_1.FSTarget);
        const using = (0, combi_1.seq)("USING KEY", expressions_1.SimpleName);
        const additions = (0, combi_1.per)(where, assigning, using);
        const target = (0, combi_1.alt)(expressions_1.Target, expressions_1.Dynamic);
        const options = (0, combi_1.alt)((0, combi_1.per)(index, transporting), (0, combi_1.seq)(from, (0, combi_1.opt)((0, combi_1.per)(index, transporting))), (0, combi_1.seq)((0, combi_1.per)(index, transporting), from, (0, combi_1.opt)((0, combi_1.per)(index, transporting))));
        const long = (0, combi_1.seq)("MODIFY", (0, combi_1.opt)("TABLE"), target, (0, combi_1.opt)(options), (0, combi_1.opt)(additions));
        const simple = (0, combi_1.seq)("MODIFY TABLE", target, from, (0, combi_1.opt)(using));
        return (0, combi_1.alt)(long, simple);
    }
}
exports.ModifyInternal = ModifyInternal;
//# sourceMappingURL=modify_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_line.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_line.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyLine = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ModifyLine {
    getMatcher() {
        const form = (0, combi_1.seq)((0, combi_1.alt)("INVERSE", "INPUT"), "=", expressions_1.Source);
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const value = (0, combi_1.seq)("FIELD VALUE", (0, combi_1.plus)((0, combi_1.seq)(expressions_1.Source, (0, combi_1.optPrio)(from))));
        const format = (0, combi_1.seq)("FIELD FORMAT", expressions_1.Source, (0, combi_1.opt)(form));
        const lineValue = (0, combi_1.seq)("LINE VALUE FROM", expressions_1.Source);
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const page = (0, combi_1.seq)("OF PAGE", expressions_1.Source);
        const ocp = (0, combi_1.str)("OF CURRENT PAGE");
        const lineFormat = (0, combi_1.seq)("LINE FORMAT", (0, combi_1.alt)("INPUT OFF", "INVERSE", "RESET", "INTENSIFIED"));
        const onOff = (0, combi_1.alt)("ON", "OFF");
        const intensified = (0, combi_1.seq)("INTENSIFIED", onOff);
        const options = (0, combi_1.per)(index, value, format, page, lineFormat, lineValue, ocp, intensified, expressions_1.Color);
        const ret = (0, combi_1.seq)("MODIFY", (0, combi_1.altPrio)("CURRENT LINE", (0, combi_1.seq)("LINE", expressions_1.Source)), (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ModifyLine = ModifyLine;
//# sourceMappingURL=modify_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_screen.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/modify_screen.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ModifyScreen {
    getMatcher() {
        const ret = (0, combi_1.seq)("MODIFY SCREEN", (0, combi_1.opt)((0, combi_1.seq)("FROM", expressions_1.Source)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ModifyScreen = ModifyScreen;
//# sourceMappingURL=modify_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/module.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/module.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Module = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Module {
    getMatcher() {
        const ret = (0, combi_1.seq)("MODULE", expressions_1.FormName, (0, combi_1.opt)((0, combi_1.alt)("INPUT", "OUTPUT")));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Module = Module;
//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Move = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Move {
    getMatcher() {
        const mov = (0, combi_1.verNot)(version_1.Version.Cloud, "MOVE");
        const move = (0, combi_1.seq)(mov, (0, combi_1.altPrio)((0, combi_1.seq)("EXACT", expressions_1.Source, "TO", expressions_1.Target), (0, combi_1.seq)(expressions_1.Source, (0, combi_1.altPrio)("?TO", "TO"), expressions_1.Target)));
        const calcAssign = (0, combi_1.ver)(version_1.Version.v754, (0, combi_1.alt)((0, combi_1.seq)((0, combi_1.tok)(tokens_1.WPlus), "="), (0, combi_1.seq)((0, combi_1.tok)(tokens_1.WDash), "="), "/=", "*=", "&&="));
        const chained = (0, combi_1.seq)("=", (0, combi_1.star)((0, combi_1.seq)(expressions_1.Target, "=")));
        const equals = (0, combi_1.altPrio)((0, combi_1.altPrio)(chained, "?="), calcAssign);
        // todo, move "?=" to CAST?
        const eq = (0, combi_1.seq)(expressions_1.Target, equals, expressions_1.Source);
        return (0, combi_1.altPrio)(move, eq);
    }
}
exports.Move = Move;
//# sourceMappingURL=move.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move_corresponding.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/move_corresponding.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MoveCorresponding = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class MoveCorresponding {
    getMatcher() {
        const keeping = (0, combi_1.ver)(version_1.Version.v740sp05, "KEEPING TARGET LINES");
        const expanding = (0, combi_1.ver)(version_1.Version.v740sp05, "EXPANDING NESTED TABLES");
        const move = (0, combi_1.seq)("MOVE-CORRESPONDING", (0, combi_1.optPrio)("EXACT"), expressions_1.Source, "TO", 
        // inline defintions not possible in this position,
        expressions_1.SimpleTarget, (0, combi_1.optPrio)(expanding), (0, combi_1.optPrio)(keeping));
        return move;
    }
}
exports.MoveCorresponding = MoveCorresponding;
//# sourceMappingURL=move_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/multiply.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/multiply.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Multiply = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Multiply {
    getMatcher() {
        const ret = (0, combi_1.seq)("MULTIPLY", expressions_1.Target, "BY", expressions_1.Source);
        return ret;
    }
}
exports.Multiply = Multiply;
//# sourceMappingURL=multiply.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_line.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_line.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewLine = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class NewLine {
    getMatcher() {
        const ret = (0, combi_1.seq)("NEW-LINE", (0, combi_1.opt)((0, combi_1.alt)("SCROLLING", "NO-SCROLLING")));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.NewLine = NewLine;
//# sourceMappingURL=new_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_page.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/new_page.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewPage = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class NewPage {
    getMatcher() {
        const line = (0, combi_1.seq)("LINE-SIZE", expressions_1.Source);
        const print = (0, combi_1.seq)("PRINT", (0, combi_1.alt)("OFF", "ON"));
        const parameters = (0, combi_1.seq)("PARAMETERS", expressions_1.Source);
        const destination = (0, combi_1.seq)("DESTINATION", expressions_1.Source);
        const archive = (0, combi_1.seq)("ARCHIVE PARAMETERS", expressions_1.Source);
        const lineCount = (0, combi_1.seq)("LINE-COUNT", expressions_1.Source);
        const coverText = (0, combi_1.seq)("COVER TEXT", expressions_1.Source);
        const coverPage = (0, combi_1.seq)("SAP COVER PAGE", expressions_1.Source);
        const immediately = (0, combi_1.seq)("IMMEDIATELY", expressions_1.Source);
        const keep = (0, combi_1.seq)("KEEP IN SPOOL", expressions_1.Source);
        const layout = (0, combi_1.seq)("LAYOUT", expressions_1.Source);
        const listAuth = (0, combi_1.seq)("LIST AUTHORITY", expressions_1.Source);
        const dataset = (0, combi_1.seq)("LIST DATASET", expressions_1.Source);
        const name = (0, combi_1.seq)("LIST NAME", expressions_1.Source);
        const newList = (0, combi_1.seq)("NEW LIST IDENTIFICATION", expressions_1.Source);
        const ret = (0, combi_1.seq)("NEW-PAGE", (0, combi_1.opt)((0, combi_1.per)(print, (0, combi_1.alt)("NO-TITLE", "WITH-TITLE"), (0, combi_1.alt)("NO-HEADING", "WITH-HEADING"), "NO DIALOG", parameters, listAuth, immediately, dataset, coverPage, newList, keep, name, layout, destination, coverText, archive, "NEW-SECTION", lineCount, line)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.NewPage = NewPage;
//# sourceMappingURL=new_page.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/nodes.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/nodes.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Nodes = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Nodes {
    getMatcher() {
        const ret = (0, combi_1.seq)("NODES", expressions_1.Field);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Nodes = Nodes;
//# sourceMappingURL=nodes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/on_change.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/on_change.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnChange = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class OnChange {
    getMatcher() {
        const or = (0, combi_1.seq)("OR", expressions_1.Target);
        const ret = (0, combi_1.seq)("ON CHANGE OF", expressions_1.Target, (0, combi_1.star)(or));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.OnChange = OnChange;
//# sourceMappingURL=on_change.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_cursor.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_cursor.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenCursor = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class OpenCursor {
    getMatcher() {
        const ret = (0, combi_1.seq)("OPEN CURSOR", (0, combi_1.optPrio)("WITH HOLD"), expressions_1.SQLTarget, "FOR", expressions_1.Select);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.OpenCursor = OpenCursor;
//# sourceMappingURL=open_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_dataset.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/open_dataset.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class OpenDataset {
    getMatcher() {
        const mode = (0, combi_1.seq)("IN", (0, combi_1.opt)("LEGACY"), (0, combi_1.altPrio)("BINARY MODE", "TEXT MODE"));
        const code = (0, combi_1.seq)("CODE PAGE", expressions_1.Source);
        const direction = (0, combi_1.seq)("FOR", (0, combi_1.altPrio)("OUTPUT", "INPUT", "UPDATE", "APPENDING"));
        const encoding = (0, combi_1.seq)("ENCODING", (0, combi_1.altPrio)("DEFAULT", "UTF-8", "NON-UNICODE"));
        const pos = (0, combi_1.seq)("AT POSITION", expressions_1.Source);
        const message = (0, combi_1.seq)("MESSAGE", expressions_1.Target);
        const ignoring = (0, combi_1.str)("IGNORING CONVERSION ERRORS");
        const replacement = (0, combi_1.seq)("REPLACEMENT CHARACTER", expressions_1.Source);
        const bom = (0, combi_1.str)("SKIPPING BYTE-ORDER MARK");
        const wbom = (0, combi_1.str)("WITH BYTE-ORDER MARK");
        const type = (0, combi_1.seq)("TYPE", expressions_1.Source);
        const filter = (0, combi_1.seq)("FILTER", expressions_1.Source);
        const linetype = (0, combi_1.altPrio)("SMART", "NATIVE", "UNIX");
        const feed = (0, combi_1.seq)("WITH", linetype, "LINEFEED");
        const windows = (0, combi_1.str)("WITH WINDOWS LINEFEED");
        const ret = (0, combi_1.seq)("OPEN DATASET", expressions_1.Source, (0, combi_1.per)(direction, type, mode, wbom, replacement, filter, encoding, pos, message, ignoring, bom, code, feed, windows));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.OpenDataset = OpenDataset;
//# sourceMappingURL=open_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/overlay.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/overlay.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Overlay = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Overlay {
    getMatcher() {
        const only = (0, combi_1.seq)("ONLY", expressions_1.Source);
        const ret = (0, combi_1.seq)("OVERLAY", expressions_1.Target, "WITH", expressions_1.Source, (0, combi_1.opt)(only));
        return ret;
    }
}
exports.Overlay = Overlay;
//# sourceMappingURL=overlay.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/pack.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/pack.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pack = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Pack {
    getMatcher() {
        const ret = (0, combi_1.seq)("PACK", expressions_1.Source, "TO", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Pack = Pack;
//# sourceMappingURL=pack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/parameter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/parameter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameter = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Parameter {
    getMatcher() {
        const para = (0, combi_1.altPrio)("PARAMETER", "PARAMETERS");
        const def = (0, combi_1.seq)("DEFAULT", (0, combi_1.altPrio)(expressions_1.Constant, expressions_1.FieldChain));
        const radio = (0, combi_1.seq)("RADIOBUTTON GROUP", expressions_1.RadioGroupName);
        const type = (0, combi_1.seq)((0, combi_1.altPrio)("TYPE", "LIKE"), (0, combi_1.altPrio)(expressions_1.TypeName, expressions_1.Dynamic));
        const memory = (0, combi_1.seq)("MEMORY ID", expressions_1.SimpleSource1);
        const listbox = (0, combi_1.str)("AS LISTBOX");
        const cmd = (0, combi_1.seq)("USER-COMMAND", (0, combi_1.regex)(/^\w+$/));
        const modif = (0, combi_1.seq)("MODIF ID", expressions_1.Modif);
        const visible = (0, combi_1.seq)("VISIBLE LENGTH", expressions_1.Constant);
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Constant);
        const match = (0, combi_1.seq)("MATCHCODE OBJECT", expressions_1.Field);
        const decimals = (0, combi_1.seq)("DECIMALS", expressions_1.Source);
        const perm = (0, combi_1.per)(type, def, "OBLIGATORY", match, cmd, length, decimals, radio, memory, modif, listbox, visible, "VALUE CHECK", "NO-DISPLAY", "AS CHECKBOX", "LOWER CASE");
        const ret = (0, combi_1.seq)(para, expressions_1.FieldSub, (0, combi_1.opt)(expressions_1.FieldLength), (0, combi_1.opt)(perm));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Parameter = Parameter;
//# sourceMappingURL=parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/perform.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/perform.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Perform = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const Expressions = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Perform {
    getMatcher() {
        const level = (0, combi_1.seq)("LEVEL", Expressions.Source);
        const commit = (0, combi_1.alt)((0, combi_1.seq)("ON COMMIT", (0, combi_1.opt)(level)), "ON ROLLBACK");
        const short = (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.seq)(Expressions.FormName, (0, combi_1.tok)(tokens_1.ParenLeft), Expressions.IncludeName, (0, combi_1.tok)(tokens_1.ParenRightW)));
        const program = (0, combi_1.seq)("IN PROGRAM", (0, combi_1.opt)((0, combi_1.alt)(Expressions.Dynamic, Expressions.IncludeName)));
        const found = (0, combi_1.str)("IF FOUND");
        const full = (0, combi_1.seq)((0, combi_1.alt)(Expressions.FormName, Expressions.Dynamic), (0, combi_1.opt)((0, combi_1.verNot)(version_1.Version.Cloud, program)));
        const ret = (0, combi_1.seq)("PERFORM", (0, combi_1.alt)(short, full), (0, combi_1.opt)(found), (0, combi_1.opt)(expressions_1.PerformTables), (0, combi_1.opt)(expressions_1.PerformUsing), (0, combi_1.opt)(expressions_1.PerformChanging), (0, combi_1.opt)(found), (0, combi_1.opt)(commit));
        return ret;
    }
}
exports.Perform = Perform;
//# sourceMappingURL=perform.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/position.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/position.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Position = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Position {
    getMatcher() {
        const ret = (0, combi_1.seq)("POSITION", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Position = Position;
//# sourceMappingURL=position.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/print_control.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/print_control.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrintControl = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class PrintControl {
    getMatcher() {
        const index = (0, combi_1.seq)("INDEX-LINE", expressions_1.Source);
        const func = (0, combi_1.seq)("FUNCTION", expressions_1.Source);
        const ret = (0, combi_1.seq)("PRINT-CONTROL", (0, combi_1.alt)(index, func));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.PrintControl = PrintControl;
//# sourceMappingURL=print_control.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/private.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/private.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Private = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Private {
    getMatcher() {
        return (0, combi_1.str)("PRIVATE SECTION");
    }
}
exports.Private = Private;
//# sourceMappingURL=private.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/program.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/program.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Program = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Program {
    getMatcher() {
        const message = (0, combi_1.seq)("MESSAGE-ID", expressions_1.Source);
        const size = (0, combi_1.seq)("LINE-SIZE", expressions_1.Source);
        const heading = (0, combi_1.str)("NO STANDARD PAGE HEADING");
        const line = (0, combi_1.seq)("LINE-COUNT", expressions_1.Source);
        const options = (0, combi_1.per)(message, size, heading, line);
        const ret = (0, combi_1.seq)("PROGRAM", (0, combi_1.optPrio)(expressions_1.ReportName), (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Program = Program;
//# sourceMappingURL=program.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/protected.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/protected.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Protected = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Protected {
    getMatcher() {
        return (0, combi_1.str)("PROTECTED SECTION");
    }
}
exports.Protected = Protected;
//# sourceMappingURL=protected.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/provide.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/provide.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Provide = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Provide {
    getMatcher() {
        const list = (0, combi_1.plus)((0, combi_1.altPrio)("*", expressions_1.Field));
        const fields = (0, combi_1.seq)("FIELDS", list, "FROM", expressions_1.Source, "INTO", expressions_1.Target, "VALID", expressions_1.Field, "BOUNDS", expressions_1.Field, "AND", expressions_1.Field);
        const fieldList = (0, combi_1.altPrio)((0, combi_1.seq)(list, "FROM", expressions_1.Source), list);
        const ret = (0, combi_1.seq)("PROVIDE", (0, combi_1.altPrio)((0, combi_1.plus)(fields), (0, combi_1.plus)(fieldList)), "BETWEEN", expressions_1.SimpleSource3, "AND", expressions_1.SimpleSource3);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Provide = Provide;
//# sourceMappingURL=provide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/public.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/public.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Public = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Public {
    getMatcher() {
        return (0, combi_1.str)("PUBLIC SECTION");
    }
}
exports.Public = Public;
//# sourceMappingURL=public.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/put.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/put.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Put = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Put {
    getMatcher() {
        const ret = (0, combi_1.seq)("PUT", expressions_1.Field);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Put = Put;
//# sourceMappingURL=put.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Raise = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Raise {
    getMatcher() {
        const mess = (0, combi_1.seq)("MESSAGE", expressions_1.MessageSource, (0, combi_1.opt)(expressions_1.RaiseWith));
        const messid = (0, combi_1.seq)("MESSAGE ID", expressions_1.Source, "NUMBER", (0, combi_1.altPrio)(expressions_1.MessageNumber, expressions_1.Source), (0, combi_1.optPrio)(expressions_1.RaiseWith));
        const exporting = (0, combi_1.seq)("EXPORTING", expressions_1.ParameterListS);
        const from = (0, combi_1.seq)("TYPE", expressions_1.ClassName, (0, combi_1.opt)((0, combi_1.alt)((0, combi_1.ver)(version_1.Version.v750, (0, combi_1.alt)(mess, messid)), (0, combi_1.ver)(version_1.Version.v752, "USING MESSAGE"))), (0, combi_1.optPrio)(exporting));
        const pre = (0, combi_1.altPrio)((0, combi_1.seq)((0, combi_1.optPrio)("RESUMABLE"), "EXCEPTION"), "SHORTDUMP");
        const clas = (0, combi_1.seq)(pre, (0, combi_1.altPrio)(from, (0, combi_1.ver)(version_1.Version.v752, expressions_1.Source), expressions_1.SimpleSource2));
        const ret = (0, combi_1.seq)("RAISE", (0, combi_1.altPrio)(clas, expressions_1.ExceptionName));
        return ret;
    }
}
exports.Raise = Raise;
//# sourceMappingURL=raise.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_entity_event.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_entity_event.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaiseEntityEvent = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class RaiseEntityEvent {
    getMatcher() {
        return (0, combi_1.seq)("RAISE ENTITY EVENT", expressions_1.EventName, "FROM", expressions_1.Source);
    }
}
exports.RaiseEntityEvent = RaiseEntityEvent;
//# sourceMappingURL=raise_entity_event.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_event.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/raise_event.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaiseEvent = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class RaiseEvent {
    getMatcher() {
        const exporting = (0, combi_1.seq)("EXPORTING", expressions_1.ParameterListS);
        return (0, combi_1.seq)("RAISE EVENT", expressions_1.EventName, (0, combi_1.opt)(exporting));
    }
}
exports.RaiseEvent = RaiseEvent;
//# sourceMappingURL=raise_event.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/ranges.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/ranges.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ranges = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Ranges {
    getMatcher() {
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Source);
        const ret = (0, combi_1.seq)("RANGES", expressions_1.SimpleName, "FOR", expressions_1.SimpleFieldChain2, (0, combi_1.opt)(occurs));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Ranges = Ranges;
//# sourceMappingURL=ranges.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_dataset.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_dataset.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ReadDataset {
    getMatcher() {
        const ret = (0, combi_1.seq)("READ DATASET", expressions_1.Source, "INTO", expressions_1.Target, (0, combi_1.opt)((0, combi_1.seq)("MAXIMUM LENGTH", expressions_1.Source)), (0, combi_1.opt)((0, combi_1.seq)("ACTUAL LENGTH", expressions_1.Target)), (0, combi_1.opt)((0, combi_1.seq)("LENGTH", expressions_1.Target)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ReadDataset = ReadDataset;
//# sourceMappingURL=read_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_entities.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_entities.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadEntities = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class ReadEntities {
    getMatcher() {
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const fields = (0, combi_1.seq)("FIELDS", (0, combi_1.tok)(tokens_1.WParenLeftW), (0, combi_1.plus)(expressions_1.SimpleName), (0, combi_1.tok)(tokens_1.WParenRightW), "WITH", expressions_1.Source);
        const all = (0, combi_1.seq)("ALL FIELDS WITH", expressions_1.Source);
        const s = (0, combi_1.seq)("READ ENTITIES OF", expressions_1.NamespaceSimpleName, (0, combi_1.opt)("IN LOCAL MODE"), "ENTITY", expressions_1.SimpleName, (0, combi_1.opt)((0, combi_1.seq)("BY", expressions_1.AssociationName)), (0, combi_1.alt)(fields, from, all), "RESULT", expressions_1.Target, (0, combi_1.optPrio)((0, combi_1.seq)("LINK", expressions_1.Target)), (0, combi_1.optPrio)((0, combi_1.seq)("FAILED", expressions_1.Target)), (0, combi_1.optPrio)((0, combi_1.seq)("REPORTED", expressions_1.Target)));
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.ReadEntities = ReadEntities;
//# sourceMappingURL=read_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_line.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_line.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadLine = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ReadLine {
    getMatcher() {
        const val = (0, combi_1.seq)("LINE VALUE INTO", expressions_1.Target);
        const fields = (0, combi_1.seq)(expressions_1.Target, (0, combi_1.opt)((0, combi_1.seq)("INTO", expressions_1.Target)));
        const field = (0, combi_1.seq)("FIELD VALUE", (0, combi_1.plus)(fields));
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const page = (0, combi_1.seq)("OF PAGE", expressions_1.Source);
        const current = (0, combi_1.str)("OF CURRENT PAGE");
        const ret = (0, combi_1.seq)("READ", (0, combi_1.alt)("CURRENT LINE", (0, combi_1.seq)("LINE", expressions_1.Source)), (0, combi_1.opt)((0, combi_1.per)(val, index, field, page, current)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ReadLine = ReadLine;
//# sourceMappingURL=read_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_report.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_report.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadReport = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ReadReport {
    getMatcher() {
        const state = (0, combi_1.seq)("STATE", expressions_1.Source);
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const maximum = (0, combi_1.seq)("MAXIMUM WIDTH INTO", expressions_1.Target);
        const ret = (0, combi_1.seq)("READ REPORT", expressions_1.Source, (0, combi_1.per)(state, into, maximum));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ReadReport = ReadReport;
//# sourceMappingURL=read_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_table.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_table.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadTable = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const transporting_fields_1 = __webpack_require__(/*! ../expressions/transporting_fields */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/transporting_fields.js");
class ReadTable {
    getMatcher() {
        const comparing = (0, combi_1.seq)("COMPARING", (0, combi_1.alt)((0, combi_1.plus)(expressions_1.FieldSub), expressions_1.Dynamic));
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const components = (0, combi_1.seq)((0, combi_1.alt)(expressions_1.Field, expressions_1.Dynamic), "COMPONENTS", expressions_1.ComponentCompareSimple);
        const key = (0, combi_1.seq)((0, combi_1.altPrio)("WITH KEY", "WITH TABLE KEY"), (0, combi_1.alt)(expressions_1.ComponentCompareSimple, components, (0, combi_1.seq)((0, combi_1.optPrio)("="), expressions_1.Source)));
        const using = (0, combi_1.seq)("USING KEY", (0, combi_1.alt)(expressions_1.Field, expressions_1.Dynamic));
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const perm = (0, combi_1.per)((0, combi_1.alt)(index, key, from), expressions_1.ReadTableTarget, using, comparing, "CASTING", "TRANSPORTING ALL FIELDS", (0, combi_1.seq)("TRANSPORTING", transporting_fields_1.TransportingFields), "BINARY SEARCH");
        return (0, combi_1.seq)("READ TABLE", (0, combi_1.alt)(expressions_1.SimpleSource2, (0, combi_1.ver)(version_1.Version.v740sp02, expressions_1.Source)), (0, combi_1.opt)(perm));
    }
}
exports.ReadTable = ReadTable;
//# sourceMappingURL=read_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_textpool.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/read_textpool.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadTextpool = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ReadTextpool {
    getMatcher() {
        const language = (0, combi_1.seq)("LANGUAGE", expressions_1.Source);
        const into = (0, combi_1.seq)("INTO", expressions_1.SimpleTarget);
        const state = (0, combi_1.seq)("STATE", expressions_1.Source);
        const ret = (0, combi_1.seq)("READ TEXTPOOL", expressions_1.Source, (0, combi_1.per)(into, language, state));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ReadTextpool = ReadTextpool;
//# sourceMappingURL=read_textpool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/receive.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/receive.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Receive = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Receive {
    getMatcher() {
        const ret = (0, combi_1.seq)("RECEIVE RESULTS FROM FUNCTION", expressions_1.FunctionName, (0, combi_1.opt)("KEEPING TASK"), expressions_1.ReceiveParameters);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Receive = Receive;
//# sourceMappingURL=receive.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Refresh = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Refresh {
    getMatcher() {
        const from = (0, combi_1.seq)("FROM TABLE", expressions_1.DatabaseTable);
        const ret = (0, combi_1.seq)("REFRESH", expressions_1.Target, (0, combi_1.optPrio)(from));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Refresh = Refresh;
//# sourceMappingURL=refresh.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh_control.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/refresh_control.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RefreshControl = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class RefreshControl {
    getMatcher() {
        const ret = (0, combi_1.seq)("REFRESH CONTROL", expressions_1.Source, "FROM SCREEN", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.RefreshControl = RefreshControl;
//# sourceMappingURL=refresh_control.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reject.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reject.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reject = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Reject {
    getMatcher() {
        const ret = (0, combi_1.seq)("REJECT", (0, combi_1.opt)(expressions_1.Source));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Reject = Reject;
//# sourceMappingURL=reject.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/replace.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/replace.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Replace = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Replace {
    getMatcher() {
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Source);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Source);
        const section = (0, combi_1.seq)((0, combi_1.opt)("IN"), "SECTION", (0, combi_1.per)(offset, length), "OF", expressions_1.Target);
        const source = (0, combi_1.seq)((0, combi_1.opt)("OF"), expressions_1.FindType, expressions_1.Source);
        const cas = (0, combi_1.altPrio)("IGNORING CASE", "RESPECTING CASE");
        const repl = (0, combi_1.seq)("REPLACEMENT COUNT", expressions_1.Target);
        const replo = (0, combi_1.seq)("REPLACEMENT OFFSET", expressions_1.Target);
        const repll = (0, combi_1.seq)("REPLACEMENT LENGTH", expressions_1.Target);
        const repli = (0, combi_1.seq)("REPLACEMENT LINE", expressions_1.Target);
        const occ = (0, combi_1.altPrio)("ALL OCCURRENCES", "ALL OCCURENCES", "FIRST OCCURENCE", "FIRST OCCURRENCE");
        const mode = (0, combi_1.alt)("IN CHARACTER MODE", "IN BYTE MODE");
        const wit = (0, combi_1.seq)("WITH", expressions_1.Source);
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        return (0, combi_1.seq)("REPLACE", (0, combi_1.per)(section, (0, combi_1.seq)((0, combi_1.opt)(occ), source)), (0, combi_1.opt)((0, combi_1.seq)("IN", (0, combi_1.opt)("TABLE"), expressions_1.Target)), (0, combi_1.opt)((0, combi_1.per)(wit, into, cas, mode, repl, replo, repll, repli, length)));
    }
}
exports.Replace = Replace;
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/report.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/report.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Report = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Report {
    getMatcher() {
        const more = (0, combi_1.seq)((0, combi_1.tok)(tokens_1.ParenLeft), expressions_1.Integer, (0, combi_1.tok)(tokens_1.ParenRightW));
        const heading = (0, combi_1.str)("NO STANDARD PAGE HEADING");
        const size = (0, combi_1.seq)("LINE-SIZE", expressions_1.Integer);
        const count = (0, combi_1.seq)("LINE-COUNT", expressions_1.Integer, (0, combi_1.opt)(more));
        const message = (0, combi_1.seq)("MESSAGE-ID", expressions_1.MessageClass);
        const database = (0, combi_1.seq)("USING DATABASE", expressions_1.Field);
        const ret = (0, combi_1.seq)("REPORT", (0, combi_1.opt)(expressions_1.ReportName), (0, combi_1.opt)((0, combi_1.per)(heading, size, count, database, message)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Report = Report;
//# sourceMappingURL=report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reserve.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/reserve.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Reserve = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Reserve {
    getMatcher() {
        const ret = (0, combi_1.seq)("RESERVE", expressions_1.Source, "LINES");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Reserve = Reserve;
//# sourceMappingURL=reserve.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/resume.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/resume.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Resume = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Resume {
    getMatcher() {
        return (0, combi_1.str)("RESUME");
    }
}
exports.Resume = Resume;
//# sourceMappingURL=resume.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/retry.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/retry.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Retry = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Retry {
    getMatcher() {
        return (0, combi_1.ver)(version_1.Version.v702, "RETRY");
    }
}
exports.Retry = Retry;
//# sourceMappingURL=retry.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/return.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/return.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Return = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Return {
    getMatcher() {
        return (0, combi_1.seq)((0, combi_1.str)("RETURN"), (0, combi_1.optPrio)((0, combi_1.ver)(version_1.Version.v758, expressions_1.Source)));
    }
}
exports.Return = Return;
//# sourceMappingURL=return.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rollback = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Rollback {
    getMatcher() {
        return (0, combi_1.seq)("ROLLBACK", (0, combi_1.altPrio)("WORK", expressions_1.DatabaseConnection));
    }
}
exports.Rollback = Rollback;
//# sourceMappingURL=rollback.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback_entities.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/rollback_entities.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RollbackEntities = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class RollbackEntities {
    getMatcher() {
        const s = "ROLLBACK ENTITIES";
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.RollbackEntities = RollbackEntities;
//# sourceMappingURL=rollback_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scan.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scan.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scan = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Scan {
    getMatcher() {
        const tokens = (0, combi_1.seq)("TOKENS INTO", expressions_1.Target);
        const word = (0, combi_1.seq)("WORD INTO", expressions_1.Target);
        const line = (0, combi_1.seq)("LINE INTO", expressions_1.Target);
        const statements = (0, combi_1.seq)("STATEMENTS INTO", expressions_1.Target);
        const levels = (0, combi_1.seq)("LEVELS INTO", expressions_1.Target);
        const structures = (0, combi_1.seq)("STRUCTURES INTO", expressions_1.Target);
        const include = (0, combi_1.seq)("INCLUDE INTO", expressions_1.Target);
        const offset = (0, combi_1.seq)("OFFSET INTO", expressions_1.Target);
        const enh = (0, combi_1.seq)("ENHANCEMENTS INTO", expressions_1.Target);
        const enhO = (0, combi_1.seq)("ENHANCEMENT OPTIONS INTO", expressions_1.Target);
        const keywords = (0, combi_1.seq)("KEYWORDS FROM", expressions_1.Source);
        const pragmas = (0, combi_1.seq)("WITH PRAGMAS", expressions_1.Source);
        const overflow = (0, combi_1.seq)("OVERFLOW INTO", expressions_1.Target);
        const message = (0, combi_1.seq)("MESSAGE INTO", expressions_1.Target);
        const includeProgram = (0, combi_1.seq)("INCLUDE PROGRAM FROM", expressions_1.Source);
        const frame = (0, combi_1.seq)("FRAME PROGRAM FROM", expressions_1.Source);
        const program = (0, combi_1.seq)("PROGRAM FROM", expressions_1.Source);
        const from = (0, combi_1.seq)("FROM", expressions_1.Source);
        const to = (0, combi_1.seq)("TO", expressions_1.Source);
        const replacing = (0, combi_1.seq)("REPLACING", expressions_1.Source);
        const id = (0, combi_1.seq)("ID", expressions_1.Source, "TABLE", expressions_1.Source);
        const ret = (0, combi_1.seq)("SCAN ABAP-SOURCE", expressions_1.Source, (0, combi_1.per)(tokens, levels, from, to, statements, structures, keywords, word, line, offset, overflow, message, includeProgram, include, frame, enhO, enh, program, replacing, "WITH ANALYSIS", "WITH COMMENTS", "WITH TYPE-POOLS", "WITH INCLUDES", "WITHOUT TRMAC", "WITH DECLARATIONS", "WITH BLOCKS", "PRESERVING IDENTIFIER ESCAPING", "WITH LIST TOKENIZATION", "WITH EXPLICIT ENHANCEMENTS", "WITH IMPLICIT ENHANCEMENTS", "WITH INACTIVE ENHANCEMENTS", pragmas, id));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Scan = Scan;
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scroll_list.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/scroll_list.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScrollList = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class ScrollList {
    getMatcher() {
        const index = (0, combi_1.seq)("INDEX", expressions_1.Source);
        const line = (0, combi_1.seq)("LINE", expressions_1.Source);
        const column = (0, combi_1.seq)("TO COLUMN", expressions_1.Source);
        const to = (0, combi_1.seq)("TO", (0, combi_1.alt)("FIRST PAGE", "LAST PAGE", (0, combi_1.seq)("PAGE", expressions_1.Source)));
        const ret = (0, combi_1.seq)("SCROLL LIST", (0, combi_1.per)(index, (0, combi_1.alt)(to, "BACKWARD", "FORWARD"), column, line));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.ScrollList = ScrollList;
//# sourceMappingURL=scroll_list.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/search.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/search.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Search = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Search {
    getMatcher() {
        const starting = (0, combi_1.seq)("STARTING AT", expressions_1.Source);
        const ending = (0, combi_1.seq)("ENDING AT", expressions_1.Source);
        const mark = (0, combi_1.str)("AND MARK");
        const mode = (0, combi_1.altPrio)("IN BYTE MODE", "IN CHARACTER MODE");
        const ret = (0, combi_1.seq)("SEARCH", expressions_1.Source, "FOR", expressions_1.Source, (0, combi_1.opt)((0, combi_1.per)(mode, starting, ending, mark)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Search = Search;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Select = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Select {
    getMatcher() {
        const union = (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("UNION", (0, combi_1.optPrio)((0, combi_1.altPrio)("DISTINCT", "ALL")), expressions_1.Select));
        return (0, combi_1.seq)(expressions_1.Select, (0, combi_1.starPrio)(union));
    }
}
exports.Select = Select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select_loop.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/select_loop.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectLoop = void 0;
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SelectLoop {
    getMatcher() {
        return new expressions_1.SelectLoop();
    }
}
exports.SelectLoop = SelectLoop;
//# sourceMappingURL=select_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectionscreen.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectionscreen.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SelectionScreen {
    getMatcher() {
        const beginBlock = (0, combi_1.seq)("BEGIN OF BLOCK", expressions_1.BlockName, (0, combi_1.optPrio)("WITH FRAME"), (0, combi_1.optPrio)((0, combi_1.seq)("TITLE", (0, combi_1.alt)(expressions_1.InlineField, expressions_1.TextElement))), (0, combi_1.optPrio)("NO INTERVALS"));
        const endBlock = (0, combi_1.seq)("END OF BLOCK", expressions_1.BlockName);
        const nesting = (0, combi_1.seq)("NESTING LEVEL", expressions_1.Source);
        const scrOptions = (0, combi_1.per)((0, combi_1.seq)("AS", (0, combi_1.alt)("WINDOW", "SUBSCREEN")), (0, combi_1.seq)("TITLE", (0, combi_1.alt)(expressions_1.InlineField, expressions_1.TextElement)), "NO INTERVALS", nesting);
        const beginScreen = (0, combi_1.seq)("BEGIN OF SCREEN", expressions_1.Integer, (0, combi_1.opt)(scrOptions));
        const endScreen = (0, combi_1.seq)("END OF SCREEN", expressions_1.Integer);
        const beginLine = (0, combi_1.str)("BEGIN OF LINE");
        const endLine = (0, combi_1.str)("END OF LINE");
        const modif = (0, combi_1.seq)("MODIF ID", expressions_1.Modif);
        const visible = (0, combi_1.seq)("VISIBLE LENGTH", (0, combi_1.regex)(/^\d+$/));
        const commentOpt = (0, combi_1.per)((0, combi_1.seq)("FOR FIELD", expressions_1.Field), modif, visible);
        const position = (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.regex)(/^\/?[\d\w]+$/)), (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenLeft), (0, combi_1.tok)(tokens_1.WParenLeft)), expressions_1.Integer, (0, combi_1.altPrio)((0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.tok)(tokens_1.ParenRight)));
        const comment = (0, combi_1.seq)("COMMENT", position, (0, combi_1.opt)((0, combi_1.alt)(expressions_1.InlineField, expressions_1.TextElement)), (0, combi_1.opt)(commentOpt));
        const command = (0, combi_1.seq)("USER-COMMAND", (0, combi_1.alt)(expressions_1.Field, expressions_1.Constant));
        const push = (0, combi_1.seq)("PUSHBUTTON", position, (0, combi_1.alt)(expressions_1.InlineField, expressions_1.TextElement), command, (0, combi_1.opt)(modif), (0, combi_1.opt)(visible));
        const prog = (0, combi_1.seq)("PROGRAM", expressions_1.Field);
        const def = (0, combi_1.seq)("DEFAULT", (0, combi_1.opt)(prog), "SCREEN", expressions_1.Integer);
        const tab = (0, combi_1.seq)("TAB", (0, combi_1.tok)(tokens_1.WParenLeft), expressions_1.Integer, (0, combi_1.tok)(tokens_1.ParenRightW), (0, combi_1.alt)(expressions_1.InlineField, expressions_1.TextElement), command, (0, combi_1.opt)(def), (0, combi_1.opt)(modif));
        const func = (0, combi_1.seq)("FUNCTION KEY", expressions_1.Integer);
        const skip = (0, combi_1.seq)("SKIP", (0, combi_1.opt)(expressions_1.Integer));
        const posSymbols = (0, combi_1.altPrio)("POS_LOW", "POS_HIGH");
        // number between 1 and 83
        const posIntegers = (0, combi_1.regex)(/^(0?[1-9]|[1234567][0-9]|8[0-3])$/);
        const pos = (0, combi_1.seq)("POSITION", (0, combi_1.altPrio)(posIntegers, posSymbols));
        const incl = (0, combi_1.seq)("INCLUDE BLOCKS", expressions_1.BlockName);
        const tabbed = (0, combi_1.seq)("BEGIN OF TABBED BLOCK", expressions_1.InlineField, "FOR", expressions_1.Integer, "LINES", (0, combi_1.optPrio)("NO INTERVALS"));
        const uline = (0, combi_1.seq)("ULINE", (0, combi_1.opt)(position));
        const param = (0, combi_1.seq)("INCLUDE PARAMETERS", expressions_1.Field);
        const iso = (0, combi_1.seq)("INCLUDE SELECT-OPTIONS", expressions_1.Field);
        const ret = (0, combi_1.seq)("SELECTION-SCREEN", (0, combi_1.altPrio)(comment, func, skip, pos, incl, iso, push, tab, uline, beginBlock, tabbed, endBlock, beginLine, endLine, param, beginScreen, endScreen));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SelectionScreen = SelectionScreen;
//# sourceMappingURL=selectionscreen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectoption.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/selectoption.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectOption = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SelectOption {
    getMatcher() {
        const sourc = (0, combi_1.alt)(expressions_1.Constant, expressions_1.FieldChain);
        const to = (0, combi_1.seq)("TO", sourc);
        const def = (0, combi_1.seq)("DEFAULT", sourc, (0, combi_1.opt)(to));
        const option = (0, combi_1.seq)("OPTION", (0, combi_1.alt)("CP", expressions_1.Field));
        const sign = (0, combi_1.seq)("SIGN", expressions_1.Field);
        const memory = (0, combi_1.seq)("MEMORY ID", expressions_1.SimpleSource1);
        const match = (0, combi_1.seq)("MATCHCODE OBJECT", expressions_1.Field);
        const modif = (0, combi_1.seq)("MODIF ID", expressions_1.Modif);
        const visible = (0, combi_1.seq)("VISIBLE LENGTH", expressions_1.Source);
        const options = (0, combi_1.per)(def, option, sign, memory, match, visible, modif, "NO DATABASE SELECTION", "LOWER CASE", "NO-EXTENSION", "NO INTERVALS", "NO-DISPLAY", "OBLIGATORY");
        const ret = (0, combi_1.seq)("SELECT-OPTIONS", expressions_1.FieldSub, "FOR", (0, combi_1.alt)(expressions_1.FieldChain, expressions_1.Dynamic), (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SelectOption = SelectOption;
//# sourceMappingURL=selectoption.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_bit.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_bit.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetBit = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SetBit {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET BIT", expressions_1.Source, "OF", expressions_1.Target, (0, combi_1.opt)((0, combi_1.seq)("TO", expressions_1.Source)));
        return ret;
    }
}
exports.SetBit = SetBit;
//# sourceMappingURL=set_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_blank.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_blank.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetBlank = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetBlank {
    getMatcher() {
        const onOff = (0, combi_1.alt)("ON", "OFF");
        const ret = (0, combi_1.seq)("SET BLANK LINES", onOff);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetBlank = SetBlank;
//# sourceMappingURL=set_blank.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_country.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_country.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetCountry = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetCountry {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET COUNTRY", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetCountry = SetCountry;
//# sourceMappingURL=set_country.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_cursor.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_cursor.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetCursor = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetCursor {
    getMatcher() {
        const line = (0, combi_1.seq)("LINE", expressions_1.Source);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Source);
        const field = (0, combi_1.seq)("FIELD", expressions_1.Source);
        const pos = (0, combi_1.seq)(expressions_1.Source, expressions_1.Source);
        const ret = (0, combi_1.seq)("SET CURSOR", (0, combi_1.altPrio)((0, combi_1.per)(field, offset, line), pos));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetCursor = SetCursor;
//# sourceMappingURL=set_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_dataset.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_dataset.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetDataset {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET DATASET", expressions_1.Source, "POSITION", (0, combi_1.alt)(expressions_1.Source, "END OF FILE"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetDataset = SetDataset;
//# sourceMappingURL=set_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_extended_check.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_extended_check.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetExtendedCheck = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetExtendedCheck {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET EXTENDED CHECK", (0, combi_1.alt)("OFF", "ON"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetExtendedCheck = SetExtendedCheck;
//# sourceMappingURL=set_extended_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_handler.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_handler.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetHandler = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SetHandler {
    getMatcher() {
        const activation = (0, combi_1.seq)("ACTIVATION", expressions_1.Source);
        const fo = (0, combi_1.seq)("FOR", (0, combi_1.altPrio)("ALL INSTANCES", expressions_1.Source));
        const ret = (0, combi_1.seq)("SET HANDLER", (0, combi_1.plus)(expressions_1.MethodSource), (0, combi_1.optPrio)(fo), (0, combi_1.optPrio)(activation));
        return ret;
    }
}
exports.SetHandler = SetHandler;
//# sourceMappingURL=set_handler.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_language.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_language.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLanguage = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetLanguage {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET LANGUAGE", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetLanguage = SetLanguage;
//# sourceMappingURL=set_language.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_left.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_left.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLeft = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class SetLeft {
    getMatcher() {
        const column = (0, combi_1.seq)("COLUMN", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.seq)("SET LEFT SCROLL-BOUNDARY", (0, combi_1.opt)(column)));
    }
}
exports.SetLeft = SetLeft;
//# sourceMappingURL=set_left.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locale.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locale.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLocale = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetLocale {
    getMatcher() {
        const country = (0, combi_1.seq)("COUNTRY", expressions_1.Source);
        const modifier = (0, combi_1.seq)("MODIFIER", expressions_1.Source);
        const ret = (0, combi_1.seq)("SET LOCALE LANGUAGE", expressions_1.Source, (0, combi_1.opt)(country), (0, combi_1.opt)(modifier));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetLocale = SetLocale;
//# sourceMappingURL=set_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locks.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_locks.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLocks = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetLocks {
    getMatcher() {
        const s = (0, combi_1.seq)("SET LOCKS OF", expressions_1.SimpleName, "ENTITY", expressions_1.SimpleName, "FROM", expressions_1.Source, "FAILED", expressions_1.Target, "REPORTED", expressions_1.Target);
        return (0, combi_1.ver)(version_1.Version.v754, s);
    }
}
exports.SetLocks = SetLocks;
//# sourceMappingURL=set_locks.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_margin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_margin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetMargin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetMargin {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET MARGIN", expressions_1.Source, (0, combi_1.opt)(expressions_1.Source));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetMargin = SetMargin;
//# sourceMappingURL=set_margin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_parameter.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_parameter.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetParameter = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetParameter {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET PARAMETER ID", expressions_1.Source, "FIELD", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetParameter = SetParameter;
//# sourceMappingURL=set_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_pf_status.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_pf_status.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPFStatus = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetPFStatus {
    getMatcher() {
        const program = (0, combi_1.seq)("OF PROGRAM", expressions_1.Source);
        const options = (0, combi_1.per)(program, "IMMEDIATELY", (0, combi_1.seq)("EXCLUDING", expressions_1.Source));
        const ret = (0, combi_1.seq)("SET PF-STATUS", expressions_1.Source, (0, combi_1.opt)(options));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetPFStatus = SetPFStatus;
//# sourceMappingURL=set_pf_status.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_property.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_property.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetProperty = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetProperty {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET PROPERTY OF", expressions_1.Source, (0, combi_1.alt)(expressions_1.Constant, expressions_1.Field), "=", expressions_1.Source, (0, combi_1.optPrio)("NO FLUSH"), (0, combi_1.opt)(expressions_1.OLEExporting));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetProperty = SetProperty;
//# sourceMappingURL=set_property.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_run_time.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_run_time.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetRunTime = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetRunTime {
    getMatcher() {
        const clock = (0, combi_1.seq)("CLOCK RESOLUTION", (0, combi_1.alt)("LOW", "HIGH"));
        const analyzer = (0, combi_1.seq)("ANALYZER", (0, combi_1.alt)("ON", "OFF"));
        const ret = (0, combi_1.seq)("SET RUN TIME", (0, combi_1.alt)(clock, analyzer));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetRunTime = SetRunTime;
//# sourceMappingURL=set_run_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_screen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_screen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetScreen = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetScreen {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET SCREEN", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetScreen = SetScreen;
//# sourceMappingURL=set_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_titlebar.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_titlebar.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetTitlebar = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetTitlebar {
    getMatcher() {
        const wit = (0, combi_1.seq)("WITH", (0, combi_1.plus)(expressions_1.Source));
        const program = (0, combi_1.seq)("OF PROGRAM", expressions_1.Source);
        const ret = (0, combi_1.seq)("SET TITLEBAR", expressions_1.Source, (0, combi_1.opt)(program), (0, combi_1.opt)(wit));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetTitlebar = SetTitlebar;
//# sourceMappingURL=set_titlebar.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_update_task.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_update_task.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetUpdateTask = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetUpdateTask {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "SET UPDATE TASK LOCAL");
    }
}
exports.SetUpdateTask = SetUpdateTask;
//# sourceMappingURL=set_update_task.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_user_command.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/set_user_command.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetUserCommand = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SetUserCommand {
    getMatcher() {
        const ret = (0, combi_1.seq)("SET USER-COMMAND", expressions_1.Source);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SetUserCommand = SetUserCommand;
//# sourceMappingURL=set_user_command.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/shift.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/shift.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shift = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Shift {
    getMatcher() {
        const deleting = (0, combi_1.seq)("DELETING", (0, combi_1.altPrio)("LEADING", "TRAILING"), expressions_1.Source);
        const up = (0, combi_1.seq)("UP TO", expressions_1.Source);
        const mode = (0, combi_1.seq)("IN", (0, combi_1.altPrio)("CHARACTER", "BYTE"), "MODE");
        const dir = (0, combi_1.altPrio)("LEFT", "RIGHT");
        const by = (0, combi_1.seq)("BY", expressions_1.Source, (0, combi_1.optPrio)("PLACES"));
        const options = (0, combi_1.per)(deleting, up, mode, dir, by, "CIRCULAR");
        return (0, combi_1.seq)("SHIFT", expressions_1.Target, (0, combi_1.opt)(options));
    }
}
exports.Shift = Shift;
//# sourceMappingURL=shift.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/skip.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/skip.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Skip = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Skip {
    getMatcher() {
        const ret = (0, combi_1.seq)("SKIP", (0, combi_1.opt)("TO LINE"), (0, combi_1.opt)(expressions_1.Source));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Skip = Skip;
//# sourceMappingURL=skip.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Sort {
    getMatcher() {
        const order = (0, combi_1.altPrio)("ASCENDING", "DESCENDING");
        const sel = (0, combi_1.alt)(expressions_1.ComponentChain, expressions_1.Dynamic, expressions_1.SourceFieldSymbol);
        const text = "AS TEXT";
        const fields = (0, combi_1.plus)((0, combi_1.seq)(sel, (0, combi_1.optPrio)(text), (0, combi_1.optPrio)(order), (0, combi_1.optPrio)(text)));
        const by = (0, combi_1.seq)("BY", fields);
        const normal = (0, combi_1.seq)(expressions_1.Target, (0, combi_1.opt)((0, combi_1.per)(order, by, "STABLE", text)));
        const target = (0, combi_1.altPrio)(text, normal);
        return (0, combi_1.seq)("SORT", target);
    }
}
exports.Sort = Sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort_dataset.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sort_dataset.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SortDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SortDataset {
    getMatcher() {
        const order = (0, combi_1.alt)("ASCENDING", "DESCENDING");
        const sel = (0, combi_1.alt)(expressions_1.FieldSub, expressions_1.SourceFieldSymbol, expressions_1.Dynamic);
        const fields = (0, combi_1.plus)((0, combi_1.seq)(sel, (0, combi_1.optPrio)(order)));
        const by = (0, combi_1.seq)("BY", fields);
        const ret = (0, combi_1.seq)("SORT", (0, combi_1.opt)(by));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SortDataset = SortDataset;
//# sourceMappingURL=sort_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/split.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/split.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Split = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Split {
    getMatcher() {
        const mode = (0, combi_1.seq)("IN", (0, combi_1.alt)("CHARACTER", "BYTE"), "MODE");
        const into = (0, combi_1.altPrio)((0, combi_1.seq)("TABLE", expressions_1.Target, (0, combi_1.opt)(mode)), (0, combi_1.seq)((0, combi_1.plus)(expressions_1.Target), (0, combi_1.opt)(mode)));
        const ret = (0, combi_1.seq)("SPLIT", expressions_1.Source, "AT", expressions_1.Source, "INTO", into);
        return ret;
    }
}
exports.Split = Split;
//# sourceMappingURL=split.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/start_of_selection.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/start_of_selection.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartOfSelection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class StartOfSelection {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "START-OF-SELECTION");
    }
}
exports.StartOfSelection = StartOfSelection;
//# sourceMappingURL=start_of_selection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Static = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Static {
    getMatcher() {
        const p = (0, combi_1.opt)((0, combi_1.per)(Expressions.Type, Expressions.Value, Expressions.Length, Expressions.Decimals));
        const type = (0, combi_1.seq)((0, combi_1.opt)(Expressions.ConstantFieldLength), p);
        const ret = (0, combi_1.seq)((0, combi_1.alt)("STATIC", "STATICS"), Expressions.DefinitionName, (0, combi_1.alt)(type, Expressions.TypeTable));
        return ret;
    }
}
exports.Static = Static;
//# sourceMappingURL=static.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_begin.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_begin.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class StaticBegin {
    getMatcher() {
        const occurs = (0, combi_1.seq)("OCCURS", expressions_1.Integer);
        const ret = (0, combi_1.seq)((0, combi_1.alt)("STATIC", "STATICS"), "BEGIN OF", expressions_1.DefinitionName, (0, combi_1.opt)(occurs));
        return ret;
    }
}
exports.StaticBegin = StaticBegin;
//# sourceMappingURL=static_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_end.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/static_end.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class StaticEnd {
    getMatcher() {
        const ret = (0, combi_1.seq)((0, combi_1.alt)("STATIC", "STATICS"), "END OF", expressions_1.DefinitionName);
        return ret;
    }
}
exports.StaticEnd = StaticEnd;
//# sourceMappingURL=static_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/stop.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/stop.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Stop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Stop {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "STOP");
    }
}
exports.Stop = Stop;
//# sourceMappingURL=stop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/submit.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/submit.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Submit = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Submit {
    getMatcher() {
        const sign = (0, combi_1.seq)("SIGN", expressions_1.Source);
        const eq = (0, combi_1.alt)("=", "EQ", "IN", "NE", "CP", "GE", "LE", "INCL");
        const compare = (0, combi_1.seq)(eq, expressions_1.Source);
        const between = (0, combi_1.seq)("BETWEEN", expressions_1.Source, "AND", expressions_1.Source);
        const selectionTable = (0, combi_1.seq)("WITH SELECTION-TABLE", expressions_1.Source);
        const awith = (0, combi_1.seq)("WITH", expressions_1.FieldSub, (0, combi_1.alt)(compare, between), (0, combi_1.optPrio)(sign));
        const prog = (0, combi_1.alt)(expressions_1.NamespaceSimpleName, expressions_1.Dynamic);
        const job = (0, combi_1.seq)("VIA JOB", expressions_1.Source, "NUMBER", expressions_1.Source);
        const exporting = (0, combi_1.str)("EXPORTING LIST TO MEMORY");
        const spool = (0, combi_1.seq)("SPOOL PARAMETERS", expressions_1.Source);
        const archive = (0, combi_1.seq)("ARCHIVE PARAMETERS", expressions_1.Source);
        const lineSize = (0, combi_1.seq)("LINE-SIZE", expressions_1.Source);
        const lineCount = (0, combi_1.seq)("LINE-COUNT", expressions_1.Source);
        const user = (0, combi_1.seq)("USER", expressions_1.Source);
        const sset = (0, combi_1.seq)("USING SELECTION-SET", expressions_1.Source);
        const ssetp = (0, combi_1.seq)("USING SELECTION-SETS OF PROGRAM", expressions_1.Source);
        const uss = (0, combi_1.seq)("USING SELECTION-SCREEN", expressions_1.Source);
        const free = (0, combi_1.seq)("WITH FREE SELECTIONS", expressions_1.Source);
        const newList = (0, combi_1.seq)("NEW LIST IDENTIFICATION", expressions_1.Source);
        const layout = (0, combi_1.seq)("LAYOUT", expressions_1.Source);
        const cover = (0, combi_1.seq)("SAP COVER PAGE", expressions_1.Source);
        const keep = (0, combi_1.seq)("KEEP IN SPOOL", expressions_1.Source);
        const imm = (0, combi_1.seq)("IMMEDIATELY", expressions_1.Source);
        const dest = (0, combi_1.seq)("DESTINATION", expressions_1.Source);
        const language = (0, combi_1.seq)("LANGUAGE", expressions_1.Source);
        const perm = (0, combi_1.per)((0, combi_1.plus)(awith), selectionTable, spool, lineSize, lineCount, archive, user, sset, ssetp, keep, cover, imm, layout, dest, language, free, newList, uss, "TO SAP-SPOOL", "WITHOUT SPOOL DYNPRO", "VIA SELECTION-SCREEN", exporting, expressions_1.AndReturn, job);
        const ret = (0, combi_1.seq)("SUBMIT", prog, (0, combi_1.opt)(perm));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Submit = Submit;
//# sourceMappingURL=submit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subtract = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Subtract {
    getMatcher() {
        const ret = (0, combi_1.seq)("SUBTRACT", expressions_1.Source, "FROM", expressions_1.Target);
        return ret;
    }
}
exports.Subtract = Subtract;
//# sourceMappingURL=subtract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract_corresponding.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/subtract_corresponding.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubtractCorresponding = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SubtractCorresponding {
    getMatcher() {
        const ret = (0, combi_1.seq)("SUBTRACT-CORRESPONDING", expressions_1.Source, "FROM", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SubtractCorresponding = SubtractCorresponding;
//# sourceMappingURL=subtract_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sum.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/sum.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sum = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Sum {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "SUM");
    }
}
exports.Sum = Sum;
//# sourceMappingURL=sum.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/summary.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/summary.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Summary = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Summary {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, "SUMMARY");
    }
}
exports.Summary = Summary;
//# sourceMappingURL=summary.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/supply.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/supply.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Supply = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Supply {
    getMatcher() {
        const field = (0, combi_1.seq)(expressions_1.Field, "=", expressions_1.Source);
        const ret = (0, combi_1.seq)("SUPPLY", (0, combi_1.plus)(field), "TO CONTEXT", expressions_1.Field);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Supply = Supply;
//# sourceMappingURL=supply.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/suppress_dialog.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/suppress_dialog.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuppressDialog = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SuppressDialog {
    getMatcher() {
        const ret = (0, combi_1.str)("SUPPRESS DIALOG");
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SuppressDialog = SuppressDialog;
//# sourceMappingURL=suppress_dialog.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/syntax_check.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/syntax_check.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntaxCheck = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SyntaxCheck {
    getMatcher() {
        const program = (0, combi_1.seq)("PROGRAM", expressions_1.Source);
        const offset = (0, combi_1.seq)("OFFSET", expressions_1.Target);
        const frame = (0, combi_1.seq)("FRAME ENTRY", expressions_1.Target);
        const include = (0, combi_1.seq)("INCLUDE", expressions_1.Target);
        const trace = (0, combi_1.seq)("TRACE-TABLE", expressions_1.Target);
        const line = (0, combi_1.seq)("LINE", expressions_1.Target);
        const word = (0, combi_1.seq)("WORD", expressions_1.Target);
        const messageId = (0, combi_1.seq)("MESSAGE-ID", expressions_1.Target);
        const message = (0, combi_1.seq)("MESSAGE", expressions_1.Target);
        const id = (0, combi_1.seq)("ID", expressions_1.Source, "TABLE", expressions_1.Target);
        const replacing = (0, combi_1.seq)("REPLACING", expressions_1.Target);
        const directory = (0, combi_1.seq)("DIRECTORY ENTRY", expressions_1.Source);
        const dump = (0, combi_1.seq)("SHORTDUMP-ID", expressions_1.Source);
        const filter = (0, combi_1.seq)("FILTER", expressions_1.Source);
        const syntax = (0, combi_1.seq)((0, combi_1.optPrio)("PROGRAM"), expressions_1.Source, (0, combi_1.per)(message, line, word, offset, program, replacing, directory, frame, include, messageId, trace, dump, filter, (0, combi_1.plus)(id)));
        const dynpro = (0, combi_1.seq)("DYNPRO", expressions_1.Source, expressions_1.Source, expressions_1.Source, expressions_1.Source, (0, combi_1.per)(message, line, word, offset, messageId, trace));
        const ret = (0, combi_1.seq)("SYNTAX-CHECK FOR", (0, combi_1.alt)(syntax, dynpro));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SyntaxCheck = SyntaxCheck;
//# sourceMappingURL=syntax_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/system_call.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/system_call.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemCall = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/target.js");
class SystemCall {
    getMatcher() {
        const anyy = (0, combi_1.regex)(/^.+$/);
        const objmgr = (0, combi_1.seq)("OBJMGR CLONE", source_1.Source, "TO", target_1.Target);
        const did = (0, combi_1.seq)(anyy, "DID", source_1.Source, "PARAMETERS", source_1.Source, source_1.Source, source_1.Source);
        const ret = (0, combi_1.seq)("SYSTEM-CALL", (0, combi_1.altPrio)(objmgr, did, (0, combi_1.plus)(anyy)));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.SystemCall = SystemCall;
//# sourceMappingURL=system_call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/tables.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/tables.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tables = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Tables {
    getMatcher() {
        const ret = (0, combi_1.seq)("TABLES", expressions_1.Field);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Tables = Tables;
//# sourceMappingURL=tables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_injection.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_injection.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestInjection = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TestInjection {
    getMatcher() {
        return (0, combi_1.seq)("TEST-INJECTION", expressions_1.TestSeamName);
    }
}
exports.TestInjection = TestInjection;
//# sourceMappingURL=test_injection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_seam.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/test_seam.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSeam = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TestSeam {
    getMatcher() {
        return (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("TEST-SEAM", expressions_1.TestSeamName));
    }
}
exports.TestSeam = TestSeam;
//# sourceMappingURL=test_seam.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/top_of_page.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/top_of_page.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TopOfPage = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TopOfPage {
    getMatcher() {
        const ret = (0, combi_1.seq)("TOP-OF-PAGE", (0, combi_1.opt)("DURING LINE-SELECTION"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.TopOfPage = TopOfPage;
//# sourceMappingURL=top_of_page.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/transfer.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/transfer.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transfer = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Transfer {
    getMatcher() {
        const length = (0, combi_1.seq)("LENGTH", expressions_1.Source);
        const ret = (0, combi_1.seq)("TRANSFER", expressions_1.Source, "TO", expressions_1.Source, (0, combi_1.opt)(length), (0, combi_1.opt)("NO END OF LINE"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Transfer = Transfer;
//# sourceMappingURL=transfer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/translate.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/translate.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Translate = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Translate {
    getMatcher() {
        const cas = (0, combi_1.seq)("TO", (0, combi_1.altPrio)("UPPER", "LOWER"), "CASE");
        const using = (0, combi_1.seq)("USING", expressions_1.Source);
        return (0, combi_1.seq)("TRANSLATE", expressions_1.Target, (0, combi_1.altPrio)(cas, using));
    }
}
exports.Translate = Translate;
//# sourceMappingURL=translate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/truncate_dataset.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/truncate_dataset.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TruncateDataset = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TruncateDataset {
    getMatcher() {
        return (0, combi_1.verNot)(version_1.Version.Cloud, (0, combi_1.seq)("TRUNCATE DATASET", expressions_1.Source, "AT CURRENT POSITION"));
    }
}
exports.TruncateDataset = TruncateDataset;
//# sourceMappingURL=truncate_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/try.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/try.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Try = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class Try {
    getMatcher() {
        return (0, combi_1.str)("TRY");
    }
}
exports.Try = Try;
//# sourceMappingURL=try.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Expressions = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Type {
    getMatcher() {
        const simple = (0, combi_1.per)(Expressions.Type, Expressions.Decimals, Expressions.Length);
        const def = (0, combi_1.seq)(Expressions.NamespaceSimpleName, (0, combi_1.opt)(Expressions.ConstantFieldLength), (0, combi_1.opt)((0, combi_1.alt)(simple, Expressions.TypeTable, Expressions.TypeStructure)));
        // todo, BOXED is only allowed with structures inside structures?
        const boxed = (0, combi_1.ver)(version_1.Version.v702, "BOXED");
        const ret = (0, combi_1.seq)("TYPES", def, (0, combi_1.opt)(boxed));
        return ret;
    }
}
exports.Type = Type;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_begin.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_begin.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeBegin {
    getMatcher() {
        const ret = (0, combi_1.seq)("TYPES", "BEGIN OF", expressions_1.NamespaceSimpleName, (0, combi_1.optPrio)((0, combi_1.verNot)(version_1.Version.Cloud, "%_FINAL")));
        return ret;
    }
}
exports.TypeBegin = TypeBegin;
//# sourceMappingURL=type_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_end.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_end.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class TypeEnd {
    getMatcher() {
        const ret = (0, combi_1.seq)("TYPES", "END OF", expressions_1.NamespaceSimpleName);
        return ret;
    }
}
exports.TypeEnd = TypeEnd;
//# sourceMappingURL=type_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnum = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeEnum {
    getMatcher() {
        // it is also possible to define without Value, this is covered by normal type
        const ret = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("TYPES", expressions_1.NamespaceSimpleName, expressions_1.Value));
        return ret;
    }
}
exports.TypeEnum = TypeEnum;
//# sourceMappingURL=type_enum.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_begin.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_begin.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnumBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeEnumBegin {
    getMatcher() {
        const structure = (0, combi_1.seq)("STRUCTURE", expressions_1.NamespaceSimpleName);
        const base = (0, combi_1.seq)("BASE TYPE", expressions_1.NamespaceSimpleName);
        const em = (0, combi_1.seq)("ENUM", expressions_1.NamespaceSimpleName, (0, combi_1.opt)(structure), (0, combi_1.opt)(base));
        const ret = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("TYPES", "BEGIN OF", em));
        return ret;
    }
}
exports.TypeEnumBegin = TypeEnumBegin;
//# sourceMappingURL=type_enum_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_end.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_enum_end.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnumEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeEnumEnd {
    getMatcher() {
        const structure = (0, combi_1.seq)("STRUCTURE", expressions_1.NamespaceSimpleName);
        const ret = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("TYPES", "END OF", "ENUM", expressions_1.NamespaceSimpleName, (0, combi_1.opt)(structure)));
        return ret;
    }
}
exports.TypeEnumEnd = TypeEnumEnd;
//# sourceMappingURL=type_enum_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeMesh = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeMesh {
    getMatcher() {
        const on = (0, combi_1.seq)("ON", expressions_1.NamespaceSimpleName, "=", expressions_1.NamespaceSimpleName, (0, combi_1.star)((0, combi_1.seq)("AND", expressions_1.NamespaceSimpleName, "=", expressions_1.NamespaceSimpleName)));
        const using = (0, combi_1.seq)("USING KEY", expressions_1.NamespaceSimpleName);
        const association = (0, combi_1.seq)("ASSOCIATION", expressions_1.NamespaceSimpleName, "TO", expressions_1.NamespaceSimpleName, (0, combi_1.plus)(on));
        const ret = (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("TYPES", expressions_1.NamespaceSimpleName, "TYPE", (0, combi_1.opt)("REF TO"), expressions_1.TypeName, (0, combi_1.plus)(association), (0, combi_1.opt)(using)));
        return ret;
    }
}
exports.TypeMesh = TypeMesh;
//# sourceMappingURL=type_mesh.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_begin.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_begin.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeMeshBegin = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeMeshBegin {
    getMatcher() {
        const ret = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)("TYPES", "BEGIN OF MESH", expressions_1.NamespaceSimpleName));
        return ret;
    }
}
exports.TypeMeshBegin = TypeMeshBegin;
//# sourceMappingURL=type_mesh_begin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_end.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_mesh_end.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeMeshEnd = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class TypeMeshEnd {
    getMatcher() {
        const ret = (0, combi_1.ver)(version_1.Version.v740sp05, (0, combi_1.seq)("TYPES", "END OF MESH", expressions_1.NamespaceSimpleName));
        return ret;
    }
}
exports.TypeMeshEnd = TypeMeshEnd;
//# sourceMappingURL=type_mesh_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pool.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypePool = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
// type pool definition
class TypePool {
    getMatcher() {
        const fieldName = (0, combi_1.regex)(/^\w+$/);
        const ret = (0, combi_1.seq)("TYPE-POOL", fieldName);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.TypePool = TypePool;
//# sourceMappingURL=type_pool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pools.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/type_pools.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypePools = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
// type pool usage
class TypePools {
    getMatcher() {
        const fieldName = (0, combi_1.regex)(/^\w+$/);
        const ret = (0, combi_1.seq)("TYPE-POOLS", fieldName);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.TypePools = TypePools;
//# sourceMappingURL=type_pools.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/uline.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/uline.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Uline = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Uline {
    getMatcher() {
        const ret = (0, combi_1.seq)("ULINE", (0, combi_1.optPrio)(expressions_1.WriteOffsetLength), (0, combi_1.optPrio)("NO-GAP"));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Uline = Uline;
//# sourceMappingURL=uline.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unassign.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unassign.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unassign = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Unassign {
    getMatcher() {
        return (0, combi_1.seq)("UNASSIGN", expressions_1.TargetFieldSymbol);
    }
}
exports.Unassign = Unassign;
//# sourceMappingURL=unassign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unpack.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/unpack.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unpack = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Unpack {
    getMatcher() {
        const ret = (0, combi_1.seq)("UNPACK", expressions_1.Source, "TO", expressions_1.Target);
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Unpack = Unpack;
//# sourceMappingURL=unpack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/update_database.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/update_database.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDatabase = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class UpdateDatabase {
    getMatcher() {
        const parameters = (0, combi_1.seq)(expressions_1.SQLFieldAndValue, (0, combi_1.star)((0, combi_1.seq)((0, combi_1.opt)(","), expressions_1.SQLFieldAndValue)));
        const set = (0, combi_1.seq)("SET", (0, combi_1.alt)(parameters, expressions_1.Dynamic), (0, combi_1.opt)((0, combi_1.seq)("WHERE", expressions_1.SQLCond)));
        const fromTable = (0, combi_1.seq)("FROM", (0, combi_1.opt)("TABLE"), expressions_1.SQLSource);
        const ret = (0, combi_1.seq)("UPDATE", expressions_1.DatabaseTable, (0, combi_1.opt)(expressions_1.SQLClient), (0, combi_1.opt)(expressions_1.DatabaseConnection), (0, combi_1.opt)((0, combi_1.alt)(fromTable, set)));
        return ret;
    }
}
exports.UpdateDatabase = UpdateDatabase;
//# sourceMappingURL=update_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/wait.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/wait.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wait = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Wait {
    getMatcher() {
        const up = (0, combi_1.seq)("UP TO", expressions_1.Source, "SECONDS");
        const channels = "MESSAGING CHANNELS";
        const push = (0, combi_1.ver)(version_1.Version.v750, "PUSH CHANNELS", version_1.Version.OpenABAP);
        const tasks = "ASYNCHRONOUS TASKS";
        const type = (0, combi_1.seq)("FOR", (0, combi_1.per)(channels, push, tasks));
        const until = (0, combi_1.seq)((0, combi_1.opt)(type), "UNTIL", expressions_1.Cond, (0, combi_1.opt)(up));
        const ret = (0, combi_1.seq)("WAIT", (0, combi_1.alt)(until, up));
        return ret;
    }
}
exports.Wait = Wait;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.When = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class When {
    getMatcher() {
        const sourc = (0, combi_1.seq)(expressions_1.Source, (0, combi_1.starPrio)(expressions_1.Or));
        return (0, combi_1.seq)("WHEN", sourc);
    }
}
exports.When = When;
//# sourceMappingURL=when.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_others.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_others.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhenOthers = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class WhenOthers {
    getMatcher() {
        return (0, combi_1.str)("WHEN OTHERS");
    }
}
exports.WhenOthers = WhenOthers;
//# sourceMappingURL=when_others.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_type.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/when_type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhenType = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class WhenType {
    getMatcher() {
        const into = (0, combi_1.seq)("INTO", expressions_1.Target);
        const type = (0, combi_1.seq)(expressions_1.ClassName, (0, combi_1.optPrio)(into));
        return (0, combi_1.ver)(version_1.Version.v750, (0, combi_1.seq)("WHEN TYPE", type), version_1.Version.OpenABAP);
    }
}
exports.WhenType = WhenType;
//# sourceMappingURL=when_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/while.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/while.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.While = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class While {
    getMatcher() {
        const vary = (0, combi_1.seq)("VARY", expressions_1.Target, "FROM", expressions_1.Source, "NEXT", expressions_1.Source);
        return (0, combi_1.seq)("WHILE", expressions_1.Cond, (0, combi_1.opt)(vary));
    }
}
exports.While = While;
//# sourceMappingURL=while.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/window.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/window.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Window = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Window {
    getMatcher() {
        const ending = (0, combi_1.seq)("ENDING AT", expressions_1.Source, expressions_1.Source);
        const ret = (0, combi_1.seq)("WINDOW STARTING AT", expressions_1.Source, expressions_1.Source, (0, combi_1.opt)(ending));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Window = Window;
//# sourceMappingURL=window.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.With = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class With {
    getMatcher() {
        const as = (0, combi_1.seq)(expressions_1.WithName, "AS", (0, combi_1.tok)(tokens_1.WParenLeftW), expressions_1.SelectLoop, (0, combi_1.tok)(tokens_1.WParenRightW));
        return (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("WITH", (0, combi_1.plus)(as), expressions_1.Select));
    }
}
exports.With = With;
//# sourceMappingURL=with.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with_loop.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/with_loop.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WithLoop = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class WithLoop {
    getMatcher() {
        const as = (0, combi_1.seq)(expressions_1.WithName, "AS", (0, combi_1.tok)(tokens_1.WParenLeftW), expressions_1.SelectLoop, (0, combi_1.tok)(tokens_1.WParenRightW));
        return (0, combi_1.ver)(version_1.Version.v751, (0, combi_1.seq)("WITH", (0, combi_1.plus)(as), expressions_1.SelectLoop));
    }
}
exports.WithLoop = WithLoop;
//# sourceMappingURL=with_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/write.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/2_statements/statements/write.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Write = void 0;
const combi_1 = __webpack_require__(/*! ../combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const expressions_1 = __webpack_require__(/*! ../expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Write {
    getMatcher() {
        const mask = (0, combi_1.seq)("USING", (0, combi_1.altPrio)("NO EDIT MASK", (0, combi_1.seq)("EDIT MASK", expressions_1.Source)));
        const onOff = (0, combi_1.alt)((0, combi_1.altPrio)("ON", "OFF"), (0, combi_1.seq)("=", expressions_1.FieldSub));
        const dateFormat = (0, combi_1.altPrio)("DD/MM/YY", "MM/DD/YY", "DD/MM/YYYY", "MM/DD/YYYY", "DDMMYY", "MMDDYY", "YYMMDD");
        const as = (0, combi_1.seq)("AS", (0, combi_1.altPrio)("LINE", "ICON", "CHECKBOX", "SYMBOL"));
        const to = (0, combi_1.seq)("TO", expressions_1.Target);
        const options = (0, combi_1.per)(mask, to, (0, combi_1.seq)("EXPONENT", expressions_1.Source), "NO-GROUPING", "NO-ZERO", "CENTERED", (0, combi_1.seq)("INPUT", (0, combi_1.opt)(onOff)), "NO-GAP", "LEFT-JUSTIFIED", as, (0, combi_1.seq)("FRAMES", onOff), (0, combi_1.seq)("HOTSPOT", (0, combi_1.opt)(onOff)), "RIGHT-JUSTIFIED", (0, combi_1.seq)("TIME ZONE", expressions_1.Source), (0, combi_1.seq)("UNDER", expressions_1.Source), (0, combi_1.seq)("STYLE", expressions_1.Source), (0, combi_1.seq)("ROUND", expressions_1.Source), (0, combi_1.seq)("QUICKINFO", expressions_1.Source), "ENVIRONMENT TIME FORMAT", dateFormat, (0, combi_1.seq)("UNIT", expressions_1.Source), (0, combi_1.seq)("INTENSIFIED", (0, combi_1.opt)(onOff)), (0, combi_1.seq)("INDEX", expressions_1.Source), (0, combi_1.seq)("DECIMALS", expressions_1.Source), (0, combi_1.seq)("INVERSE", (0, combi_1.opt)(onOff)), expressions_1.Color, (0, combi_1.seq)("CURRENCY", expressions_1.Source), "NO-SIGN");
        const ret = (0, combi_1.seq)("WRITE", (0, combi_1.alt)("AT /", (0, combi_1.seq)((0, combi_1.opt)(expressions_1.WriteOffsetLength), (0, combi_1.altPrio)(expressions_1.Source, expressions_1.Dynamic, "/"), (0, combi_1.opt)(options))));
        return (0, combi_1.verNot)(version_1.Version.Cloud, ret);
    }
}
exports.Write = Write;
//# sourceMappingURL=write.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structure_parser.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structure_parser.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructureParser = void 0;
const _statement_1 = __webpack_require__(/*! ../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const Structures = __webpack_require__(/*! ./structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const issue_1 = __webpack_require__(/*! ../../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const severity_1 = __webpack_require__(/*! ../../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
class StructureParser {
    static run(input) {
        const structure = this.findStructureForFile(input.file.getFilename());
        const filtered = [];
        for (const s of input.statements) {
            const get = s.get();
            if (get instanceof _statement_1.Comment || get instanceof _statement_1.Empty || get instanceof _statement_1.Unknown) {
                continue;
            }
            filtered.push(s);
        }
        return this.runFile(structure, input.file, filtered);
    }
    //////////////////
    static findStructureForFile(filename) {
        // todo, not sure this is the right place for this logic
        if (filename.endsWith(".clas.abap")) {
            return new Structures.ClassGlobal();
        }
        else if (filename.endsWith(".intf.abap")) {
            return new Structures.InterfaceGlobal();
        }
        else {
            // todo, add a special structure for TYPE-POOLS
            return new Structures.Any();
        }
    }
    static runFile(structure, file, statements) {
        const parent = new nodes_1.StructureNode(structure);
        if (this.singletons[structure.constructor.name] === undefined) {
            this.singletons[structure.constructor.name] = structure.getMatcher();
        }
        const result = this.singletons[structure.constructor.name].run(statements, parent);
        if (result.error) {
            const issue = issue_1.Issue.atPosition(file, new position_1.Position(1, 1), result.errorDescription, "structure", severity_1.Severity.Error);
            return { issues: [issue], node: undefined };
        }
        if (result.unmatched.length > 0) {
            const statement = result.unmatched[0];
            const descr = "Unexpected " + statement.get().constructor.name.toUpperCase();
            const issue = issue_1.Issue.atPosition(file, statement.getStart(), descr, "structure", severity_1.Severity.Error);
            return { issues: [issue], node: undefined };
        }
        return { issues: [], node: parent };
    }
}
exports.StructureParser = StructureParser;
StructureParser.singletons = {};
//# sourceMappingURL=structure_parser.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.seq = seq;
exports.alt = alt;
exports.beginEnd = beginEnd;
exports.opt = opt;
exports.star = star;
exports.sta = sta;
exports.sub = sub;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class Sequence {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Sequence, length error");
        }
        this.list = list;
    }
    toRailroad() {
        const children = this.list.map((e) => { return e.toRailroad(); });
        return "Railroad.Sequence(" + children.join() + ")";
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    first() {
        return this.list[0].first();
    }
    run(statements, parent) {
        let inn = statements;
        let out = [];
        for (const i of this.list) {
            const match = i.run(inn, parent);
            if (match.error) {
                return {
                    matched: [],
                    unmatched: statements,
                    error: true,
                    errorDescription: match.errorDescription,
                    errorMatched: out.length,
                };
            }
            if (match.matched.length < 100) {
                out.push(...match.matched);
            }
            else {
                // avoid using the spread operator, it might trigger "Maximum call stack size exceeded"
                // when the number of matched elements is very large
                out = out.concat(match.matched);
            }
            inn = match.unmatched;
        }
        return {
            matched: out,
            unmatched: inn,
            error: false,
            errorDescription: "",
            errorMatched: 0,
        };
    }
}
// Note that the Alternative does not nessesarily return the first in the alternative
// as a map is used for better performance
class Alternative {
    constructor(list) {
        if (list.length < 2) {
            throw new Error("Alternative, length error");
        }
        this.list = list;
    }
    setupMap() {
        // dont call from constructor, it will cause infinite loop
        if (this.map === undefined) {
            this.map = {};
            for (const i of this.list) {
                for (const first of i.first()) {
                    if (this.map[first]) {
                        this.map[first].push(i);
                    }
                    else {
                        this.map[first] = [i];
                    }
                }
            }
        }
    }
    first() {
        return [""];
    }
    toRailroad() {
        const children = this.list.map((e) => { return e.toRailroad(); });
        return "Railroad.Choice(0, " + children.join() + ")";
    }
    getUsing() {
        return this.list.reduce((a, c) => { return a.concat(c.getUsing()); }, []);
    }
    run(statements, parent) {
        this.setupMap();
        let count = 0;
        let countError = "";
        if (statements.length === 0) {
            return {
                matched: [],
                unmatched: statements,
                error: true,
                errorDescription: countError,
                errorMatched: count,
            };
        }
        const token = statements[0].getFirstToken().getStr().toUpperCase();
        for (const i of this.map[token] || []) {
            const match = i.run(statements, parent);
            if (match.error === false) {
                return match;
            }
            if (match.errorMatched > count) {
                countError = match.errorDescription;
                count = match.errorMatched;
            }
        }
        for (const i of this.map[""] || []) {
            const match = i.run(statements, parent);
            if (match.error === false) {
                return match;
            }
            if (match.errorMatched > count) {
                countError = match.errorDescription;
                count = match.errorMatched;
            }
        }
        if (count === 0) {
            return {
                matched: [],
                unmatched: statements,
                error: true,
                errorDescription: "Unexpected code structure",
                errorMatched: count,
            };
        }
        else {
            return {
                matched: [],
                unmatched: statements,
                error: true,
                errorDescription: countError,
                errorMatched: count,
            };
        }
    }
}
class Optional {
    constructor(obj) {
        this.obj = obj;
    }
    toRailroad() {
        return "Railroad.Optional(" + this.obj.toRailroad() + ")";
    }
    getUsing() {
        return this.obj.getUsing();
    }
    run(statements, parent) {
        const ret = this.obj.run(statements, parent);
        ret.error = false;
        return ret;
    }
    first() {
        return [""];
    }
}
class Star {
    constructor(obj) {
        this.obj = obj;
    }
    toRailroad() {
        return "Railroad.ZeroOrMore(" + this.obj.toRailroad() + ")";
    }
    getUsing() {
        return this.obj.getUsing();
    }
    run(statements, parent) {
        let inn = statements;
        let out = [];
        while (true) {
            if (inn.length === 0) {
                return {
                    matched: out,
                    unmatched: inn,
                    error: false,
                    errorDescription: "",
                    errorMatched: 0,
                };
            }
            const match = this.obj.run(inn, parent);
            if (match.error === true) {
                if (match.errorMatched > 0) {
                    return {
                        matched: out,
                        unmatched: inn,
                        error: true,
                        errorDescription: match.errorDescription,
                        errorMatched: match.errorMatched,
                    };
                }
                else {
                    return {
                        matched: out,
                        unmatched: inn,
                        error: false,
                        errorDescription: "",
                        errorMatched: 0,
                    };
                }
            }
            if (match.matched.length < 100) {
                out.push(...match.matched);
            }
            else {
                // avoid using the spread operator, it might trigger "Maximum call stack size exceeded"
                // when the number of matched elements is very large
                out = out.concat(match.matched);
            }
            inn = match.unmatched;
        }
    }
    first() {
        return [""];
    }
}
class SubStructure {
    constructor(s) {
        this.s = s;
    }
    toRailroad() {
        return "Railroad.NonTerminal('" + this.s.constructor.name + "', {href: '#/structure/" + this.s.constructor.name + "'})";
    }
    getUsing() {
        return ["structure/" + this.s.constructor.name];
    }
    first() {
        this.setupMatcher();
        return this.matcher.first();
    }
    setupMatcher() {
        if (this.matcher === undefined) {
            // SubStructures are singletons, so the getMatcher can be saved, its expensive to create
            // dont move this to the constructor, as it might trigger infinite recursion
            this.matcher = this.s.getMatcher();
        }
    }
    run(statements, parent) {
        const nparent = new nodes_1.StructureNode(this.s);
        this.setupMatcher();
        const ret = this.matcher.run(statements, nparent);
        if (ret.matched.length === 0) {
            ret.error = true;
        }
        else {
            parent.addChild(nparent);
        }
        return ret;
    }
}
class SubStatement {
    constructor(obj) {
        this.obj = obj;
    }
    first() {
        const o = new this.obj();
        if (o instanceof _statement_1.MacroCall || o instanceof _statement_1.NativeSQL) {
            return [""];
        }
        return o.getMatcher().first();
    }
    toRailroad() {
        return "Railroad.Terminal('" + this.className() + "', {href: '#/statement/" + this.className() + "'})";
    }
    getUsing() {
        return ["statement/" + this.className()];
    }
    className() {
        return this.obj.name;
    }
    run(statements, parent) {
        if (statements.length === 0) {
            return {
                matched: [],
                unmatched: [],
                error: true,
                errorDescription: "Expected " + this.className().toUpperCase(),
                errorMatched: 0,
            };
        }
        else if (statements[0].get() instanceof this.obj) {
            parent.addChild(statements[0]);
            return {
                matched: [statements[0]],
                unmatched: statements.splice(1),
                error: false,
                errorDescription: "",
                errorMatched: 0,
            };
        }
        else {
            return {
                matched: [],
                unmatched: statements,
                error: true,
                errorDescription: "Expected " + this.className().toUpperCase(),
                errorMatched: 0,
            };
        }
    }
}
function seq(first, ...rest) {
    return new Sequence([first].concat(rest));
}
function alt(first, ...rest) {
    return new Alternative([first].concat(rest));
}
function beginEnd(begin, body, end) {
    return new Sequence([begin, body, end]);
}
function opt(o) {
    return new Optional(o);
}
function star(s) {
    return new Star(s);
}
function sta(s) {
    return new SubStatement(s);
}
const singletons = {};
function sub(s) {
    if (singletons[s.name] === undefined) {
        singletons[s.name] = new SubStructure(new s());
    }
    return singletons[s.name];
}
//# sourceMappingURL=_combi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/any.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/any.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Any = void 0;
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const Structures = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
class Any {
    getMatcher() {
        return (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.ClassLocalFriends), (0, _combi_1.sta)(Statements.ClassDeferred), (0, _combi_1.sta)(Statements.Report), (0, _combi_1.sta)(Statements.Program), (0, _combi_1.sta)(Statements.Parameter), (0, _combi_1.sta)(Statements.CheckSelectOptions), (0, _combi_1.sta)(Statements.Get), (0, _combi_1.sta)(Statements.Initialization), (0, _combi_1.sta)(Statements.InterfaceDeferred), (0, _combi_1.sta)(Statements.SelectionScreen), (0, _combi_1.sta)(Statements.SelectOption), (0, _combi_1.sta)(Statements.AtSelectionScreen), (0, _combi_1.sta)(Statements.AtLineSelection), (0, _combi_1.sta)(Statements.AtUserCommand), (0, _combi_1.sta)(Statements.StartOfSelection), (0, _combi_1.sta)(Statements.EndOfSelection), (0, _combi_1.sta)(Statements.LoadOfProgram), (0, _combi_1.sta)(Statements.TopOfPage), (0, _combi_1.sta)(Statements.EndOfPage), (0, _combi_1.sta)(Statements.Controls), (0, _combi_1.sta)(Statements.TypePools), (0, _combi_1.sta)(Statements.TypePool), (0, _combi_1.sta)(Statements.FunctionPool), (0, _combi_1.sub)(Structures.Normal), (0, _combi_1.sub)(Structures.Form), (0, _combi_1.sub)(Structures.Module), (0, _combi_1.sub)(Structures.FunctionModule), (0, _combi_1.sub)(Structures.Interface), (0, _combi_1.sub)(Structures.ClassDefinition), (0, _combi_1.sub)(Structures.ClassImplementation)));
    }
}
exports.Any = Any;
//# sourceMappingURL=any.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.At = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class At {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.At), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndAt));
    }
}
exports.At = At;
//# sourceMappingURL=at.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_first.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_first.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtFirst = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class AtFirst {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.AtFirst), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndAt));
    }
}
exports.AtFirst = AtFirst;
//# sourceMappingURL=at_first.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_last.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_last.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AtLast = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class AtLast {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.AtLast), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndAt));
    }
}
exports.AtLast = AtLast;
//# sourceMappingURL=at_last.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Body = void 0;
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const normal_1 = __webpack_require__(/*! ./normal */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/normal.js");
class Body {
    getMatcher() {
        // todo, this should be a "plus" instead, however its not implemented yet
        return (0, _combi_1.star)((0, _combi_1.sub)(normal_1.Normal));
    }
}
exports.Body = Body;
//# sourceMappingURL=body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Case = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const when_1 = __webpack_require__(/*! ./when */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class Case {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Case), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sub)(when_1.When), (0, _combi_1.sta)(_statement_1.MacroCall), (0, _combi_1.sta)(Statements.Include))), (0, _combi_1.sta)(Statements.EndCase));
    }
}
exports.Case = Case;
//# sourceMappingURL=case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case_type.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case_type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CaseType = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const when_type_1 = __webpack_require__(/*! ./when_type */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when_type.js");
class CaseType {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.CaseType), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sub)(when_type_1.WhenType), (0, _combi_1.sta)(Statements.Data))), (0, _combi_1.sta)(Statements.EndCase));
    }
}
exports.CaseType = CaseType;
//# sourceMappingURL=case_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Catch = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Catch {
    getMatcher() {
        const cat = (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Catch), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)));
        return cat;
    }
}
exports.Catch = Catch;
//# sourceMappingURL=catch.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch_system_exceptions.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch_system_exceptions.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CatchSystemExceptions = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class CatchSystemExceptions {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.CatchSystemExceptions), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndCatch));
    }
}
exports.CatchSystemExceptions = CatchSystemExceptions;
//# sourceMappingURL=catch_system_exceptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_data.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_data.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassData = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class ClassData {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.ClassDataBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.ClassData), (0, _combi_1.sub)(ClassData))), (0, _combi_1.sta)(Statements.ClassDataEnd));
    }
}
exports.ClassData = ClassData;
//# sourceMappingURL=class_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_definition.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_definition.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDefinition = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const private_section_1 = __webpack_require__(/*! ./private_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/private_section.js");
const protected_section_1 = __webpack_require__(/*! ./protected_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/protected_section.js");
const public_section_1 = __webpack_require__(/*! ./public_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/public_section.js");
class ClassDefinition {
    getMatcher() {
        const body = (0, _combi_1.seq)((0, _combi_1.opt)((0, _combi_1.sta)(Statements.SetExtendedCheck)), (0, _combi_1.star)((0, _combi_1.sta)(Statements.TypePools)), (0, _combi_1.opt)((0, _combi_1.sub)(public_section_1.PublicSection)), (0, _combi_1.opt)((0, _combi_1.sub)(protected_section_1.ProtectedSection)), (0, _combi_1.opt)((0, _combi_1.sub)(private_section_1.PrivateSection)), (0, _combi_1.opt)((0, _combi_1.sta)(Statements.SetExtendedCheck)));
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.ClassDefinition), body, (0, _combi_1.sta)(Statements.EndClass));
    }
}
exports.ClassDefinition = ClassDefinition;
//# sourceMappingURL=class_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_global.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_global.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassGlobal = void 0;
const Structures = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class ClassGlobal {
    getMatcher() {
        return (0, _combi_1.seq)((0, _combi_1.star)((0, _combi_1.sta)(Statements.TypePools)), (0, _combi_1.sub)(Structures.ClassDefinition), (0, _combi_1.sub)(Structures.ClassImplementation));
    }
}
exports.ClassGlobal = ClassGlobal;
//# sourceMappingURL=class_global.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_implementation.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_implementation.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassImplementation = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class ClassImplementation {
    getMatcher() {
        // the DEFINE statement is allowed between local method implementations, but not global?
        const body = (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sub)(Structures.Define), (0, _combi_1.sta)(Statements.Include), (0, _combi_1.sub)(Structures.Method)));
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.ClassImplementation), body, (0, _combi_1.sta)(Statements.EndClass));
    }
}
exports.ClassImplementation = ClassImplementation;
//# sourceMappingURL=class_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/cleanup.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/cleanup.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cleanup = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Cleanup {
    getMatcher() {
        const cleanup = (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Cleanup), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)));
        return cleanup;
    }
}
exports.Cleanup = Cleanup;
//# sourceMappingURL=cleanup.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/constants.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/constants.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constants = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class Constants {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.ConstantBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.Constant), (0, _combi_1.sta)(Statements.Include), (0, _combi_1.sub)(Constants))), (0, _combi_1.sta)(Statements.ConstantEnd));
    }
}
exports.Constants = Constants;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/data.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/data.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Data = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const enhancement_1 = __webpack_require__(/*! ./enhancement */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement.js");
const constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/constants.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/types.js");
const define_1 = __webpack_require__(/*! ./define */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/define.js");
class Data {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.DataBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.Data), (0, _combi_1.sub)(Data), (0, _combi_1.sta)(Statements.Include), (0, _combi_1.sta)(Statements.Ranges), (0, _combi_1.sta)(Statements.Constant), (0, _combi_1.sub)(constants_1.Constants), (0, _combi_1.sta)(Statements.Type), (0, _combi_1.sub)(types_1.Types), (0, _combi_1.sub)(enhancement_1.Enhancement), (0, _combi_1.sub)(define_1.Define), (0, _combi_1.sta)(Statements.IncludeType), (0, _combi_1.sta)(Statements.TypePools), (0, _combi_1.sta)(Statements.EnhancementPoint))), (0, _combi_1.sta)(Statements.DataEnd));
    }
}
exports.Data = Data;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/define.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/define.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Define = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class Define {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Define), (0, _combi_1.star)((0, _combi_1.sta)(_statement_1.MacroContent)), (0, _combi_1.sta)(Statements.EndOfDefinition));
    }
}
exports.Define = Define;
//# sourceMappingURL=define.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/do.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/do.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Do = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Do {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Do), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndDo));
    }
}
exports.Do = Do;
//# sourceMappingURL=do.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/else.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/else.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Else = void 0;
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Else {
    getMatcher() {
        const body = (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body));
        const elseif = (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Else), body);
        return elseif;
    }
}
exports.Else = Else;
//# sourceMappingURL=else.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/elseif.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/elseif.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElseIf = void 0;
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class ElseIf {
    getMatcher() {
        const body = (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body));
        const elseif = (0, _combi_1.seq)((0, _combi_1.sta)(Statements.ElseIf), body);
        return elseif;
    }
}
exports.ElseIf = ElseIf;
//# sourceMappingURL=elseif.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Enhancement = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Enhancement {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Enhancement), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndEnhancement));
    }
}
exports.Enhancement = Enhancement;
//# sourceMappingURL=enhancement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement_section.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement_section.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancementSection = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class EnhancementSection {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.EnhancementSection), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndEnhancementSection));
    }
}
exports.EnhancementSection = EnhancementSection;
//# sourceMappingURL=enhancement_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/exec_sql.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/exec_sql.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExecSQL = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class ExecSQL {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.ExecSQL), (0, _combi_1.star)((0, _combi_1.sta)(_statement_1.NativeSQL)), (0, _combi_1.sta)(Statements.EndExec));
    }
}
exports.ExecSQL = ExecSQL;
//# sourceMappingURL=exec_sql.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/form.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/form.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Form = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Form {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Form), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndForm));
    }
}
exports.Form = Form;
//# sourceMappingURL=form.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/function_module.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/function_module.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionModule = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class FunctionModule {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.FunctionModule), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndFunction));
    }
}
exports.FunctionModule = FunctionModule;
//# sourceMappingURL=function_module.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/if.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/if.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.If = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
const elseif_1 = __webpack_require__(/*! ./elseif */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/elseif.js");
const else_1 = __webpack_require__(/*! ./else */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/else.js");
class If {
    getMatcher() {
        const contents = (0, _combi_1.seq)((0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.star)((0, _combi_1.sub)(elseif_1.ElseIf)), (0, _combi_1.opt)((0, _combi_1.sub)(else_1.Else)));
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.If), contents, (0, _combi_1.sta)(Statements.EndIf));
    }
}
exports.If = If;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js ***!
  \*************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./any */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/any.js"), exports);
__exportStar(__webpack_require__(/*! ./at */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at.js"), exports);
__exportStar(__webpack_require__(/*! ./at_first */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_first.js"), exports);
__exportStar(__webpack_require__(/*! ./at_last */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/at_last.js"), exports);
__exportStar(__webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js"), exports);
__exportStar(__webpack_require__(/*! ./case_type */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case_type.js"), exports);
__exportStar(__webpack_require__(/*! ./case */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/case.js"), exports);
__exportStar(__webpack_require__(/*! ./catch_system_exceptions */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch_system_exceptions.js"), exports);
__exportStar(__webpack_require__(/*! ./catch */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch.js"), exports);
__exportStar(__webpack_require__(/*! ./class_data */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_data.js"), exports);
__exportStar(__webpack_require__(/*! ./class_definition */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./class_global */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_global.js"), exports);
__exportStar(__webpack_require__(/*! ./class_implementation */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./cleanup */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/cleanup.js"), exports);
__exportStar(__webpack_require__(/*! ./constants */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/constants.js"), exports);
__exportStar(__webpack_require__(/*! ./data */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/data.js"), exports);
__exportStar(__webpack_require__(/*! ./define */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/define.js"), exports);
__exportStar(__webpack_require__(/*! ./do */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/do.js"), exports);
__exportStar(__webpack_require__(/*! ./type_mesh */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_mesh.js"), exports);
__exportStar(__webpack_require__(/*! ./else */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/else.js"), exports);
__exportStar(__webpack_require__(/*! ./elseif */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/elseif.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement_section.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/enhancement.js"), exports);
__exportStar(__webpack_require__(/*! ./exec_sql */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/exec_sql.js"), exports);
__exportStar(__webpack_require__(/*! ./form */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/form.js"), exports);
__exportStar(__webpack_require__(/*! ./function_module */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/function_module.js"), exports);
__exportStar(__webpack_require__(/*! ./if */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/if.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_global */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface_global.js"), exports);
__exportStar(__webpack_require__(/*! ./interface */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface.js"), exports);
__exportStar(__webpack_require__(/*! ./loop_at_screen */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop_at_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./loop */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop.js"), exports);
__exportStar(__webpack_require__(/*! ./method */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/method.js"), exports);
__exportStar(__webpack_require__(/*! ./module */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/module.js"), exports);
__exportStar(__webpack_require__(/*! ./normal */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/normal.js"), exports);
__exportStar(__webpack_require__(/*! ./on_change */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/on_change.js"), exports);
__exportStar(__webpack_require__(/*! ./private_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/private_section.js"), exports);
__exportStar(__webpack_require__(/*! ./protected_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/protected_section.js"), exports);
__exportStar(__webpack_require__(/*! ./provide */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/provide.js"), exports);
__exportStar(__webpack_require__(/*! ./public_section */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/public_section.js"), exports);
__exportStar(__webpack_require__(/*! ./section_contents */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js"), exports);
__exportStar(__webpack_require__(/*! ./select */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/select.js"), exports);
__exportStar(__webpack_require__(/*! ./statics */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/statics.js"), exports);
__exportStar(__webpack_require__(/*! ./test_injection */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_injection.js"), exports);
__exportStar(__webpack_require__(/*! ./test_seam */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_seam.js"), exports);
__exportStar(__webpack_require__(/*! ./try */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/try.js"), exports);
__exportStar(__webpack_require__(/*! ./type_enum */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_enum.js"), exports);
__exportStar(__webpack_require__(/*! ./types */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/types.js"), exports);
__exportStar(__webpack_require__(/*! ./when_type */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when_type.js"), exports);
__exportStar(__webpack_require__(/*! ./when */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when.js"), exports);
__exportStar(__webpack_require__(/*! ./while */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/while.js"), exports);
__exportStar(__webpack_require__(/*! ./with */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/with.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const section_contents_1 = __webpack_require__(/*! ./section_contents */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js");
class Interface {
    getMatcher() {
        const intf = (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Interface), (0, _combi_1.star)((0, _combi_1.sub)(section_contents_1.SectionContents)), (0, _combi_1.sta)(Statements.EndInterface));
        return intf;
    }
}
exports.Interface = Interface;
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface_global.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/interface_global.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceGlobal = void 0;
const Structures = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class InterfaceGlobal {
    getMatcher() {
        return (0, _combi_1.seq)((0, _combi_1.star)((0, _combi_1.sta)(Statements.TypePools)), (0, _combi_1.star)((0, _combi_1.sta)(Statements.InterfaceLoad)), (0, _combi_1.sub)(Structures.Interface));
    }
}
exports.InterfaceGlobal = InterfaceGlobal;
//# sourceMappingURL=interface_global.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Loop = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
class Loop {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Loop), (0, _combi_1.star)((0, _combi_1.sub)(_1.Body)), (0, _combi_1.sta)(Statements.EndLoop));
    }
}
exports.Loop = Loop;
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop_at_screen.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/loop_at_screen.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopAtScreen = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
class LoopAtScreen {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.LoopAtScreen), (0, _combi_1.opt)((0, _combi_1.sub)(_1.Body)), (0, _combi_1.sta)(Statements.EndLoop));
    }
}
exports.LoopAtScreen = LoopAtScreen;
//# sourceMappingURL=loop_at_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/method.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/method.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Method = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Method {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.MethodImplementation), (0, _combi_1.opt)((0, _combi_1.alt)((0, _combi_1.sub)(body_1.Body), (0, _combi_1.star)((0, _combi_1.sta)(_statement_1.NativeSQL)))), (0, _combi_1.sta)(Statements.EndMethod));
    }
}
exports.Method = Method;
//# sourceMappingURL=method.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/module.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/module.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Module = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Module {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Module), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndModule));
    }
}
exports.Module = Module;
//# sourceMappingURL=module.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/normal.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/normal.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Normal = void 0;
const Structures = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class Normal {
    getMatcher() {
        // note that the sequence of alternatives here influences performance
        return (0, _combi_1.alt)((0, _combi_1.sta)(Statements.Move), (0, _combi_1.sta)(Statements.Call), (0, _combi_1.sta)(Statements.Data), (0, _combi_1.sub)(Structures.If), (0, _combi_1.sta)(Statements.Clear), (0, _combi_1.sta)(Statements.FieldSymbol), (0, _combi_1.sta)(Statements.CreateObject), (0, _combi_1.sta)(Statements.CallFunction), (0, _combi_1.sta)(_statement_1.MacroCall), (0, _combi_1.sub)(Structures.LoopAtScreen), (0, _combi_1.sub)(Structures.Loop), (0, _combi_1.sta)(Statements.Append), (0, _combi_1.sub)(Structures.Try), (0, _combi_1.sub)(Structures.OnChange), (0, _combi_1.sta)(Statements.ReadTable), (0, _combi_1.sta)(Statements.Assert), (0, _combi_1.sta)(Statements.Return), (0, _combi_1.sta)(Statements.Select), (0, _combi_1.sta)(Statements.Assign), (0, _combi_1.sta)(Statements.InsertInternal), (0, _combi_1.sta)(Statements.DeleteInternal), (0, _combi_1.sta)(Statements.Concatenate), (0, _combi_1.sub)(Structures.Case), (0, _combi_1.sub)(Structures.CaseType), (0, _combi_1.sub)(Structures.Enhancement), (0, _combi_1.sub)(Structures.EnhancementSection), (0, _combi_1.sta)(Statements.AddCorresponding), (0, _combi_1.sta)(Statements.Add), (0, _combi_1.sta)(Statements.AssignLocalCopy), (0, _combi_1.sta)(Statements.AuthorityCheck), (0, _combi_1.sta)(Statements.Back), (0, _combi_1.sta)(Statements.Break), (0, _combi_1.sta)(Statements.BreakId), (0, _combi_1.sta)(Statements.CallDatabase), (0, _combi_1.sta)(Statements.CallDialog), (0, _combi_1.sta)(Statements.CallKernel), (0, _combi_1.sta)(Statements.CallOLE), (0, _combi_1.sta)(Statements.CallScreen), (0, _combi_1.sta)(Statements.ModifyScreen), (0, _combi_1.sta)(Statements.CallSelectionScreen), (0, _combi_1.sta)(Statements.CallTransaction), (0, _combi_1.sta)(Statements.CallTransformation), (0, _combi_1.sta)(Statements.Check), (0, _combi_1.sta)(Statements.ClassDefinitionLoad), (0, _combi_1.sta)(Statements.CloseCursor), (0, _combi_1.sta)(Statements.CloseDataset), (0, _combi_1.sta)(Statements.Collect), (0, _combi_1.sta)(Statements.Commit), (0, _combi_1.sta)(Statements.Communication), (0, _combi_1.sta)(Statements.Compute), (0, _combi_1.sta)(Statements.CallBadi), (0, _combi_1.sta)(Statements.Condense), (0, _combi_1.sta)(Statements.Constant), (0, _combi_1.sta)(Statements.Contexts), (0, _combi_1.sta)(Statements.Continue), (0, _combi_1.sta)(Statements.ConvertText), (0, _combi_1.sta)(Statements.Convert), (0, _combi_1.sta)(Statements.CreateData), (0, _combi_1.sta)(Statements.CreateOLE), (0, _combi_1.sta)(Statements.DeleteCluster), (0, _combi_1.sta)(Statements.DeleteDatabase), (0, _combi_1.sta)(Statements.DeleteDataset), (0, _combi_1.sta)(Statements.DeleteDynpro), (0, _combi_1.sta)(Statements.DeleteMemory), (0, _combi_1.sta)(Statements.DeleteReport), (0, _combi_1.sta)(Statements.DeleteTextpool), (0, _combi_1.sta)(Statements.Demand), (0, _combi_1.sta)(Statements.Describe), (0, _combi_1.sta)(Statements.Detail), (0, _combi_1.sta)(Statements.Divide), (0, _combi_1.sta)(Statements.EditorCall), (0, _combi_1.sta)(Statements.EnhancementPoint), (0, _combi_1.sta)(Statements.Exit), (0, _combi_1.sta)(Statements.ExportDynpro), (0, _combi_1.sta)(Statements.Export), (0, _combi_1.sta)(Statements.Extract), (0, _combi_1.sta)(Statements.FetchNextCursor), (0, _combi_1.sta)(Statements.FieldGroup), (0, _combi_1.sta)(Statements.Fields), (0, _combi_1.sta)(Statements.Find), (0, _combi_1.sta)(Statements.Format), (0, _combi_1.sta)(Statements.FreeMemory), (0, _combi_1.sta)(Statements.FreeObject), (0, _combi_1.sta)(Statements.Free), (0, _combi_1.sta)(Statements.GenerateDynpro), (0, _combi_1.sta)(Statements.GenerateReport), (0, _combi_1.sta)(Statements.GenerateSubroutine), (0, _combi_1.sta)(Statements.GetBadi), (0, _combi_1.sta)(Statements.GetBit), (0, _combi_1.sta)(Statements.GetCursor), (0, _combi_1.sta)(Statements.GetDataset), (0, _combi_1.sta)(Statements.GetLocale), (0, _combi_1.sta)(Statements.GetParameter), (0, _combi_1.sta)(Statements.GetPFStatus), (0, _combi_1.sta)(Statements.GetProperty), (0, _combi_1.sta)(Statements.GetReference), (0, _combi_1.sta)(Statements.GetRunTime), (0, _combi_1.sta)(Statements.GetTime), (0, _combi_1.sta)(Statements.Hide), (0, _combi_1.sta)(Statements.Nodes), (0, _combi_1.sta)(Statements.ImportDynpro), (0, _combi_1.sta)(Statements.ImportNametab), (0, _combi_1.sta)(Statements.MoveCorresponding), (0, _combi_1.sta)(Statements.Import), (0, _combi_1.sta)(Statements.Infotypes), (0, _combi_1.sta)(Statements.Include), // include does not have to be at top level
        (0, _combi_1.sta)(Statements.InsertDatabase), (0, _combi_1.sta)(Statements.InsertReport), (0, _combi_1.sta)(Statements.InsertTextpool), (0, _combi_1.sta)(Statements.InsertFieldGroup), (0, _combi_1.sta)(Statements.InterfaceLoad), (0, _combi_1.sta)(Statements.Leave), (0, _combi_1.sta)(Statements.LoadReport), (0, _combi_1.sta)(Statements.Local), (0, _combi_1.sta)(Statements.With), (0, _combi_1.sta)(Statements.LogPoint), (0, _combi_1.sta)(Statements.Message), (0, _combi_1.sta)(Statements.ModifyLine), (0, _combi_1.sta)(Statements.ModifyDatabase), (0, _combi_1.sta)(Statements.ModifyInternal), (0, _combi_1.sta)(Statements.Multiply), (0, _combi_1.sta)(Statements.NewLine), (0, _combi_1.sta)(Statements.NewPage), (0, _combi_1.sta)(Statements.OpenCursor), (0, _combi_1.sta)(Statements.OpenDataset), (0, _combi_1.sta)(Statements.Overlay), (0, _combi_1.sta)(Statements.Pack), (0, _combi_1.sta)(Statements.Perform), (0, _combi_1.sta)(Statements.FormDefinition), (0, _combi_1.sta)(Statements.Position), (0, _combi_1.sta)(Statements.Put), (0, _combi_1.sta)(Statements.PrintControl), (0, _combi_1.sta)(Statements.RaiseEvent), (0, _combi_1.sta)(Statements.RaiseEntityEvent), (0, _combi_1.sta)(Statements.Raise), (0, _combi_1.sta)(Statements.Ranges), (0, _combi_1.sta)(Statements.ReadDataset), (0, _combi_1.sta)(Statements.ReadLine), (0, _combi_1.sta)(Statements.ReadReport), (0, _combi_1.sta)(Statements.ReadTextpool), (0, _combi_1.sta)(Statements.Receive), (0, _combi_1.sta)(Statements.RefreshControl), (0, _combi_1.sta)(Statements.Refresh), (0, _combi_1.sta)(Statements.Reject), (0, _combi_1.sta)(Statements.Replace), (0, _combi_1.sta)(Statements.Reserve), (0, _combi_1.sta)(Statements.Resume), (0, _combi_1.sta)(Statements.Retry), (0, _combi_1.sta)(Statements.Rollback), (0, _combi_1.sta)(Statements.Scan), (0, _combi_1.sta)(Statements.ScrollList), (0, _combi_1.sta)(Statements.Search), (0, _combi_1.sta)(Statements.SetBit), (0, _combi_1.sta)(Statements.SetBlank), (0, _combi_1.sta)(Statements.SetCountry), (0, _combi_1.sta)(Statements.SetCursor), (0, _combi_1.sta)(Statements.SetDataset), (0, _combi_1.sta)(Statements.SetExtendedCheck), (0, _combi_1.sta)(Statements.SetHandler), (0, _combi_1.sta)(Statements.SetLanguage), (0, _combi_1.sta)(Statements.SetLeft), (0, _combi_1.sta)(Statements.SetLocale), (0, _combi_1.sta)(Statements.SetMargin), (0, _combi_1.sta)(Statements.SetParameter), (0, _combi_1.sta)(Statements.SetPFStatus), (0, _combi_1.sta)(Statements.SetProperty), (0, _combi_1.sta)(Statements.SetRunTime), (0, _combi_1.sta)(Statements.SetScreen), (0, _combi_1.sta)(Statements.SetTitlebar), (0, _combi_1.sta)(Statements.SetUserCommand), (0, _combi_1.sta)(Statements.SetUpdateTask), (0, _combi_1.sta)(Statements.Shift), (0, _combi_1.sta)(Statements.Skip), (0, _combi_1.sta)(Statements.SortDataset), (0, _combi_1.sta)(Statements.Sort), (0, _combi_1.sta)(Statements.Static), (0, _combi_1.sta)(Statements.Split), (0, _combi_1.sta)(Statements.Stop), (0, _combi_1.sta)(Statements.Submit), (0, _combi_1.sta)(Statements.Summary), (0, _combi_1.sta)(Statements.SubtractCorresponding), (0, _combi_1.sta)(Statements.Subtract), (0, _combi_1.sta)(Statements.SuppressDialog), (0, _combi_1.sta)(Statements.Supply), (0, _combi_1.sta)(Statements.Sum), (0, _combi_1.sta)(Statements.SyntaxCheck), (0, _combi_1.sta)(Statements.SystemCall), (0, _combi_1.sta)(Statements.Tables), (0, _combi_1.sta)(Statements.Transfer), (0, _combi_1.sta)(Statements.Translate), (0, _combi_1.sta)(Statements.Type), (0, _combi_1.sta)(Statements.TypePools), (0, _combi_1.sta)(Statements.Uline), (0, _combi_1.sta)(Statements.Unassign), (0, _combi_1.sta)(Statements.Unpack), (0, _combi_1.sta)(Statements.UpdateDatabase), (0, _combi_1.sta)(Statements.Wait), (0, _combi_1.sta)(Statements.Window), (0, _combi_1.sta)(Statements.Write), (0, _combi_1.sta)(Statements.CommitEntities), (0, _combi_1.sta)(Statements.GetPermissions), (0, _combi_1.sta)(Statements.SetLocks), (0, _combi_1.sta)(Statements.ModifyEntities), (0, _combi_1.sta)(Statements.ReadEntities), (0, _combi_1.sta)(Statements.RollbackEntities), (0, _combi_1.sub)(Structures.Define), (0, _combi_1.sub)(Structures.TestInjection), (0, _combi_1.sub)(Structures.TestSeam), (0, _combi_1.sub)(Structures.TypeMesh), (0, _combi_1.sub)(Structures.Provide), (0, _combi_1.sub)(Structures.CatchSystemExceptions), (0, _combi_1.sub)(Structures.At), (0, _combi_1.sub)(Structures.AtFirst), (0, _combi_1.sub)(Structures.AtLast), (0, _combi_1.sub)(Structures.Constants), (0, _combi_1.sub)(Structures.Types), (0, _combi_1.sub)(Structures.Statics), (0, _combi_1.sub)(Structures.Select), (0, _combi_1.sub)(Structures.Data), (0, _combi_1.sub)(Structures.TypeEnum), (0, _combi_1.sub)(Structures.While), (0, _combi_1.sub)(Structures.With), (0, _combi_1.sub)(Structures.Do), (0, _combi_1.sub)(Structures.ExecSQL));
    }
}
exports.Normal = Normal;
//# sourceMappingURL=normal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/on_change.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/on_change.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OnChange = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class OnChange {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.OnChange), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndOn));
    }
}
exports.OnChange = OnChange;
//# sourceMappingURL=on_change.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/private_section.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/private_section.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrivateSection = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const section_contents_1 = __webpack_require__(/*! ./section_contents */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js");
class PrivateSection {
    getMatcher() {
        return (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Private), (0, _combi_1.opt)((0, _combi_1.sub)(section_contents_1.SectionContents)));
    }
}
exports.PrivateSection = PrivateSection;
//# sourceMappingURL=private_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/protected_section.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/protected_section.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProtectedSection = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const section_contents_1 = __webpack_require__(/*! ./section_contents */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js");
class ProtectedSection {
    getMatcher() {
        return (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Protected), (0, _combi_1.opt)((0, _combi_1.sub)(section_contents_1.SectionContents)));
    }
}
exports.ProtectedSection = ProtectedSection;
//# sourceMappingURL=protected_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/provide.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/provide.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Provide = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Provide {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Provide), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndProvide));
    }
}
exports.Provide = Provide;
//# sourceMappingURL=provide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/public_section.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/public_section.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PublicSection = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const section_contents_1 = __webpack_require__(/*! ./section_contents */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js");
class PublicSection {
    getMatcher() {
        return (0, _combi_1.seq)((0, _combi_1.sta)(Statements.Public), (0, _combi_1.opt)((0, _combi_1.sub)(section_contents_1.SectionContents)));
    }
}
exports.PublicSection = PublicSection;
//# sourceMappingURL=public_section.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/section_contents.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SectionContents = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const types_1 = __webpack_require__(/*! ./types */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/types.js");
const constants_1 = __webpack_require__(/*! ./constants */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/constants.js");
const type_enum_1 = __webpack_require__(/*! ./type_enum */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_enum.js");
const class_data_1 = __webpack_require__(/*! ./class_data */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/class_data.js");
const data_1 = __webpack_require__(/*! ./data */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/data.js");
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
class SectionContents {
    getMatcher() {
        return (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.MethodDef), (0, _combi_1.sta)(Statements.InterfaceDef), (0, _combi_1.sta)(Statements.Data), (0, _combi_1.sta)(Statements.ClassData), (0, _combi_1.sta)(Statements.Events), (0, _combi_1.sta)(Statements.Constant), (0, _combi_1.sta)(Statements.Aliases), (0, _combi_1.sta)(Statements.TypePools), (0, _combi_1.sta)(Statements.InterfaceLoad), (0, _combi_1.sta)(Statements.ClassDefinitionLoad), (0, _combi_1.sta)(Statements.Include), (0, _combi_1.sub)(types_1.Types), (0, _combi_1.sub)(constants_1.Constants), (0, _combi_1.sub)(type_enum_1.TypeEnum), (0, _combi_1.sub)(_1.TypeMesh), (0, _combi_1.sub)(data_1.Data), (0, _combi_1.sub)(class_data_1.ClassData), (0, _combi_1.sta)(Statements.Type)));
    }
}
exports.SectionContents = SectionContents;
//# sourceMappingURL=section_contents.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/select.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/select.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Select = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class Select {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.SelectLoop), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndSelect));
    }
}
exports.Select = Select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/statics.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/statics.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Statics = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class Statics {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.StaticBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.Static), (0, _combi_1.sta)(Statements.IncludeType))), (0, _combi_1.sta)(Statements.StaticEnd));
    }
}
exports.Statics = Statics;
//# sourceMappingURL=statics.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_injection.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_injection.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestInjection = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class TestInjection {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.TestInjection), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndTestInjection));
    }
}
exports.TestInjection = TestInjection;
//# sourceMappingURL=test_injection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_seam.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/test_seam.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TestSeam = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class TestSeam {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.TestSeam), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndTestSeam));
    }
}
exports.TestSeam = TestSeam;
//# sourceMappingURL=test_seam.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/try.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/try.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Try = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const catch_1 = __webpack_require__(/*! ./catch */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/catch.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
const cleanup_1 = __webpack_require__(/*! ./cleanup */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/cleanup.js");
class Try {
    getMatcher() {
        const block = (0, _combi_1.seq)((0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.star)((0, _combi_1.sub)(catch_1.Catch)), (0, _combi_1.opt)((0, _combi_1.sub)(cleanup_1.Cleanup)));
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.Try), block, (0, _combi_1.sta)(Statements.EndTry));
    }
}
exports.Try = Try;
//# sourceMappingURL=try.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_enum.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_enum.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnum = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class TypeEnum {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.TypeEnumBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.TypeEnum), (0, _combi_1.sta)(Statements.Type))), (0, _combi_1.sta)(Statements.TypeEnumEnd));
    }
}
exports.TypeEnum = TypeEnum;
//# sourceMappingURL=type_enum.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_mesh.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/type_mesh.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeMesh = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
class TypeMesh {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.TypeMeshBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.TypeMesh), (0, _combi_1.sta)(Statements.Type))), (0, _combi_1.sta)(Statements.TypeMeshEnd));
    }
}
exports.TypeMesh = TypeMesh;
//# sourceMappingURL=type_mesh.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/types.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/types.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Types = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const _statement_1 = __webpack_require__(/*! ../../2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class Types {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.TypeBegin), (0, _combi_1.star)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.Type), (0, _combi_1.sub)(Types), (0, _combi_1.sta)(_statement_1.MacroCall), (0, _combi_1.sta)(Statements.Include), (0, _combi_1.sta)(Statements.IncludeType))), (0, _combi_1.sta)(Statements.TypeEnd));
    }
}
exports.Types = Types;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.When = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class When {
    getMatcher() {
        const when = (0, _combi_1.seq)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.When), (0, _combi_1.sta)(Statements.WhenOthers)), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)));
        return when;
    }
}
exports.When = When;
//# sourceMappingURL=when.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when_type.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/when_type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhenType = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class WhenType {
    getMatcher() {
        const when = (0, _combi_1.seq)((0, _combi_1.alt)((0, _combi_1.sta)(Statements.WhenType), (0, _combi_1.sta)(Statements.WhenOthers)), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)));
        return when;
    }
}
exports.WhenType = WhenType;
//# sourceMappingURL=when_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/while.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/while.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.While = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class While {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.While), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndWhile));
    }
}
exports.While = While;
//# sourceMappingURL=while.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/with.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/3_structures/structures/with.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.With = void 0;
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _combi_1 = __webpack_require__(/*! ./_combi */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/_combi.js");
const body_1 = __webpack_require__(/*! ./body */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/body.js");
class With {
    getMatcher() {
        return (0, _combi_1.beginEnd)((0, _combi_1.sta)(Statements.WithLoop), (0, _combi_1.opt)((0, _combi_1.sub)(body_1.Body)), (0, _combi_1.sta)(Statements.EndWith));
    }
}
exports.With = With;
//# sourceMappingURL=with.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RiskLevel = exports.Duration = exports.MethodParameterDirection = exports.AttributeLevel = void 0;
// Only helper functions to get data from single file, no type information
var AttributeLevel;
(function (AttributeLevel) {
    AttributeLevel["Instance"] = "instance";
    AttributeLevel["Static"] = "static";
    AttributeLevel["Constant"] = "constant";
})(AttributeLevel || (exports.AttributeLevel = AttributeLevel = {}));
var MethodParameterDirection;
(function (MethodParameterDirection) {
    MethodParameterDirection["Importing"] = "importing";
    MethodParameterDirection["Exporting"] = "exporting";
    MethodParameterDirection["Changing"] = "changing";
    MethodParameterDirection["Returning"] = "returning";
})(MethodParameterDirection || (exports.MethodParameterDirection = MethodParameterDirection = {}));
var Duration;
(function (Duration) {
    Duration["short"] = "SHORT";
    Duration["medium"] = "MEDIUM";
    Duration["long"] = "LONG";
})(Duration || (exports.Duration = Duration = {}));
var RiskLevel;
(function (RiskLevel) {
    RiskLevel["harmless"] = "HARMLESS";
    RiskLevel["critical"] = "CRITICAL";
    RiskLevel["dangerous"] = "DANGEROUS";
})(RiskLevel || (exports.RiskLevel = RiskLevel = {}));
//# sourceMappingURL=_abap_file_information.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Identifier = void 0;
class Identifier {
    constructor(token, filename) {
        this.token = token;
        this.filename = filename;
    }
    getName() {
        let name = this.token.getStr();
        // todo, should this be handled in the parser instead?
        if (name.substr(0, 1) === "!") {
            name = name.substr(1);
        }
        return name;
    }
    equals(id) {
        // note how the boolean condition is evalulated lazily
        return id.getStart().equals(this.getStart())
            && id.getFilename() === this.getFilename();
    }
    getToken() {
        return this.token;
    }
    getFilename() {
        return this.filename;
    }
    getStart() {
        return this.token.getStart();
    }
    getEnd() {
        return this.token.getEnd();
    }
}
exports.Identifier = Identifier;
//# sourceMappingURL=_identifier.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/4_file_information/abap_file_information.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/4_file_information/abap_file_information.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPFileInformation = void 0;
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _abap_file_information_1 = __webpack_require__(/*! ./_abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js");
const _identifier_1 = __webpack_require__(/*! ./_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const Tokens = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const visibility_1 = __webpack_require__(/*! ./visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
class ABAPFileInformation {
    constructor(structure, filename) {
        this.forms = [];
        this.implementations = [];
        this.interfaces = [];
        this.classes = [];
        this.filename = filename;
        this.parse(structure);
    }
    listClassImplementations() {
        return this.implementations;
    }
    listInterfaceDefinitions() {
        return this.interfaces;
    }
    getInterfaceDefinitionByName(name) {
        const upper = name.toUpperCase();
        for (const i of this.listInterfaceDefinitions()) {
            if (i.identifier.getName().toUpperCase() === upper) {
                return i;
            }
        }
        return undefined;
    }
    listClassDefinitions() {
        return this.classes;
    }
    getClassDefinitionByName(name) {
        const upper = name.toUpperCase();
        for (const d of this.listClassDefinitions()) {
            if (d.identifier.getName().toUpperCase() === upper) {
                return d;
            }
        }
        return undefined;
    }
    getClassImplementationByName(name) {
        const upper = name.toUpperCase();
        for (const impl of this.listClassImplementations()) {
            if (impl.identifier.getName().toUpperCase() === upper) {
                return impl;
            }
        }
        return undefined;
    }
    listFormDefinitions() {
        return this.forms;
    }
    ///////////////////////
    parse(structure) {
        var _a;
        if (structure === undefined) {
            return;
        }
        this.parseClasses(structure);
        this.parseInterfaces(structure);
        for (const found of structure.findAllStructures(Structures.ClassImplementation)) {
            const methods = [];
            for (const method of found.findAllStructures(Structures.Method)) {
                const methodName = (_a = method.findFirstExpression(Expressions.MethodName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                if (methodName) {
                    methods.push(new _identifier_1.Identifier(methodName, this.filename));
                }
            }
            const name = found.findFirstStatement(Statements.ClassImplementation).findFirstExpression(Expressions.ClassName).getFirstToken();
            this.implementations.push({
                name: name.getStr(),
                identifier: new _identifier_1.Identifier(name, this.filename),
                methods,
            });
        }
        for (const statement of structure.findAllStructures(Structures.Form)) {
            // FORMs can contain a dash in the name
            const pos = statement.findFirstExpression(Expressions.FormName).getFirstToken().getStart();
            const name = statement.findFirstExpression(Expressions.FormName).concatTokens();
            const nameToken = new Tokens.Identifier(pos, name);
            this.forms.push({
                name: nameToken.getStr(),
                identifier: new _identifier_1.Identifier(nameToken, this.filename),
            });
        }
    }
    parseInterfaces(structure) {
        for (const found of structure.findDirectStructures(Structures.Interface)) {
            const i = found.findFirstStatement(Statements.Interface);
            if (i === undefined) {
                throw new Error("Interface expected, parseInterfaces");
            }
            const interfaceName = i.findDirectExpression(Expressions.InterfaceName).getFirstToken();
            const methods = this.parseMethodDefinition(found, visibility_1.Visibility.Public);
            const attributes = this.parseAttributes(found, visibility_1.Visibility.Public);
            const aliases = this.parseAliases(found, visibility_1.Visibility.Public);
            const constants = this.parseConstants(found, visibility_1.Visibility.Public);
            const g = i.findDirectExpression(Expressions.ClassGlobal);
            this.interfaces.push({
                name: interfaceName.getStr(),
                identifier: new _identifier_1.Identifier(interfaceName, this.filename),
                isLocal: g === undefined,
                isGlobal: g !== undefined,
                interfaces: this.getImplementing(found),
                aliases,
                methods,
                constants,
                attributes,
            });
        }
    }
    parseClasses(structure) {
        var _a;
        for (const found of structure.findAllStructures(Structures.ClassDefinition)) {
            const className = found.findFirstStatement(Statements.ClassDefinition).findFirstExpression(Expressions.ClassName).getFirstToken();
            const methods = this.parseMethodDefinition(found.findFirstStructure(Structures.PublicSection), visibility_1.Visibility.Public);
            methods.push(...this.parseMethodDefinition(found.findFirstStructure(Structures.ProtectedSection), visibility_1.Visibility.Protected));
            methods.push(...this.parseMethodDefinition(found.findFirstStructure(Structures.PrivateSection), visibility_1.Visibility.Private));
            const attributes = this.parseAttributes(found.findFirstStructure(Structures.PublicSection), visibility_1.Visibility.Public);
            attributes.push(...this.parseAttributes(found.findFirstStructure(Structures.ProtectedSection), visibility_1.Visibility.Protected));
            attributes.push(...this.parseAttributes(found.findFirstStructure(Structures.PrivateSection), visibility_1.Visibility.Private));
            const aliases = this.parseAliases(found.findFirstStructure(Structures.PublicSection), visibility_1.Visibility.Public);
            aliases.push(...this.parseAliases(found.findFirstStructure(Structures.ProtectedSection), visibility_1.Visibility.Protected));
            aliases.push(...this.parseAliases(found.findFirstStructure(Structures.PrivateSection), visibility_1.Visibility.Private));
            const constants = this.parseConstants(found.findFirstStructure(Structures.PublicSection), visibility_1.Visibility.Public);
            constants.push(...this.parseConstants(found.findFirstStructure(Structures.ProtectedSection), visibility_1.Visibility.Protected));
            constants.push(...this.parseConstants(found.findFirstStructure(Structures.PrivateSection), visibility_1.Visibility.Private));
            const superClassName = (_a = found.findFirstExpression(Expressions.SuperClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr();
            const containsGlobal = found.findFirstExpression(Expressions.ClassGlobal);
            const cdef = found.findFirstStatement(Statements.ClassDefinition);
            const concat = (cdef === null || cdef === void 0 ? void 0 : cdef.concatTokens().toUpperCase()) || "";
            let riskLevel;
            if (concat.includes("RISK LEVEL CRITICAL")) {
                riskLevel = _abap_file_information_1.RiskLevel.critical;
            }
            else if (concat.includes("RISK LEVEL DANGEROUS")) {
                riskLevel = _abap_file_information_1.RiskLevel.dangerous;
            }
            else if (concat.includes("RISK LEVEL HARMLESS")) {
                riskLevel = _abap_file_information_1.RiskLevel.harmless;
            }
            let duration;
            if (concat.includes("DURATION SHORT")) {
                duration = _abap_file_information_1.Duration.short;
            }
            else if (concat.includes("DURATION LONG")) {
                duration = _abap_file_information_1.Duration.long;
            }
            else if (concat.includes("DURATION MEDIUM")) {
                duration = _abap_file_information_1.Duration.medium;
            }
            this.classes.push({
                name: className.getStr(),
                identifier: new _identifier_1.Identifier(className, this.filename),
                isLocal: containsGlobal === undefined,
                isGlobal: containsGlobal !== undefined,
                methods,
                superClassName,
                interfaces: this.getImplementing(found),
                isForTesting: concat.includes(" FOR TESTING"),
                duration,
                riskLevel,
                isAbstract: (cdef === null || cdef === void 0 ? void 0 : cdef.findDirectTokenByText("ABSTRACT")) !== undefined,
                isSharedMemory: concat.includes(" SHARED MEMORY ENABLED"),
                isFinal: found.findFirstExpression(Expressions.ClassFinal) !== undefined,
                aliases,
                attributes,
                constants,
            });
        }
    }
    ///////////////////
    getImplementing(input) {
        const ret = [];
        for (const node of input.findAllStatements(Statements.InterfaceDef)) {
            const abstract = node.findDirectExpression(Expressions.AbstractMethods);
            const abstractMethods = [];
            if (abstract) {
                for (const m of abstract.findDirectExpressions(Expressions.MethodName)) {
                    abstractMethods.push(m.concatTokens().toUpperCase());
                }
            }
            const final = node.findDirectExpression(Expressions.FinalMethods);
            const finalMethods = [];
            if (final) {
                for (const m of final.findDirectExpressions(Expressions.MethodName)) {
                    finalMethods.push(m.concatTokens().toUpperCase());
                }
            }
            const concat = node.concatTokens().toUpperCase();
            const allAbstract = concat.includes(" ALL METHODS ABSTRACT");
            const partial = concat.includes(" PARTIALLY IMPLEMENTED");
            const name = node.findFirstExpression(Expressions.InterfaceName).getFirstToken().getStr().toUpperCase();
            ret.push({
                name,
                partial,
                allAbstract,
                abstractMethods,
                finalMethods,
            });
        }
        return ret;
    }
    parseAliases(node, visibility) {
        if (node === undefined) {
            return [];
        }
        const ret = [];
        for (const a of node.findAllStatements(Statements.Aliases)) {
            const name = a.findFirstExpression(Expressions.SimpleName).getFirstToken();
            const comp = a.findFirstExpression(Expressions.Field).getFirstToken();
            ret.push({
                name: name.getStr(),
                identifier: new _identifier_1.Identifier(name, this.filename),
                visibility,
                component: comp.getStr(),
            });
        }
        return ret;
    }
    parseConstants(node, visibility) {
        var _a, _b;
        if (node === undefined) {
            return [];
        }
        const results = [];
        for (const constant of node.findAllStatements(Statements.Constant)) {
            const name = constant.findFirstExpression(Expressions.DefinitionName).getFirstToken();
            const typeName = constant.findFirstExpression(Expressions.TypeName);
            // VALUE `const_value` -> `const_value`
            const literal = (_b = (_a = constant.findFirstExpression(Expressions.Value)) === null || _a === void 0 ? void 0 : _a.getTokens()[1].getStr()) !== null && _b !== void 0 ? _b : "``";
            // `const_value` -> const_value
            const value = literal.slice(1, (literal === null || literal === void 0 ? void 0 : literal.length) - 1);
            results.push({
                name: name.getStr(),
                typeName: typeName ? typeName.getFirstToken().getStr() : "",
                value: value,
                identifier: new _identifier_1.Identifier(name, this.filename),
                visibility,
            });
        }
        return results;
    }
    parseAttributes(node, visibility) {
        if (node === undefined) {
            return [];
        }
        const contents = node.findFirstStructure(Structures.SectionContents);
        if (contents === undefined) {
            return [];
        }
        const ret = [];
        for (const d of contents.findDirectStatements(Statements.Data)) {
            const name = d.findFirstExpression(Expressions.DefinitionName).getFirstToken();
            ret.push({
                name: name.getStr(),
                identifier: new _identifier_1.Identifier(name, this.filename),
                level: _abap_file_information_1.AttributeLevel.Instance,
                readOnly: d.concatTokens().toUpperCase().includes(" READ-ONLY"),
                visibility,
            });
        }
        for (const d of contents.findDirectStatements(Statements.ClassData)) {
            const name = d.findFirstExpression(Expressions.DefinitionName).getFirstToken();
            ret.push({
                name: name.getStr(),
                identifier: new _identifier_1.Identifier(name, this.filename),
                level: _abap_file_information_1.AttributeLevel.Static,
                readOnly: d.concatTokens().toUpperCase().includes(" READ-ONLY"),
                visibility,
            });
        }
        for (const d of contents.findDirectStatements(Statements.Constant)) {
            const name = d.findFirstExpression(Expressions.DefinitionName).getFirstToken();
            ret.push({
                name: name.getStr(),
                identifier: new _identifier_1.Identifier(name, this.filename),
                level: _abap_file_information_1.AttributeLevel.Constant,
                readOnly: true,
                visibility,
            });
        }
        return ret;
    }
    parseMethodDefinition(node, visibility) {
        var _a;
        if (node === undefined) {
            return [];
        }
        const methods = [];
        for (const def of node.findAllStatements(Statements.MethodDef)) {
            const methodName = (_a = def.findDirectExpression(Expressions.MethodName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            if (methodName === undefined) {
                continue;
            }
            const parameters = this.parseMethodParameters(def);
            methods.push({
                name: methodName.getStr(),
                identifier: new _identifier_1.Identifier(methodName, this.filename),
                isRedefinition: def.findDirectExpression(Expressions.Redefinition) !== undefined,
                isForTesting: def.concatTokens().toUpperCase().includes(" FOR TESTING"),
                isFinal: def.concatTokens().toUpperCase().includes(" FINAL"),
                isAbstract: def.findDirectExpression(Expressions.Abstract) !== undefined,
                isEventHandler: def.findDirectExpression(Expressions.EventHandler) !== undefined,
                visibility,
                parameters,
                exceptions: [], // todo
            });
        }
        return methods;
    }
    // todo, refactor this method, it is too long
    parseMethodParameters(node) {
        var _a, _b, _c, _d;
        const ret = [];
        const importing = node.findFirstExpression(Expressions.MethodDefImporting);
        if (importing) {
            for (const param of importing.findAllExpressions(Expressions.MethodParam)) {
                const name = (_a = param.findDirectExpression(Expressions.MethodParamName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                if (name) {
                    ret.push({
                        name: name.getStr().replace("!", ""),
                        identifier: new _identifier_1.Identifier(name, this.filename),
                        direction: _abap_file_information_1.MethodParameterDirection.Importing,
                    });
                }
            }
        }
        const exporting = node.findFirstExpression(Expressions.MethodDefExporting);
        if (exporting) {
            for (const param of exporting.findAllExpressions(Expressions.MethodParam)) {
                const name = (_b = param.findDirectExpression(Expressions.MethodParamName)) === null || _b === void 0 ? void 0 : _b.getFirstToken();
                if (name) {
                    ret.push({
                        name: name.getStr().replace("!", ""),
                        identifier: new _identifier_1.Identifier(name, this.filename),
                        direction: _abap_file_information_1.MethodParameterDirection.Exporting,
                    });
                }
            }
        }
        const changing = node.findFirstExpression(Expressions.MethodDefChanging);
        if (changing) {
            for (const param of changing.findAllExpressions(Expressions.MethodParam)) {
                const name = (_c = param.findDirectExpression(Expressions.MethodParamName)) === null || _c === void 0 ? void 0 : _c.getFirstToken();
                if (name) {
                    ret.push({
                        name: name.getStr().replace("!", ""),
                        identifier: new _identifier_1.Identifier(name, this.filename),
                        direction: _abap_file_information_1.MethodParameterDirection.Changing,
                    });
                }
            }
        }
        const returning = node.findFirstExpression(Expressions.MethodDefReturning);
        if (returning) {
            const name = (_d = returning.findDirectExpression(Expressions.MethodParamName)) === null || _d === void 0 ? void 0 : _d.getFirstToken();
            if (name) {
                ret.push({
                    name: name.getStr().replace("!", ""),
                    identifier: new _identifier_1.Identifier(name, this.filename),
                    direction: _abap_file_information_1.MethodParameterDirection.Returning,
                });
            }
        }
        return ret;
    }
}
exports.ABAPFileInformation = ABAPFileInformation;
//# sourceMappingURL=abap_file_information.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Visibility = void 0;
var Visibility;
(function (Visibility) {
    Visibility[Visibility["Private"] = 1] = "Private";
    Visibility[Visibility["Protected"] = 2] = "Protected";
    Visibility[Visibility["Public"] = 3] = "Public";
})(Visibility || (exports.Visibility = Visibility = {}));
//# sourceMappingURL=visibility.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BuiltIn = exports.BuiltInMethod = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const tokens_1 = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const version_1 = __webpack_require__(/*! ../../version */ "./node_modules/@abaplint/core/build/src/version.js");
class BuiltInMethod extends _identifier_1.Identifier {
    constructor(token, filename, method, row) {
        super(token, filename);
        this.method = method;
        this.row = row;
    }
    getRequiredParameters() {
        const ret = [];
        for (const i in this.method.mandatory) {
            const id = new tokens_1.Identifier(new position_1.Position(this.row, 1), i);
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, this.method.mandatory[i]));
        }
        return ret;
    }
    getOptional() {
        throw new Error("BuiltInMethod->Method not implemented");
    }
    getAll() {
        throw new Error("BuiltInMethod->getAll, Method not implemented");
    }
    getImporting() {
        const ret = [];
        for (const i in this.method.mandatory) {
            const id = new tokens_1.Identifier(new position_1.Position(this.row, 1), i);
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, this.method.mandatory[i]));
        }
        for (const i in this.method.optional) {
            const id = new tokens_1.Identifier(new position_1.Position(this.row, 1), i);
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, this.method.optional[i]));
        }
        return ret;
    }
    getDefaultImporting() {
        if (this.method.mandatory === undefined) {
            return undefined;
        }
        const keys = Object.keys(this.method.mandatory);
        if (keys.length === 1) {
            return keys[0].toUpperCase();
        }
        return undefined;
    }
    getExporting() {
        return [];
    }
    getRaising() {
        return [];
    }
    getChanging() {
        return [];
    }
    getReturning() {
        const id = new tokens_1.Identifier(new position_1.Position(this.row, 1), "ret");
        return new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, this.method.return);
    }
    getExceptions() {
        return [];
    }
    getVisibility() {
        return visibility_1.Visibility.Public;
    }
    isRedefinition() {
        return false;
    }
    isAbstract() {
        return false;
    }
    isStatic() {
        return false;
    }
    isEventHandler() {
        return false;
    }
    getParameters() {
        return this;
    }
    getParameterDefault(_parameter) {
        return undefined;
    }
}
exports.BuiltInMethod = BuiltInMethod;
class BuiltIn {
    constructor() {
        this.row = 1;
    }
    buildDefinition(method, name) {
        if (method.cache) {
            return method.cache;
        }
        const token = new tokens_1.Identifier(new position_1.Position(1, 1), name);
        const result = new BuiltInMethod(token, BuiltIn.filename, method, method.counter);
        method.cache = result;
        return result;
    }
    searchBuiltin(name) {
        if (name === undefined) {
            return undefined;
        }
        const def = BuiltIn.methods[name.toUpperCase()];
        if (def === undefined) {
            return undefined;
        }
        return this.buildDefinition(def, name);
    }
    isPredicate(name) {
        if (name === undefined) {
            return undefined;
        }
        const def = BuiltIn.methods[name.toUpperCase()];
        if (def === undefined) {
            return undefined;
        }
        return def.predicate;
    }
    getTypes() {
        const ret = this.buildSY();
        {
            const id = new tokens_1.Identifier(new position_1.Position(1, 1), "abap_bool");
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" })));
        }
        {
            const id = new tokens_1.Identifier(new position_1.Position(1, 1), "cursor");
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, basic_1.IntegerType.get({ qualifiedName: "CURSOR", ddicName: "CURSOR" })));
        }
        return ret;
    }
    get(extras) {
        const ret = [];
        if (BuiltIn.getCache.length === 0) {
            BuiltIn.getCache.push(...this.buildSY());
            BuiltIn.getCache.push(this.buildVariable("screen"));
            BuiltIn.getCache.push(this.buildConstant("%_ENDIAN"));
            BuiltIn.getCache.push(this.buildConstant("%_CHARSIZE"));
            BuiltIn.getCache.push(this.buildConstant("%_BACKSPACE", new basic_1.CharacterType(1), "\b"));
            BuiltIn.getCache.push(this.buildConstant("%_CR_LF", new basic_1.CharacterType(2), "\r\n"));
            BuiltIn.getCache.push(this.buildConstant("%_FORMFEED", new basic_1.CharacterType(1), "\f"));
            BuiltIn.getCache.push(this.buildConstant("%_HORIZONTAL_TAB", new basic_1.CharacterType(1), "\t"));
            BuiltIn.getCache.push(this.buildConstant("%_MAXCHAR", new basic_1.CharacterType(1), Buffer.from("FDFF", "hex").toString()));
            BuiltIn.getCache.push(this.buildConstant("%_MINCHAR", new basic_1.CharacterType(1), Buffer.from("0000", "hex").toString()));
            BuiltIn.getCache.push(this.buildConstant("%_NEWLINE", new basic_1.CharacterType(1), "\n"));
            BuiltIn.getCache.push(this.buildConstant("%_VERTICAL_TAB", new basic_1.CharacterType(1), "\v"));
            BuiltIn.getCache.push(this.buildConstant("abap_false", new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }), "' '"));
            BuiltIn.getCache.push(this.buildConstant("abap_true", new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }), "'X'"));
            BuiltIn.getCache.push(this.buildConstant("abap_undefined", new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }), "'-'"));
            BuiltIn.getCache.push(this.buildConstant("abap_off", new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }), "' '"));
            BuiltIn.getCache.push(this.buildConstant("abap_on", new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" }), "'X'"));
            BuiltIn.getCache.push(this.buildConstant("col_background", basic_1.IntegerType.get(), "0"));
            BuiltIn.getCache.push(this.buildConstant("col_heading", basic_1.IntegerType.get(), "1"));
            BuiltIn.getCache.push(this.buildConstant("col_key", basic_1.IntegerType.get(), "4"));
            BuiltIn.getCache.push(this.buildConstant("col_negative", basic_1.IntegerType.get(), "6"));
            BuiltIn.getCache.push(this.buildConstant("col_group", basic_1.IntegerType.get(), "7"));
            BuiltIn.getCache.push(this.buildConstant("col_normal", basic_1.IntegerType.get(), "2"));
            BuiltIn.getCache.push(this.buildConstant("col_positive", basic_1.IntegerType.get(), "5"));
            BuiltIn.getCache.push(this.buildConstant("col_total", basic_1.IntegerType.get(), "3"));
            BuiltIn.getCache.push(this.buildConstant("space", new basic_1.CharacterType(1, { derivedFromConstant: true }), "' '"));
        }
        ret.push(...BuiltIn.getCache);
        for (const e of extras) {
            const id = new tokens_1.Identifier(new position_1.Position(this.row++, 1), e);
            ret.push(new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, new basic_1.VoidType(e), ["read_only" /* IdentifierMeta.ReadOnly */, "built-in" /* IdentifierMeta.BuiltIn */], "'?'"));
        }
        return ret;
    }
    /////////////////////////////
    buildVariable(name) {
        const id = new tokens_1.Identifier(new position_1.Position(this.row++, 1), name);
        return new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, new basic_1.VoidType(name), ["built-in" /* IdentifierMeta.BuiltIn */]);
    }
    buildSY() {
        const components = [];
        // NOTE: fields must be in correct sequence for the syntax check
        components.push({ name: "index", type: basic_1.IntegerType.get() });
        components.push({ name: "pagno", type: basic_1.IntegerType.get() });
        components.push({ name: "tabix", type: basic_1.IntegerType.get() });
        components.push({ name: "tfill", type: basic_1.IntegerType.get() });
        components.push({ name: "tlopc", type: basic_1.IntegerType.get() });
        components.push({ name: "tmaxl", type: basic_1.IntegerType.get() });
        components.push({ name: "toccu", type: basic_1.IntegerType.get() });
        components.push({ name: "ttabc", type: basic_1.IntegerType.get() });
        components.push({ name: "tstis", type: basic_1.IntegerType.get() });
        components.push({ name: "ttabi", type: basic_1.IntegerType.get() });
        components.push({ name: "dbcnt", type: basic_1.IntegerType.get() });
        components.push({ name: "fdpos", type: basic_1.IntegerType.get() });
        components.push({ name: "colno", type: basic_1.IntegerType.get() });
        components.push({ name: "linct", type: basic_1.IntegerType.get() });
        components.push({ name: "linno", type: basic_1.IntegerType.get() });
        components.push({ name: "linsz", type: basic_1.IntegerType.get() });
        components.push({ name: "pagct", type: basic_1.IntegerType.get() });
        components.push({ name: "macol", type: basic_1.IntegerType.get() });
        components.push({ name: "marow", type: basic_1.IntegerType.get() });
        components.push({ name: "tleng", type: basic_1.IntegerType.get() });
        components.push({ name: "sfoff", type: basic_1.IntegerType.get() });
        components.push({ name: "willi", type: basic_1.IntegerType.get() });
        components.push({ name: "lilli", type: basic_1.IntegerType.get() });
        components.push({ name: "subrc", type: basic_1.IntegerType.get() });
        components.push({ name: "fleng", type: basic_1.IntegerType.get() });
        components.push({ name: "cucol", type: basic_1.IntegerType.get() });
        components.push({ name: "curow", type: basic_1.IntegerType.get() });
        components.push({ name: "lsind", type: basic_1.IntegerType.get() });
        components.push({ name: "listi", type: basic_1.IntegerType.get() });
        components.push({ name: "stepl", type: basic_1.IntegerType.get() });
        components.push({ name: "tpagi", type: basic_1.IntegerType.get() });
        components.push({ name: "winx1", type: basic_1.IntegerType.get() });
        components.push({ name: "winy1", type: basic_1.IntegerType.get() });
        components.push({ name: "winx2", type: basic_1.IntegerType.get() });
        components.push({ name: "winy2", type: basic_1.IntegerType.get() });
        components.push({ name: "winco", type: basic_1.IntegerType.get() });
        components.push({ name: "winro", type: basic_1.IntegerType.get() });
        components.push({ name: "windi", type: basic_1.IntegerType.get() });
        components.push({ name: "srows", type: basic_1.IntegerType.get() });
        components.push({ name: "scols", type: basic_1.IntegerType.get() });
        components.push({ name: "loopc", type: basic_1.IntegerType.get() });
        components.push({ name: "folen", type: basic_1.IntegerType.get() });
        components.push({ name: "fodec", type: basic_1.IntegerType.get() });
        components.push({ name: "tzone", type: basic_1.IntegerType.get() });
        components.push({ name: "dayst", type: new basic_1.CharacterType(1) });
        components.push({ name: "ftype", type: new basic_1.CharacterType(1) });
        components.push({ name: "appli", type: new basic_1.HexType(2) });
        components.push({ name: "fdayw", type: new basic_1.AnyType() });
        components.push({ name: "ccurs", type: new basic_1.PackedType(5, 0) });
        components.push({ name: "ccurt", type: new basic_1.PackedType(5, 0) });
        components.push({ name: "debug", type: new basic_1.CharacterType(1) });
        components.push({ name: "ctype", type: new basic_1.CharacterType(1) });
        components.push({ name: "input", type: new basic_1.CharacterType(1, { qualifiedName: "sy-input" }) });
        components.push({ name: "langu", type: new basic_1.CharacterType(1, { qualifiedName: "sy-langu", conversionExit: "ISOLA" }) });
        components.push({ name: "modno", type: basic_1.IntegerType.get() });
        components.push({ name: "batch", type: new basic_1.CharacterType(1, { qualifiedName: "sy-batch" }) });
        components.push({ name: "binpt", type: new basic_1.CharacterType(1, { qualifiedName: "sy-binpt" }) });
        components.push({ name: "calld", type: new basic_1.CharacterType(1, { qualifiedName: "sy-calld" }) });
        components.push({ name: "dynnr", type: new basic_1.CharacterType(4, { qualifiedName: "sy-dynnr" }) });
        components.push({ name: "dyngr", type: new basic_1.CharacterType(4, { qualifiedName: "sy-dyngr" }) });
        components.push({ name: "newpa", type: new basic_1.CharacterType(1) });
        components.push({ name: "pri40", type: new basic_1.CharacterType(1) });
        components.push({ name: "rstrt", type: new basic_1.CharacterType(1) });
        components.push({ name: "wtitl", type: new basic_1.CharacterType(1, { qualifiedName: "sy-wtitl" }) });
        components.push({ name: "cpage", type: basic_1.IntegerType.get() });
        components.push({ name: "dbnam", type: new basic_1.CharacterType(20, { qualifiedName: "sy-dbnam" }) });
        components.push({ name: "mandt", type: new basic_1.CharacterType(3, { qualifiedName: "sy-mandt" }) });
        components.push({ name: "prefx", type: new basic_1.CharacterType(3) });
        components.push({ name: "fmkey", type: new basic_1.CharacterType(3) });
        components.push({ name: "pexpi", type: new basic_1.NumericType(1) });
        components.push({ name: "prini", type: new basic_1.NumericType(1) });
        components.push({ name: "primm", type: new basic_1.CharacterType(1) });
        components.push({ name: "prrel", type: new basic_1.CharacterType(1) });
        components.push({ name: "playo", type: new basic_1.CharacterType(5) });
        components.push({ name: "prbig", type: new basic_1.CharacterType(1) });
        components.push({ name: "playp", type: new basic_1.CharacterType(1) });
        components.push({ name: "prnew", type: new basic_1.CharacterType(1) });
        components.push({ name: "prlog", type: new basic_1.CharacterType(1) });
        components.push({ name: "pdest", type: new basic_1.CharacterType(4, { qualifiedName: "sy-pdest" }) });
        components.push({ name: "plist", type: new basic_1.CharacterType(12) });
        components.push({ name: "pauth", type: new basic_1.NumericType(2) });
        components.push({ name: "prdsn", type: new basic_1.CharacterType(6) });
        components.push({ name: "pnwpa", type: new basic_1.CharacterType(1) });
        components.push({ name: "callr", type: new basic_1.CharacterType(8, { qualifiedName: "sy-callr" }) });
        components.push({ name: "repi2", type: new basic_1.CharacterType(40) });
        components.push({ name: "rtitl", type: new basic_1.CharacterType(70) });
        components.push({ name: "prrec", type: new basic_1.CharacterType(12) });
        components.push({ name: "prtxt", type: new basic_1.CharacterType(68) });
        components.push({ name: "prabt", type: new basic_1.CharacterType(12) });
        components.push({ name: "lpass", type: new basic_1.CharacterType(4) });
        components.push({ name: "nrpag", type: new basic_1.CharacterType(1) });
        components.push({ name: "paart", type: new basic_1.CharacterType(16) });
        components.push({ name: "prcop", type: new basic_1.NumericType(3) });
        components.push({ name: "batzs", type: new basic_1.CharacterType(1) });
        components.push({ name: "bspld", type: new basic_1.CharacterType(1) });
        components.push({ name: "brep4", type: new basic_1.CharacterType(4) });
        components.push({ name: "batzo", type: new basic_1.CharacterType(1) });
        components.push({ name: "batzd", type: new basic_1.CharacterType(1) });
        components.push({ name: "batzw", type: new basic_1.CharacterType(1) });
        components.push({ name: "batzm", type: new basic_1.CharacterType(1) });
        components.push({ name: "ctabl", type: new basic_1.CharacterType(4) });
        components.push({ name: "dbsys", type: new basic_1.CharacterType(10, { qualifiedName: "sy-dbsys" }) });
        components.push({ name: "dcsys", type: new basic_1.CharacterType(4) });
        components.push({ name: "macdb", type: new basic_1.CharacterType(4) });
        components.push({ name: "sysid", type: new basic_1.CharacterType(8, { qualifiedName: "sy-sysid" }) });
        components.push({ name: "opsys", type: new basic_1.CharacterType(10, { qualifiedName: "sy-opsys" }) });
        components.push({ name: "pfkey", type: new basic_1.CharacterType(20, { qualifiedName: "sy-pfkey" }) });
        components.push({ name: "saprl", type: new basic_1.CharacterType(4, { qualifiedName: "sy-saprl" }) });
        components.push({ name: "tcode", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tcode" }) });
        components.push({ name: "ucomm", type: new basic_1.CharacterType(70, { qualifiedName: "sy-ucomm" }) });
        components.push({ name: "cfwae", type: new basic_1.CharacterType(5) });
        components.push({ name: "chwae", type: new basic_1.CharacterType(5) });
        components.push({ name: "spono", type: new basic_1.CharacterType(10, { qualifiedName: "sy-spono" }) });
        components.push({ name: "sponr", type: new basic_1.NumericType(10) });
        components.push({ name: "waers", type: new basic_1.CharacterType(5) });
        components.push({ name: "cdate", type: new basic_1.DateType() });
        components.push({ name: "datum", type: new basic_1.DateType() });
        components.push({ name: "slset", type: new basic_1.CharacterType(14, { qualifiedName: "sy-slset" }) });
        components.push({ name: "subty", type: new basic_1.HexType(1) });
        components.push({ name: "subcs", type: new basic_1.CharacterType(1) });
        components.push({ name: "group", type: new basic_1.CharacterType(1) });
        components.push({ name: "ffile", type: new basic_1.CharacterType(8) });
        components.push({ name: "uzeit", type: new basic_1.TimeType() });
        components.push({ name: "dsnam", type: new basic_1.CharacterType(8) });
        components.push({ name: "tabid", type: new basic_1.CharacterType(8) });
        components.push({ name: "tfdsn", type: new basic_1.CharacterType(8) });
        components.push({ name: "uname", type: new basic_1.CharacterType(12, { qualifiedName: "sy-uname" }) });
        components.push({ name: "lstat", type: new basic_1.CharacterType(16) });
        components.push({ name: "abcde", type: new basic_1.CharacterType(26, { qualifiedName: "sy-abcde" }) });
        components.push({ name: "marky", type: new basic_1.CharacterType(1) });
        components.push({ name: "sfnam", type: new basic_1.CharacterType(30) });
        components.push({ name: "tname", type: new basic_1.CharacterType(30) });
        components.push({ name: "msgli", type: new basic_1.CharacterType(60, { qualifiedName: "sy-msgli" }) });
        components.push({ name: "title", type: new basic_1.CharacterType(70, { qualifiedName: "sy-title" }) });
        components.push({ name: "entry", type: new basic_1.CharacterType(72) });
        components.push({ name: "lisel", type: new basic_1.CharacterType(255, { qualifiedName: "sy-lisel" }) });
        components.push({ name: "uline", type: new basic_1.CharacterType(255, { qualifiedName: "sy-uline" }) });
        components.push({ name: "xcode", type: new basic_1.CharacterType(70) });
        components.push({ name: "cprog", type: new basic_1.CharacterType(40, { qualifiedName: "sy-cprog" }) });
        components.push({ name: "xprog", type: new basic_1.CharacterType(40) });
        components.push({ name: "xform", type: new basic_1.CharacterType(30) });
        components.push({ name: "ldbpg", type: new basic_1.CharacterType(40, { qualifiedName: "sy-ldbpg" }) });
        components.push({ name: "tvar0", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar0" }) });
        components.push({ name: "tvar1", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar1" }) });
        components.push({ name: "tvar2", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar2" }) });
        components.push({ name: "tvar3", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar3" }) });
        components.push({ name: "tvar4", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar4" }) });
        components.push({ name: "tvar5", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar5" }) });
        components.push({ name: "tvar6", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar6" }) });
        components.push({ name: "tvar7", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar7" }) });
        components.push({ name: "tvar8", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar8" }) });
        components.push({ name: "tvar9", type: new basic_1.CharacterType(20, { qualifiedName: "sy-tvar9" }) });
        components.push({ name: "msgid", type: new basic_1.CharacterType(20, { qualifiedName: "sy-msgid" }) });
        components.push({ name: "msgty", type: new basic_1.CharacterType(1, { qualifiedName: "sy-msgty" }) });
        components.push({ name: "msgno", type: new basic_1.NumericType(3, "sy-msgno") });
        components.push({ name: "msgv1", type: new basic_1.CharacterType(50, { qualifiedName: "sy-msgv1" }) });
        components.push({ name: "msgv2", type: new basic_1.CharacterType(50, { qualifiedName: "sy-msgv2" }) });
        components.push({ name: "msgv3", type: new basic_1.CharacterType(50, { qualifiedName: "sy-msgv3" }) });
        components.push({ name: "msgv4", type: new basic_1.CharacterType(50, { qualifiedName: "sy-msgv4" }) });
        components.push({ name: "oncom", type: new basic_1.CharacterType(1) });
        components.push({ name: "vline", type: new basic_1.CharacterType(1, { qualifiedName: "sy-vline" }) });
        components.push({ name: "winsl", type: new basic_1.CharacterType(79) });
        components.push({ name: "staco", type: basic_1.IntegerType.get() });
        components.push({ name: "staro", type: basic_1.IntegerType.get() });
        components.push({ name: "datar", type: new basic_1.CharacterType(1, { qualifiedName: "sy-datar" }) });
        components.push({ name: "host", type: new basic_1.CharacterType(32, { qualifiedName: "sy-host" }) });
        components.push({ name: "locdb", type: new basic_1.CharacterType(1) });
        components.push({ name: "locop", type: new basic_1.CharacterType(1) });
        components.push({ name: "datlo", type: new basic_1.DateType() });
        components.push({ name: "timlo", type: new basic_1.TimeType() });
        components.push({ name: "zonlo", type: new basic_1.CharacterType(6, { qualifiedName: "sy-zonlo" }) });
        const type = new basic_1.StructureType(components);
        const id1 = new tokens_1.Identifier(new position_1.Position(this.row++, 1), "sy");
        const sy = new _typed_identifier_1.TypedIdentifier(id1, BuiltIn.filename, type, ["read_only" /* IdentifierMeta.ReadOnly */, "built-in" /* IdentifierMeta.BuiltIn */]);
        const id2 = new tokens_1.Identifier(new position_1.Position(this.row++, 1), "syst");
        const syst = new _typed_identifier_1.TypedIdentifier(id2, BuiltIn.filename, type, ["read_only" /* IdentifierMeta.ReadOnly */, "built-in" /* IdentifierMeta.BuiltIn */]);
        // https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abennews-610-system.htm
        const id3 = new tokens_1.Identifier(new position_1.Position(this.row++, 1), "sy-repid");
        const syrepid = new _typed_identifier_1.TypedIdentifier(id3, BuiltIn.filename, new basic_1.CharacterType(40, { qualifiedName: "sy-repid" }), ["read_only" /* IdentifierMeta.ReadOnly */, "built-in" /* IdentifierMeta.BuiltIn */]);
        return [sy, syst, syrepid];
    }
    buildConstant(name, type, value) {
        const id = new tokens_1.Identifier(new position_1.Position(this.row++, 1), name);
        if (type === undefined) {
            type = new basic_1.VoidType(name);
        }
        if (value === undefined) {
            value = "'?'";
        }
        return new _typed_identifier_1.TypedIdentifier(id, BuiltIn.filename, type, ["read_only" /* IdentifierMeta.ReadOnly */, "built-in" /* IdentifierMeta.BuiltIn */], value);
    }
}
exports.BuiltIn = BuiltIn;
BuiltIn.filename = "_builtin.prog.abap";
BuiltIn.counter = 1;
BuiltIn.getCache = [];
// todo: "pcre" vs "regex", only one of these parameters are allowed
// todo: "pcre", only possible from 755
BuiltIn.methods = {
    "ABS": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "ACOS": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "ASIN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "ATAN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "BIT-SET": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.IntegerType.get(),
        },
        return: new basic_1.XStringType(),
        version: version_1.Version.v702,
    },
    "BOOLC": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "BOOLX": {
        counter: BuiltIn.counter++,
        mandatory: {
            "bool": basic_1.CLikeType.get(),
        },
        optional: {
            "bit": basic_1.IntegerType.get(),
        },
        return: new basic_1.XStringType(),
        version: version_1.Version.v702,
    },
    "CEIL": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "CHAR_OFF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "add": basic_1.IntegerType.get(),
        },
        optional: {
            "off": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "CHARLEN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
    },
    "CMAX": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val1": basic_1.CLikeType.get(),
            "val2": basic_1.CLikeType.get(),
        },
        optional: {
            "val3": basic_1.CLikeType.get(),
            "val4": basic_1.CLikeType.get(),
            "val5": basic_1.CLikeType.get(),
            "val6": basic_1.CLikeType.get(),
            "val7": basic_1.CLikeType.get(),
            "val9": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "CMIN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val1": basic_1.CLikeType.get(),
            "val2": basic_1.CLikeType.get(),
        },
        optional: {
            "val3": basic_1.CLikeType.get(),
            "val4": basic_1.CLikeType.get(),
            "val5": basic_1.CLikeType.get(),
            "val6": basic_1.CLikeType.get(),
            "val7": basic_1.CLikeType.get(),
            "val9": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "CONCAT_LINES_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "table": new basic_1.TableType(new basic_1.AnyType(), { withHeader: false, keyType: basic_1.TableKeyType.default }),
        },
        optional: {
            "sep": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "CONDENSE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "del": basic_1.CLikeType.get(),
            "from": basic_1.CLikeType.get(),
            "to": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "CONTAINS": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "start": basic_1.CLikeType.get(),
            "end": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: new basic_1.CharacterType(1),
        predicate: true,
        version: version_1.Version.v702,
    },
    "CONTAINS_ANY_NOT_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "start": basic_1.CLikeType.get(),
            "end": basic_1.CLikeType.get(),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        predicate: true,
        return: new basic_1.CharacterType(1), version: version_1.Version.v702,
    },
    "CONTAINS_ANY_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "start": basic_1.CLikeType.get(),
            "end": basic_1.CLikeType.get(),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: new basic_1.CharacterType(1),
        predicate: true,
        version: version_1.Version.v702,
    },
    "COS": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "COSH": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "COUNT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "COUNT_ANY_NOT_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "COUNT_ANY_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "DBMAXLEN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
    },
    "DISTANCE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val1": basic_1.CLikeType.get(),
            "val2": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "ESCAPE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "format": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "EXP": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "FIND": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "FIND_ANY_NOT_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "FIND_ANY_OF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "FIND_END": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "FLOOR": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "FRAC": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "FROM_MIXED": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get()
        },
        optional: {
            "case": new basic_1.CharacterType(1),
            "sep": basic_1.IntegerType.get(),
            "min": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "INSERT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "sub": basic_1.CLikeType.get(),
        },
        optional: {
            "off": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "IPOW": {
        counter: BuiltIn.counter++,
        mandatory: {
            "base": new basic_1.FloatType(),
            "exp": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v740sp02,
    },
    "LINE_EXISTS": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.AnyType(),
        },
        return: new basic_1.CharacterType(1),
        predicate: true,
        version: version_1.Version.v740sp02,
    },
    "LINE_INDEX": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.AnyType(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v740sp02,
    },
    "LINES": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.TableType(new basic_1.AnyType(), { withHeader: false, keyType: basic_1.TableKeyType.default }),
        },
        return: basic_1.IntegerType.get(),
    },
    "LOG": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "LOG10": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "MATCH": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        }, optional: {
            "case": new basic_1.CharacterType(1),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "MATCHES": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "case": new basic_1.CharacterType(1),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
        },
        return: new basic_1.CharacterType(1),
        predicate: true,
        version: version_1.Version.v702,
    },
    "NMAX": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val1": basic_1.CLikeType.get(),
            "val2": basic_1.CLikeType.get(),
        },
        optional: {
            "val3": basic_1.CLikeType.get(),
            "val4": basic_1.CLikeType.get(),
            "val5": basic_1.CLikeType.get(),
            "val6": basic_1.CLikeType.get(),
            "val7": basic_1.CLikeType.get(),
            "val8": basic_1.CLikeType.get(),
            "val9": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "NMIN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val1": basic_1.CLikeType.get(),
            "val2": basic_1.CLikeType.get(),
        },
        optional: {
            "val3": basic_1.CLikeType.get(),
            "val4": basic_1.CLikeType.get(),
            "val5": basic_1.CLikeType.get(),
            "val6": basic_1.CLikeType.get(),
            "val7": basic_1.CLikeType.get(),
            "val8": basic_1.CLikeType.get(),
            "val9": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "NUMOFCHAR": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
    },
    "REPEAT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "occ": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "REPLACE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "with": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "RESCALE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        optional: {
            "dec": basic_1.IntegerType.get(),
            "prec": basic_1.IntegerType.get(),
            "mode": basic_1.IntegerType.get(),
        },
        return: new basic_1.FloatType(),
        version: version_1.Version.v702,
    },
    "REVERSE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "ROUND": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        optional: {
            "dec": basic_1.IntegerType.get(),
            "prec": basic_1.IntegerType.get(),
            "mode": basic_1.IntegerType.get(),
        },
        return: basic_1.IntegerType.get(),
        version: version_1.Version.v702,
    },
    "SEGMENT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "index": basic_1.IntegerType.get(),
        },
        optional: {
            "sep": basic_1.CLikeType.get(),
            "space": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SHIFT_LEFT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "places": basic_1.IntegerType.get(),
            "circular": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SHIFT_RIGHT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "places": basic_1.IntegerType.get(),
            "circular": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SIGN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "SIN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "SINH": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "SQRT": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "STRLEN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.IntegerType.get(),
    },
    "SUBSTRING": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "off": basic_1.IntegerType.get(),
            "len": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SUBSTRING_AFTER": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SUBSTRING_BEFORE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SUBSTRING_FROM": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "SUBSTRING_TO": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "sub": basic_1.CLikeType.get(),
            "regex": basic_1.CLikeType.get(),
            "pcre": basic_1.CLikeType.get(),
            "case": new basic_1.CharacterType(1),
            "len": basic_1.IntegerType.get(),
            "occ": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "TAN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "TANH": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: new basic_1.FloatType(),
    },
    "TO_LOWER": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "TO_MIXED": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        optional: {
            "case": new basic_1.CharacterType(1),
            "sep": basic_1.CLikeType.get(),
            "min": basic_1.IntegerType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "TO_UPPER": {
        counter: BuiltIn.counter++,
        mandatory: { "val": basic_1.CLikeType.get() },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "TRANSLATE": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
            "from": basic_1.CLikeType.get(),
            "to": basic_1.CLikeType.get(),
        },
        return: basic_1.StringType.get(),
        version: version_1.Version.v702,
    },
    "TRUNC": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.FloatType(),
        },
        return: basic_1.IntegerType.get(),
    },
    "UTCLONG_ADD": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.UTCLongType(),
        },
        optional: {
            "days": basic_1.IntegerType.get(),
            "hour": basic_1.IntegerType.get(),
            "minutes": basic_1.IntegerType.get(),
            "seconds": new basic_1.FloatType(),
        },
        return: new basic_1.UTCLongType(),
        version: version_1.Version.v754,
    },
    "UTCLONG_CURRENT": {
        counter: BuiltIn.counter++,
        return: new basic_1.UTCLongType(),
        version: version_1.Version.v754,
    },
    "UTCLONG_DIFF": {
        counter: BuiltIn.counter++,
        mandatory: {
            "high": new basic_1.UTCLongType(),
            "low": new basic_1.UTCLongType(),
        },
        return: new basic_1.FloatType(),
        version: version_1.Version.v754,
    },
    "XSDBOOL": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": basic_1.CLikeType.get(),
        },
        return: new basic_1.CharacterType(1),
        version: version_1.Version.v740sp08,
    },
    "XSTRLEN": {
        counter: BuiltIn.counter++,
        mandatory: {
            "val": new basic_1.XSequenceType(),
        },
        return: basic_1.IntegerType.get(),
    },
};
//# sourceMappingURL=_builtin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CurrentScope = void 0;
const _builtin_1 = __webpack_require__(/*! ./_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const ddic_1 = __webpack_require__(/*! ../../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const spaghetti_scope_1 = __webpack_require__(/*! ./spaghetti_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/spaghetti_scope.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const _scope_type_1 = __webpack_require__(/*! ./_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const syntax_1 = __webpack_require__(/*! ./syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
class CurrentScope {
    static buildDefault(reg, obj) {
        const s = new CurrentScope(reg, obj);
        s.push(_scope_type_1.ScopeType.BuiltIn, _scope_type_1.ScopeType.BuiltIn, new position_1.Position(1, 1), _builtin_1.BuiltIn.filename);
        this.addBuiltIn(s, reg.getConfig().getSyntaxSetttings().globalConstants);
        let name = _scope_type_1.ScopeType.Global;
        if (obj) {
            name = name + "_" + obj.getName();
        }
        s.push(_scope_type_1.ScopeType.Global, name, new position_1.Position(1, 1), name);
        return s;
    }
    static addBuiltIn(s, extras) {
        const b = new _builtin_1.BuiltIn();
        const builtin = b.get(extras);
        s.addList(builtin);
        for (const t of b.getTypes()) {
            s.addType(t);
        }
    }
    constructor(reg, obj) {
        this.current = undefined;
        this.parentObj = obj;
        this.reg = reg;
    }
    ///////////////////////////
    getVersion() {
        return this.reg.getConfig().getVersion();
    }
    getRegistry() {
        return this.reg;
    }
    addType(type) {
        if (type === undefined) {
            return;
        }
        this.addTypeNamed(type.getName(), type);
    }
    addTypeNamed(name, type) {
        if (type === undefined) {
            return;
        }
        if (this.current === undefined) {
            return;
        }
        const upper = name.toUpperCase();
        if (this.current.getData().types[upper] !== undefined) {
            throw new Error(`Type name "${name}" already defined`);
        }
        else if (this.isOO() && this.current.getData().vars[upper] !== undefined) {
            throw new Error(`"${name}" already defined`);
        }
        this.current.getData().types[upper] = type;
    }
    addExtraLikeType(type) {
        if (type === undefined) {
            return;
        }
        this.addExtraLikeTypeNamed(type.getName(), type);
    }
    addExtraLikeTypeNamed(name, type) {
        if (type === undefined) {
            return;
        }
        if (this.current === undefined) {
            return;
        }
        const upper = name.toUpperCase();
        if (this.current.getData().extraLikeTypes[upper] !== undefined) {
            throw new Error(`Type name "${name}" already defined`);
        }
        this.current.getData().extraLikeTypes[upper] = type;
    }
    addClassDefinition(c) {
        if (this.current === undefined) {
            return;
        }
        const name = c.getName().toUpperCase();
        if (this.current.getData().cdefs[name] !== undefined) {
            throw new Error(`Class "${name}" already defined`);
        }
        this.current.getData().cdefs[name] = c;
    }
    addFormDefinitions(f) {
        if (this.current === undefined) {
            return;
        }
        this.current.getData().forms.push(...f);
    }
    addInterfaceDefinition(i) {
        if (this.current === undefined) {
            return;
        }
        const name = i.getName().toUpperCase();
        if (this.current.getData().cdefs[name] !== undefined) {
            throw new Error(`Interface "${name}" already defined`);
        }
        this.current.getData().idefs[name] = i;
    }
    addNamedIdentifier(name, identifier) {
        if (this.current === undefined) {
            return;
        }
        const upper = name.toUpperCase();
        if (this.current.getData().vars[upper] !== undefined) {
            //      console.dir(new Error().stack);
            throw new Error(`Variable name "${name}" already defined`);
        }
        else if (this.isOO() && this.current.getData().types[upper] !== undefined) {
            throw new Error(`"${name}" already defined`);
        }
        this.current.getData().vars[upper] = identifier;
    }
    addNamedIdentifierToParent(name, identifier) {
        if (this.current === undefined) {
            return;
        }
        const parent = this.current.getParent();
        if (parent === undefined) {
            return;
        }
        const upper = name.toUpperCase();
        if (parent.getData().vars[upper] !== undefined) {
            //      console.dir(new Error().stack);
            throw new Error(`Variable name "${name}" already defined`);
        }
        else if (this.isOO() && parent.getData().types[upper] !== undefined) {
            throw new Error(`"${name}" already defined`);
        }
        parent.getData().vars[upper] = identifier;
    }
    addIdentifier(identifier) {
        if (identifier === undefined) {
            return;
        }
        this.addNamedIdentifier(identifier.getName(), identifier);
    }
    addDeferred(token, type) {
        if (token === undefined) {
            return;
        }
        this.current.getData().deferred[token.getStr().toUpperCase()] = { token, ooType: type };
    }
    addListPrefix(identifiers, prefix) {
        for (const id of identifiers) {
            this.addNamedIdentifier(prefix + id.getName(), id);
        }
    }
    addList(identifiers) {
        for (const id of identifiers) {
            this.addIdentifier(id);
        }
    }
    addReference(usage, referencing, type, filename, extra) {
        var _a, _b;
        if (usage === undefined || type === undefined) {
            return;
        }
        const position = new _identifier_1.Identifier(usage, filename);
        if (Array.isArray(type)) {
            for (const t of type) {
                (_a = this.current) === null || _a === void 0 ? void 0 : _a.getData().references.push({ position, resolved: referencing, referenceType: t, extra });
            }
        }
        else {
            (_b = this.current) === null || _b === void 0 ? void 0 : _b.getData().references.push({ position, resolved: referencing, referenceType: type, extra });
        }
    }
    addSQLConversion(fieldName, message, token) {
        var _a;
        (_a = this.current) === null || _a === void 0 ? void 0 : _a.getData().sqlConversion.push({ fieldName, message, token });
    }
    ///////////////////////////
    findFunctionModule(name) {
        if (name === undefined) {
            return undefined;
        }
        for (const fugr of this.reg.getObjectsByType("FUGR")) {
            const func = fugr.getModule(name);
            if (func !== undefined) {
                return func;
            }
        }
        return undefined;
    }
    findObjectDefinition(name) {
        if (name === undefined) {
            return undefined;
        }
        const clas = this.findClassDefinition(name);
        if (clas) {
            return clas;
        }
        const intf = this.findInterfaceDefinition(name);
        if (intf) {
            return intf;
        }
        return undefined;
    }
    isBadiDef(name) {
        const upper = name.toUpperCase();
        for (const enhs of this.reg.getObjectsByType("ENHS")) {
            for (const def of enhs.listBadiDefinitions()) {
                if (def.name.toUpperCase() === upper) {
                    return true;
                }
            }
        }
        return false;
    }
    existsObject(name) {
        var _a, _b, _c;
        if (name === undefined) {
            return undefined;
        }
        let prefixRTTI = "";
        if (this.parentObj.getType() === "PROG") {
            prefixRTTI = "\\PROGRAM=" + this.parentObj.getName();
        }
        else if (this.parentObj.getType() === "CLAS") {
            prefixRTTI = "\\CLASS-POOL=" + this.parentObj.getName();
        }
        const findLocalClass = (_a = this.current) === null || _a === void 0 ? void 0 : _a.findClassDefinition(name);
        if (findLocalClass) {
            if (findLocalClass.isGlobal() === true) {
                prefixRTTI = "";
            }
            return { id: findLocalClass, ooType: "CLAS", RTTIName: prefixRTTI + "\\CLASS=" + findLocalClass.getName() };
        }
        const globalClas = this.reg.getObject("CLAS", name);
        if (globalClas) {
            return { id: globalClas.getIdentifier(), ooType: "CLAS", RTTIName: "\\CLASS=" + globalClas.getName() };
        }
        const findLocalInterface = (_b = this.current) === null || _b === void 0 ? void 0 : _b.findInterfaceDefinition(name);
        if (findLocalInterface) {
            if (findLocalInterface.isGlobal() === true) {
                prefixRTTI = "";
            }
            return { id: findLocalInterface, ooType: "INTF", RTTIName: prefixRTTI + "\\INTERFACE=" + findLocalInterface.getName() };
        }
        const globalIntf = this.reg.getObject("INTF", name);
        if (globalIntf) {
            return { id: globalIntf.getIdentifier(), ooType: "INTF", RTTIName: "\\INTERFACE=" + globalIntf.getName() };
        }
        const def = (_c = this.current) === null || _c === void 0 ? void 0 : _c.findDeferred(name);
        if (def !== undefined) {
            let rttiName = prefixRTTI;
            switch (def.ooType) {
                case "INTF":
                    rttiName = rttiName + "\\INTERFACE=" + name;
                    break;
                default:
                    rttiName = rttiName + "\\CLASS=" + name;
                    break;
            }
            return { id: def.id, ooType: def.ooType, RTTIName: rttiName };
        }
        return undefined;
    }
    ///////////////////////////
    /** Lookup class in local and global scope */
    findClassDefinition(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        const clocal = (_a = this.current) === null || _a === void 0 ? void 0 : _a.findClassDefinition(name);
        if (clocal) {
            return clocal;
        }
        const cglobal = this.reg.getObject("CLAS", name);
        if (cglobal) {
            return cglobal.getDefinition();
        }
        return undefined;
    }
    findTypePoolConstant(name) {
        var _a;
        if (name === undefined || name.includes("_") === undefined) {
            return undefined;
        }
        const typePoolName = name.split("_")[0];
        if (typePoolName.length <= 1 || typePoolName.length > 5) {
            return undefined;
        }
        if (this.parentObj.getType() === "TYPE"
            && this.parentObj.getName().toUpperCase() === typePoolName.toUpperCase()) {
            // dont recurse into itself
            return undefined;
        }
        const typePool = this.reg.getObject("TYPE", typePoolName);
        if (typePool === undefined) {
            return undefined;
        }
        const spag = (_a = new syntax_1.SyntaxLogic(this.reg, typePool).run().spaghetti.getFirstChild()) === null || _a === void 0 ? void 0 : _a.getFirstChild();
        const found = spag === null || spag === void 0 ? void 0 : spag.findVariable(name);
        return found;
    }
    findTypePoolType(name) {
        var _a;
        if (name.includes("_") === undefined) {
            return undefined;
        }
        const typePoolName = name.split("_")[0];
        if (typePoolName.length <= 2 || typePoolName.length > 5) {
            return undefined;
        }
        if (this.parentObj.getType() === "TYPE"
            && this.parentObj.getName().toUpperCase() === typePoolName.toUpperCase()) {
            // dont recurse into itself
            return undefined;
        }
        if (new ddic_1.DDIC(this.reg).lookupNoVoid(name) !== undefined) {
            // this is tricky, it should not do recursion when parsing the type pool itself,
            // think about DTEL ABAP_ENCOD vs TYPE ABAP
            return undefined;
        }
        const typePool = this.reg.getObject("TYPE", typePoolName);
        if (typePool === undefined) {
            return undefined;
        }
        const spag = (_a = new syntax_1.SyntaxLogic(this.reg, typePool).run().spaghetti.getFirstChild()) === null || _a === void 0 ? void 0 : _a.getFirstChild();
        const found = spag === null || spag === void 0 ? void 0 : spag.findType(name);
        return found;
    }
    /** Lookup interface in local and global scope */
    findInterfaceDefinition(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        const ilocal = (_a = this.current) === null || _a === void 0 ? void 0 : _a.findInterfaceDefinition(name);
        if (ilocal) {
            return ilocal;
        }
        const iglobal = this.reg.getObject("INTF", name);
        if (iglobal) {
            return iglobal.getDefinition();
        }
        return undefined;
    }
    findFormDefinition(name) {
        var _a;
        return (_a = this.current) === null || _a === void 0 ? void 0 : _a.findFormDefinition(name);
    }
    findType(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        return (_a = this.current) === null || _a === void 0 ? void 0 : _a.findType(name);
    }
    findExtraLikeType(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        return (_a = this.current) === null || _a === void 0 ? void 0 : _a.findExtraLikeType(name);
    }
    findVariable(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        const found = (_a = this.current) === null || _a === void 0 ? void 0 : _a.findVariable(name);
        if (found) {
            return found;
        }
        return this.findTypePoolConstant(name);
    }
    ///////////////////////////
    getDDIC() {
        return new ddic_1.DDIC(this.reg);
    }
    getDDICReferences() {
        return this.reg.getDDICReferences();
    }
    getMSAGReferences() {
        return this.reg.getMSAGReferences();
    }
    getParentObj() {
        return this.parentObj;
    }
    getName() {
        if (this.current === undefined) {
            throw new Error("error, getName");
        }
        return this.current.getIdentifier().sname;
    }
    getType() {
        if (this.current === undefined) {
            throw new Error("error, getType");
        }
        return this.current.getIdentifier().stype;
    }
    push(stype, sname, start, filename) {
        const identifier = { stype, sname, start, filename, end: undefined };
        //    console.dir("push scope, " + stype);
        if (this.current === undefined) {
            // the top node
            this.current = new spaghetti_scope_1.SpaghettiScopeNode(identifier, undefined);
        }
        else {
            const parent = this.current;
            this.current = new spaghetti_scope_1.SpaghettiScopeNode(identifier, parent);
            parent.addChild(this.current);
        }
    }
    isOO() {
        let curr = this.current;
        while (curr !== undefined) {
            const stype = curr.getIdentifier().stype;
            if (stype === _scope_type_1.ScopeType.ClassDefinition
                //          || stype === ScopeType.ClassImplementation
                || stype === _scope_type_1.ScopeType.Interface) {
                return true;
            }
            curr = curr.getParent();
        }
        return false;
    }
    isGlobalOO() {
        return this.parentObj.getType() === "INTF" || this.parentObj.getType() === "CLAS";
    }
    isTypePool() {
        var _a;
        return ((_a = this.current) === null || _a === void 0 ? void 0 : _a.getIdentifier().filename.endsWith(".type.abap")) === true || false;
    }
    setAllowHeaderUse(name) {
        // workaround for SELECT FOR ALL ENTRIES
        this.allowHeaderUse = name;
    }
    isAllowHeaderUse(name) {
        var _a;
        return name.toUpperCase() === ((_a = this.allowHeaderUse) === null || _a === void 0 ? void 0 : _a.toUpperCase());
    }
    pop(end) {
        //    console.dir("pop scope, " + this.current?.getIdentifier().stype);
        this.allowHeaderUse = undefined;
        if (this.current === undefined) {
            throw new Error("something wrong, top scope popped");
        }
        this.current.setEnd(end);
        const current = this.current;
        this.current = this.current.getParent();
        return new spaghetti_scope_1.SpaghettiScope(current);
    }
}
exports.CurrentScope = CurrentScope;
//# sourceMappingURL=_current_scope.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectOriented = void 0;
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
// todo, think some of the public methods can be made private
// todo: changet this class to static? for performance
class ObjectOriented {
    constructor(scope) {
        this.scope = scope;
    }
    fromInterfaceByName(name, ignore) {
        const idef = this.scope.findInterfaceDefinition(name);
        if (idef === undefined || ignore.includes(name.toUpperCase())) {
            return [];
        }
        const ret = [name.toUpperCase()];
        for (const t of idef.getTypeDefinitions().getAll()) {
            const n = name + "~" + t.type.getName();
            this.scope.addTypeNamed(n, t.type);
        }
        this.scope.addListPrefix(idef.getAttributes().getConstants(), name + "~");
        this.scope.addListPrefix(idef.getAttributes().getStatic(), name + "~");
        this.scope.addListPrefix(idef.getAttributes().getInstance(), name + "~");
        for (const i of idef.getImplementing()) {
            if (ignore.includes(i.name.toUpperCase())) {
                continue;
            }
            ret.push(...this.fromInterfaceByName(i.name, ignore));
            ignore.push(i.name.toUpperCase());
            ret.push(i.name.toUpperCase());
        }
        return ret;
    }
    addAliasedAttributes(classDefinition) {
        for (const alias of classDefinition.getAliases()) {
            const comp = alias.getComponent();
            const idef = this.scope.findInterfaceDefinition(comp.split("~")[0]);
            if (idef) {
                const found = idef.getAttributes().findByName(comp.split("~")[1]);
                if (found) {
                    this.scope.addNamedIdentifier(alias.getName(), found);
                }
            }
        }
        const superName = classDefinition.getSuperClass();
        if (superName !== undefined) {
            const def = this.scope.findClassDefinition(superName);
            if (def) {
                this.addAliasedAttributes(def);
            }
        }
    }
    findMethodInInterface(interfaceName, methodName) {
        const idef = this.scope.findInterfaceDefinition(interfaceName);
        if (idef) {
            const methods = idef.getMethodDefinitions().getAll();
            for (const method of methods) {
                if (method.getName().toUpperCase() === methodName.toUpperCase()) {
                    return { method, def: idef };
                }
            }
            return this.findMethodViaAlias(methodName, idef);
        }
        return undefined;
    }
    findMethodViaAlias(methodName, def) {
        for (const a of def.getAliases()) {
            if (a.getName().toUpperCase() === methodName.toUpperCase()) {
                const comp = a.getComponent();
                const res = this.findMethodInInterface(comp.split("~")[0], comp.split("~")[1]);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
    methodReferenceExtras(foundDef, ooName) {
        if (foundDef === undefined) {
            return {
                ooName: ooName,
                ooType: undefined,
            };
        }
        return {
            ooName: foundDef === null || foundDef === void 0 ? void 0 : foundDef.getName(),
            ooType: foundDef instanceof types_1.ClassDefinition ? "CLAS" : "INTF",
        };
    }
    findClassName(node) {
        if (!(node.get() instanceof Statements.ClassImplementation
            || node.get() instanceof Statements.ClassDefinition)) {
            throw new Error("findClassName, unexpected node type");
        }
        const className = node.findFirstExpression(Expressions.ClassName);
        if (className === undefined) {
            throw new Error("findClassName, unexpected node type");
        }
        return className.getFirstToken().getStr();
    }
    findInterfaces(cd) {
        var _a;
        const ret = [...cd.getImplementing()];
        for (const r of ret) {
            const nested = (_a = this.scope.findInterfaceDefinition(r.name)) === null || _a === void 0 ? void 0 : _a.getImplementing();
            if (nested) {
                ret.push(...nested);
            }
        }
        const sup = cd.getSuperClass();
        if (sup) {
            try {
                ret.push(...this.findInterfaces(this.findSuperDefinition(sup)));
            }
            catch (_b) {
                // ignore errors, they will show up as variable not found anyhow
            }
        }
        return ret;
    }
    searchEvent(def, name) {
        if (def === undefined || name === undefined) {
            return undefined;
        }
        const found = def.getEvents().find(e => e.getName().toUpperCase() === (name === null || name === void 0 ? void 0 : name.toUpperCase()));
        if (found) {
            return found;
        }
        for (const a of def.getAliases() || []) {
            if (a.getName().toUpperCase() === name.toUpperCase()) {
                const comp = a.getComponent();
                const res = this.searchEvent(this.scope.findObjectDefinition(comp.split("~")[0]), comp.split("~")[1]);
                if (res) {
                    return res;
                }
            }
        }
        const sup = def.getSuperClass();
        if (sup) {
            return this.searchEvent(this.findSuperDefinition(sup), name);
        }
        return undefined;
    }
    // search in via super class, interfaces and aliases
    searchAttributeName(def, name) {
        if (def === undefined || name === undefined) {
            return undefined;
        }
        const upper = name.toUpperCase();
        for (const a of def.getAttributes().getAll()) {
            if (a.getName().toUpperCase() === upper) {
                return a;
            }
        }
        for (const a of def.getAliases() || []) {
            if (a.getName().toUpperCase() === upper) {
                const comp = a.getComponent();
                const res = this.searchAttributeName(this.scope.findObjectDefinition(comp.split("~")[0]), comp.split("~")[1]);
                if (res) {
                    return res;
                }
            }
        }
        if (name.includes("~")) {
            const interfaceName = upper.split("~")[0];
            if (this.listInterfacesRecursive(def).includes(interfaceName)) {
                return this.searchAttributeName(this.scope.findInterfaceDefinition(interfaceName), name.split("~")[1]);
            }
        }
        const sup = def.getSuperClass();
        if (sup) {
            return this.searchAttributeName(this.findSuperDefinition(sup), name);
        }
        return undefined;
    }
    // search in via super class, interfaces and aliases
    searchTypeName(def, name) {
        if (def === undefined || name === undefined) {
            return undefined;
        }
        const search = def.getTypeDefinitions().getByName(name);
        if (search) {
            return search;
        }
        if (name.includes("~")) {
            const interfaceName = name.split("~")[0];
            if (def.getImplementing().some((a) => a.name.toUpperCase() === interfaceName.toUpperCase())) {
                return this.searchTypeName(this.scope.findInterfaceDefinition(interfaceName), name.split("~")[1]);
            }
        }
        const sup = def.getSuperClass();
        if (sup) {
            return this.searchTypeName(this.findSuperDefinition(sup), name);
        }
        return undefined;
    }
    // search in via super class, interfaces and aliases
    searchConstantName(def, name) {
        if (def === undefined || name === undefined) {
            return undefined;
        }
        const upper = name.toUpperCase();
        for (const a of def.getAttributes().getConstants()) {
            if (a.getName().toUpperCase() === upper) {
                return a;
            }
        }
        for (const a of def.getAliases()) {
            if (a.getName().toUpperCase() === upper) {
                const comp = a.getComponent();
                const res = this.searchConstantName(this.scope.findObjectDefinition(comp.split("~")[0]), comp.split("~")[1]);
                if (res) {
                    return res;
                }
            }
        }
        if (name.includes("~")) {
            const interfaceName = upper.split("~")[0];
            if (def.getImplementing().some((a) => a.name.toUpperCase() === interfaceName)) {
                return this.searchConstantName(this.scope.findInterfaceDefinition(interfaceName), name.split("~")[1]);
            }
        }
        const sup = def.getSuperClass();
        if (sup) {
            return this.searchConstantName(this.findSuperDefinition(sup), name);
        }
        return undefined;
    }
    // search in via super class, interfaces and aliases
    searchMethodName(def, name) {
        if (def === undefined || name === undefined) {
            return { method: undefined, def: undefined };
        }
        const methodDefinition = this.findMethod(def, name);
        if (methodDefinition) {
            return { method: methodDefinition, def };
        }
        let interfaceName = undefined;
        if (name.includes("~")) {
            interfaceName = name.split("~")[0];
            if (interfaceName && this.findInterfaces(def).some(i => i.name.toUpperCase() === (interfaceName === null || interfaceName === void 0 ? void 0 : interfaceName.toUpperCase())) === false) {
                return { method: undefined, def: undefined };
            }
        }
        // todo, this is not completely correct? hmm, why? visibility?
        if (methodDefinition === undefined && interfaceName) {
            name = name.split("~")[1];
            const found = this.findMethodInInterface(interfaceName, name);
            if (found) {
                return found;
            }
        }
        else if (methodDefinition === undefined) {
            const found = this.findMethodViaAlias(name, def);
            if (found) {
                return found;
            }
        }
        const sup = def.getSuperClass();
        if (methodDefinition === undefined && sup) {
            return this.searchMethodName(this.findSuperDefinition(sup), name);
        }
        return { method: undefined, def: undefined };
    }
    findMethod(def, methodName) {
        for (const method of def.getMethodDefinitions().getAll()) {
            if (method.getName().toUpperCase() === methodName.toUpperCase()) {
                if (method.isRedefinition()) {
                    return this.findMethodInSuper(def, methodName);
                }
                else {
                    return method;
                }
            }
        }
        return undefined;
    }
    findMethodInSuper(child, methodName) {
        let sup = child.getSuperClass();
        while (sup !== undefined) {
            const cdef = this.findSuperDefinition(sup);
            const found = this.findMethod(cdef, methodName);
            if (found) {
                return found;
            }
            sup = cdef.getSuperClass();
        }
        return undefined;
    }
    findSuperDefinition(name) {
        const csup = this.scope.findClassDefinition(name);
        if (csup === undefined) {
            throw new Error("Super class \"" + name + "\" not found or contains errors");
        }
        return csup;
    }
    fromSuperClassesAndInterfaces(child) {
        const implemented = this.fromSuperClasses(child);
        this.fromInterfaces(child, implemented);
    }
    // returns list of interfaces implemented
    fromSuperClasses(child) {
        let sup = child.getSuperClass();
        const ignore = [];
        while (sup !== undefined) {
            const cdef = this.findSuperDefinition(sup);
            for (const a of cdef.getAttributes().getAll()) {
                if (a.getVisibility() !== visibility_1.Visibility.Private) {
                    this.scope.addIdentifier(a);
                    // todo, handle scope and instance vs static
                }
            }
            for (const c of cdef.getAttributes().getConstants()) {
                if (c.getVisibility() !== visibility_1.Visibility.Private) {
                    this.scope.addIdentifier(c);
                }
            }
            for (const t of cdef.getTypeDefinitions().getAll()) {
                if (t.visibility !== visibility_1.Visibility.Private) {
                    this.scope.addType(t.type);
                }
            }
            ignore.push(...this.fromInterfaces(cdef, ignore));
            sup = cdef.getSuperClass();
        }
        return ignore;
    }
    /** returns list of interfaces implemented, recursive */
    listInterfacesRecursive(definition) {
        const list = [];
        for (const i of definition.getImplementing()) {
            const upper = i.name.toUpperCase();
            list.push(upper);
            const def = this.scope.findInterfaceDefinition(upper);
            if (def) {
                list.push(...this.listInterfacesRecursive(def));
            }
        }
        return [...new Set(list)];
    }
    fromInterfaces(definition, skip) {
        const ignore = [];
        for (const i of definition.getImplementing()) {
            ignore.push(...this.fromInterfaceByName(i.name, ignore.concat(skip || [])));
        }
        return ignore;
    }
}
exports.ObjectOriented = ObjectOriented;
//# sourceMappingURL=_object_oriented.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_procedural.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_procedural.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Procedural = void 0;
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const _current_scope_1 = __webpack_require__(/*! ./_current_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js");
const _scope_type_1 = __webpack_require__(/*! ./_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const objects_1 = __webpack_require__(/*! ../../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _object_oriented_1 = __webpack_require__(/*! ./_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _reference_1 = __webpack_require__(/*! ./_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class Procedural {
    constructor(reg, scope) {
        this.scope = scope;
        this.reg = reg;
    }
    addAllFormDefinitions(file, obj) {
        const structure = file.getStructure();
        if (structure) {
            const input = {
                scope: _current_scope_1.CurrentScope.buildDefault(this.reg, obj),
                filename: file.getFilename(),
                issues: [],
            };
            for (const found of structure.findAllStructures(Structures.Form)) {
                this.scope.addFormDefinitions([new types_1.FormDefinition(found, input)]);
            }
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return;
        }
        const includes = stru.findAllStatements(Statements.Include);
        for (const node of includes) {
            const found = this.findInclude(node, obj);
            if (found) {
                this.addAllFormDefinitions(found, obj);
            }
        }
    }
    findInclude(node, obj) {
        // assumption: no cyclic includes, includes not found are reported by rule "check_include"
        // todo: how to make sure code is not duplicated here and in rule "check_include" / include graph?
        const expr = node.findFirstExpression(Expressions.IncludeName);
        if (expr === undefined) {
            return undefined;
        }
        const name = expr.getFirstToken().getStr();
        // look in the current function group
        if (obj instanceof objects_1.FunctionGroup) {
            const incl = obj.getInclude(name);
            if (incl !== undefined) {
                return incl;
            }
        }
        const prog = this.reg.getObject("PROG", name);
        if (prog !== undefined) {
            return prog.getABAPFiles()[0];
        }
        // todo, this is slow, try determining the FUGR name from the include name
        for (const fugr of this.reg.getObjectsByType("FUGR")) {
            if (fugr instanceof objects_1.FunctionGroup) {
                const found = fugr.getInclude(name);
                if (found) {
                    return found;
                }
            }
        }
        return undefined;
    }
    findFunctionScope(obj, node, filename) {
        var _a, _b, _c, _d, _e;
        if (!(obj instanceof objects_1.FunctionGroup)) {
            throw new Error("findFunctionScope, expected function group input");
        }
        const nameToken = node.findFirstExpression(Expressions.Field).getFirstToken();
        const name = nameToken.getStr();
        this.scope.push(_scope_type_1.ScopeType.FunctionModule, name, node.getFirstToken().getStart(), filename);
        const definition = obj.getModule(name);
        if (definition === undefined) {
            throw new Error("Function module definition \"" + name + "\" not found");
        }
        const ddic = new ddic_1.DDIC(this.reg);
        const allNames = new Set();
        for (const param of definition.getParameters()) {
            let found = undefined;
            if (param.type === undefined || param.type === "") {
                found = new basic_1.AnyType();
            }
            else if (param.type.includes("=>")) {
                // then its a type from global INTF or CLAS
                const [clas, name] = param.type.split("=>");
                const def = this.scope.findObjectDefinition(clas);
                if (def) {
                    const type = def.getTypeDefinitions().getByName(name);
                    if (type) {
                        this.scope.addReference(nameToken, type, _reference_1.ReferenceType.TypeReference, filename);
                        found = type.getType();
                    }
                }
            }
            if (found === undefined) {
                found = ddic.lookup(param.type).type;
            }
            if (param.direction === types_1.FunctionModuleParameterDirection.tables) {
                if (found instanceof basic_1.TableType) {
                    found = new basic_1.TableType(found.getRowType(), { withHeader: true, keyType: basic_1.TableKeyType.default });
                }
                else {
                    found = new basic_1.TableType(found, { withHeader: true, keyType: basic_1.TableKeyType.default });
                }
            }
            if ((found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) && ((_a = param.type) === null || _a === void 0 ? void 0 : _a.includes("-"))) {
                const [name, field] = param.type.split("-");
                const f = ddic.lookupTableOrView(name).type;
                if (f && f instanceof basic_1.StructureType) {
                    const c = f.getComponentByName(field);
                    if (c) {
                        found = c;
                    }
                }
                if (found === undefined || found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) {
                    const f = (_b = this.scope.findType(name)) === null || _b === void 0 ? void 0 : _b.getType();
                    if (f && f instanceof basic_1.StructureType) {
                        const c = f.getComponentByName(field);
                        if (c) {
                            found = c;
                        }
                    }
                }
            }
            else if ((found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) && ((_c = param.type) === null || _c === void 0 ? void 0 : _c.includes("=>"))) {
                const [name, field] = param.type.split("=>");
                const def = this.scope.findObjectDefinition(name);
                const c = new _object_oriented_1.ObjectOriented(this.scope).searchTypeName(def, field);
                if (c) {
                    found = c.getType();
                }
            }
            if ((found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) && param.type) {
                const f = ddic.lookupBuiltinType(param.type);
                if (f) {
                    found = f;
                }
                if (found === undefined || found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) {
                    const f = (_d = this.scope.findType(param.type)) === null || _d === void 0 ? void 0 : _d.getType();
                    if (f) {
                        found = f;
                    }
                }
                if (found === undefined || found instanceof basic_1.UnknownType || found instanceof basic_1.VoidType) {
                    const f = (_e = this.scope.findTypePoolType(param.type)) === null || _e === void 0 ? void 0 : _e.getType();
                    if (f) {
                        found = f;
                    }
                }
            }
            if (found instanceof basic_1.UnknownType && new ddic_1.DDIC(this.reg).inErrorNamespace(param.type) === false) {
                found = new basic_1.VoidType(param.type);
            }
            if (allNames.has(param.name.toUpperCase())) {
                // yea, IMPORTING and EXPORTING can have the same name
                // workaround to avoid false postivies, can be improved
                continue;
            }
            else {
                const type = new _typed_identifier_1.TypedIdentifier(nameToken, filename, found);
                this.scope.addNamedIdentifier(param.name, type);
                allNames.add(param.name.toUpperCase());
            }
        }
    }
}
exports.Procedural = Procedural;
//# sourceMappingURL=_procedural.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReferenceType = void 0;
var ReferenceType;
(function (ReferenceType) {
    /** for classes and interface references */
    ReferenceType["ObjectOrientedReference"] = "Object";
    ReferenceType["ObjectOrientedVoidReference"] = "Object (Void)";
    ReferenceType["ObjectOrientedUnknownReference"] = "Object (Unknown)";
    ReferenceType["TableReference"] = "Table";
    ReferenceType["TableVoidReference"] = "Table (Void)";
    ReferenceType["MethodReference"] = "Method";
    ReferenceType["BuiltinMethodReference"] = "Builtin Method";
    ReferenceType["MethodImplementationReference"] = "Method Implementation";
    ReferenceType["TypeReference"] = "Type";
    ReferenceType["BuiltinTypeReference"] = "Builtin Type";
    ReferenceType["VoidType"] = "Type (Void)";
    ReferenceType["InferredType"] = "Inferred Type";
    ReferenceType["FormReference"] = "Form";
    //  FormVoidReference = "Form (void)",
    ReferenceType["DataReadReference"] = "Read From";
    ReferenceType["DataWriteReference"] = "Write To";
})(ReferenceType || (exports.ReferenceType = ReferenceType = {}));
//# sourceMappingURL=_reference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScopeType = void 0;
var ScopeType;
(function (ScopeType) {
    ScopeType["BuiltIn"] = "_builtin";
    ScopeType["Dummy"] = "_dummy";
    ScopeType["Global"] = "_global";
    ScopeType["Program"] = "_program";
    ScopeType["TypePool"] = "_type_pool";
    ScopeType["FunctionGroup"] = "_function_group";
    ScopeType["ClassDefinition"] = "class_definition";
    ScopeType["Interface"] = "interface";
    ScopeType["ClassImplementation"] = "class_implementation";
    ScopeType["Form"] = "form";
    ScopeType["FunctionModule"] = "function";
    ScopeType["Method"] = "method";
    ScopeType["MethodInstance"] = "method_instance";
    ScopeType["MethodDefinition"] = "method_definition";
    ScopeType["For"] = "for";
    ScopeType["Let"] = "let";
    ScopeType["OpenSQL"] = "open_sql";
})(ScopeType || (exports.ScopeType = ScopeType = {}));
//# sourceMappingURL=_scope_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckSyntaxKey = void 0;
exports.syntaxIssue = syntaxIssue;
const issue_1 = __webpack_require__(/*! ../../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const severity_1 = __webpack_require__(/*! ../../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
exports.CheckSyntaxKey = "check_syntax";
function syntaxIssue(input, token, message) {
    return issue_1.Issue.atTokenFilename(input.filename, token, message, exports.CheckSyntaxKey, severity_1.Severity.Error);
}
//# sourceMappingURL=_syntax_input.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeUtils = void 0;
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const basic_1 = __webpack_require__(/*! ../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const cgeneric_type_1 = __webpack_require__(/*! ../types/basic/cgeneric_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/cgeneric_type.js");
// todo: refactor to static? for performance
class TypeUtils {
    constructor(scope) {
        this.scope = scope;
    }
    isCharLikeStrict(type) {
        if (type === undefined) {
            return false;
        }
        else if (type instanceof basic_1.StructureType) {
            for (const c of type.getComponents()) {
                if (this.isCharLikeStrict(c.type) === false) {
                    return false;
                }
            }
            return true;
        }
        else if (type instanceof basic_1.TableType && type.isWithHeader()) {
            return this.isCharLikeStrict(type.getRowType());
        }
        else if (type instanceof basic_1.StringType
            || type instanceof basic_1.AnyType
            || type instanceof basic_1.DataType
            || type instanceof basic_1.CharacterType
            || type instanceof basic_1.SimpleType
            || type instanceof cgeneric_type_1.CGenericType
            || type instanceof basic_1.CLikeType
            || type instanceof basic_1.DateType
            || type instanceof basic_1.CSequenceType
            || type instanceof basic_1.NumericGenericType
            || type instanceof basic_1.NumericType
            || type instanceof basic_1.TimeType
            || type instanceof basic_1.UnknownType
            || type instanceof basic_1.VoidType) {
            return true;
        }
        return false;
    }
    isCharLike(type) {
        if (type === undefined) {
            return false;
        }
        else if (type instanceof basic_1.TableType && type.isWithHeader()) {
            return this.isCharLike(type.getRowType());
        }
        else if (type instanceof basic_1.StructureType) {
            for (const c of type.getComponents()) {
                if (this.isCharLike(c.type) === false) {
                    return false;
                }
            }
            return true;
        }
        else if (type instanceof basic_1.StringType
            || type instanceof basic_1.CharacterType
            || type instanceof basic_1.VoidType
            || type instanceof basic_1.AnyType
            || type instanceof basic_1.UnknownType
            || type instanceof basic_1.NumericType
            || type instanceof basic_1.IntegerType
            || type instanceof basic_1.Integer8Type
            || type instanceof basic_1.SimpleType
            || type instanceof basic_1.FloatType
            || type instanceof basic_1.FloatingPointType
            || type instanceof basic_1.DecFloatType
            || type instanceof basic_1.DecFloat16Type
            || type instanceof basic_1.DecFloat34Type
            || type instanceof basic_1.NumericGenericType
            || type instanceof basic_1.CSequenceType
            || type instanceof cgeneric_type_1.CGenericType
            || type instanceof basic_1.DateType
            || type instanceof basic_1.DataType
            || type instanceof basic_1.CLikeType
            || type instanceof basic_1.PackedType
            || type instanceof basic_1.TimeType) {
            return true;
        }
        return false;
    }
    isHexLike(type) {
        if (type === undefined) {
            return false;
        }
        else if (type instanceof basic_1.StructureType) {
            for (const c of type.getComponents()) {
                if (this.isHexLike(c.type) === false) {
                    return false;
                }
            }
            return true;
        }
        else if (type instanceof basic_1.TableType && type.isWithHeader()) {
            return this.isHexLike(type.getRowType());
        }
        else if (type instanceof basic_1.XStringType
            || type instanceof basic_1.HexType
            || type instanceof basic_1.VoidType
            || type instanceof basic_1.XGenericType
            || type instanceof basic_1.XSequenceType
            || type instanceof basic_1.AnyType
            || type instanceof basic_1.UnknownType) {
            return true;
        }
        return false;
    }
    isOOAssignable(source, target) {
        let sid = source.getIdentifier();
        let tid = target.getIdentifier();
        const tname = tid.getName().toUpperCase();
        const sname = sid.getName().toUpperCase();
        if (tname === sname) {
            return true;
        }
        /*
            console.dir(sid);
            console.dir(tid);
        */
        if (!(sid instanceof types_1.ClassDefinition || sid instanceof types_1.InterfaceDefinition)) {
            const found = this.scope.findObjectDefinition(sid.getName());
            if (found) {
                sid = found;
            }
            else {
                return false;
            }
        }
        if (!(tid instanceof types_1.ClassDefinition || tid instanceof types_1.InterfaceDefinition)) {
            const found = this.scope.findObjectDefinition(tid.getName());
            if (found) {
                tid = found;
            }
            else {
                return false;
            }
        }
        if (sid instanceof types_1.ClassDefinition && tid instanceof types_1.ClassDefinition) {
            if (sname === tname) {
                return true;
            }
            const slist = this.listAllSupers(sid);
            if (slist.indexOf(tname) >= 0) {
                return true;
            }
        }
        else if (sid instanceof types_1.ClassDefinition && tid instanceof types_1.InterfaceDefinition) {
            if (sid.getImplementing().some(i => i.name === tname)) {
                return true;
            }
            const slist = this.listAllInterfaces(sid);
            if (slist.indexOf(tname) >= 0) {
                return true;
            }
        }
        else if (sid instanceof types_1.InterfaceDefinition && tid instanceof types_1.InterfaceDefinition) {
            if (sname === tname) {
                return true;
            }
            if (sid.getImplementing().some(i => i.name === tname)) {
                return true;
            }
            const slist = this.listAllInterfaces(sid);
            if (slist.indexOf(tname) >= 0) {
                return true;
            }
        }
        return false;
    }
    listAllInterfaces(cdef) {
        var _a;
        const ret = new Set();
        const stack = [];
        // initialize
        cdef.getImplementing().forEach(i => stack.push(i.name));
        if (cdef instanceof types_1.ClassDefinition) {
            const supers = this.listAllSupers(cdef);
            for (const s of supers) {
                (_a = this.scope.findClassDefinition(s)) === null || _a === void 0 ? void 0 : _a.getImplementing().forEach(i => stack.push(i.name));
            }
        }
        // main loop
        while (stack.length > 0) {
            const intf = stack.pop().toUpperCase();
            ret.add(intf);
            const idef = this.scope.findInterfaceDefinition(intf);
            idef === null || idef === void 0 ? void 0 : idef.getImplementing().forEach(i => stack.push(i.name));
        }
        return Array.from(ret.values());
    }
    listAllSupers(cdef) {
        var _a, _b;
        const ret = [];
        let sup = cdef.getSuperClass();
        while (sup !== undefined) {
            ret.push(sup === null || sup === void 0 ? void 0 : sup.toUpperCase());
            sup = (_b = (_a = this.scope.findClassDefinition(sup)) === null || _a === void 0 ? void 0 : _a.getSuperClass()) === null || _b === void 0 ? void 0 : _b.toUpperCase();
        }
        return ret;
    }
    isCastable(_source, _target) {
        // todo
        return true;
    }
    structureContainsString(structure) {
        for (const c of structure.getComponents()) {
            if (c.type instanceof basic_1.StringType) {
                return true;
            }
        }
        return false;
    }
    structureContainsVoid(structure) {
        for (const c of structure.getComponents()) {
            if (c.type instanceof basic_1.VoidType) {
                return true;
            }
        }
        return false;
    }
    isAssignableStrict(source, target, calculated = false) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        /*
            console.dir(source);
            console.dir(target);
            console.dir(calculated);
        */
        if (calculated && source instanceof basic_1.StringType && target instanceof basic_1.XStringType) {
            return false;
        }
        if (calculated) {
            return this.isAssignable(source, target);
        }
        if (source instanceof basic_1.CharacterType) {
            if (target instanceof basic_1.CharacterType) {
                if (((_a = source.getAbstractTypeData()) === null || _a === void 0 ? void 0 : _a.derivedFromConstant) === true) {
                    return source.getLength() <= target.getLength();
                }
                return source.getLength() === target.getLength();
            }
            else if (target instanceof basic_1.IntegerType) {
                if (((_b = source.getAbstractTypeData()) === null || _b === void 0 ? void 0 : _b.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
            else if (target instanceof basic_1.StringType) {
                if (((_c = source.getAbstractTypeData()) === null || _c === void 0 ? void 0 : _c.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
        }
        else if (source instanceof basic_1.HexType) {
            if (target instanceof basic_1.HexType) {
                if (((_d = source.getAbstractTypeData()) === null || _d === void 0 ? void 0 : _d.derivedFromConstant) === true) {
                    return source.getLength() <= target.getLength();
                }
                return source.getLength() === target.getLength();
            }
            else if (target instanceof basic_1.XStringType) {
                return false;
            }
            else if (target instanceof basic_1.IntegerType || target instanceof basic_1.Integer8Type) {
                if (((_e = source.getAbstractTypeData()) === null || _e === void 0 ? void 0 : _e.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
        }
        else if (source instanceof basic_1.StringType) {
            if (target instanceof basic_1.StructureType && this.structureContainsString(target)) {
                return false;
            }
            else if (target instanceof basic_1.IntegerType) {
                if (((_f = source.getAbstractTypeData()) === null || _f === void 0 ? void 0 : _f.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
            else if (target instanceof cgeneric_type_1.CGenericType
                || target instanceof basic_1.GenericObjectReferenceType) {
                return false;
            }
            else if (target instanceof basic_1.XSequenceType || target instanceof basic_1.XStringType) {
                if (((_g = source.getAbstractTypeData()) === null || _g === void 0 ? void 0 : _g.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
            return true;
        }
        else if (source instanceof basic_1.StructureType) {
            if (target instanceof basic_1.StructureType) {
                const sourceComponents = source.getComponents();
                const targetComponents = target.getComponents();
                if (sourceComponents.length !== targetComponents.length) {
                    return false;
                }
                for (let i = 0; i < sourceComponents.length; i++) {
                    if (this.isAssignableStrict(sourceComponents[i].type, targetComponents[i].type) === false) {
                        return false;
                    }
                }
                return true;
            }
            else if (target instanceof basic_1.CLikeType) {
                return this.isCharLikeStrict(source);
            }
            else if (target instanceof basic_1.VoidType
                || target instanceof basic_1.AnyType
                || target instanceof basic_1.DataType) {
                return true;
            }
            return false;
        }
        else if (source instanceof basic_1.Integer8Type) {
            if (target instanceof basic_1.IntegerType || target instanceof basic_1.StringType) {
                return false;
            }
        }
        else if (source instanceof basic_1.IntegerType) {
            if (target instanceof basic_1.StringType) {
                return false;
            }
            else if (target instanceof basic_1.Integer8Type || target instanceof basic_1.PackedType) {
                if (((_h = source.getAbstractTypeData()) === null || _h === void 0 ? void 0 : _h.derivedFromConstant) === true) {
                    return true;
                }
                return false;
            }
        }
        else if (source instanceof basic_1.FloatType) {
            if (target instanceof basic_1.IntegerType) {
                return false;
            }
        }
        else if (source instanceof basic_1.GenericObjectReferenceType) {
            if (target instanceof basic_1.ObjectReferenceType
                || target instanceof basic_1.StringType
                || target instanceof basic_1.CharacterType
                || target instanceof basic_1.TableType
                || target instanceof basic_1.CLikeType) {
                return false;
            }
        }
        else if (source instanceof basic_1.ObjectReferenceType) {
            if (target instanceof basic_1.XSequenceType
                || target instanceof basic_1.IntegerType
                || target instanceof basic_1.StructureType
                || target instanceof basic_1.TableType
                || target instanceof basic_1.XStringType) {
                return false;
            }
        }
        else if (source instanceof basic_1.XStringType) {
            if (target instanceof basic_1.CLikeType
                || target instanceof basic_1.IntegerType
                || target instanceof basic_1.StringType
                || target instanceof basic_1.ObjectReferenceType
                || target instanceof basic_1.HexType) {
                return false;
            }
        }
        else if (source instanceof basic_1.TableType) {
            if (target instanceof basic_1.TableType) {
                return this.isAssignableStrict(source.getRowType(), target.getRowType());
            }
            else if (target instanceof basic_1.UnknownType
                || target instanceof basic_1.AnyType
                || target instanceof basic_1.VoidType) {
                return true;
            }
        }
        return this.isAssignable(source, target);
    }
    isAssignable(source, target) {
        /*
            console.dir(source);
            console.dir(target);
        */
        if (target instanceof basic_1.TableType) {
            if (target.isWithHeader()) {
                return this.isAssignable(source, target.getRowType());
            }
            if (source instanceof basic_1.VoidType
                || source instanceof basic_1.AnyType
                || source instanceof basic_1.DataType
                || source instanceof basic_1.UnknownType) {
                return true;
            }
            else if (source instanceof basic_1.TableType) {
                const targetRowType = target.getRowType();
                const sourceRowType = source.getRowType();
                if (targetRowType instanceof basic_1.VoidType || targetRowType instanceof basic_1.AnyType || targetRowType instanceof basic_1.UnknownType) {
                    return true;
                }
                else if (sourceRowType instanceof basic_1.VoidType || sourceRowType instanceof basic_1.AnyType || sourceRowType instanceof basic_1.UnknownType) {
                    return true;
                }
                if (targetRowType instanceof basic_1.StructureType
                    && this.structureContainsString(targetRowType)) {
                    if (!(sourceRowType instanceof basic_1.StructureType)) {
                        return false;
                    }
                    else if (!(this.structureContainsString(sourceRowType))
                        && this.structureContainsVoid(sourceRowType) === false) {
                        return false;
                    }
                }
                else if (sourceRowType instanceof basic_1.StructureType
                    && this.structureContainsString(sourceRowType)) {
                    if (!(targetRowType instanceof basic_1.StructureType)) {
                        return false;
                    }
                    else if (!(this.structureContainsString(targetRowType))
                        && this.structureContainsVoid(targetRowType) === false) {
                        return false;
                    }
                }
                return true;
            }
            return false;
        }
        else if (target instanceof basic_1.ObjectReferenceType && source instanceof basic_1.ObjectReferenceType) {
            return this.isOOAssignable(source, target);
        }
        else if (target instanceof basic_1.ObjectReferenceType
            || target instanceof basic_1.GenericObjectReferenceType) {
            if (source instanceof basic_1.ObjectReferenceType
                || source instanceof basic_1.GenericObjectReferenceType
                || source instanceof basic_1.VoidType
                || source instanceof basic_1.DataType
                || source instanceof basic_1.AnyType
                || source instanceof basic_1.UnknownType) {
                return true;
            }
            return false;
        }
        else if (target instanceof basic_1.DataReference) {
            if (source instanceof basic_1.DataReference
                || source instanceof basic_1.VoidType
                || source instanceof basic_1.DataType
                || source instanceof basic_1.AnyType
                || source instanceof basic_1.UnknownType) {
                return true;
            }
            return false;
        }
        else if (target instanceof basic_1.StructureType) {
            if (source instanceof basic_1.TableType && source.isWithHeader()) {
                return this.isAssignable(source.getRowType(), target);
            }
            else if (source instanceof basic_1.VoidType
                || source instanceof basic_1.AnyType
                || source instanceof basic_1.DataType
                || source instanceof basic_1.UnknownType) {
                return true;
            }
            else if (source instanceof basic_1.StructureType) {
                if (this.structureContainsString(target) && !this.structureContainsString(source)) {
                    return false;
                }
                return true;
            }
            else if (target.containsVoid() === true) {
                return true;
            }
            else if (source instanceof basic_1.StringType && this.structureContainsString(target)) {
                return false;
            }
            else if (source instanceof basic_1.IntegerType) {
                return false;
            }
            else if (this.isCharLike(target) && this.isCharLike(source)) {
                return true;
            }
            return false;
        }
        else if (target instanceof basic_1.IntegerType
            || target instanceof basic_1.CharacterType
            || target instanceof basic_1.StringType) {
            if (source instanceof basic_1.TableType && source.isWithHeader() === false) {
                return false;
            }
            else if ((target instanceof basic_1.StringType || target instanceof basic_1.CharacterType)
                && source instanceof basic_1.StructureType
                && this.isCharLike(source)) {
                return true;
            }
            else if (source instanceof basic_1.DataReference
                || source instanceof basic_1.ObjectReferenceType
                || source instanceof basic_1.StructureType
                || source instanceof basic_1.GenericObjectReferenceType) {
                return false;
            }
            return true;
        }
        else if (target instanceof basic_1.SimpleType) {
            if (source instanceof basic_1.ObjectReferenceType
                || source instanceof basic_1.TableType) {
                return false;
            }
        }
        return true;
    }
}
exports.TypeUtils = TypeUtils;
//# sourceMappingURL=_type_utils.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssertError = void 0;
class AssertError extends Error {
}
exports.AssertError = AssertError;
//# sourceMappingURL=assert_error.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicTypes = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Types = __webpack_require__(/*! ../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _scope_type_1 = __webpack_require__(/*! ./_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _object_oriented_1 = __webpack_require__(/*! ./_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const class_constant_1 = __webpack_require__(/*! ../types/class_constant */ "./node_modules/@abaplint/core/build/src/abap/types/class_constant.js");
const identifier_1 = __webpack_require__(/*! ../1_lexer/tokens/identifier */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js");
const _reference_1 = __webpack_require__(/*! ./_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const basic_1 = __webpack_require__(/*! ../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const field_chain_1 = __webpack_require__(/*! ./expressions/field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const types_1 = __webpack_require__(/*! ../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const expressions_1 = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _builtin_1 = __webpack_require__(/*! ./_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
class BasicTypes {
    constructor(input) {
        this.input = input;
    }
    lookupQualifiedName(name) {
        var _a;
        // argh, todo, rewrite this entire method, more argh, again argh
        if (name === undefined) {
            return undefined;
        }
        const found = this.input.scope.findType(name);
        if (found) {
            return found;
        }
        if (name.includes("=>")) {
            const split = name.split("=>");
            const ooName = split[0];
            const typeName = split[1];
            const oo = this.input.scope.findObjectDefinition(ooName);
            if (oo) {
                if (typeName.includes("-")) {
                    const split = typeName.split("-");
                    const subTypeName = split[0];
                    const fieldName = split[1];
                    const stru = oo.getTypeDefinitions().getByName(subTypeName);
                    const struType = stru === null || stru === void 0 ? void 0 : stru.getType();
                    if (stru && struType instanceof basic_1.StructureType) {
                        let f = struType.getComponentByName(fieldName);
                        if (split[2] && f instanceof basic_1.StructureType) {
                            f = f.getComponentByName(split[2]);
                        }
                        if (f) {
                            return new _typed_identifier_1.TypedIdentifier(stru.getToken(), stru.getFilename(), f);
                        }
                    }
                }
                else {
                    const f = oo.getTypeDefinitions().getByName(typeName);
                    if (f) {
                        return f;
                    }
                }
            }
        }
        else if (name.includes("-")) {
            const split = name.split("-");
            const typeName = split[0];
            const fieldName = split[1];
            const type = this.input.scope.findType(typeName);
            if (type) {
                const stru = type.getType();
                if (stru instanceof basic_1.StructureType) {
                    let f = stru.getComponentByName(fieldName);
                    if (split[2] && f instanceof basic_1.StructureType) {
                        f = f.getComponentByName(split[2]);
                    }
                    if (f) {
                        return new _typed_identifier_1.TypedIdentifier(type.getToken(), type.getFilename(), f);
                    }
                }
            }
        }
        const lookup = this.input.scope.getDDIC().lookupNoVoid(name);
        const id = (_a = lookup === null || lookup === void 0 ? void 0 : lookup.object) === null || _a === void 0 ? void 0 : _a.getIdentifier();
        if (id && (lookup === null || lookup === void 0 ? void 0 : lookup.type)) {
            return new _typed_identifier_1.TypedIdentifier(id.getToken(), id.getFilename(), lookup.type);
        }
        const builtin = this.input.scope.getDDIC().lookupBuiltinType(name);
        if (builtin) {
            return new _typed_identifier_1.TypedIdentifier(new identifier_1.Identifier(new position_1.Position(1, 1), name), _builtin_1.BuiltIn.filename, builtin);
        }
        const type = this.input.scope.findTypePoolType(name);
        if (type) {
            return type;
        }
        return undefined;
    }
    resolveLikeName(node, headerLogic = true) {
        var _a;
        if (node === undefined) {
            return undefined;
        }
        let chain = node.findFirstExpression(Expressions.FieldChain);
        if (chain === undefined) {
            chain = node.findFirstExpression(Expressions.TypeName);
        }
        if (chain === undefined) {
            chain = node.findFirstExpression(Expressions.FieldSub);
        }
        if (chain === undefined) {
            chain = node.findFirstExpression(Expressions.SimpleFieldChain);
        }
        if (chain === undefined) {
            throw new Error("resolveLikeName, chain undefined");
        }
        const fullName = chain.concatTokens();
        let children = [...chain.getChildren()];
        if (children.length === 0) {
            return new Types.UnknownType("Type error, could not resolve \"" + fullName + "\", resolveLikeName1");
        }
        let type = undefined;
        if (children[1] && (children[1].getFirstToken().getStr() === "=>" || children[1].getFirstToken().getStr() === "->")) {
            type = new field_chain_1.FieldChain().runSyntax(chain, this.input, _reference_1.ReferenceType.TypeReference);
        }
        else {
            const name = children.shift().getFirstToken().getStr();
            let found = this.input.scope.findVariable(name);
            const full = this.input.scope.findVariable(fullName); // workaround for eg "sy-repid"
            if (full) {
                children = [];
                found = full;
            }
            type = found === null || found === void 0 ? void 0 : found.getType();
            if (found === undefined) {
                found = this.input.scope.findExtraLikeType(name);
                type = found === null || found === void 0 ? void 0 : found.getType();
            }
            if (found) {
                this.input.scope.addReference(chain === null || chain === void 0 ? void 0 : chain.getFirstToken(), found, _reference_1.ReferenceType.TypeReference, this.input.filename);
            }
            if (type === undefined) {
                type = (_a = this.input.scope.getDDIC().lookupNoVoid(name)) === null || _a === void 0 ? void 0 : _a.type;
            }
            if (type === undefined && this.input.scope.isOO() === false && this.input.scope.getDDIC().inErrorNamespace(name) === false) {
                this.input.scope.addReference(chain.getChildren()[0].getFirstToken(), undefined, _reference_1.ReferenceType.VoidType, this.input.filename);
                return new Types.VoidType(name);
            }
            while (children.length > 0) {
                const child = children.shift();
                if (child.getFirstToken().getStr() === "-") {
                    if (type instanceof Types.VoidType) {
                        return type;
                    }
                }
                else if (child.concatTokens() === "[]") {
                    if (type instanceof Types.TableType) {
                        type = new basic_1.TableType(type.getRowType(), { withHeader: false, keyType: Types.TableKeyType.default });
                    }
                }
                else { // field name
                    if (type instanceof Types.TableType) {
                        type = type.getRowType();
                    }
                    if (type instanceof Types.StructureType) {
                        type = type.getComponentByName(child.getFirstToken().getStr());
                        if (type === undefined) {
                            return new Types.UnknownType("Type error, field not part of structure " + fullName);
                        }
                    }
                    else if (!(type instanceof Types.VoidType)) {
                        return new Types.UnknownType("Type error, field not part of structure " + fullName);
                    }
                }
            }
            if (type instanceof Types.VoidType) {
                return type;
            }
            else if (type instanceof basic_1.TableType
                && type.isWithHeader()
                && headerLogic === true) {
                type = type.getRowType();
            }
            else if (type instanceof Types.TableType
                && type.isWithHeader() === true
                && type.getRowType() instanceof Types.VoidType) {
                return type.getRowType();
            }
        }
        if (!type) {
            return new Types.UnknownType("Type error, could not resolve \"" + fullName + "\", resolveLikeName2");
        }
        return type;
    }
    cloneType(type, qualifiedName) {
        // nested types(containing "-") will inherit the qualified names if possible
        // todo, this needs to be extended to all AbstractTypes instead of just CharacterType
        if (type instanceof basic_1.CharacterType
            && qualifiedName
            && qualifiedName.includes("-") === false) {
            type = type.cloneType({ qualifiedName });
        }
        return type;
    }
    resolveTypeName(typeName, length, decimals, qualifiedName) {
        var _a;
        if (typeName === undefined) {
            return undefined;
        }
        const chain = this.resolveTypeChain(typeName);
        if (chain) {
            return this.cloneType(chain, qualifiedName);
        }
        const chainText = typeName.concatTokens().toUpperCase();
        const f = this.input.scope.getDDIC().lookupBuiltinType(chainText, length, decimals, qualifiedName);
        if (f !== undefined) {
            return f;
        }
        const typ = this.input.scope.findType(chainText);
        if (typ) {
            const token = typeName.getFirstToken();
            if (chainText.includes("~")) {
                const name = chainText.split("~")[0];
                const idef = this.input.scope.findInterfaceDefinition(name);
                if (idef) {
                    this.input.scope.addReference(token, idef, _reference_1.ReferenceType.ObjectOrientedReference, this.input.filename, { ooType: "INTF", ooName: name });
                }
            }
            this.input.scope.addReference(token, typ, _reference_1.ReferenceType.TypeReference, this.input.filename);
            return typ.getType();
        }
        const type = (_a = this.input.scope.findTypePoolType(chainText)) === null || _a === void 0 ? void 0 : _a.getType();
        if (type) {
            //      this.scope.addReference(typeName.getFirstToken(), type, ReferenceType.TypeReference, this.filename);
            return type;
        }
        const ddic = this.input.scope.getDDIC().lookup(chainText);
        if (ddic) {
            this.input.scope.getDDICReferences().addUsing(this.input.scope.getParentObj(), { object: ddic.object, token: typeName.getFirstToken(), filename: this.input.filename });
            if (ddic.type instanceof _typed_identifier_1.TypedIdentifier) {
                this.input.scope.addReference(typeName.getFirstToken(), ddic.type, _reference_1.ReferenceType.TypeReference, this.input.filename);
            }
            else if (ddic.type instanceof basic_1.VoidType) {
                this.input.scope.addReference(typeName.getFirstToken(), undefined, _reference_1.ReferenceType.VoidType, this.input.filename);
            }
            return this.cloneType(ddic.type, qualifiedName);
        }
        return undefined;
    }
    simpleType(node, qualifiedNamePrefix) {
        let nameExpr = node.findFirstExpression(Expressions.NamespaceSimpleName);
        if (nameExpr === undefined) {
            nameExpr = node.findFirstExpression(Expressions.DefinitionName);
        }
        if (nameExpr === undefined) {
            return undefined;
        }
        let name = nameExpr.getFirstToken();
        if (nameExpr.countTokens() > 1) { // workaround for names with dashes
            name = new identifier_1.Identifier(name.getStart(), nameExpr.concatTokens());
        }
        let qualifiedName = undefined;
        if (node.get() instanceof Statements.Type) {
            if (this.input.scope.isTypePool() === true) {
                qualifiedName = name.getStr();
            }
            else {
                qualifiedName = (qualifiedNamePrefix || "") + name.getStr();
                if (this.input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition
                    || this.input.scope.getType() === _scope_type_1.ScopeType.Interface) {
                    qualifiedName = this.input.scope.getName() + "=>" + qualifiedName;
                }
            }
        }
        else if (qualifiedNamePrefix) {
            qualifiedName = qualifiedNamePrefix + qualifiedName;
        }
        const found = this.parseType(node, qualifiedName);
        if (found) {
            return new _typed_identifier_1.TypedIdentifier(name, this.input.filename, found);
        }
        return undefined;
    }
    parseTable(node, name) {
        var _a, _b, _c, _d;
        const typename = node.findFirstExpression(Expressions.TypeName);
        const text = (_a = node.findFirstExpression(Expressions.TypeTable)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
        if (text === undefined) {
            return undefined;
        }
        let type = undefined;
        if (text.startsWith("TYPE STANDARD TABLE ")
            || text.startsWith("TYPE TABLE ")
            || text.startsWith("LIKE TABLE ")
            || text.startsWith("LIKE STANDARD TABLE ")) {
            type = basic_1.TableAccessType.standard;
        }
        else if (text.startsWith("TYPE SORTED TABLE ")
            || text.startsWith("LIKE SORTED TABLE ")) {
            type = basic_1.TableAccessType.sorted;
        }
        else if (text.startsWith("TYPE HASHED TABLE ")
            || text.startsWith("LIKE HASHED TABLE ")) {
            type = basic_1.TableAccessType.hashed;
        }
        const typeTableKeys = node.findAllExpressions(expressions_1.TypeTableKey);
        const firstKey = typeTableKeys[0];
        const isNamed = (firstKey === null || firstKey === void 0 ? void 0 : firstKey.findDirectExpression(expressions_1.Field)) !== undefined
            && ((_b = firstKey === null || firstKey === void 0 ? void 0 : firstKey.findDirectExpression(expressions_1.Field)) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase()) !== "PRIMARY_KEY";
        const primaryKey = {
            name: "primary_key",
            type: type || basic_1.TableAccessType.standard,
            isUnique: isNamed ? false : (firstKey === null || firstKey === void 0 ? void 0 : firstKey.concatTokens().toUpperCase().includes("WITH UNIQUE ")) === true,
            keyFields: [],
        };
        let start = 1;
        if (isNamed === false) {
            for (const k of (firstKey === null || firstKey === void 0 ? void 0 : firstKey.findDirectExpressions(expressions_1.FieldSub)) || []) {
                primaryKey.keyFields.push(k.concatTokens().toUpperCase());
            }
        }
        else {
            start = 0;
        }
        const secondaryKeys = [];
        for (let i = start; i < typeTableKeys.length; i++) {
            const row = typeTableKeys[i];
            const name = (_c = row.findDirectExpression(expressions_1.Field)) === null || _c === void 0 ? void 0 : _c.concatTokens();
            if (name === undefined) {
                continue;
            }
            const secondary = {
                name: name,
                type: row.findDirectTokenByText("SORTED") ? basic_1.TableAccessType.sorted : basic_1.TableAccessType.hashed,
                isUnique: (row === null || row === void 0 ? void 0 : row.concatTokens().toUpperCase().includes("WITH UNIQUE ")) === true,
                keyFields: [],
            };
            for (const k of (row === null || row === void 0 ? void 0 : row.findDirectExpressions(expressions_1.FieldSub)) || []) {
                secondary.keyFields.push(k.concatTokens().toUpperCase());
            }
            secondaryKeys.push(secondary);
        }
        let keyType = Types.TableKeyType.user;
        if (text.includes(" EMPTY KEY")) {
            keyType = Types.TableKeyType.empty;
        }
        else if (text.includes(" DEFAULT KEY")) {
            keyType = Types.TableKeyType.default;
        }
        const options = {
            withHeader: text.includes(" WITH HEADER LINE"),
            keyType: keyType,
            primaryKey: primaryKey,
            secondary: secondaryKeys,
        };
        let found = undefined;
        if (text.startsWith("TYPE TABLE OF REF TO ")
            || text.startsWith("TYPE STANDARD TABLE OF REF TO ")
            || text.startsWith("TYPE SORTED TABLE OF REF TO ")
            || text.startsWith("TYPE HASHED TABLE OF REF TO ")) {
            found = this.resolveTypeRef(typename);
            if (found) {
                return new Types.TableType(found, options, name);
            }
        }
        else if (text.startsWith("TYPE TABLE OF ")
            || text.startsWith("TYPE STANDARD TABLE OF ")
            || text.startsWith("TYPE SORTED TABLE OF ")
            || text.startsWith("TYPE HASHED TABLE OF ")) {
            found = this.resolveTypeName(typename);
            if (found) {
                return new Types.TableType(found, options, name);
            }
        }
        else if (text.startsWith("LIKE TABLE OF ")
            || text.startsWith("LIKE STANDARD TABLE OF ")
            || text.startsWith("LIKE SORTED TABLE OF ")
            || text.startsWith("LIKE HASHED TABLE OF ")) {
            found = this.resolveLikeName(node);
            if (found) {
                return new Types.TableType(found, options, name);
            }
        }
        else if (text === "TYPE STANDARD TABLE"
            || text === "TYPE SORTED TABLE"
            || text === "TYPE HASHED TABLE"
            || text === "TYPE INDEX TABLE"
            || text === "TYPE ANY TABLE") {
            return new Types.TableType(new Types.AnyType(), options);
        }
        else if (text.startsWith("TYPE RANGE OF ")) {
            const sub = node.findFirstExpression(Expressions.TypeName);
            found = this.resolveTypeName(sub);
            if (found === undefined) {
                return new Types.UnknownType("TYPE RANGE OF, could not resolve type");
            }
            const structure = new Types.StructureType([
                { name: "sign", type: new Types.CharacterType(1) },
                { name: "option", type: new Types.CharacterType(2) },
                { name: "low", type: found },
                { name: "high", type: found },
            ]);
            options.primaryKey.type = basic_1.TableAccessType.standard;
            return new Types.TableType(structure, options, name);
        }
        else if (text.startsWith("LIKE RANGE OF ")) {
            const sub = node.findFirstExpression(Expressions.FieldChain);
            found = this.resolveLikeName(sub);
            if (found === undefined) {
                return new Types.UnknownType("LIKE RANGE OF, could not resolve type");
            }
            const structure = new Types.StructureType([
                { name: "sign", type: new Types.CharacterType(1) },
                { name: "option", type: new Types.CharacterType(2) },
                { name: "low", type: found },
                { name: "high", type: found },
            ], name);
            options.primaryKey.type = basic_1.TableAccessType.standard;
            return new Types.TableType(structure, options);
        }
        else if (typename && (text.startsWith("TYPE TABLE FOR CREATE ")
            || text.startsWith("TYPE TABLE FOR UPDATE "))) {
            const name = typename.concatTokens();
            const type = (_d = this.input.scope.getDDIC().lookupDDLS(name)) === null || _d === void 0 ? void 0 : _d.type;
            if (type) {
                return new Types.TableType(new basic_1.VoidType("RapTodo"), options);
            }
            else if (this.input.scope.getDDIC().inErrorNamespace(name)) {
                return new Types.UnknownType(`DDLS ${name} not found`);
            }
            else {
                return new Types.VoidType(name);
            }
        }
        // fallback to old style syntax, OCCURS etc
        return this.parseType(node, name);
    }
    parseType(node, qualifiedName) {
        var _a, _b, _c, _d, _e, _f;
        const typeName = node.findFirstExpression(Expressions.TypeName);
        let text = (_a = node.findFirstExpression(Expressions.Type)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
        if (text === undefined) {
            text = (_b = node.findFirstExpression(Expressions.TypeParam)) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase();
        }
        if (text === undefined) {
            text = (_c = node.findFirstExpression(Expressions.TypeTable)) === null || _c === void 0 ? void 0 : _c.concatTokens().toUpperCase();
            if ((text === null || text === void 0 ? void 0 : text.startsWith("TYPE")) === false && (text === null || text === void 0 ? void 0 : text.startsWith("LIKE")) === false) {
                text = "TYPE";
            }
        }
        if (text === undefined) {
            text = (_d = node.findFirstExpression(Expressions.FormParamType)) === null || _d === void 0 ? void 0 : _d.concatTokens().toUpperCase();
        }
        if (text === undefined
            && node.get() instanceof Statements.Parameter
            && node.findDirectTokenByText("LIKE")) {
            text = "LIKE " + (typeName === null || typeName === void 0 ? void 0 : typeName.concatTokens());
        }
        if (text === undefined) {
            text = "TYPE";
        }
        let found = undefined;
        if (text.startsWith("LIKE LINE OF ")) {
            const name = (_e = node.findFirstExpression(Expressions.FieldChain)) === null || _e === void 0 ? void 0 : _e.concatTokens();
            let e = node.findFirstExpression(Expressions.Type);
            if (e === undefined) {
                e = node.findFirstExpression(Expressions.FormParamType);
            }
            if (e === undefined) {
                e = node.findFirstExpression(Expressions.FieldChain);
            }
            const type = this.resolveLikeName(e, false);
            if (type === undefined) {
                return new Types.UnknownType("Type error, could not resolve \"" + name + "\", parseType");
            }
            else if (type instanceof Types.TableType) {
                return type.getRowType();
            }
            else if (type instanceof Types.VoidType) {
                return type;
            }
            else {
                return new Types.UnknownType("Type error, not a table type " + name);
            }
        }
        else if (text.startsWith("LIKE REF TO ")) {
            const name = (_f = node.findFirstExpression(Expressions.FieldChain)) === null || _f === void 0 ? void 0 : _f.concatTokens();
            const type = this.resolveLikeName(node.findFirstExpression(Expressions.Type), false);
            if (type === undefined) {
                return new Types.UnknownType("Type error, could not resolve \"" + name + "\", parseType");
            }
            return new Types.DataReference(type, name);
        }
        else if (text === "TYPE STANDARD TABLE"
            || text === "TYPE SORTED TABLE"
            || text === "TYPE HASHED TABLE"
            || text === "TYPE INDEX TABLE"
            || text === "TYPE ANY TABLE") {
            return new Types.TableType(new Types.AnyType(), { withHeader: node.concatTokens().toUpperCase().includes("WITH HEADER LINE"), keyType: Types.TableKeyType.default });
        }
        else if (text.startsWith("LIKE ")) {
            let sub = node.findFirstExpression(Expressions.Type);
            if (sub === undefined) {
                sub = node.findFirstExpression(Expressions.FormParamType);
            }
            if (sub === undefined) {
                sub = node.findFirstExpression(Expressions.TypeParam);
            }
            if (sub === undefined) {
                sub = node.findFirstExpression(Expressions.FieldChain);
            }
            if (sub === undefined) {
                sub = node.findFirstExpression(Expressions.TypeName);
            }
            found = this.resolveLikeName(sub);
            if (found && this.isOccurs(node)) {
                found = new Types.TableType(found, { withHeader: text.includes("WITH HEADER LINE"), keyType: Types.TableKeyType.default }, qualifiedName);
            }
        }
        else if (text.startsWith("TYPE LINE OF ")) {
            const sub = node.findFirstExpression(Expressions.TypeName);
            found = this.resolveTypeName(sub);
            if (found instanceof _typed_identifier_1.TypedIdentifier) {
                found = found.getType();
            }
            if (found instanceof Types.TableType) {
                return found.getRowType();
            }
            else if (found instanceof Types.VoidType) {
                return found;
            }
            else if (found instanceof Types.UnknownType) {
                return new Types.UnknownType("TYPE LINE OF, unknown type, " + found.getError());
            }
            else {
                return new Types.UnknownType("TYPE LINE OF, unexpected type, " + (found === null || found === void 0 ? void 0 : found.constructor.name));
            }
        }
        else if (text.startsWith("TYPE REF TO ")) {
            found = this.resolveTypeRef(typeName);
        }
        else if (text.startsWith("TYPE")) {
            found = this.resolveTypeName(typeName, this.findLength(node), this.findDecimals(node), qualifiedName);
            const concat = node.concatTokens().toUpperCase();
            if (found && this.isOccurs(node)) {
                found = new Types.TableType(found, { withHeader: concat.includes(" WITH HEADER LINE"), keyType: Types.TableKeyType.default }, qualifiedName);
            }
            else if (found && concat.includes(" WITH HEADER LINE")) {
                if (found instanceof Types.VoidType) {
                    found = new Types.TableType(found, { withHeader: true, keyType: Types.TableKeyType.default });
                }
                else if (!(found instanceof Types.TableType)) {
                    throw new Error("WITH HEADER LINE can only be used with internal table");
                }
                else {
                    found = new Types.TableType(found.getRowType(), { withHeader: true, keyType: Types.TableKeyType.default });
                }
            }
            if (found === undefined && typeName === undefined) {
                let length = 1;
                const len = node.findDirectExpression(Expressions.ConstantFieldLength);
                if (len) {
                    const int = len.findDirectExpression(Expressions.Integer);
                    if (int) {
                        length = parseInt(int.concatTokens(), 10);
                    }
                }
                found = new Types.CharacterType(length, { qualifiedName: qualifiedName }); // fallback
                if (this.isOccurs(node)) {
                    found = new Types.TableType(found, { withHeader: concat.includes(" WITH HEADER LINE"), keyType: Types.TableKeyType.default }, qualifiedName);
                }
            }
        }
        return found;
    }
    /////////////////////
    isOccurs(node) {
        var _a;
        if (node.findDirectTokenByText("OCCURS")) {
            return true;
        }
        else if ((_a = node.findFirstExpression(Expressions.TypeTable)) === null || _a === void 0 ? void 0 : _a.findDirectTokenByText("OCCURS")) {
            return true;
        }
        return false;
    }
    // todo, rewrite this method
    resolveTypeChain(expr) {
        var _a, _b, _c, _d;
        const chainText = expr.concatTokens().toUpperCase();
        if (chainText.includes("-")) {
            // workaround for stuff like "sy-repid"
            const built = this.input.scope.findType(chainText);
            if (built) {
                this.input.scope.addReference(expr.getFirstToken(), built, _reference_1.ReferenceType.TypeReference, this.input.filename);
                return built.getType();
            }
        }
        else if (chainText.includes("=>") === false && chainText.includes("-") === false) {
            return undefined;
        }
        let className;
        let rest = chainText;
        if (chainText.includes("=>")) {
            const split = chainText.split("=>");
            className = split[0];
            rest = split[1];
        }
        else if (chainText.includes("->")) {
            const split = chainText.split("->");
            className = split[0];
            rest = split[1];
        }
        const subs = rest.split("-");
        let foundType = undefined;
        if (className && chainText.includes("=>")) {
            const split = chainText.split("=>");
            const className = split[0];
            // the prefix might be itself
            if ((this.input.scope.getType() === _scope_type_1.ScopeType.Interface
                || this.input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition)
                && this.input.scope.getName().toUpperCase() === className.toUpperCase()) {
                const foundId = this.input.scope.findType(subs[0]);
                foundType = foundId === null || foundId === void 0 ? void 0 : foundId.getType();
                if (foundType === undefined) {
                    return new Types.UnknownType("Could not resolve type " + chainText);
                }
                const token = (_a = expr.getChildren()[2]) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                if (token) {
                    this.input.scope.addReference(token, foundId, _reference_1.ReferenceType.TypeReference, this.input.filename);
                }
            }
            else {
                // lookup in local and global scope
                const obj = this.input.scope.findObjectDefinition(className);
                if (obj === undefined && this.input.scope.getDDIC().inErrorNamespace(className) === false) {
                    this.input.scope.addReference(expr.getFirstToken(), undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, this.input.filename, { ooName: className.toUpperCase() });
                    return new Types.VoidType(className);
                }
                else if (obj === undefined) {
                    return new Types.UnknownType("Could not resolve top " + className + ", resolveTypeChain");
                }
                const type = obj instanceof types_1.ClassDefinition ? "CLAS" : "INTF";
                this.input.scope.addReference(expr.getFirstToken(), obj, _reference_1.ReferenceType.ObjectOrientedReference, this.input.filename, { ooType: type, ooName: className });
                const byName = new _object_oriented_1.ObjectOriented(this.input.scope).searchTypeName(obj, subs[0]);
                foundType = byName === null || byName === void 0 ? void 0 : byName.getType();
                if (byName === undefined || foundType === undefined) {
                    return new Types.UnknownType(subs[0] + " not found in class or interface");
                }
                const token = (_b = expr.getChildren()[2]) === null || _b === void 0 ? void 0 : _b.getFirstToken();
                if (token) {
                    this.input.scope.addReference(token, byName, _reference_1.ReferenceType.TypeReference, this.input.filename);
                }
            }
        }
        else if (className && chainText.includes("->")) {
            const varVar = this.input.scope.findVariable(className);
            const foo = varVar === null || varVar === void 0 ? void 0 : varVar.getType();
            if (foo instanceof basic_1.ObjectReferenceType) {
                const typeName = subs[0];
                let id = foo.getIdentifier();
                if (!(id instanceof types_1.ClassDefinition || id instanceof types_1.InterfaceDefinition)) {
                    const found = this.input.scope.findObjectDefinition(foo.getIdentifierName());
                    if (found) {
                        id = found;
                    }
                    else {
                        return new Types.UnknownType(foo.getIdentifierName() + " not found in scope");
                    }
                }
                if (id instanceof types_1.ClassDefinition || id instanceof types_1.InterfaceDefinition) {
                    const type = id instanceof types_1.ClassDefinition ? "CLAS" : "INTF";
                    this.input.scope.addReference(expr.getFirstToken(), id, _reference_1.ReferenceType.ObjectOrientedReference, this.input.filename, { ooType: type, ooName: id.getName() });
                    const byName = new _object_oriented_1.ObjectOriented(this.input.scope).searchTypeName(id, typeName);
                    foundType = byName === null || byName === void 0 ? void 0 : byName.getType();
                    if (byName === undefined || foundType === undefined) {
                        return new Types.UnknownType(typeName + " not found in class or interface");
                    }
                    const token = (_c = expr.getChildren()[2]) === null || _c === void 0 ? void 0 : _c.getFirstToken();
                    if (token) {
                        this.input.scope.addReference(token, byName, _reference_1.ReferenceType.TypeReference, this.input.filename);
                    }
                }
                else {
                    return new Types.UnknownType("Not an object reference, " + className + ", " + id.constructor.name);
                }
            }
            else if (foo === undefined) {
                return new Types.UnknownType(className + " not found in scope");
            }
            else {
                return new Types.UnknownType("Not an object reference, " + className + ", " + foo.constructor.name);
            }
        }
        else {
            const found = this.input.scope.findType(subs[0]);
            foundType = found === null || found === void 0 ? void 0 : found.getType();
            if (foundType === undefined) {
                const typePoolType = (_d = this.input.scope.findTypePoolType(subs[0])) === null || _d === void 0 ? void 0 : _d.getType();
                if (typePoolType) {
                    //          this.scope.addReference(typeName.getFirstToken(), typePoolType, ReferenceType.TypeReference, this.filename);
                    foundType = typePoolType;
                }
                if (foundType === undefined) {
                    const f = this.input.scope.getDDIC().lookupTableOrView(subs[0]);
                    this.input.scope.getDDICReferences().addUsing(this.input.scope.getParentObj(), { object: f.object, filename: this.input.filename, token: expr.getFirstToken() });
                    if (f.type instanceof _typed_identifier_1.TypedIdentifier) {
                        foundType = f.type.getType();
                    }
                    else {
                        foundType = f.type;
                    }
                }
            }
            else {
                this.input.scope.addReference(expr.getFirstToken(), found, _reference_1.ReferenceType.TypeReference, this.input.filename);
            }
            if (foundType === undefined && this.input.scope.getDDIC().inErrorNamespace(subs[0]) === false) {
                this.input.scope.addReference(expr.getFirstToken(), undefined, _reference_1.ReferenceType.VoidType, this.input.filename);
                return new Types.VoidType(subs[0]);
            }
            else if (foundType instanceof Types.VoidType) {
                this.input.scope.addReference(expr.getFirstToken(), undefined, _reference_1.ReferenceType.VoidType, this.input.filename);
                return foundType;
            }
            else if (foundType === undefined) {
                return new Types.UnknownType("Unknown type " + subs[0]);
            }
        }
        subs.shift();
        while (subs.length > 0) {
            if (foundType instanceof Types.UnknownType
                || foundType instanceof Types.VoidType) {
                return foundType;
            }
            else if (!(foundType instanceof Types.StructureType)) {
                return new Types.UnknownType("Not a structured type");
            }
            foundType = foundType.getComponentByName(subs[0]);
            if (foundType === undefined) {
                return new Types.UnknownType(`Field "${subs[0]}" not found in structure`);
            }
            subs.shift();
        }
        return foundType;
    }
    resolveConstantValue(expr) {
        var _a, _b;
        // todo: rewrite this method
        if (!(expr.get() instanceof Expressions.SimpleFieldChain)) {
            throw new Error("resolveConstantValue");
        }
        const firstNode = expr.getFirstChild();
        const firstToken = firstNode.getFirstToken();
        const firstName = firstToken.getStr();
        if (firstNode.get() instanceof Expressions.Field) {
            const found = this.input.scope.findVariable(firstName);
            const val = found === null || found === void 0 ? void 0 : found.getValue();
            if (typeof val === "string") {
                this.input.scope.addReference(firstToken, found, _reference_1.ReferenceType.DataReadReference, this.input.filename);
                return val;
            }
            else if ((found === null || found === void 0 ? void 0 : found.getType()) instanceof basic_1.StructureType) {
                this.input.scope.addReference(firstToken, found, _reference_1.ReferenceType.DataReadReference, this.input.filename);
            }
            return undefined;
        }
        else if (firstNode.get() instanceof Expressions.ClassName
            && firstName.toLowerCase() === this.input.scope.getName().toLowerCase()
            && (this.input.scope.getType() === _scope_type_1.ScopeType.Interface
                || this.input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition)) {
            const children = expr.getChildren();
            const token = (_a = children[2]) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            const found = this.input.scope.findVariable(token.getStr());
            const val = found === null || found === void 0 ? void 0 : found.getValue();
            if (typeof val === "string") {
                this.input.scope.addReference(firstToken, found, _reference_1.ReferenceType.DataReadReference, this.input.filename);
                return val;
            }
            return undefined;
        }
        else if (firstNode.get() instanceof Expressions.ClassName) {
            const obj = this.input.scope.findObjectDefinition(firstName);
            if (obj === undefined) {
                if (this.input.scope.existsObject(firstName) !== undefined) {
                    return undefined;
                }
                else if (this.input.scope.getDDIC().inErrorNamespace(firstName) === true) {
                    throw new Error("resolveConstantValue, not found: " + firstName);
                }
                else {
                    this.input.scope.addReference(firstNode.getFirstToken(), undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, this.input.filename, { ooName: firstName.toUpperCase() });
                    return undefined;
                }
            }
            const children = expr.getChildren();
            const token = (_b = children[2]) === null || _b === void 0 ? void 0 : _b.getFirstToken();
            const attr = token.getStr();
            const c = new _object_oriented_1.ObjectOriented(this.input.scope).searchConstantName(obj, attr);
            if (c instanceof class_constant_1.ClassConstant) {
                this.input.scope.addReference(firstToken, obj, _reference_1.ReferenceType.ObjectOrientedReference, this.input.filename, { ooName: obj.getName() });
                this.input.scope.addReference(token, c, _reference_1.ReferenceType.DataReadReference, this.input.filename);
                const val = c.getValue();
                if (typeof val === "string") {
                    return val;
                }
                else if (typeof val === "object" && children[4]) {
                    const name = children[4].getFirstToken().getStr();
                    if (val[name] !== undefined) {
                        return val[name];
                    }
                }
                return undefined;
            }
            throw new Error("resolveConstantValue, constant not found " + attr);
        }
        else {
            throw new Error("resolveConstantValue, unexpected structure");
        }
    }
    resolveTypeRef(chain) {
        var _a;
        if (chain === undefined) {
            return undefined;
        }
        const name = chain.getFirstToken().getStr();
        if (chain.getChildren().length === 1) {
            if (name.toUpperCase() === "OBJECT") {
                return new Types.GenericObjectReferenceType();
            }
            const search = this.input.scope.existsObject(name);
            if (search === null || search === void 0 ? void 0 : search.id) {
                this.input.scope.addReference(chain.getFirstToken(), search.id, _reference_1.ReferenceType.ObjectOrientedReference, this.input.filename, { ooType: search.ooType, ooName: name });
                return new Types.ObjectReferenceType(search.id, { qualifiedName: name, RTTIName: search.RTTIName });
            }
        }
        const found = this.resolveTypeName(chain);
        if (found && !(found instanceof Types.UnknownType) && !(found instanceof Types.VoidType)) {
            return new Types.DataReference(found);
        }
        else if (chain.concatTokens().toUpperCase() === "DATA") {
            return new Types.DataReference(new Types.DataType());
        }
        if (this.input.scope.isBadiDef(name) === true) {
            return new Types.VoidType(name);
        }
        if (((_a = this.input.scope.getDDIC()) === null || _a === void 0 ? void 0 : _a.inErrorNamespace(name)) === false) {
            //      this.scope.addReference(chain.getFirstToken(), undefined, ReferenceType.VoidType, this.filename);
            return new Types.VoidType(name);
        }
        return new Types.UnknownType("REF, unable to resolve " + name);
    }
    findValue(node) {
        const val = node.findFirstExpression(Expressions.Value);
        if (val === undefined) {
            throw new Error("VALUE missing in expression");
        }
        if (val.concatTokens().toUpperCase() === "VALUE IS INITIAL") {
            return undefined;
        }
        const constant = val.findFirstExpression(Expressions.Constant);
        if (constant) {
            const conc = val.findFirstExpression(Expressions.ConcatenatedConstant);
            if (conc) {
                const first = conc.getFirstToken().getStr().substring(0, 1);
                let result = "";
                for (const token of conc.getAllTokens()) {
                    if (token.getStr() === "&") {
                        continue;
                    }
                    else {
                        result += token.getStr().substring(1, token.getStr().length - 1);
                    }
                }
                return first + result + first;
            }
            else {
                return constant.concatTokens();
            }
        }
        const chain = val.findFirstExpression(Expressions.SimpleFieldChain);
        if (chain) {
            return this.resolveConstantValue(chain);
        }
        throw new Error("findValue, unexpected");
    }
    findDecimals(node) {
        var _a, _b;
        const dec = (_b = (_a = node.findDirectExpression(Expressions.Decimals)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Integer)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (dec) {
            return parseInt(dec, 10);
        }
        return undefined;
    }
    findLength(node) {
        const val = node.findFirstExpression(Expressions.Length);
        const flen = node.findFirstExpression(Expressions.ConstantFieldLength);
        if (val && flen) {
            throw new Error("Only specify length once");
        }
        if (flen) {
            const cintExpr = flen.findFirstExpression(Expressions.Integer);
            if (cintExpr) {
                return this.parseInt(cintExpr.concatTokens());
            }
            const cchain = flen.findFirstExpression(Expressions.SimpleFieldChain);
            if (cchain) {
                const val = this.resolveConstantValue(cchain);
                return this.parseInt(val);
            }
        }
        if (val === undefined) {
            return 1;
        }
        const intExpr = val.findFirstExpression(Expressions.Integer);
        if (intExpr) {
            return this.parseInt(intExpr.concatTokens());
        }
        const strExpr = val.findFirstExpression(Expressions.ConstantString);
        if (strExpr) {
            return this.parseInt(strExpr.concatTokens());
        }
        const chain = val.findFirstExpression(Expressions.SimpleFieldChain);
        if (chain) {
            const val = this.resolveConstantValue(chain);
            return this.parseInt(val);
        }
        throw new Error("Unexpected, findLength");
    }
    parseInt(text) {
        if (text === undefined) {
            return undefined;
        }
        if (text.startsWith("'")) {
            text = text.split("'")[1];
        }
        else if (text.startsWith("`")) {
            text = text.split("`")[1];
        }
        return parseInt(text, 10);
    }
}
exports.BasicTypes = BasicTypes;
//# sourceMappingURL=basic_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_chain.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_chain.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttributeChain = void 0;
const void_type_1 = __webpack_require__(/*! ../../types/basic/void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js");
const object_reference_type_1 = __webpack_require__(/*! ../../types/basic/object_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/object_reference_type.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class AttributeChain {
    runSyntax(inputContext, node, input, type) {
        if (inputContext instanceof void_type_1.VoidType) {
            return inputContext;
        }
        else if (!(inputContext instanceof object_reference_type_1.ObjectReferenceType)) {
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), "Not an object reference(AttributeChain)"));
            return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const children = node.getChildren().slice();
        const first = children[0];
        if (!(first.get() instanceof expressions_1.AttributeName)) {
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), "AttributeChain, unexpected first child"));
            return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const def = input.scope.findObjectDefinition(inputContext.getIdentifierName());
        if (def === undefined) {
            const message = "Definition for \"" + inputContext.getIdentifierName() + "\" not found in scope(AttributeChain)";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const nameToken = first.getFirstToken();
        const name = nameToken.getStr();
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        let context = helper.searchAttributeName(def, name);
        if (context === undefined) {
            context = helper.searchConstantName(def, name);
        }
        if (context === undefined) {
            const message = "Attribute or constant \"" + name + "\" not found in \"" + def.getName() + "\"";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, message));
            return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        for (const t of type) {
            input.scope.addReference(nameToken, context, t, input.filename);
        }
        // todo, loop, handle ArrowOrDash, ComponentName, TableExpression
        return context.getType();
    }
}
exports.AttributeChain = AttributeChain;
//# sourceMappingURL=attribute_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AttributeName = void 0;
const void_type_1 = __webpack_require__(/*! ../../types/basic/void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js");
const structure_type_1 = __webpack_require__(/*! ../../types/basic/structure_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js");
const object_reference_type_1 = __webpack_require__(/*! ../../types/basic/object_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/object_reference_type.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const data_reference_type_1 = __webpack_require__(/*! ../../types/basic/data_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/data_reference_type.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class AttributeName {
    runSyntax(context, node, input, type, error = true) {
        if (context instanceof void_type_1.VoidType) {
            return context;
        }
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        let ret = undefined;
        if (context instanceof object_reference_type_1.ObjectReferenceType) {
            const def = input.scope.findObjectDefinition(context.getIdentifierName());
            if (def === undefined) {
                const message = "Definition for \"" + context.getIdentifierName() + "\" not found in scope(AttributeName)";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            const token = node.getFirstToken();
            const name = token.getStr();
            let found = helper.searchAttributeName(def, name);
            if (found === undefined) {
                found = helper.searchConstantName(def, name);
            }
            if (found === undefined) {
                const message = "Attribute or constant \"" + name + "\" not found in \"" + def.getName() + "\"";
                if (error === true) {
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                }
                return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            if (type) {
                input.scope.addReference(token, found, type, input.filename);
            }
            if (found && name.includes("~")) {
                const idef = input.scope.findInterfaceDefinition(name.split("~")[0]);
                if (idef) {
                    input.scope.addReference(token, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                }
            }
            ret = found.getType();
        }
        else if (context instanceof data_reference_type_1.DataReference) {
            const sub = context.getType();
            const name = node.getFirstToken().getStr();
            if (name === "*" || sub instanceof void_type_1.VoidType || sub instanceof basic_1.AnyType) {
                return sub;
            }
            if (!(sub instanceof structure_type_1.StructureType)) {
                const message = "Data reference not structured";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            ret = sub.getComponentByName(name);
            if (ret === undefined) {
                const message = "Component \"" + name + "\" not found in data reference structure";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        else {
            const message = "Not an object reference, attribute name";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return ret;
    }
}
exports.AttributeName = AttributeName;
//# sourceMappingURL=attribute_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cast.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cast.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cast = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Cast {
    runSyntax(node, input, targetType) {
        const sourceNode = node.findDirectExpression(Expressions.Source);
        if (sourceNode === undefined) {
            const message = "Cast, source node not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const sourceType = new source_1.Source().runSyntax(sourceNode, input);
        let tt = undefined;
        const typeExpression = node.findDirectExpression(Expressions.TypeNameOrInfer);
        const typeName = typeExpression === null || typeExpression === void 0 ? void 0 : typeExpression.concatTokens();
        if (typeName === undefined) {
            const message = "Cast, child TypeNameOrInfer not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        else if (typeName === "#" && targetType) {
            tt = targetType;
        }
        else if (typeName === "#") {
            const message = "Cast, todo, infer type";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        if (tt === undefined && typeExpression) {
            const basic = new basic_types_1.BasicTypes(input);
            tt = basic.parseType(typeExpression);
            if (tt === undefined || tt instanceof basic_1.VoidType || tt instanceof basic_1.UnknownType) {
                const found = input.scope.findObjectDefinition(typeName);
                if (found) {
                    tt = new basic_1.ObjectReferenceType(found, { qualifiedName: typeName });
                    input.scope.addReference(typeExpression.getFirstToken(), found, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                }
            }
            else {
                tt = new basic_1.DataReference(tt, typeName);
            }
            if (tt === undefined && input.scope.getDDIC().inErrorNamespace(typeName) === false) {
                tt = new basic_1.VoidType(typeName);
            }
            else if (typeName.toUpperCase() === "OBJECT") {
                return new basic_1.GenericObjectReferenceType();
            }
            else if (tt === undefined) {
                // todo, this should be an UnknownType instead?
                const message = "Type \"" + typeName + "\" not found in scope, Cast";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, typeExpression.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        new source_1.Source().addIfInferred(node, input, tt);
        if (new _type_utils_1.TypeUtils(input.scope).isCastable(sourceType, tt) === false) {
            const message = "Cast, incompatible types";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return tt;
    }
}
exports.Cast = Cast;
//# sourceMappingURL=cast.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/compare.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/compare.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Compare = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const method_call_chain_1 = __webpack_require__(/*! ./method_call_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_chain.js");
const source_field_symbol_1 = __webpack_require__(/*! ./source_field_symbol */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field_symbol.js");
class Compare {
    runSyntax(node, input) {
        for (const t of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(t, input);
        }
        for (const t of node.findDirectExpressions(Expressions.SourceFieldSymbolChain)) {
            new source_field_symbol_1.SourceFieldSymbol().runSyntax(t, input);
        }
        for (const t of node.findDirectExpressions(Expressions.MethodCallChain)) {
            new method_call_chain_1.MethodCallChain().runSyntax(t, input);
        }
    }
}
exports.Compare = Compare;
//# sourceMappingURL=compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_chain.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_chain.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentChain = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const void_type_1 = __webpack_require__(/*! ../../types/basic/void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js");
const structure_type_1 = __webpack_require__(/*! ../../types/basic/structure_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const types_1 = __webpack_require__(/*! ../../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ComponentChain {
    runSyntax(context, node, input) {
        if (context === undefined) {
            return undefined;
        }
        const children = node.getChildren();
        for (let i = 0; i < children.length; i++) {
            if (context instanceof void_type_1.VoidType || context instanceof basic_1.UnknownType) {
                return context;
            }
            const child = children[i];
            if (i === 0 && child.concatTokens().toUpperCase() === "TABLE_LINE") {
                continue;
            }
            else if (child.get() instanceof Expressions.ArrowOrDash) {
                const concat = child.concatTokens();
                if (concat === "-") {
                    if (!(context instanceof structure_type_1.StructureType)) {
                        const message = "ComponentChain, not a structure";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                }
                else if (concat === "=>") {
                    if (!(context instanceof basic_1.ObjectReferenceType)) {
                        const message = "ComponentChain, not a reference";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                }
                else if (concat === "->") {
                    if (!(context instanceof basic_1.ObjectReferenceType) && !(context instanceof basic_1.DataReference)) {
                        const message = "ComponentChain, not a reference";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                }
            }
            else if (child.get() instanceof Expressions.ComponentName) {
                const name = child.concatTokens();
                if (context instanceof basic_1.DataReference) {
                    context = context.getType();
                    if (name === "*") {
                        continue;
                    }
                }
                if (context instanceof structure_type_1.StructureType) {
                    context = context.getComponentByName(name);
                    if (context === undefined) {
                        const message = "Component \"" + name + "\" not found in structure";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                }
                else if (context instanceof basic_1.ObjectReferenceType) {
                    const id = context.getIdentifier();
                    const def = input.scope.findObjectDefinition(id.getName());
                    if (def === undefined) {
                        const message = id.getName() + " not found in scope";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                    const helper = new _object_oriented_1.ObjectOriented(input.scope);
                    const found = helper.searchAttributeName(def, name);
                    context = found === null || found === void 0 ? void 0 : found.getType();
                    if (context === undefined) {
                        const message = "Attribute \"" + name + "\" not found";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                        return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                    else {
                        const extra = {
                            ooName: id.getName(),
                            ooType: id instanceof types_1.ClassDefinition ? "CLAS" : "INTF"
                        };
                        input.scope.addReference(child.getFirstToken(), found, _reference_1.ReferenceType.DataWriteReference, input.filename, extra);
                    }
                }
                else {
                    const message = "ComponentChain, not a structure, " + (context === null || context === void 0 ? void 0 : context.constructor.name);
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, child.getFirstToken(), message));
                    return new void_type_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
        }
        return context;
    }
}
exports.ComponentChain = ComponentChain;
//# sourceMappingURL=component_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCompare = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const component_chain_1 = __webpack_require__(/*! ./component_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_chain.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class ComponentCompare {
    runSyntax(node, input, type) {
        const chain = node.findDirectExpression(Expressions.ComponentChainSimple);
        if (chain === undefined) {
            const message = "ComponentCompare, chain not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        new component_chain_1.ComponentChain().runSyntax(type, chain, input);
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.ComponentCompare = ComponentCompare;
//# sourceMappingURL=component_compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare_simple.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare_simple.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCompareSimple = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const component_chain_1 = __webpack_require__(/*! ./component_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_chain.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class ComponentCompareSimple {
    runSyntax(node, input, rowType) {
        let targetType = undefined;
        for (const c of node.getChildren()) {
            if (c instanceof nodes_1.ExpressionNode) {
                if (c.get() instanceof Expressions.ComponentChainSimple) {
                    targetType = new component_chain_1.ComponentChain().runSyntax(rowType, c, input);
                }
                else if (c.get() instanceof Expressions.Dynamic) {
                    targetType = undefined;
                }
                else if (c.get() instanceof Expressions.Source) {
                    const sourceType = new source_1.Source().runSyntax(c, input, targetType);
                    if (targetType && new _type_utils_1.TypeUtils(input.scope).isAssignable(sourceType, targetType) === false) {
                        const message = "ComponentCompareSimple, incompatible types";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                }
                else {
                    const message = "ComponentCompareSimple, unexpected node";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
    }
}
exports.ComponentCompareSimple = ComponentCompareSimple;
//# sourceMappingURL=component_compare_simple.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentCond = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const component_compare_1 = __webpack_require__(/*! ./component_compare */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare.js");
class ComponentCond {
    runSyntax(node, input, type) {
        for (const t of node.findDirectExpressions(Expressions.ComponentCondSub)) {
            const c = t.findDirectExpression(Expressions.ComponentCond);
            if (c) {
                new ComponentCond().runSyntax(c, input, type);
            }
        }
        for (const t of node.findDirectExpressions(Expressions.ComponentCompare)) {
            new component_compare_1.ComponentCompare().runSyntax(t, input, type);
        }
    }
}
exports.ComponentCond = ComponentCond;
//# sourceMappingURL=component_cond.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ComponentName = void 0;
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ComponentName {
    runSyntax(context, node, input) {
        if (context instanceof Basic.VoidType) {
            return context;
        }
        const nameToken = node.getFirstToken();
        const name = nameToken.getStr();
        if (context instanceof Basic.StructureType) {
            const ret = context.getComponentByName(name);
            if (ret === undefined) {
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, "Component \"" + name + "\" not found in structure"));
                return new Basic.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            return ret;
        }
        if (context instanceof Basic.TableType && context.isWithHeader() === true) {
            const rowType = context.getRowType();
            if (rowType instanceof Basic.VoidType) {
                return context;
            }
            else if (name.toUpperCase() === "TABLE_LINE") {
                return rowType;
            }
            else if (rowType instanceof Basic.StructureType) {
                const ret = rowType.getComponentByName(name);
                if (ret === undefined) {
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, "Component \"" + name + "\" not found in structure"));
                    return new Basic.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                return ret;
            }
        }
        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, "Not a structure, ComponentName, \"" + name + "\""));
        return new Basic.VoidType(_syntax_input_1.CheckSyntaxKey);
    }
}
exports.ComponentName = ComponentName;
//# sourceMappingURL=component_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Cond = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const compare_1 = __webpack_require__(/*! ./compare */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/compare.js");
class Cond {
    runSyntax(node, input) {
        for (const t of node.findDirectExpressions(Expressions.CondSub)) {
            const c = t.findDirectExpression(Expressions.Cond);
            if (c) {
                new Cond().runSyntax(c, input);
            }
        }
        for (const t of node.findDirectExpressions(Expressions.Compare)) {
            new compare_1.Compare().runSyntax(t, input);
        }
    }
}
exports.Cond = Cond;
//# sourceMappingURL=cond.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond_body.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond_body.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CondBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js");
const cond_1 = __webpack_require__(/*! ./cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class CondBody {
    runSyntax(node, input) {
        if (node === undefined) {
            return undefined;
        }
        let scoped = false;
        const l = node.findDirectExpression(Expressions.Let);
        if (l) {
            scoped = new let_1.Let().runSyntax(l, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
        let type = undefined;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            if (type === undefined) {
                type = new source_1.Source().runSyntax(s, input);
            }
            else {
                new source_1.Source().runSyntax(s, input);
            }
        }
        if (scoped === true) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        return type;
    }
}
exports.CondBody = CondBody;
//# sourceMappingURL=cond_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/constant.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/constant.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constant = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class Constant {
    runSyntax(node) {
        // todo: ConcatenatedConstant is not used?
        if (node.findDirectExpression(expressions_1.Integer)) {
            return basic_1.IntegerType.get({ derivedFromConstant: true });
        }
        const first = node.getFirstToken().getStr();
        if (first.startsWith("'")) {
            let len = first.length - 2;
            if (len <= 0) {
                len = 1;
            }
            return new basic_1.CharacterType(len, { derivedFromConstant: true });
        }
        else if (first.startsWith("`")) {
            return basic_1.StringType.get({ derivedFromConstant: true });
        }
        else {
            return basic_1.StringType.get();
        }
    }
}
exports.Constant = Constant;
//# sourceMappingURL=constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/conv_body.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/conv_body.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConvBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class ConvBody {
    runSyntax(node, input) {
        let scoped = false;
        const l = node.findDirectExpression(Expressions.Let);
        if (l) {
            scoped = new let_1.Let().runSyntax(l, input);
        }
        const s = node.findDirectExpression(Expressions.Source);
        if (s === undefined) {
            const message = "ConvBody, no source found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const sourceType = new source_1.Source().runSyntax(s, input);
        if (scoped === true) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        return sourceType;
    }
}
exports.ConvBody = ConvBody;
//# sourceMappingURL=conv_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/corresponding_body.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/corresponding_body.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CorrespondingBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class CorrespondingBody {
    runSyntax(node, input, targetType) {
        if (node === undefined) {
            return targetType;
        }
        let type = undefined;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            if (type === undefined) {
                type = new source_1.Source().runSyntax(s, input);
            }
            else {
                new source_1.Source().runSyntax(s, input);
            }
        }
        return targetType ? targetType : type;
    }
}
exports.CorrespondingBody = CorrespondingBody;
//# sourceMappingURL=corresponding_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/data_definition.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/data_definition.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataDefinition = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const type_table_1 = __webpack_require__(/*! ./type_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table.js");
class DataDefinition {
    runSyntax(node, input) {
        const tt = node.findFirstExpression(Expressions.TypeTable);
        if (tt) {
            return new type_table_1.TypeTable().runSyntax(node, input);
        }
        const valueNode = node.findFirstExpression(Expressions.Value);
        let value = undefined;
        if (valueNode) {
            value = new basic_types_1.BasicTypes(input).findValue(node);
        }
        const name = node.findFirstExpression(Expressions.DefinitionName);
        const typeStructure = node.findFirstExpression(Expressions.TypeStructure);
        if (typeStructure && name) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.VoidType("DataDefinition, TypeStructure"));
        }
        const bfound = new basic_types_1.BasicTypes(input).simpleType(node);
        if (bfound) {
            if (value) {
                return new _typed_identifier_1.TypedIdentifier(bfound.getToken(), input.filename, bfound.getType(), bfound.getMeta(), value);
            }
            else {
                return bfound;
            }
        }
        if (name) {
            console.dir("undef");
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.UnknownType("DataDefinition, fallback"));
        }
        return undefined;
    }
}
exports.DataDefinition = DataDefinition;
//# sourceMappingURL=data_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DatabaseTable = void 0;
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class DatabaseTable {
    runSyntax(node, input) {
        const token = node.getFirstToken();
        const name = token.getStr();
        if (name === "(") {
            // dynamic
            return undefined;
        }
        const found = input.scope.getDDIC().lookupTableOrView2(name);
        if (found === undefined && input.scope.getDDIC().inErrorNamespace(name) === true) {
            const message = "Database table or view \"" + name + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
        }
        else if (found === undefined) {
            input.scope.addReference(token, undefined, _reference_1.ReferenceType.TableVoidReference, input.filename);
        }
        else {
            input.scope.addReference(token, found.getIdentifier(), _reference_1.ReferenceType.TableReference, input.filename);
            input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: found, token: token, filename: input.filename });
        }
        return found;
    }
}
exports.DatabaseTable = DatabaseTable;
//# sourceMappingURL=database_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/default.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/default.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Default = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/constant.js");
class Default {
    runSyntax(node, input) {
        const chain = node.findDirectExpression(Expressions.FieldChain);
        if (chain) {
            return new field_chain_1.FieldChain().runSyntax(chain, input, _reference_1.ReferenceType.DataReadReference);
        }
        const constant = node.findDirectExpression(Expressions.Constant);
        if (constant) {
            return new constant_1.Constant().runSyntax(constant);
        }
        return undefined;
    }
}
exports.Default = Default;
//# sourceMappingURL=default.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dereference.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dereference.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dereference = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Dereference {
    runSyntax(node, type, input) {
        if (type instanceof basic_1.VoidType
            || type instanceof basic_1.AnyType
            || type instanceof basic_1.DataType
            || type === undefined
            || type instanceof basic_1.UnknownType) {
            return type;
        }
        if (!(type instanceof basic_1.DataReference)) {
            const message = "Not a data reference, cannot be dereferenced";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return type.getType();
    }
}
exports.Dereference = Dereference;
//# sourceMappingURL=dereference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Dynamic = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class Dynamic {
    runSyntax(node, input) {
        const chain = node.findDirectExpression(Expressions.FieldChain);
        if (chain) {
            new field_chain_1.FieldChain().runSyntax(chain, input, _reference_1.ReferenceType.DataReadReference);
        }
    }
}
exports.Dynamic = Dynamic;
//# sourceMappingURL=dynamic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_assignment.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_assignment.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldAssignment = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class FieldAssignment {
    runSyntax(node, input, targetType) {
        const fieldSub = node.findDirectExpression(Expressions.FieldSub);
        if (fieldSub === undefined) {
            const message = "FieldAssignment, FieldSub node not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const s = node.findDirectExpression(Expressions.Source);
        if (s === undefined) {
            const message = "FieldAssignment, Source node not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        let type = undefined;
        if (targetType instanceof basic_1.StructureType) {
            let context = targetType;
            for (const c of fieldSub.getChildren()) {
                const text = c.concatTokens();
                if (text !== "-" && context instanceof basic_1.StructureType) {
                    context = context.getComponentByName(text);
                    if (context === undefined && targetType.containsVoid() === false) {
                        const message = `field ${text} does not exist in structure`;
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                }
            }
            type = context;
        }
        else if (targetType instanceof basic_1.VoidType) {
            type = targetType;
        }
        new source_1.Source().runSyntax(s, input, type);
    }
}
exports.FieldAssignment = FieldAssignment;
//# sourceMappingURL=field_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldChain = void 0;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const component_name_1 = __webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const field_offset_1 = __webpack_require__(/*! ./field_offset */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_offset.js");
const field_length_1 = __webpack_require__(/*! ./field_length */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_length.js");
const table_expression_1 = __webpack_require__(/*! ./table_expression */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/table_expression.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const dereference_1 = __webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dereference.js");
const source_field_symbol_1 = __webpack_require__(/*! ./source_field_symbol */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field_symbol.js");
const source_field_1 = __webpack_require__(/*! ./source_field */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class FieldChain {
    runSyntax(node, input, refType) {
        var _a, _b, _c;
        if (((_a = node.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.SourceField
            && node.findDirectExpression(Expressions.ComponentName)) {
            // workaround for names with dashes, eg. "sy-repid"
            const concat = node.concatTokens();
            const offset = ((_b = node.findDirectExpression(Expressions.FieldOffset)) === null || _b === void 0 ? void 0 : _b.concatTokens()) || "";
            const length = ((_c = node.findDirectExpression(Expressions.FieldLength)) === null || _c === void 0 ? void 0 : _c.concatTokens()) || "";
            const found = input.scope.findVariable(concat.replace(offset, "").replace(length, ""));
            if (found) {
                if (refType) {
                    input.scope.addReference(node.getFirstToken(), found, refType, input.filename);
                }
                // this is not completely correct, but will work, dashes in names is a mess anyhow
                return found.getType();
            }
        }
        let context = undefined;
        const children = node.getChildren();
        context = this.findTop(children[0], input, refType);
        for (let i = 1; i < children.length; i++) {
            const current = children[i];
            if (current === undefined) {
                break;
            }
            if (current.get() instanceof tokens_1.DashW) {
                const message = "Ending with dash";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            else if (current.get() instanceof tokens_1.Dash) {
                if (context instanceof basic_1.UnknownType) {
                    const message = "Not a structure, type unknown, FieldChain";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                else if (!(context instanceof basic_1.StructureType)
                    && !(context instanceof basic_1.TableType && context.isWithHeader())
                    && !(context instanceof basic_1.VoidType)) {
                    if (context instanceof basic_1.TableType && context.isWithHeader() === false) {
                        let contextName = "";
                        for (let j = 0; j < i; j++) {
                            contextName += children[j].concatTokens();
                        }
                        if (input.scope.isAllowHeaderUse(contextName)) {
                            // FOR ALL ENTRIES workaround
                            context = context.getRowType();
                            if (!(context instanceof basic_1.StructureType) && !(context instanceof basic_1.VoidType)) {
                                context = new basic_1.StructureType([{ name: "TABLE_LINE", type: context }]);
                            }
                        }
                        else {
                            const message = "Table without header, cannot access fields, " + contextName;
                            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                        }
                    }
                    else {
                        const message = "Not a structure, FieldChain";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                        return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                }
            }
            else if (current.get() instanceof tokens_1.InstanceArrow) {
                if (!(context instanceof basic_1.ObjectReferenceType)
                    && !(context instanceof basic_1.DataReference)
                    && !(context instanceof basic_1.VoidType)) {
                    const message = "Not an object reference, field chain";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            else if (current.get() instanceof expressions_1.Dereference) {
                context = new dereference_1.Dereference().runSyntax(current, context, input);
            }
            else if (current.get() instanceof Expressions.ComponentName) {
                if (context instanceof basic_1.TableType && context.isWithHeader()) {
                    context = context.getRowType();
                }
                context = new component_name_1.ComponentName().runSyntax(context, current, input);
            }
            else if (current instanceof nodes_1.ExpressionNode
                && current.get() instanceof Expressions.TableExpression) {
                if (!(context instanceof basic_1.TableType) && !(context instanceof basic_1.VoidType)) {
                    const message = "Table expression, expected table";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, current.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                new table_expression_1.TableExpression().runSyntax(current, input);
                if (!(context instanceof basic_1.VoidType)) {
                    context = context.getRowType();
                }
            }
            else if (current.get() instanceof Expressions.AttributeName) {
                context = new attribute_name_1.AttributeName().runSyntax(context, current, input, refType);
            }
            else if (current.get() instanceof Expressions.FieldOffset && current instanceof nodes_1.ExpressionNode) {
                const offset = new field_offset_1.FieldOffset().runSyntax(current, input);
                if (offset) {
                    if (context instanceof basic_1.CharacterType) {
                        context = new basic_1.CharacterType(context.getLength() - offset);
                    }
                    else if (context instanceof basic_1.HexType) {
                        context = new basic_1.HexType(context.getLength() - offset);
                    }
                }
            }
            else if (current.get() instanceof Expressions.FieldLength && current instanceof nodes_1.ExpressionNode) {
                const length = new field_length_1.FieldLength().runSyntax(current, input);
                if (length) {
                    if (context instanceof basic_1.CharacterType) {
                        context = new basic_1.CharacterType(length);
                    }
                    else if (context instanceof basic_1.HexType) {
                        context = new basic_1.HexType(length);
                    }
                }
            }
        }
        return context;
    }
    ////////////////
    findTop(node, input, type) {
        if (node === undefined) {
            return undefined;
        }
        if (node instanceof nodes_1.ExpressionNode
            && node.get() instanceof Expressions.SourceFieldSymbol) {
            return new source_field_symbol_1.SourceFieldSymbol().runSyntax(node, input);
        }
        else if (node instanceof nodes_1.ExpressionNode
            && node.get() instanceof Expressions.SourceField) {
            return new source_field_1.SourceField().runSyntax(node, input, type);
        }
        else if (node instanceof nodes_1.ExpressionNode
            && node.get() instanceof Expressions.Field) {
            return new source_field_1.SourceField().runSyntax(node, input, type);
        }
        else if (node.get() instanceof Expressions.ClassName) {
            const classTok = node.getFirstToken();
            const classNam = classTok.getStr();
            if (classNam.toUpperCase() === "OBJECT") {
                return new basic_1.GenericObjectReferenceType();
            }
            const found = input.scope.existsObject(classNam);
            if (found === null || found === void 0 ? void 0 : found.id) {
                input.scope.addReference(classTok, found.id, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                return new basic_1.ObjectReferenceType(found.id);
            }
            else if (input.scope.getDDIC().inErrorNamespace(classNam) === false) {
                input.scope.addReference(classTok, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, { ooName: classNam.toUpperCase() });
                return new basic_1.VoidType(classNam);
            }
            else {
                const message = "Unknown class " + classNam;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        return undefined;
    }
}
exports.FieldChain = FieldChain;
//# sourceMappingURL=field_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_length.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_length.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldLength = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
class FieldLength {
    runSyntax(node, input) {
        const field = node.findDirectExpression(Expressions.SimpleFieldChain2);
        if (field) {
            new field_chain_1.FieldChain().runSyntax(field, input, _reference_1.ReferenceType.DataReadReference);
            return undefined;
        }
        else {
            const children = node.getChildren();
            const num = children[children.length - 2];
            if (num.getLastToken().getStr() === "*") {
                return undefined;
            }
            return parseInt(num.getLastToken().getStr(), 10);
        }
    }
}
exports.FieldLength = FieldLength;
//# sourceMappingURL=field_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_offset.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_offset.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldOffset = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
class FieldOffset {
    runSyntax(node, input) {
        const field = node.findDirectExpression(Expressions.SimpleFieldChain2);
        if (field) {
            new field_chain_1.FieldChain().runSyntax(field, input, _reference_1.ReferenceType.DataReadReference);
            return undefined;
        }
        else {
            return parseInt(node.getLastToken().getStr(), 10);
        }
    }
}
exports.FieldOffset = FieldOffset;
//# sourceMappingURL=field_offset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/filter_body.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/filter_body.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FilterBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class FilterBody {
    runSyntax(node, input, targetType) {
        if (node === undefined) {
            return targetType;
        }
        let type = undefined;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            if (type === undefined) {
                type = new source_1.Source().runSyntax(s, input);
            }
            else {
                new source_1.Source().runSyntax(s, input);
            }
        }
        return type ? type : targetType;
    }
}
exports.FilterBody = FilterBody;
//# sourceMappingURL=filter_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/for.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/for.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.For = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_field_definition_1 = __webpack_require__(/*! ./inline_field_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_field_definition.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const inline_loop_definition_1 = __webpack_require__(/*! ./inline_loop_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_loop_definition.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const component_cond_1 = __webpack_require__(/*! ./component_cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js");
const cond_1 = __webpack_require__(/*! ./cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js");
class For {
    runSyntax(node, input) {
        var _a;
        let scoped = false;
        const inlineLoop = node.findDirectExpressions(Expressions.InlineLoopDefinition);
        const inlineField = node.findDirectExpressions(Expressions.InlineFieldDefinition);
        const groupsToken = (_a = node.findExpressionAfterToken("GROUPS")) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        const lett = node.findDirectExpression(Expressions.Let);
        const addScope = inlineLoop.length > 0
            || inlineField.length > 0
            || lett !== undefined
            || groupsToken !== undefined;
        if (addScope) {
            // this scope is popped in parent expressions
            input.scope.push(_scope_type_1.ScopeType.For, "FOR", node.getFirstToken().getStart(), input.filename);
            scoped = true;
        }
        for (const s of inlineLoop) {
            new inline_loop_definition_1.InlineLoopDefinition().runSyntax(s, input);
        }
        for (const f of inlineField) {
            new inline_field_definition_1.InlineFieldDefinition().runSyntax(f, input);
        }
        if (groupsToken !== undefined) {
            const type = new basic_1.VoidType("todoGroupBy");
            const identifier = new _typed_identifier_1.TypedIdentifier(groupsToken, input.filename, type, ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addIdentifier(identifier);
            input.scope.addReference(groupsToken, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.ComponentCond)) {
            new component_cond_1.ComponentCond().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
        if (lett) {
            new let_1.Let().runSyntax(lett, input, true);
        }
        return scoped;
    }
}
exports.For = For;
//# sourceMappingURL=for.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/form_param.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/form_param.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormParam = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class FormParam {
    runSyntax(node, input) {
        var _a, _b, _c;
        const nameToken = (_a = node.findFirstExpression(expressions_1.FormParamName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (node.findDirectTokenByText("STRUCTURE") && nameToken) {
            // STRUCTURES typing
            const typeName = (_b = node.findDirectExpression(expressions_1.SimpleFieldChain)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr();
            let type = undefined;
            if (typeName) {
                type = (_c = input.scope.findType(typeName)) === null || _c === void 0 ? void 0 : _c.getType();
                if (type === undefined) {
                    type = input.scope.getDDIC().lookupTableOrView(typeName).type;
                }
            }
            else {
                type = new basic_1.UnknownType("todo, FORM STRUCTURES typing");
            }
            return new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, type, ["form_parameter" /* IdentifierMeta.FormParameter */]);
        }
        if (node.getChildren().length === 1 && nameToken) {
            // untyped FORM parameter
            return new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new basic_1.AnyType(), ["form_parameter" /* IdentifierMeta.FormParameter */]);
        }
        const bfound = new basic_types_1.BasicTypes(input).parseType(node);
        if (nameToken && bfound) {
            return new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, bfound, ["form_parameter" /* IdentifierMeta.FormParameter */]);
        }
        if (nameToken) {
            return new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new basic_1.UnknownType("FormParam, todo"), ["form_parameter" /* IdentifierMeta.FormParameter */]);
        }
        throw new assert_error_1.AssertError("FormParam, unexpected node");
    }
}
exports.FormParam = FormParam;
//# sourceMappingURL=form_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FSTarget = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_fs_1 = __webpack_require__(/*! ./inline_fs */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_fs.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class FSTarget {
    runSyntax(node, input, type) {
        const inlinefs = node === null || node === void 0 ? void 0 : node.findDirectExpression(Expressions.InlineFS);
        if (inlinefs) {
            new inline_fs_1.InlineFS().runSyntax(inlinefs, input, type);
        }
        const target = node === null || node === void 0 ? void 0 : node.findDirectExpression(Expressions.TargetFieldSymbol);
        if (target) {
            const token = target.getFirstToken();
            const found = input.scope.findVariable(token.getStr());
            if (found === undefined) {
                const message = `"${token.getStr()}" not found, FSTarget`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            input.scope.addReference(token, found, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
    }
}
exports.FSTarget = FSTarget;
//# sourceMappingURL=fstarget.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineData = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class InlineData {
    runSyntax(node, input, type) {
        var _a;
        const token = (_a = node.findFirstExpression(Expressions.TargetField)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (token && type) {
            if (type instanceof basic_1.CSequenceType || type instanceof basic_1.CLikeType) {
                type = basic_1.StringType.get();
            }
            else if (type instanceof basic_1.CGenericType) {
                const message = "InlineData, generic type C cannot be used for inferred type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, type, ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addIdentifier(identifier);
            input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
        else if (token) {
            const message = "InlineData, could not determine type for \"" + token.getStr() + "\"";
            const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, new basic_1.UnknownType(message), ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addIdentifier(identifier);
            input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
    }
}
exports.InlineData = InlineData;
//# sourceMappingURL=inline_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_field_definition.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_field_definition.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineFieldDefinition = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class InlineFieldDefinition {
    runSyntax(node, input, targetType) {
        var _a;
        let type = undefined;
        const field = (_a = node.findDirectExpression(Expressions.Field)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (field === undefined) {
            return undefined;
        }
        const source = node.findDirectExpression(Expressions.Source);
        if (source) {
            type = new source_1.Source().runSyntax(source, input);
        }
        const typeName = node.findDirectExpression(Expressions.TypeName);
        if (typeName) {
            type = new basic_types_1.BasicTypes(input).parseType(typeName);
        }
        if (targetType !== undefined) {
            type = targetType;
        }
        if (type === undefined) {
            type = new unknown_type_1.UnknownType("InlineFieldDefinition, fallback");
        }
        const name = field.getStr();
        if (input.scope.findVariable(name) !== undefined) {
            const message = `Variable ${name} already defined`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const identifier = new _typed_identifier_1.TypedIdentifier(field, input.filename, type, ["inline" /* IdentifierMeta.InlineDefinition */]);
        input.scope.addReference(field, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        input.scope.addIdentifier(identifier);
        return type;
    }
}
exports.InlineFieldDefinition = InlineFieldDefinition;
//# sourceMappingURL=inline_field_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_fs.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_fs.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineFS = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class InlineFS {
    runSyntax(node, input, type) {
        var _a;
        const token = (_a = node.findFirstExpression(Expressions.TargetFieldSymbol)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (token && type) {
            const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, type, ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addIdentifier(identifier);
            input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
        else if (token) {
            const message = "InlineFS, could not determine type for \"" + token.getStr() + "\"";
            const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, new basic_1.UnknownType(message), ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addIdentifier(identifier);
            input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
    }
}
exports.InlineFS = InlineFS;
//# sourceMappingURL=inline_fs.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_loop_definition.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_loop_definition.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineLoopDefinition = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class InlineLoopDefinition {
    runSyntax(node, input) {
        if (node === undefined) {
            return;
        }
        let target = node.findDirectExpression(Expressions.TargetField);
        if (target === undefined) {
            target = node.findDirectExpression(Expressions.TargetFieldSymbol);
        }
        const source = node.findDirectExpression(Expressions.Source);
        if (source && target) {
            const sourceType = new source_1.Source().runSyntax(source, input);
            let rowType = undefined;
            if (sourceType instanceof basic_1.TableType) {
                rowType = sourceType.getRowType();
            }
            else if (sourceType instanceof basic_1.VoidType) {
                rowType = sourceType;
            }
            else if (sourceType instanceof basic_1.UnknownType) {
                const message = "Unknown type, " + sourceType.getError();
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            if (rowType === undefined
                && node.concatTokens().toUpperCase().includes(" IN GROUP ")
                && sourceType !== undefined) {
                rowType = sourceType;
            }
            else if (rowType === undefined) {
                const message = "InlineLoopDefinition, not a table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const identifier = new _typed_identifier_1.TypedIdentifier(target.getFirstToken(), input.filename, rowType, ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addReference(target.getFirstToken(), identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
            input.scope.addReference(target.getFirstToken(), identifier, _reference_1.ReferenceType.DataReadReference, input.filename);
            input.scope.addIdentifier(identifier);
        }
        const index = node.findExpressionAfterToken("INTO");
        if (index && index.get() instanceof Expressions.TargetField) {
            const identifier = new _typed_identifier_1.TypedIdentifier(index.getFirstToken(), input.filename, basic_1.IntegerType.get(), ["inline" /* IdentifierMeta.InlineDefinition */]);
            input.scope.addReference(index.getFirstToken(), identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
            input.scope.addIdentifier(identifier);
        }
    }
}
exports.InlineLoopDefinition = InlineLoopDefinition;
//# sourceMappingURL=inline_loop_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Let = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_field_definition_1 = __webpack_require__(/*! ./inline_field_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_field_definition.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class Let {
    runSyntax(node, input, skipScope = false) {
        if (node === undefined) {
            return false;
        }
        if (skipScope !== true) {
            input.scope.push(_scope_type_1.ScopeType.Let, "LET", node.getFirstToken().getStart(), input.filename);
        }
        for (const f of node.findDirectExpressions(Expressions.InlineFieldDefinition)) {
            new inline_field_definition_1.InlineFieldDefinition().runSyntax(f, input);
        }
        return true;
    }
}
exports.Let = Let;
//# sourceMappingURL=let.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/loop_group_by.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/loop_group_by.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopGroupBy = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const component_compare_1 = __webpack_require__(/*! ./component_compare */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare.js");
const inline_data_1 = __webpack_require__(/*! ./inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const fstarget_1 = __webpack_require__(/*! ./fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class LoopGroupBy {
    runSyntax(node, input) {
        for (const t of node.findAllExpressions(Expressions.Target)) {
            const inline = t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("todoGroupBy"));
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
        for (const t of node.findAllExpressions(Expressions.FSTarget)) {
            new fstarget_1.FSTarget().runSyntax(t, input, new basic_1.VoidType("todoGroupBy"));
        }
        for (const c of node.findDirectExpressions(Expressions.LoopGroupByComponent)) {
            for (const t of c.findDirectExpressions(Expressions.ComponentCompareSingle)) {
                new component_compare_1.ComponentCompare().runSyntax(t, input);
            }
        }
    }
}
exports.LoopGroupBy = LoopGroupBy;
//# sourceMappingURL=loop_group_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/message_source.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/message_source.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageSource = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class MessageSource {
    runSyntax(node, input) {
        var _a, _b, _c, _d, _e;
        for (const f of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(f, input);
        }
        if (node.getFirstToken().getStr().toUpperCase() === "ID") {
            const id = (_a = node.findExpressionAfterToken("ID")) === null || _a === void 0 ? void 0 : _a.concatTokens();
            let number = (_b = node.findDirectExpression(Expressions.MessageNumber)) === null || _b === void 0 ? void 0 : _b.concatTokens();
            if (number === undefined) {
                const num = (_c = node.findExpressionAfterToken("NUMBER")) === null || _c === void 0 ? void 0 : _c.concatTokens();
                if (num === null || num === void 0 ? void 0 : num.startsWith("'")) {
                    number = num.substring(1, num.length - 1).toUpperCase();
                }
            }
            if ((id === null || id === void 0 ? void 0 : id.startsWith("'")) && number) {
                const messageClass = id.substring(1, id.length - 1).toUpperCase();
                input.scope.getMSAGReferences().addUsing(input.filename, node.getFirstToken(), messageClass, number);
            }
        }
        else {
            const typeAndNumber = (_d = node.findDirectExpression(Expressions.MessageTypeAndNumber)) === null || _d === void 0 ? void 0 : _d.concatTokens();
            const messageNumber = typeAndNumber === null || typeAndNumber === void 0 ? void 0 : typeAndNumber.substring(1);
            const messageClass = (_e = node.findDirectExpression(Expressions.MessageClass)) === null || _e === void 0 ? void 0 : _e.concatTokens().toUpperCase();
            if (messageNumber && messageClass) {
                input.scope.getMSAGReferences().addUsing(input.filename, node.getFirstToken(), messageClass, messageNumber);
            }
        }
    }
}
exports.MessageSource = MessageSource;
//# sourceMappingURL=message_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_body.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_body.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_parameters_1 = __webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const method_call_param_1 = __webpack_require__(/*! ./method_call_param */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_param.js");
class MethodCallBody {
    runSyntax(node, input, method) {
        const parameters = node.findDirectExpression(Expressions.MethodParameters);
        if (parameters) {
            new method_parameters_1.MethodParameters().runSyntax(parameters, input, method);
        }
        const param = node.findDirectExpression(Expressions.MethodCallParam);
        if (param) {
            new method_call_param_1.MethodCallParam().runSyntax(param, input, method);
        }
        // for PARAMETER-TABLE and EXCEPTION-TABLE
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.MethodCallBody = MethodCallBody;
//# sourceMappingURL=method_call_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_chain.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_chain.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallChain = void 0;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const new_object_1 = __webpack_require__(/*! ./new_object */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/new_object.js");
const cast_1 = __webpack_require__(/*! ./cast */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cast.js");
const _builtin_1 = __webpack_require__(/*! ../_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const method_call_param_1 = __webpack_require__(/*! ./method_call_param */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_param.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const component_name_1 = __webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class MethodCallChain {
    runSyntax(node, input, targetType) {
        var _a, _b;
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        const children = node.getChildren().slice();
        const first = children.shift();
        if (first === undefined) {
            const message = "MethodCallChain, first child expected";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        let context = this.findTop(first, input, targetType);
        if (first.get() instanceof Expressions.MethodCall) {
            children.unshift(first);
        }
        let previous = undefined;
        while (children.length > 0) {
            const current = children.shift();
            if (current === undefined) {
                break;
            }
            if (current instanceof nodes_1.ExpressionNode && current.get() instanceof Expressions.MethodCall) {
                // for built-in methods set className to undefined
                const className = context instanceof basic_1.ObjectReferenceType ? context.getIdentifierName() : undefined;
                const methodToken = (_a = current.findDirectExpression(Expressions.MethodName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                const methodName = methodToken === null || methodToken === void 0 ? void 0 : methodToken.getStr();
                const def = input.scope.findObjectDefinition(className);
                // eslint-disable-next-line prefer-const
                let { method, def: foundDef } = helper.searchMethodName(def, methodName);
                if (method === undefined && current === first) {
                    method = new _builtin_1.BuiltIn().searchBuiltin(methodName === null || methodName === void 0 ? void 0 : methodName.toUpperCase());
                    if (method) {
                        input.scope.addReference(methodToken, method, _reference_1.ReferenceType.BuiltinMethodReference, input.filename);
                    }
                }
                else {
                    if (previous && previous.getFirstToken().getStr() === "=>" && (method === null || method === void 0 ? void 0 : method.isStatic()) === false) {
                        const message = "Method \"" + methodName + "\" not static";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, methodToken, message));
                        return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                    }
                    const voidedName = context instanceof basic_1.VoidType ? context.getVoided() : undefined;
                    const extra = helper.methodReferenceExtras(foundDef, className || voidedName);
                    input.scope.addReference(methodToken, method, _reference_1.ReferenceType.MethodReference, input.filename, extra);
                }
                if (methodName === null || methodName === void 0 ? void 0 : methodName.includes("~")) {
                    const name = methodName.split("~")[0];
                    const idef = input.scope.findInterfaceDefinition(name);
                    if (idef) {
                        input.scope.addReference(methodToken, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                    }
                }
                if (method === undefined && (methodName === null || methodName === void 0 ? void 0 : methodName.toUpperCase()) === "CONSTRUCTOR") {
                    context = undefined; // todo, this is a workaround, constructors always exists
                }
                else if (method === undefined && !(context instanceof basic_1.VoidType)) {
                    const message = "Method \"" + methodName + "\" not found, methodCallChain";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, methodToken, message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                else if (method) {
                    const ret = (_b = method.getParameters().getReturning()) === null || _b === void 0 ? void 0 : _b.getType();
                    context = ret;
                }
                const param = current.findDirectExpression(Expressions.MethodCallParam);
                if (param && method) {
                    new method_call_param_1.MethodCallParam().runSyntax(param, input, method);
                }
                else if (param && context instanceof basic_1.VoidType) {
                    new method_call_param_1.MethodCallParam().runSyntax(param, input, context);
                }
            }
            else if (current instanceof nodes_1.ExpressionNode && current.get() instanceof Expressions.ComponentName) {
                context = new component_name_1.ComponentName().runSyntax(context, current, input);
            }
            else if (current instanceof nodes_1.ExpressionNode && current.get() instanceof Expressions.AttributeName) {
                context = new attribute_name_1.AttributeName().runSyntax(context, current, input);
            }
            previous = current;
        }
        return context;
    }
    //////////////////////////////////////
    findTop(first, input, targetType) {
        var _a;
        if (first.get() instanceof Expressions.ClassName) {
            const token = first.getFirstToken();
            const className = token.getStr();
            const classDefinition = input.scope.findObjectDefinition(className);
            if (classDefinition === undefined && input.scope.getDDIC().inErrorNamespace(className) === false) {
                const extra = { ooName: className, ooType: "Void" };
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, extra);
                return new basic_1.VoidType(className);
            }
            else if (classDefinition === undefined) {
                const message = "Class " + className + " not found";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, first.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            input.scope.addReference(first.getFirstToken(), classDefinition, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            return new basic_1.ObjectReferenceType(classDefinition);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.FieldChain) {
            return new field_chain_1.FieldChain().runSyntax(first, input, _reference_1.ReferenceType.DataReadReference);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.NewObject) {
            return new new_object_1.NewObject().runSyntax(first, input, targetType);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.Cast) {
            return new cast_1.Cast().runSyntax(first, input, targetType);
        }
        else {
            const meType = (_a = input.scope.findVariable("me")) === null || _a === void 0 ? void 0 : _a.getType();
            if (meType) {
                return meType;
            }
        }
        return undefined;
    }
}
exports.MethodCallChain = MethodCallChain;
//# sourceMappingURL=method_call_chain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_param.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_param.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodCallParam = void 0;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_parameters_1 = __webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class MethodCallParam {
    runSyntax(node, input, method) {
        if (!(node.get() instanceof Expressions.MethodCallParam)) {
            const message = "MethodCallParam, unexpected input";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const children = node.getChildren();
        if (children.length < 2 || children.length > 3) {
            const message = "MethodCallParam, unexpected child length";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const child = children[1];
        if (child.get() instanceof tokens_1.WParenRight || child.get() instanceof tokens_1.WParenRightW) {
            if (!(method instanceof basic_1.VoidType)) {
                const required = method.getParameters().getRequiredParameters();
                if (required.length > 0) {
                    const message = "Parameter \"" + required[0].getName() + "\" must be supplied";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
        else if (child instanceof nodes_1.ExpressionNode
            && (child.get() instanceof Expressions.Source
                || child.get() instanceof Expressions.ConstantString)) {
            if (!(method instanceof basic_1.VoidType)) {
                if (method.getParameters().getImporting().length === 0) {
                    const message = "Method \"" + method.getName() + "\" has no importing parameters";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                else if (method.getParameters().getRequiredParameters().length > 1) {
                    const message = "Method \"" + method.getName() + "\" has more than one importing or changing parameter";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            let targetType = undefined;
            if (!(method instanceof basic_1.VoidType)) {
                const name = method.getParameters().getDefaultImporting();
                if (name === undefined) {
                    const message = "No default importing parameter";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                for (const i of method.getParameters().getImporting()) {
                    if (i.getName().toUpperCase() === name) {
                        targetType = i.getType();
                        break;
                    }
                }
            }
            else {
                targetType = method;
            }
            let sourceType = basic_1.StringType.get();
            if (child.get() instanceof Expressions.Source) {
                sourceType = new source_1.Source().runSyntax(child, input, targetType);
            }
            const calculated = child.findFirstExpression(Expressions.MethodCallChain) !== undefined
                || child.findFirstExpression(Expressions.StringTemplate) !== undefined
                || child.findFirstExpression(Expressions.ArithOperator) !== undefined;
            if (sourceType === undefined) {
                const message = "No source type determined, method source";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (new _type_utils_1.TypeUtils(input.scope).isAssignableStrict(sourceType, targetType, calculated) === false) {
                const message = "Method parameter type not compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        else if (child instanceof nodes_1.ExpressionNode && child.get() instanceof Expressions.ParameterListS) {
            new method_parameters_1.MethodParameters().checkExporting(child, input, method);
        }
        else if (child.get() instanceof Expressions.MethodParameters) {
            new method_parameters_1.MethodParameters().runSyntax(child, input, method);
        }
        else {
            //      console.dir(child);
            const message = "MethodCallParam, unexpected child";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
    }
}
exports.MethodCallParam = MethodCallParam;
//# sourceMappingURL=method_call_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_def_returning.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_def_returning.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefReturning = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class MethodDefReturning {
    runSyntax(node, input, meta) {
        const name = node.findDirectExpression(Expressions.MethodParamName);
        if (name === undefined) {
            throw new assert_error_1.AssertError("method_parameter.ts, todo, handle pass by value and reference");
        }
        const type = node.findDirectExpression(Expressions.TypeParam);
        if (type === undefined) {
            throw new assert_error_1.AssertError("method_parameter.ts, unexpected structure");
        }
        let found = new basic_types_1.BasicTypes(input).parseType(type);
        if ((found === null || found === void 0 ? void 0 : found.isGeneric()) === true) {
            found = new basic_1.UnknownType("RETURNING parameter must be fully specified");
        }
        if (found) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, found, meta);
        }
        else {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.UnknownType("method param, todo"), meta);
        }
    }
}
exports.MethodDefReturning = MethodDefReturning;
//# sourceMappingURL=method_def_returning.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_param.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_param.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParam = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const default_1 = __webpack_require__(/*! ./default */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/default.js");
const cgeneric_type_1 = __webpack_require__(/*! ../../types/basic/cgeneric_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/cgeneric_type.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class MethodParam {
    runSyntax(node, input, meta) {
        const name = node.findDirectExpression(Expressions.MethodParamName);
        if (name === undefined) {
            throw new assert_error_1.AssertError("MethodParam, todo, handle pass by value and reference");
        }
        const type = node.findDirectExpression(Expressions.TypeParam);
        if (type === undefined) {
            throw new assert_error_1.AssertError("MethodParam, unexpected structure");
        }
        const def = type.findDirectExpression(Expressions.Default);
        if (def) {
            try {
                new default_1.Default().runSyntax(def, input);
            }
            catch (e) {
                return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.UnknownType(e.toString()), meta);
            }
        }
        const concat = type.concatTokens().toUpperCase();
        if (concat === "TYPE C" || concat.startsWith("TYPE C ")) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new cgeneric_type_1.CGenericType(), meta);
        }
        else if (concat === "TYPE X" || concat.startsWith("TYPE X ")) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.XGenericType(), meta);
        }
        const found = new basic_types_1.BasicTypes(input).parseType(type);
        if (found) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, found, meta);
        }
        else {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new basic_1.UnknownType("method param, todo"), meta);
        }
    }
}
exports.MethodParam = MethodParam;
//# sourceMappingURL=method_param.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParameters = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const inline_data_1 = __webpack_require__(/*! ./inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class MethodParameters {
    constructor() {
        this.requiredParameters = undefined;
    }
    runSyntax(node, input, method) {
        var _a;
        if (!(node.get() instanceof Expressions.MethodParameters)) {
            throw new assert_error_1.AssertError("MethodParameters, unexpected input");
        }
        const children = node.getChildren().slice();
        if (method instanceof basic_1.VoidType) {
            this.requiredParameters = new Set();
        }
        else {
            this.requiredParameters = new Set(method.getParameters().getRequiredParameters().map(i => i.getName().toUpperCase()));
        }
        while (children.length > 0) {
            const name = (_a = children.shift()) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr().toUpperCase();
            switch (name) {
                case "EXPORTING":
                    this.checkExporting(children.shift(), input, method, false);
                    break;
                case "IMPORTING":
                    this.checkImporting(children.shift(), input, method);
                    break;
                case "CHANGING":
                    this.checkChanging(children.shift(), input, method);
                    break;
                case "RECEIVING":
                    this.checkReceiving(children.shift(), input, method);
                    break;
                case "EXCEPTIONS":
                    {
                        // todo, old style exceptions
                        const node = children.shift();
                        const exceptions = node.findFirstExpression(Expressions.ParameterException);
                        for (const s of (exceptions === null || exceptions === void 0 ? void 0 : exceptions.findAllExpressions(Expressions.SimpleFieldChain)) || []) {
                            new field_chain_1.FieldChain().runSyntax(s, input, _reference_1.ReferenceType.DataReadReference);
                        }
                    }
                    break;
                default:
                    throw new assert_error_1.AssertError("MethodParameters, unexpected token, " + name);
            }
        }
        this.reportErrors(node, input);
    }
    ///////////////////////
    checkReceiving(node, input, method) {
        var _a;
        const type = method instanceof basic_1.VoidType ? method : (_a = method.getParameters().getReturning()) === null || _a === void 0 ? void 0 : _a.getType();
        if (type === undefined) {
            const message = "Method does not have a returning parameter";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (!(node instanceof nodes_1.ExpressionNode)) {
            const message = "checkReceiving, not an expression node";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const target = node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, type);
        }
        else if (target) {
            const targetType = new target_1.Target().runSyntax(target, input);
            if (targetType && new _type_utils_1.TypeUtils(input.scope).isAssignable(type, targetType) === false) {
                const message = "Method returning value not type compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
    checkImporting(node, input, method) {
        for (const item of this.parameterListT(node, input)) {
            let parameterType = undefined;
            if (method instanceof basic_1.VoidType) {
                parameterType = method;
            }
            else {
                const parameter = method.getParameters().getExporting().find(p => p.getName().toUpperCase() === item.name);
                if (parameter === undefined) {
                    const message = "Method exporting parameter \"" + item.name + "\" does not exist";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                parameterType = parameter.getType();
            }
            const inline = item.target.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, parameterType);
            }
            else if (item.targetType === undefined) {
                const message = "Could not determine target type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (item.targetType && new _type_utils_1.TypeUtils(input.scope).isAssignable(parameterType, item.targetType) === false) {
                const message = "Method parameter type not compatible, " + item.name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
    checkChanging(node, input, method) {
        var _a;
        for (const item of this.parameterListT(node, input)) {
            if (item.target.findFirstExpression(Expressions.InlineData) !== undefined) {
                const message = "CHANGING cannot be inlined";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            let parameterType = undefined;
            if (method instanceof basic_1.VoidType) {
                parameterType = method;
            }
            else {
                const parameter = method.getParameters().getChanging().find(p => p.getName().toUpperCase() === item.name);
                if (parameter === undefined) {
                    const message = "Method changing parameter \"" + item.name + "\" does not exist";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                parameterType = parameter.getType();
            }
            if (item.targetType && new _type_utils_1.TypeUtils(input.scope).isAssignable(parameterType, item.targetType) === false) {
                const message = "Method parameter type not compatible, " + item.name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            (_a = this.requiredParameters) === null || _a === void 0 ? void 0 : _a.delete(item.name);
        }
    }
    checkExporting(node, input, method, errors = true) {
        const items = this.parameterListS(node, input, method);
        if (method instanceof basic_1.VoidType) {
            return;
        }
        const allImporting = method.getParameters().getImporting();
        if (this.requiredParameters === undefined) {
            this.requiredParameters = new Set(method.getParameters().getRequiredParameters().map(i => i.getName().toUpperCase()));
        }
        for (const item of items) {
            const parameter = allImporting.find(p => p.getName().toUpperCase() === item.name);
            const calculated = item.source.findFirstExpression(Expressions.MethodCallChain) !== undefined
                || item.source.findFirstExpression(Expressions.StringTemplate) !== undefined
                || item.source.findFirstExpression(Expressions.ArithOperator) !== undefined;
            if (parameter === undefined) {
                const message = "Method importing parameter \"" + item.name + "\" does not exist";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (new _type_utils_1.TypeUtils(input.scope).isAssignableStrict(item.sourceType, parameter.getType(), calculated) === false) {
                const message = "Method parameter type not compatible, " + item.name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            this.requiredParameters.delete(item.name);
        }
        if (errors === true) {
            this.reportErrors(node, input);
        }
    }
    reportErrors(node, input) {
        var _a;
        for (const r of ((_a = this.requiredParameters) === null || _a === void 0 ? void 0 : _a.values()) || []) {
            const message = `method parameter "${r}" must be supplied`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
        }
    }
    parameterListS(node, input, method) {
        var _a;
        if (node === undefined) {
            return [];
        }
        else if (!(node.get() instanceof Expressions.ParameterListS)) {
            throw new assert_error_1.AssertError("parameterListS, unexpected node");
        }
        const ret = [];
        for (const c of node.getChildren()) {
            if (!(c.get() instanceof Expressions.ParameterS) || !(c instanceof nodes_1.ExpressionNode)) {
                throw new assert_error_1.AssertError("parameterListS, unexpected node, child");
            }
            const name = (_a = c.findDirectExpression(Expressions.ParameterName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr().toUpperCase();
            if (name === undefined) {
                throw new assert_error_1.AssertError("parameterListS, no name determined");
            }
            const source = c.findDirectExpression(Expressions.Source);
            if (source === undefined) {
                throw new assert_error_1.AssertError("parameterListS, no source found");
            }
            let targetType = undefined;
            if (!(method instanceof basic_1.VoidType)) {
                for (const i of method.getParameters().getImporting()) {
                    if (i.getName().toUpperCase() === name) {
                        targetType = i.getType();
                    }
                }
            }
            let sourceType = new source_1.Source().runSyntax(source, input, targetType);
            if (sourceType === undefined) {
                if (method instanceof basic_1.VoidType) {
                    sourceType = method;
                }
                else {
                    const message = "No source type determined for parameter " + name + " input";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    sourceType = new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            ret.push({ name, source, sourceType });
        }
        return ret;
    }
    parameterListT(node, input) {
        var _a;
        if (node === undefined) {
            return [];
        }
        else if (!(node.get() instanceof Expressions.ParameterListT)) {
            throw new assert_error_1.AssertError("parameterListT, unexpected node");
        }
        const ret = [];
        for (const c of node.getChildren()) {
            if (!(c.get() instanceof Expressions.ParameterT) || !(c instanceof nodes_1.ExpressionNode)) {
                throw new assert_error_1.AssertError("parameterListT, unexpected node, child");
            }
            const name = (_a = c.findDirectExpression(Expressions.ParameterName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr().toUpperCase();
            if (name === undefined) {
                throw new assert_error_1.AssertError("parameterListT, no name determined");
            }
            const target = c.findDirectExpression(Expressions.Target);
            if (target === undefined) {
                throw new assert_error_1.AssertError("parameterListT, no target found");
            }
            const targetType = new target_1.Target().runSyntax(target, input);
            ret.push({ name, target, targetType });
        }
        return ret;
    }
}
exports.MethodParameters = MethodParameters;
//# sourceMappingURL=method_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_source.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_source.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodSource = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _abstract_type_1 = __webpack_require__(/*! ../../types/basic/_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
const source_field_symbol_1 = __webpack_require__(/*! ./source_field_symbol */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field_symbol.js");
const source_field_1 = __webpack_require__(/*! ./source_field */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js");
const component_name_1 = __webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class MethodSource {
    runSyntax(node, input) {
        var _a, _b, _c;
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        const children = node.getChildren().slice();
        const first = children.shift();
        if (first === undefined) {
            throw new assert_error_1.AssertError("MethodSource, first child expected");
        }
        let context = this.findTop(first, input, children);
        if (context === undefined) {
            context = (_a = input.scope.findVariable("me")) === null || _a === void 0 ? void 0 : _a.getType();
            children.unshift(first);
        }
        if (input.scope.getVersion() === version_1.Version.Cloud
            && first.get() instanceof Expressions.Dynamic
            && first instanceof nodes_1.ExpressionNode
            && ((_b = children[0]) === null || _b === void 0 ? void 0 : _b.concatTokens()) === "=>") {
            const name = (_c = first.findDirectExpression(Expressions.Constant)) === null || _c === void 0 ? void 0 : _c.concatTokens().replace(/'/g, "").replace(/`/g, "");
            if (name !== undefined && input.scope.findClassDefinition(name) === undefined) {
                const message = `Class "${name}" not found/released`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        if (context instanceof basic_1.VoidType) {
            // todo, if there are more dynamic with variables, the references for the variables are not added?
            return context;
        }
        while (children.length > 0) {
            const current = children.shift();
            if (current === undefined) {
                break;
            }
            if (current.get() instanceof tokens_1.Dash) {
                if (context instanceof basic_1.UnknownType) {
                    const message = "Not a structure, type unknown, MethodSource";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                else if (!(context instanceof basic_1.StructureType)) {
                    const message = "Not a structure, MethodSource";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            else if (current.get() instanceof tokens_1.InstanceArrow
                || current.get() instanceof tokens_1.StaticArrow) {
                // todo, handling static vs instance
            }
            else if (current.get() instanceof Expressions.AttributeName
                || current.get() instanceof Expressions.SourceField) {
                if (context instanceof _abstract_type_1.AbstractType) {
                    const attr = new attribute_name_1.AttributeName().runSyntax(context, current, input, _reference_1.ReferenceType.DataReadReference, false);
                    const isSyntaxError = attr instanceof basic_1.VoidType && attr.getVoided() === _syntax_input_1.CheckSyntaxKey;
                    if (isSyntaxError === false) {
                        context = attr;
                        continue;
                    }
                }
                // try looking for method name
                const className = context instanceof basic_1.ObjectReferenceType ? context.getIdentifierName() : undefined;
                const methodToken = current.getFirstToken();
                const methodName = methodToken === null || methodToken === void 0 ? void 0 : methodToken.getStr();
                const def = input.scope.findObjectDefinition(className);
                // eslint-disable-next-line prefer-const
                let { method, def: foundDef } = helper.searchMethodName(def, methodName);
                if (method === undefined && (methodName === null || methodName === void 0 ? void 0 : methodName.toUpperCase()) === "CONSTRUCTOR") {
                    context = new basic_1.VoidType("CONSTRUCTOR"); // todo, this is a workaround, constructors always exists
                }
                else if (method === undefined && !(context instanceof basic_1.VoidType)) {
                    const message = "Method or attribute \"" + methodName + "\" not found, MethodSource";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                else if (method) {
                    const extra = helper.methodReferenceExtras(foundDef, className);
                    input.scope.addReference(methodToken, method, _reference_1.ReferenceType.MethodReference, input.filename, extra);
                    context = method;
                }
            }
            else if (current.get() instanceof Expressions.ComponentName && context instanceof _abstract_type_1.AbstractType) {
                if (context instanceof basic_1.TableType && context.isWithHeader()) {
                    context = context.getRowType();
                }
                context = new component_name_1.ComponentName().runSyntax(context, current, input);
            }
            else if (current instanceof nodes_1.ExpressionNode && current.get() instanceof Expressions.Dynamic) {
                new dynamic_1.Dynamic().runSyntax(current, input);
                context = new basic_1.VoidType("Dynamic");
            }
        }
        if (context instanceof _abstract_type_1.AbstractType && !(context instanceof basic_1.VoidType)) {
            const message = "Not a method, MethodSource";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        else if (context === undefined) {
            const message = "Not found, MethodSource";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return context;
    }
    //////////////////////////////////////
    findTop(first, input, children) {
        if (first.get() instanceof Expressions.ClassName) {
            // todo, refactor this part to new expression handler,
            const token = first.getFirstToken();
            const className = token.getStr();
            const classDefinition = input.scope.findObjectDefinition(className);
            if (classDefinition === undefined && input.scope.getDDIC().inErrorNamespace(className) === false) {
                const extra = { ooName: className, ooType: "Void" };
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, extra);
                return new basic_1.VoidType(className);
            }
            else if (classDefinition === undefined) {
                const message = "Class " + className + " not found";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, first.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            input.scope.addReference(first.getFirstToken(), classDefinition, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            return new basic_1.ObjectReferenceType(classDefinition);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.SourceField && children.length > 0) {
            return new source_field_1.SourceField().runSyntax(first, input, _reference_1.ReferenceType.DataReadReference);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.SourceFieldSymbol) {
            return new source_field_symbol_1.SourceFieldSymbol().runSyntax(first, input);
        }
        else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.Dynamic) {
            new dynamic_1.Dynamic().runSyntax(first, input);
            return new basic_1.VoidType("Dynamic");
        }
        return undefined;
    }
}
exports.MethodSource = MethodSource;
//# sourceMappingURL=method_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/new_object.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/new_object.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewObject = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const method_parameters_1 = __webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class NewObject {
    runSyntax(node, input, targetType) {
        let ret = undefined;
        const typeExpr = node.findDirectExpression(Expressions.TypeNameOrInfer);
        const typeToken = typeExpr === null || typeExpr === void 0 ? void 0 : typeExpr.getFirstToken();
        const typeName = typeExpr === null || typeExpr === void 0 ? void 0 : typeExpr.concatTokens();
        if (typeName === undefined) {
            throw new assert_error_1.AssertError("NewObject, child TypeNameOrInfer not found");
        }
        else if (typeName === "#" && targetType && targetType instanceof basic_1.ObjectReferenceType) {
            const clas = input.scope.findClassDefinition(targetType.getIdentifierName());
            if (clas) {
                input.scope.addReference(typeToken, clas, _reference_1.ReferenceType.InferredType, input.filename);
            }
            else {
                const intf = input.scope.findInterfaceDefinition(targetType.getIdentifierName());
                if (intf) {
                    const message = intf.getName() + " is an interface, cannot be instantiated";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            ret = targetType;
            if ((clas === null || clas === void 0 ? void 0 : clas.isAbstract()) === true) {
                const message = clas.getName() + " is abstract, cannot be instantiated";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        else if (typeName === "#" && targetType) {
            ret = targetType;
        }
        else if (typeName === "#") {
            throw new assert_error_1.AssertError("NewObject, todo, infer type");
        }
        if (ret === undefined) {
            const objDefinition = input.scope.findObjectDefinition(typeName);
            if (objDefinition) {
                input.scope.addReference(typeToken, objDefinition, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                const objref = new basic_1.ObjectReferenceType(objDefinition);
                const clas = input.scope.findClassDefinition(objref.getIdentifierName());
                if ((clas === null || clas === void 0 ? void 0 : clas.isAbstract()) === true) {
                    const message = clas.getName() + " is abstract, cannot be instantiated";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                ret = objref;
            }
        }
        if (ret === undefined) {
            const basic = new basic_types_1.BasicTypes(input);
            const type = basic.resolveTypeName(typeExpr);
            if (type instanceof basic_1.UnknownType) {
                ret = type;
            }
            else if (type && !(type instanceof basic_1.VoidType)) {
                ret = new basic_1.DataReference(type);
            }
            else if (type instanceof basic_1.VoidType) {
                ret = type;
            }
            else {
                const message = "Type \"" + typeName + "\" not found in scope, NewObject";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        if (ret instanceof basic_1.ObjectReferenceType) {
            this.parameters(node, ret, input);
        }
        else {
            for (const s of node.findAllExpressions(Expressions.Source)) {
                new source_1.Source().runSyntax(s, input, ret);
            }
        }
        if (ret instanceof basic_1.UnknownType && input.scope.getDDIC().inErrorNamespace(typeName) === true) {
            const message = "Class or type \"" + typeName + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return ret;
    }
    parameters(node, obj, input) {
        const name = obj.getIdentifier().getName();
        const def = input.scope.findObjectDefinition(name);
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        // eslint-disable-next-line prefer-const
        let { method } = helper.searchMethodName(def, "CONSTRUCTOR");
        const requiredParameters = (method === null || method === void 0 ? void 0 : method.getParameters().getRequiredParameters()) || [];
        const source = node.findDirectExpression(Expressions.Source);
        const parameters = node.findDirectExpression(Expressions.ParameterListS);
        if (source) {
            // single unnamed parameter
            const type = this.defaultImportingType(method);
            if (type === undefined) {
                const message = "NewObject, no default importing parameter found for constructor, " + name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const sourceType = new source_1.Source().runSyntax(source, input, type);
            if (new _type_utils_1.TypeUtils(input.scope).isAssignableStrict(sourceType, type) === false) {
                const message = `NEW parameter type not compatible`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        else if (parameters) {
            // parameters with names
            if (method === undefined) {
                const message = "NewObject, no parameters for constructor found, " + name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            new method_parameters_1.MethodParameters().checkExporting(parameters, input, method);
        }
        else if (requiredParameters.length > 0) {
            const message = `constructor parameter "${requiredParameters[0].getName()}" must be supplied, ` + name;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
    }
    defaultImportingType(method) {
        let targetType = undefined;
        if (method === undefined) {
            return undefined;
        }
        const name = method.getParameters().getDefaultImporting();
        for (const i of method.getParameters().getImporting()) {
            if (i.getName().toUpperCase() === name) {
                targetType = i.getType();
            }
        }
        return targetType;
    }
}
exports.NewObject = NewObject;
//# sourceMappingURL=new_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/raise_with.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/raise_with.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaiseWith = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class RaiseWith {
    runSyntax(node, input) {
        for (const f of node.findDirectExpressions(Expressions.SimpleSource1)) {
            new source_1.Source().runSyntax(f, input);
        }
    }
}
exports.RaiseWith = RaiseWith;
//# sourceMappingURL=raise_with.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_body.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_body.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const for_1 = __webpack_require__(/*! ./for */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/for.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const inline_field_definition_1 = __webpack_require__(/*! ./inline_field_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_field_definition.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const reduce_next_1 = __webpack_require__(/*! ./reduce_next */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_next.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class ReduceBody {
    runSyntax(node, input, targetType) {
        if (node === undefined) {
            return;
        }
        let scoped = false;
        const letNode = node.findDirectExpression(Expressions.Let);
        if (letNode) {
            scoped = new let_1.Let().runSyntax(letNode, input);
        }
        let first = undefined;
        for (const i of node.findDirectExpressions(Expressions.InlineFieldDefinition)) {
            if (scoped === false) {
                input.scope.push(_scope_type_1.ScopeType.Let, "LET", node.getFirstToken().getStart(), input.filename);
                scoped = true;
            }
            let foundType = targetType;
            const source = i.findDirectExpression(Expressions.Source);
            if (source) {
                foundType = new source_1.Source().runSyntax(source, input, targetType);
            }
            const found = new inline_field_definition_1.InlineFieldDefinition().runSyntax(i, input, foundType);
            if (found && first === undefined) {
                first = found;
            }
        }
        let forScopes = 0;
        for (const forNode of node.findDirectExpressions(Expressions.For) || []) {
            const scoped = new for_1.For().runSyntax(forNode, input);
            if (scoped === true) {
                forScopes++;
            }
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.ReduceNext)) {
            new reduce_next_1.ReduceNext().runSyntax(s, input);
        }
        if (scoped === true) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        for (let i = 0; i < forScopes; i++) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        if (first) {
            return first;
        }
        else {
            return new unknown_type_1.UnknownType("todo, ReduceBody");
        }
    }
}
exports.ReduceBody = ReduceBody;
//# sourceMappingURL=reduce_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_next.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_next.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceNext = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class ReduceNext {
    runSyntax(node, input) {
        if (node === undefined) {
            return;
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleTarget)) {
            new target_1.Target().runSyntax(s, input);
        }
    }
}
exports.ReduceNext = ReduceNext;
//# sourceMappingURL=reduce_next.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Select = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ./inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const target_1 = __webpack_require__(/*! ./target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const sql_from_1 = __webpack_require__(/*! ./sql_from */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_from.js");
const sql_for_all_entries_1 = __webpack_require__(/*! ./sql_for_all_entries */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_for_all_entries.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_source.js");
const sql_compare_1 = __webpack_require__(/*! ./sql_compare */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_compare.js");
const sql_order_by_1 = __webpack_require__(/*! ./sql_order_by */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_order_by.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const isSimple = /^\w+$/;
class Select {
    runSyntax(node, input, skipImplicitInto = false) {
        var _a;
        const token = node.getFirstToken();
        const from = node.findDirectExpression(Expressions.SQLFrom);
        const dbSources = from ? new sql_from_1.SQLFrom().runSyntax(from, input) : [];
        if (from === undefined) {
            const message = `Missing FROM`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const fields = this.findFields(node, input);
        if (fields.length === 0
            && node.findDirectExpression(Expressions.SQLFieldListLoop) === undefined) {
            const message = `fields missing`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        this.checkFields(fields, dbSources, input, node);
        this.handleInto(node, input, fields, dbSources);
        const fae = node.findDirectExpression(Expressions.SQLForAllEntries);
        if (fae) {
            input.scope.push(_scope_type_1.ScopeType.OpenSQL, "SELECT", token.getStart(), input.filename);
            new sql_for_all_entries_1.SQLForAllEntries().runSyntax(fae, input);
        }
        for (const t of node.findAllExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        // check implicit into, the target field is implict equal to the table name
        if (skipImplicitInto === false
            && node.findDirectExpression(Expressions.SQLIntoTable) === undefined
            && node.findDirectExpression(Expressions.SQLIntoList) === undefined
            && node.findDirectExpression(Expressions.SQLIntoStructure) === undefined) {
            const fields = (_a = node.findFirstExpression(Expressions.SQLAggregation)) === null || _a === void 0 ? void 0 : _a.concatTokens();
            const c = new RegExp(/^count\(\s*\*\s*\)$/, "i");
            if (fields === undefined || c.test(fields) === false) {
                const nameToken = from === null || from === void 0 ? void 0 : from.findDirectExpression(Expressions.SQLFromSource);
                if (nameToken) {
                    const found = input.scope.findVariable(nameToken.concatTokens());
                    if (found) {
                        input.scope.addReference(nameToken.getFirstToken(), found, _reference_1.ReferenceType.DataWriteReference, input.filename);
                    }
                    else {
                        const message = `Target variable ${nameToken.concatTokens()} not found in scope`;
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                }
            }
        }
        // OFFSET
        for (const s of node.findDirectExpressions(Expressions.SQLSource)) {
            new sql_source_1.SQLSource().runSyntax(s, input);
        }
        for (const up of node.findDirectExpressions(Expressions.SQLUpTo)) {
            for (const s of up.findDirectExpressions(Expressions.SQLSource)) {
                new sql_source_1.SQLSource().runSyntax(s, input);
            }
        }
        for (const fae of node.findDirectExpressions(Expressions.SQLForAllEntries)) {
            for (const s of fae.findDirectExpressions(Expressions.SQLSource)) {
                new sql_source_1.SQLSource().runSyntax(s, input);
            }
        }
        for (const s of node.findAllExpressions(Expressions.SQLCompare)) {
            new sql_compare_1.SQLCompare().runSyntax(s, input, dbSources);
        }
        for (const s of node.findDirectExpressions(Expressions.SQLOrderBy)) {
            new sql_order_by_1.SQLOrderBy().runSyntax(s, input);
        }
        if (input.scope.getType() === _scope_type_1.ScopeType.OpenSQL) {
            input.scope.pop(node.getLastToken().getEnd());
        }
    }
    handleInto(node, input, fields, dbSources) {
        const intoTable = node.findDirectExpression(Expressions.SQLIntoTable);
        if (intoTable) {
            const inline = intoTable.findFirstExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, this.buildTableType(fields, dbSources, input.scope));
            }
        }
        const intoStructure = node.findDirectExpression(Expressions.SQLIntoStructure);
        if (intoStructure) {
            for (const inline of intoStructure.findAllExpressions(Expressions.InlineData)) {
                // todo, for now these are voided
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("SELECT_todo"));
            }
        }
        const intoList = node.findDirectExpression(Expressions.SQLIntoList);
        if (intoList) {
            const isDynamic = fields.length === 1 && fields[0].expression.findDirectExpression(Expressions.Dynamic) !== undefined;
            const targets = intoList.findDirectExpressions(Expressions.SQLTarget);
            if (targets.length !== fields.length && isDynamic !== true) {
                const message = `number of fields selected vs list does not match`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            for (let i = 0; i < targets.length; i++) {
                const target = targets[i];
                const field = fields[i];
                const inline = target.findFirstExpression(Expressions.InlineData);
                if (inline) {
                    if (isDynamic) {
                        const message = `dynamic field list, inlining not possible`;
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                    let type = new basic_1.VoidType("SELECT_todo");
                    if (isSimple.test(field.code)) {
                        for (const dbSource of dbSources) {
                            if (dbSource === undefined) {
                                continue;
                            }
                            const dbType = dbSource.parseType(input.scope.getRegistry());
                            if (dbType instanceof basic_1.StructureType) {
                                const found = dbType.getComponentByName(field.code);
                                if (found) {
                                    type = found;
                                    break;
                                }
                            }
                        }
                    }
                    new inline_data_1.InlineData().runSyntax(inline, input, type);
                }
            }
        }
    }
    checkFields(fields, dbSources, input, node) {
        if (dbSources.length > 1) {
            return;
        }
        const first = dbSources[0];
        if (first === undefined) {
            // then its voided
            return;
        }
        const type = first.parseType(input.scope.getRegistry());
        if (type instanceof basic_1.VoidType || type instanceof basic_1.UnknownType) {
            return;
        }
        if (!(type instanceof basic_1.StructureType)) {
            const message = "checkFields, expected structure, " + type.constructor.name;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        for (const field of fields) {
            if (field.code === "*") {
                continue;
            }
            if (isSimple.test(field.code) && type.getComponentByName(field.code) === undefined) {
                const message = `checkFields, field ${field.code} not found`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
    buildTableType(fields, dbSources, scope) {
        if (dbSources.length !== 1) {
            return new basic_1.VoidType("SELECT_todo");
        }
        if (dbSources[0] === undefined) {
            // then its a voided table
            return new basic_1.VoidType("SELECT_todo");
        }
        const dbType = dbSources[0].parseType(scope.getRegistry());
        if (!(dbType instanceof basic_1.StructureType)) {
            return new basic_1.VoidType("SELECT_todo");
        }
        if (fields.length === 1 && fields[0].code === "*") {
            return new basic_1.TableType(dbType, { withHeader: false, keyType: basic_1.TableKeyType.default }, undefined);
        }
        const allFieldsSimple = fields.every(f => isSimple.test(f.code));
        if (allFieldsSimple === true) {
            const components = [];
            for (const field of fields) {
                const type = dbType.getComponentByName(field.code);
                if (type === undefined) {
                    return new basic_1.VoidType("SELECT_todo");
                }
                components.push({ name: field.code, type });
            }
            return new basic_1.TableType(new basic_1.StructureType(components), { withHeader: false, keyType: basic_1.TableKeyType.default }, undefined);
        }
        return new basic_1.VoidType("SELECT_todo");
    }
    findFields(node, input) {
        var _a, _b;
        let expr = undefined;
        const ret = [];
        expr = node.findFirstExpression(Expressions.SQLFieldList);
        if (expr === undefined) {
            expr = node.findDirectExpression(Expressions.SQLFieldListLoop);
        }
        if (((_a = expr === null || expr === void 0 ? void 0 : expr.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.Dynamic) {
            new dynamic_1.Dynamic().runSyntax(expr.getFirstChild(), input);
        }
        for (const field of (expr === null || expr === void 0 ? void 0 : expr.findDirectExpressionsMulti([Expressions.SQLField, Expressions.SQLFieldName])) || []) {
            let code = field.concatTokens().toUpperCase();
            const as = ((_b = field.findDirectExpression(Expressions.SQLAsName)) === null || _b === void 0 ? void 0 : _b.concatTokens()) || "";
            if (as !== "") {
                code = code.replace(" AS " + as, "");
            }
            ret.push({ code, as, expression: field });
        }
        if (ret.length === 0 && expr) {
            ret.push({ code: expr.concatTokens(), as: "", expression: expr });
        }
        return ret;
    }
}
exports.Select = Select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select_loop.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select_loop.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectLoop = void 0;
const select_1 = __webpack_require__(/*! ./select */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js");
class SelectLoop {
    runSyntax(node, input) {
        // try using the other Select, they should look very much the same
        new select_1.Select().runSyntax(node, input);
    }
}
exports.SelectLoop = SelectLoop;
//# sourceMappingURL=select_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Source = void 0;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_call_chain_1 = __webpack_require__(/*! ./method_call_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_chain.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const field_chain_1 = __webpack_require__(/*! ./field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const constant_1 = __webpack_require__(/*! ./constant */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/constant.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const component_chain_1 = __webpack_require__(/*! ./component_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_chain.js");
const string_template_1 = __webpack_require__(/*! ./string_template */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/string_template.js");
const value_body_1 = __webpack_require__(/*! ./value_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/value_body.js");
const cond_1 = __webpack_require__(/*! ./cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
const reduce_body_1 = __webpack_require__(/*! ./reduce_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/reduce_body.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const switch_body_1 = __webpack_require__(/*! ./switch_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/switch_body.js");
const cond_body_1 = __webpack_require__(/*! ./cond_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond_body.js");
const conv_body_1 = __webpack_require__(/*! ./conv_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/conv_body.js");
const filter_body_1 = __webpack_require__(/*! ./filter_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/filter_body.js");
const corresponding_body_1 = __webpack_require__(/*! ./corresponding_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/corresponding_body.js");
const _builtin_1 = __webpack_require__(/*! ../_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const attribute_chain_1 = __webpack_require__(/*! ./attribute_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_chain.js");
const dereference_1 = __webpack_require__(/*! ./dereference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dereference.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
/*
* Type interference, valid scenarios:
* typed = VALUE #( ... ).         right hand side must follow left hand type
* DATA(bar) = VALUE type( ... ).  left gets the type of rigthand
* typed = VALUE type( ... ).      types must match and be compatible???
************* ERRORS *********
* VALUE #( ... ).                 syntax error
* DATA(bar) = VALUE #( ... ).     give error, no type can be derived
*/
class Source {
    runSyntax(node, input, targetType, writeReference = false) {
        if (node === undefined) {
            return undefined;
        }
        const children = node.getChildren().slice();
        let first = children.shift();
        if (first instanceof nodes_1.TokenNode) {
            const token = first.getFirstToken();
            const tok = token.getStr().toUpperCase();
            switch (tok) {
                case "(":
                case "-":
                case "+":
                case "BIT":
                    break;
                case "BOOLC":
                    {
                        const method = new _builtin_1.BuiltIn().searchBuiltin(tok);
                        input.scope.addReference(token, method, _reference_1.ReferenceType.BuiltinMethodReference, input.filename);
                        new cond_1.Cond().runSyntax(node.findDirectExpression(Expressions.Cond), input);
                        return basic_1.StringType.get();
                    }
                case "XSDBOOL":
                    {
                        const method = new _builtin_1.BuiltIn().searchBuiltin(tok);
                        input.scope.addReference(token, method, _reference_1.ReferenceType.BuiltinMethodReference, input.filename);
                        new cond_1.Cond().runSyntax(node.findDirectExpression(Expressions.Cond), input);
                        return new basic_1.CharacterType(1, { qualifiedName: "ABAP_BOOL", ddicName: "ABAP_BOOL" });
                    }
                case "REDUCE":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new reduce_body_1.ReduceBody().runSyntax(node.findDirectExpression(Expressions.ReduceBody), input, foundType);
                        if (foundType === undefined || foundType.isGeneric()) {
                            this.addIfInferred(node, input, bodyType);
                        }
                        else {
                            this.addIfInferred(node, input, foundType);
                        }
                        return foundType ? foundType : bodyType;
                    }
                case "SWITCH":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new switch_body_1.SwitchBody().runSyntax(node.findDirectExpression(Expressions.SwitchBody), input);
                        if (foundType === undefined || foundType.isGeneric()) {
                            this.addIfInferred(node, input, bodyType);
                        }
                        else {
                            this.addIfInferred(node, input, foundType);
                        }
                        return foundType ? foundType : bodyType;
                    }
                case "COND":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new cond_body_1.CondBody().runSyntax(node.findDirectExpression(Expressions.CondBody), input);
                        if (foundType === undefined || foundType.isGeneric()) {
                            this.addIfInferred(node, input, bodyType);
                        }
                        else {
                            this.addIfInferred(node, input, foundType);
                        }
                        children.shift();
                        children.shift();
                        children.shift();
                        children.shift();
                        this.traverseRemainingChildren(children, input);
                        return foundType ? foundType : bodyType;
                    }
                case "CONV":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new conv_body_1.ConvBody().runSyntax(node.findDirectExpression(Expressions.ConvBody), input);
                        if (new _type_utils_1.TypeUtils(input.scope).isAssignable(foundType, bodyType) === false) {
                            const message = "CONV: Types not compatible";
                            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                        }
                        this.addIfInferred(node, input, foundType);
                        return foundType;
                    }
                case "REF":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const s = new Source().runSyntax(node.findDirectExpression(Expressions.Source), input);
                        if (foundType === undefined && s) {
                            return new basic_1.DataReference(s);
                        }
                        else {
                            return foundType;
                        }
                    }
                case "FILTER":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new filter_body_1.FilterBody().runSyntax(node.findDirectExpression(Expressions.FilterBody), input, foundType);
                        if (foundType === undefined || foundType.isGeneric()) {
                            this.addIfInferred(node, input, bodyType);
                        }
                        else {
                            this.addIfInferred(node, input, foundType);
                        }
                        if (foundType && !(foundType instanceof unknown_type_1.UnknownType)) {
                            return foundType;
                        }
                        else {
                            return bodyType;
                        }
                    }
                case "CORRESPONDING":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        new corresponding_body_1.CorrespondingBody().runSyntax(node.findDirectExpression(Expressions.CorrespondingBody), input, foundType);
                        this.addIfInferred(node, input, foundType);
                        return foundType;
                    }
                case "EXACT":
                    return this.determineType(node, input, targetType);
                case "VALUE":
                    {
                        const foundType = this.determineType(node, input, targetType);
                        const bodyType = new value_body_1.ValueBody().runSyntax(node.findDirectExpression(Expressions.ValueBody), input, foundType);
                        if (foundType === undefined || foundType.isGeneric()) {
                            this.addIfInferred(node, input, bodyType);
                        }
                        else {
                            this.addIfInferred(node, input, foundType);
                        }
                        return foundType ? foundType : bodyType;
                    }
                default:
                    return new unknown_type_1.UnknownType("todo, Source type " + tok);
            }
        }
        else if (first === undefined || !(first instanceof nodes_1.ExpressionNode)) {
            return undefined;
        }
        let context = new unknown_type_1.UnknownType("todo, Source type");
        const type = [_reference_1.ReferenceType.DataReadReference];
        if (writeReference) {
            type.push(_reference_1.ReferenceType.DataWriteReference);
        }
        let hexExpected = false;
        let hexNext = false;
        while (children.length >= 0) {
            if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.MethodCallChain) {
                context = new method_call_chain_1.MethodCallChain().runSyntax(first, input, targetType);
                if (context === undefined) {
                    const message = "Method has no RETURNING value";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.FieldChain) {
                context = new field_chain_1.FieldChain().runSyntax(first, input, type);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.StringTemplate) {
                context = new string_template_1.StringTemplate().runSyntax(first, input);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.Source) {
                const found = new Source().runSyntax(first, input);
                context = this.infer(context, found);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.Constant) {
                const found = new constant_1.Constant().runSyntax(first);
                context = this.infer(context, found);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.Dereference) {
                context = new dereference_1.Dereference().runSyntax(first, context, input);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.ComponentChain) {
                context = new component_chain_1.ComponentChain().runSyntax(context, first, input);
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.ArithOperator) {
                if (first.concatTokens() === "**") {
                    context = new basic_1.FloatType();
                }
                const operator = first.concatTokens().toUpperCase();
                if (operator === "BIT-OR" || operator === "BIT-AND" || operator === "BIT-XOR") {
                    hexExpected = true;
                    hexNext = true;
                }
            }
            else if (first instanceof nodes_1.ExpressionNode && first.get() instanceof Expressions.AttributeChain) {
                context = new attribute_chain_1.AttributeChain().runSyntax(context, first, input, type);
            }
            if (hexExpected === true) {
                if (!(context instanceof basic_1.VoidType)
                    && !(context instanceof basic_1.XStringType)
                    && !(context instanceof basic_1.HexType)
                    && !(context instanceof basic_1.XGenericType)
                    && !(context instanceof basic_1.XSequenceType)
                    && !(context instanceof unknown_type_1.UnknownType)) {
                    const message = "Operator only valid for XSTRING or HEX";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                if (hexNext === false) {
                    hexExpected = false;
                }
                hexNext = false;
            }
            first = children.shift();
            if (first === undefined) {
                break;
            }
        }
        if (node.findDirectTokenByText("&&")) {
            return basic_1.StringType.get();
        }
        return context;
    }
    ////////////////////////////////
    traverseRemainingChildren(children, input) {
        const last = children[children.length - 1];
        if (last && last.get() instanceof Expressions.Source) {
            new Source().runSyntax(last, input);
        }
    }
    infer(context, found) {
        if (context instanceof basic_1.FloatType && found instanceof basic_1.IntegerType) {
            return context;
        }
        else {
            return found;
        }
    }
    addIfInferred(node, input, inferredType) {
        const basic = new basic_types_1.BasicTypes(input);
        const typeExpression = node.findFirstExpression(Expressions.TypeNameOrInfer);
        const typeToken = typeExpression === null || typeExpression === void 0 ? void 0 : typeExpression.getFirstToken();
        const typeName = typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStr();
        if (typeName === "#" && inferredType && typeToken) {
            const found = basic.lookupQualifiedName(inferredType.getQualifiedName());
            if (found) {
                input.scope.addReference(typeToken, found, _reference_1.ReferenceType.InferredType, input.filename);
            }
            else if (inferredType instanceof basic_1.ObjectReferenceType) {
                const def = input.scope.findObjectDefinition(inferredType.getQualifiedName());
                if (def) {
                    const tid = new _typed_identifier_1.TypedIdentifier(typeToken, input.filename, inferredType);
                    input.scope.addReference(typeToken, tid, _reference_1.ReferenceType.InferredType, input.filename);
                }
            }
            else if (inferredType instanceof basic_1.CharacterType) {
                // character is bit special it does not have a qualified name eg "TYPE c LENGTH 6"
                const tid = new _typed_identifier_1.TypedIdentifier(typeToken, input.filename, inferredType);
                input.scope.addReference(typeToken, tid, _reference_1.ReferenceType.InferredType, input.filename);
            }
        }
    }
    determineType(node, input, targetType) {
        const basic = new basic_types_1.BasicTypes(input);
        const typeExpression = node.findFirstExpression(Expressions.TypeNameOrInfer);
        const typeToken = typeExpression === null || typeExpression === void 0 ? void 0 : typeExpression.getFirstToken();
        const typeName = typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStr();
        if (typeExpression === undefined) {
            throw new assert_error_1.AssertError("determineType, child TypeNameOrInfer not found");
        }
        else if (typeName === "#" && targetType) {
            return targetType;
        }
        if (typeName !== "#" && typeToken) {
            const found = basic.parseType(typeExpression);
            if (found && found instanceof unknown_type_1.UnknownType) {
                if (input.scope.getDDIC().inErrorNamespace(typeName) === false) {
                    input.scope.addReference(typeToken, undefined, _reference_1.ReferenceType.VoidType, input.filename);
                    return new basic_1.VoidType(typeName);
                }
                else {
                    const tid = new _typed_identifier_1.TypedIdentifier(typeToken, input.filename, found);
                    input.scope.addReference(typeToken, tid, _reference_1.ReferenceType.TypeReference, input.filename);
                    return found;
                }
            }
            else if (found === undefined) {
                const message = "Type \"" + typeName + "\" not found in scope, VALUE";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            return found;
        }
        return targetType;
    }
}
exports.Source = Source;
//# sourceMappingURL=source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceField = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class SourceField {
    runSyntax(node, input, type, error = true) {
        const token = node.getFirstToken();
        const name = token.getStr();
        const found = input.scope.findVariable(name);
        if (found === undefined) {
            const message = "\"" + name + "\" not found, findTop";
            if (error === true) {
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            }
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        if (type) {
            input.scope.addReference(token, found, type, input.filename);
        }
        if (name.includes("~")) {
            const idef = input.scope.findInterfaceDefinition(name.split("~")[0]);
            if (idef) {
                input.scope.addReference(token, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            }
        }
        return found.getType();
    }
}
exports.SourceField = SourceField;
//# sourceMappingURL=source_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field_symbol.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source_field_symbol.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SourceFieldSymbol = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class SourceFieldSymbol {
    runSyntax(node, input) {
        const token = node.getFirstToken();
        const found = input.scope.findVariable(token.getStr());
        if (found === undefined) {
            const message = "\"" + node.getFirstToken().getStr() + "\" not found, SourceFieldSymbol";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        input.scope.addReference(token, found, _reference_1.ReferenceType.DataReadReference, input.filename);
        return found.getType();
    }
}
exports.SourceFieldSymbol = SourceFieldSymbol;
//# sourceMappingURL=source_field_symbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_compare.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_compare.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLCompare = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const sql_in_1 = __webpack_require__(/*! ./sql_in */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_in.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_source.js");
class SQLCompare {
    runSyntax(node, input, tables) {
        var _a, _b;
        let sourceType;
        let token;
        if (((_a = node.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.Dynamic) {
            new dynamic_1.Dynamic().runSyntax(node.getFirstChild(), input);
            return;
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SQLSource)) {
            for (const child of s.getChildren()) {
                if (child instanceof nodes_1.ExpressionNode) {
                    token = child.getFirstToken();
                    break;
                }
            }
            sourceType = new sql_source_1.SQLSource().runSyntax(s, input);
        }
        const sqlin = node.findDirectExpression(Expressions.SQLIn);
        if (sqlin) {
            new sql_in_1.SQLIn().runSyntax(sqlin, input);
        }
        const fieldName = (_b = node.findDirectExpression(Expressions.SQLFieldName)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (fieldName && sourceType && token) {
            // check compatibility for rule sql_value_conversion
            const targetType = this.findType(fieldName, tables, input.scope);
            let message = "";
            if (sourceType instanceof basic_1.IntegerType
                && targetType instanceof basic_1.CharacterType) {
                message = "Integer to CHAR conversion";
            }
            else if (sourceType instanceof basic_1.IntegerType
                && targetType instanceof basic_1.NumericType) {
                message = "Integer to NUMC conversion";
            }
            else if (sourceType instanceof basic_1.NumericType
                && targetType instanceof basic_1.IntegerType) {
                message = "NUMC to Integer conversion";
            }
            else if (sourceType instanceof basic_1.CharacterType
                && targetType instanceof basic_1.IntegerType) {
                message = "CHAR to Integer conversion";
            }
            else if (sourceType instanceof basic_1.CharacterType
                && targetType instanceof basic_1.CharacterType
                && sourceType.getLength() > targetType.getLength()) {
                message = "Source field longer than database field, CHAR -> CHAR";
            }
            else if (sourceType instanceof basic_1.NumericType
                && targetType instanceof basic_1.NumericType
                && sourceType.getLength() > targetType.getLength()) {
                message = "Source field longer than database field, NUMC -> NUMC";
            }
            if (message !== "") {
                input.scope.addSQLConversion(fieldName, message, token);
            }
        }
    }
    findType(fieldName, tables, scope) {
        for (const t of tables) {
            const type = t === null || t === void 0 ? void 0 : t.parseType(scope.getRegistry());
            if (type instanceof basic_1.StructureType) {
                return type.getComponentByName(fieldName);
            }
        }
        return undefined;
    }
}
exports.SQLCompare = SQLCompare;
//# sourceMappingURL=sql_compare.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_for_all_entries.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_for_all_entries.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLForAllEntries = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class SQLForAllEntries {
    runSyntax(node, input) {
        let s = node.findFirstExpression(Expressions.Source);
        if (s === undefined) {
            s = node.findFirstExpression(Expressions.SimpleSource3);
        }
        if (s) {
            const type = new source_1.Source().runSyntax(s, input);
            if (type instanceof basic_1.VoidType) {
                return;
            }
            if (!(type instanceof basic_1.TableType)) {
                const message = "FAE parameter must be table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const name = s.concatTokens().replace("[]", "");
            input.scope.setAllowHeaderUse(name);
        }
    }
}
exports.SQLForAllEntries = SQLForAllEntries;
//# sourceMappingURL=sql_for_all_entries.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_from.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_from.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLFrom = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const database_table_1 = __webpack_require__(/*! ./database_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js");
class SQLFrom {
    runSyntax(node, input) {
        const ret = [];
        const fromList = node.findAllExpressions(Expressions.SQLFromSource);
        for (const from of fromList) {
            for (const d of from.findAllExpressions(Expressions.Dynamic)) {
                new dynamic_1.Dynamic().runSyntax(d, input);
            }
            const dbtab = from.findFirstExpression(Expressions.DatabaseTable);
            if (dbtab !== undefined) {
                ret.push(new database_table_1.DatabaseTable().runSyntax(dbtab, input));
            }
        }
        return ret;
    }
}
exports.SQLFrom = SQLFrom;
//# sourceMappingURL=sql_from.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_in.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_in.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLIn = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const sql_source_1 = __webpack_require__(/*! ./sql_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_source.js");
class SQLIn {
    runSyntax(node, input) {
        if (node.getChildren().length === 2) {
            const insource = node.findFirstExpression(Expressions.SQLSource);
            if (insource) {
                const intype = new sql_source_1.SQLSource().runSyntax(insource, input);
                if (intype &&
                    !(intype instanceof basic_1.VoidType) &&
                    !(intype instanceof basic_1.UnknownType) &&
                    !(intype instanceof basic_1.TableType)) {
                    const message = "IN, not a table";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            return;
        }
        for (const s of node.findDirectExpressions(Expressions.SQLSource)) {
            new sql_source_1.SQLSource().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SQLSourceNoSpace)) {
            new sql_source_1.SQLSource().runSyntax(s, input);
        }
    }
}
exports.SQLIn = SQLIn;
//# sourceMappingURL=sql_in.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_order_by.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_order_by.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLOrderBy = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const dynamic_1 = __webpack_require__(/*! ./dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class SQLOrderBy {
    runSyntax(node, input) {
        const dyn = node.findDirectExpression(Expressions.Dynamic);
        if (dyn) {
            new dynamic_1.Dynamic().runSyntax(dyn, input);
        }
    }
}
exports.SQLOrderBy = SQLOrderBy;
//# sourceMappingURL=sql_order_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_source.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/sql_source.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLSource = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SQLSource {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            return new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            return new source_1.Source().runSyntax(s, input);
        }
        return undefined;
    }
}
exports.SQLSource = SQLSource;
//# sourceMappingURL=sql_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/string_template.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/string_template.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringTemplate = void 0;
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class StringTemplate {
    runSyntax(node, input) {
        const typeUtils = new _type_utils_1.TypeUtils(input.scope);
        const ret = basic_1.StringType.get();
        for (const templateSource of node.findAllExpressions(Expressions.StringTemplateSource)) {
            const s = templateSource.findDirectExpression(Expressions.Source);
            const type = new source_1.Source().runSyntax(s, input, ret);
            if (type === undefined) {
                const message = "No target type determined";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            else if ((typeUtils.isCharLike(type) === false && typeUtils.isHexLike(type) === false)
                || type instanceof basic_1.StructureType) {
                const message = "String template, not character like, " + type.constructor.name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            const format = templateSource.findDirectExpression(Expressions.StringTemplateFormatting);
            const formatConcat = format === null || format === void 0 ? void 0 : format.concatTokens();
            for (const formatSource of (format === null || format === void 0 ? void 0 : format.findAllExpressions(Expressions.Source)) || []) {
                new source_1.Source().runSyntax(formatSource, input);
            }
            if (format
                && (formatConcat === null || formatConcat === void 0 ? void 0 : formatConcat.includes("ALPHA = "))
                && !(type instanceof basic_1.UnknownType)
                && !(type instanceof basic_1.VoidType)
                && !(type instanceof basic_1.StringType)
                && !(type instanceof basic_1.CLikeType)
                && !(type instanceof basic_1.CharacterType)
                && !(type instanceof basic_1.NumericGenericType)
                && !(type instanceof basic_1.NumericType)
                && !(type instanceof basic_1.AnyType)) {
                const message = `Cannot apply ALPHA to this type (${type.constructor.name})`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, format.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
        }
        return ret;
    }
}
exports.StringTemplate = StringTemplate;
//# sourceMappingURL=string_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/switch_body.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/switch_body.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwitchBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class SwitchBody {
    runSyntax(node, input) {
        if (node === undefined) {
            return;
        }
        const thenSource = node.findExpressionAfterToken("THEN");
        if (!((thenSource === null || thenSource === void 0 ? void 0 : thenSource.get()) instanceof Expressions.Source)) {
            const message = "SwitchBody, unexpected";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        const type = new source_1.Source().runSyntax(thenSource, input);
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            if (s === thenSource) {
                continue;
            }
            new source_1.Source().runSyntax(s, input);
        }
        return type;
    }
}
exports.SwitchBody = SwitchBody;
//# sourceMappingURL=switch_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/table_expression.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/table_expression.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableExpression = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class TableExpression {
    runSyntax(node, input) {
        if (node === undefined) {
            return;
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.TableExpression = TableExpression;
//# sourceMappingURL=table_expression.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Target = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const component_name_1 = __webpack_require__(/*! ./component_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_name.js");
const attribute_name_1 = __webpack_require__(/*! ./attribute_name */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/attribute_name.js");
const field_offset_1 = __webpack_require__(/*! ./field_offset */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_offset.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const table_expression_1 = __webpack_require__(/*! ./table_expression */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/table_expression.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const field_length_1 = __webpack_require__(/*! ./field_length */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_length.js");
const cast_1 = __webpack_require__(/*! ./cast */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cast.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Target {
    runSyntax(node, input) {
        const concat = node.concatTokens();
        if (concat.includes("-")) {
            // workaround for names with dashes
            const found = input.scope.findVariable(concat);
            if (found) {
                input.scope.addReference(node.getFirstToken(), found, _reference_1.ReferenceType.DataWriteReference, input.filename);
                return found.getType();
            }
        }
        const children = node.getChildren().slice();
        const first = children.shift();
        if (first === undefined || !(first instanceof nodes_1.ExpressionNode)) {
            return undefined;
        }
        let context = this.findTop(first, input);
        if (context === undefined) {
            const message = `"${first.getFirstToken().getStr()}" not found, Target`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        while (children.length > 0) {
            const current = children.shift();
            if (current === undefined) {
                break;
            }
            if (current.get() instanceof tokens_1.Dash) {
                if (context instanceof unknown_type_1.UnknownType) {
                    const message = "Not a structure, type unknown, target";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                else if (!(context instanceof basic_1.StructureType)
                    && !(context instanceof basic_1.TableType && context.isWithHeader() && context.getRowType() instanceof basic_1.StructureType)
                    && !(context instanceof basic_1.TableType && context.isWithHeader() && context.getRowType() instanceof basic_1.VoidType)
                    && !(context instanceof basic_1.VoidType)) {
                    const message = "Not a structure, target";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            else if (current.get() instanceof tokens_1.InstanceArrow) {
                if (!(context instanceof basic_1.ObjectReferenceType)
                    && !(context instanceof basic_1.DataReference)
                    && !(context instanceof basic_1.VoidType)) {
                    const message = "Not an object reference, target";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
            }
            else if (current.get() instanceof expressions_1.Dereference) {
                if (!(context instanceof basic_1.DataReference) && !(context instanceof basic_1.VoidType)) {
                    const message = "Not an object reference, target";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                if (!(context instanceof basic_1.VoidType)) {
                    context = context.getType();
                }
            }
            else if (current.get() instanceof Expressions.ComponentName) {
                context = new component_name_1.ComponentName().runSyntax(context, current, input);
            }
            else if (current.get() instanceof Expressions.TableBody) {
                if (!(context instanceof basic_1.TableType)
                    && !(context instanceof basic_1.VoidType)
                    && !(context instanceof unknown_type_1.UnknownType)
                    && !(context instanceof unknown_type_1.UnknownType)) {
                    const message = "Not a internal table, \"[]\"";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                if (context instanceof basic_1.TableType && context.isWithHeader()) {
                    context = new basic_1.TableType(context.getRowType(), Object.assign(Object.assign({}, context.getOptions()), { withHeader: false }));
                }
            }
            else if (current instanceof nodes_1.ExpressionNode
                && current.get() instanceof Expressions.TableExpression) {
                if (!(context instanceof basic_1.TableType) && !(context instanceof basic_1.VoidType)) {
                    const message = "Table expression, expected table";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                new table_expression_1.TableExpression().runSyntax(current, input);
                if (!(context instanceof basic_1.VoidType)) {
                    context = context.getRowType();
                }
            }
            else if (current.get() instanceof Expressions.AttributeName) {
                const type = children.length === 0 ? _reference_1.ReferenceType.DataWriteReference : _reference_1.ReferenceType.DataReadReference;
                context = new attribute_name_1.AttributeName().runSyntax(context, current, input, type);
            }
        }
        const offset = node.findDirectExpression(Expressions.FieldOffset);
        if (offset) {
            if (context instanceof basic_1.XStringType || context instanceof basic_1.StringType) {
                const message = "xstring/string offset/length in writer position not possible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            new field_offset_1.FieldOffset().runSyntax(offset, input);
        }
        const length = node.findDirectExpression(Expressions.FieldLength);
        if (length) {
            if (context instanceof basic_1.XStringType || context instanceof basic_1.StringType) {
                const message = "xstring/string offset/length in writer position not possible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            new field_length_1.FieldLength().runSyntax(length, input);
        }
        return context;
    }
    /////////////////////////////////
    findTop(node, input) {
        if (node === undefined) {
            return undefined;
        }
        const token = node.getFirstToken();
        const name = token.getStr();
        if (node.get() instanceof Expressions.TargetField
            || node.get() instanceof Expressions.TargetFieldSymbol) {
            const found = input.scope.findVariable(name);
            if (found) {
                input.scope.addReference(token, found, _reference_1.ReferenceType.DataWriteReference, input.filename);
            }
            if (name.includes("~")) {
                const idef = input.scope.findInterfaceDefinition(name.split("~")[0]);
                if (idef) {
                    input.scope.addReference(token, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                }
            }
            return found === null || found === void 0 ? void 0 : found.getType();
        }
        else if (node.get() instanceof Expressions.ClassName) {
            const found = input.scope.findObjectDefinition(name);
            if (found) {
                input.scope.addReference(token, found, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                return new basic_1.ObjectReferenceType(found);
            }
            else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, { ooName: name, ooType: "CLAS" });
                return new basic_1.VoidType(name);
            }
            else {
                return new unknown_type_1.UnknownType(name + " unknown, Target");
            }
        }
        else if (node.get() instanceof Expressions.Cast && node instanceof nodes_1.ExpressionNode) {
            const ret = new cast_1.Cast().runSyntax(node, input, undefined);
            if (ret instanceof unknown_type_1.UnknownType) {
                const message = "CAST, uknown type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            return ret;
        }
        return new unknown_type_1.UnknownType("unknown target type");
    }
}
exports.Target = Target;
//# sourceMappingURL=target.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeTable = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const type_table_key_1 = __webpack_require__(/*! ./type_table_key */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table_key.js");
class TypeTable {
    runSyntax(node, input, qualifiedNamePrefix) {
        // todo, input is currently the statement, but should be the expression?
        let nameExpr = node.findFirstExpression(Expressions.DefinitionName);
        if (nameExpr === undefined) {
            nameExpr = node.findFirstExpression(Expressions.NamespaceSimpleName);
        }
        if (nameExpr === undefined) {
            return undefined;
        }
        const name = nameExpr.getFirstToken();
        let qualifiedName = qualifiedNamePrefix || "";
        if (node.getFirstToken().getStr().toUpperCase() === "TYPES") {
            qualifiedName = qualifiedName + name.getStr();
            if (input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition
                || input.scope.getType() === _scope_type_1.ScopeType.Interface) {
                qualifiedName = input.scope.getName() + "=>" + qualifiedName;
            }
        }
        let type = new basic_types_1.BasicTypes(input).parseTable(node, qualifiedName);
        if (type === undefined) {
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, new basic_1.UnknownType("TableType, fallback"));
        }
        for (const tt of node.findAllExpressions(Expressions.TypeTableKey)) {
            const error = new type_table_key_1.TypeTableKey().runSyntax(tt, type);
            if (error) {
                type = error;
            }
        }
        return new _typed_identifier_1.TypedIdentifier(name, input.filename, type);
    }
}
exports.TypeTable = TypeTable;
//# sourceMappingURL=type_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table_key.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table_key.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeTableKey = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class TypeTableKey {
    runSyntax(node, type) {
        if (type instanceof basic_1.TableType) {
            const rowType = type.getRowType();
            if (rowType instanceof basic_1.StructureType) {
                for (const c of node.findAllExpressions(Expressions.FieldSub)) {
                    const concat = c.concatTokens().replace(/^!/, "");
                    if (concat.includes("-") === false // todo, properly check sub fields
                        && rowType.getComponentByName(concat) === undefined
                        && concat.toUpperCase() !== "TABLE_LINE") {
                        return new basic_1.UnknownType(`Field ${concat} not part of structure`);
                    }
                }
            }
        }
        return undefined;
    }
}
exports.TypeTableKey = TypeTableKey;
//# sourceMappingURL=type_table_key.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/value_body.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/value_body.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ValueBody = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const for_1 = __webpack_require__(/*! ./for */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/for.js");
const source_1 = __webpack_require__(/*! ./source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const let_1 = __webpack_require__(/*! ./let */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/let.js");
const field_assignment_1 = __webpack_require__(/*! ./field_assignment */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_assignment.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ValueBody {
    runSyntax(node, input, targetType) {
        var _a;
        if (node === undefined) {
            return targetType;
        }
        let letScoped = false;
        const letNode = node.findDirectExpression(Expressions.Let);
        if (letNode) {
            letScoped = new let_1.Let().runSyntax(letNode, input);
        }
        let forScopes = 0;
        for (const forNode of node.findDirectExpressions(Expressions.For) || []) {
            const scoped = new for_1.For().runSyntax(forNode, input);
            if (scoped === true) {
                forScopes++;
            }
        }
        const fields = new Set();
        for (const s of node.findDirectExpressions(Expressions.FieldAssignment)) {
            new field_assignment_1.FieldAssignment().runSyntax(s, input, targetType);
            const fieldname = (_a = s.findDirectExpression(Expressions.FieldSub)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
            if (fieldname) {
                if (fields.has(fieldname)) {
                    const message = "Duplicate field assignment";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, s.getFirstToken(), message));
                    return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
                }
                fields.add(fieldname);
            }
        }
        let type = undefined; // todo, this is only correct if there is a single source in the body
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            type = new source_1.Source().runSyntax(s, input, type);
        }
        for (const foo of node.findDirectExpressions(Expressions.ValueBodyLine)) {
            if (!(targetType instanceof basic_1.TableType)
                && !(targetType instanceof basic_1.UnknownType)
                && !(targetType instanceof basic_1.AnyType)
                && targetType !== undefined
                && !(targetType instanceof basic_1.VoidType)) {
                const message = "Value, not a table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, foo.getFirstToken(), message));
                return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
            }
            let rowType = targetType;
            if (targetType instanceof basic_1.TableType) {
                rowType = targetType.getRowType();
            }
            for (const l of foo.findDirectExpressions(Expressions.ValueBodyLines)) {
                for (const s of l.findDirectExpressions(Expressions.Source)) {
                    // LINES OF ?? todo, pass type,
                    new source_1.Source().runSyntax(s, input);
                }
            }
            for (const s of foo.findDirectExpressions(Expressions.FieldAssignment)) {
                new field_assignment_1.FieldAssignment().runSyntax(s, input, rowType);
            }
            for (const s of foo.findDirectExpressions(Expressions.Source)) {
                new source_1.Source().runSyntax(s, input, rowType);
            }
        }
        if (letScoped === true) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        for (let i = 0; i < forScopes; i++) {
            input.scope.pop(node.getLastToken().getEnd());
        }
        if ((targetType === null || targetType === void 0 ? void 0 : targetType.isGeneric()) && type) {
            return type;
        }
        return targetType ? targetType : type;
    }
}
exports.ValueBody = ValueBody;
//# sourceMappingURL=value_body.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/global_definitions/find_global_definitions.js":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/global_definitions/find_global_definitions.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FindGlobalDefinitions = void 0;
const interface_definition_1 = __webpack_require__(/*! ../../types/interface_definition */ "./node_modules/@abaplint/core/build/src/abap/types/interface_definition.js");
const class_definition_1 = __webpack_require__(/*! ../../types/class_definition */ "./node_modules/@abaplint/core/build/src/abap/types/class_definition.js");
const _current_scope_1 = __webpack_require__(/*! ../_current_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const interface_1 = __webpack_require__(/*! ../../../objects/interface */ "./node_modules/@abaplint/core/build/src/objects/interface.js");
const class_1 = __webpack_require__(/*! ../../../objects/class */ "./node_modules/@abaplint/core/build/src/objects/class.js");
const BasicTypes = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const objects_1 = __webpack_require__(/*! ../../../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
// todo: rewrite all of this to use a graph based deterministic approach instead
// this makes sure to cache global interface and class definitions in the corresponding object
class FindGlobalDefinitions {
    constructor(reg) {
        this.reg = reg;
    }
    run(progress) {
        const MAX_PASSES = 10;
        let lastPass = Number.MAX_SAFE_INTEGER;
        // the setDirty method in the objects clears the definitions
        let candidates = [];
        for (const o of this.reg.getObjects()) {
            if ((o instanceof interface_1.Interface || o instanceof class_1.Class) && o.getDefinition() === undefined) {
                candidates.push(o);
            }
            else if (o instanceof objects_1.DataElement
                || o instanceof objects_1.View
                || o instanceof objects_1.TableType
                || o instanceof objects_1.LockObject
                || o instanceof objects_1.AuthorizationCheckField
                || o instanceof objects_1.Table) {
                o.parseType(this.reg); // make sure the references are set after parsing finishes
            }
        }
        // make sure the sequence is always the same, disregarding the sequence they were added to the registry
        // this will hopefully make it easier to debug
        candidates.sort((a, b) => { return a.getName().localeCompare(b.getName()); });
        for (let i = 1; i <= MAX_PASSES; i++) {
            progress === null || progress === void 0 ? void 0 : progress.set(candidates.length, "Global OO types, pass " + i);
            let thisPass = 0;
            const next = [];
            for (const o of candidates) {
                progress === null || progress === void 0 ? void 0 : progress.tickSync("Global OO types(pass " + i + "), next pass: " + next.length);
                this.update(o);
                const untypedCount = this.countUntyped(o);
                if (untypedCount > 0) {
                    next.push(o);
                }
                thisPass = thisPass + untypedCount;
            }
            candidates = next;
            if (lastPass === thisPass || thisPass === 0) {
                break;
            }
            lastPass = thisPass;
        }
    }
    /////////////////////////////
    countUntyped(obj) {
        const def = obj.getDefinition();
        if (def === undefined) {
            return 1;
        }
        let count = 0;
        for (const t of def.getTypeDefinitions().getAll()) {
            count = count + this.count(t.type.getType());
        }
        for (const a of def.getAttributes().getAll()) {
            count = count + this.count(a.getType());
        }
        for (const a of def.getAttributes().getConstants()) {
            count = count + this.count(a.getType());
        }
        for (const m of def.getMethodDefinitions().getAll()) {
            for (const p of m.getParameters().getAll()) {
                count = count + this.count(p.getType());
            }
        }
        for (const e of def.getEvents() || []) {
            for (const p of e.getParameters()) {
                count = count + this.count(p.getType());
            }
        }
        return count;
    }
    count(type) {
        if (type instanceof BasicTypes.UnknownType || type instanceof BasicTypes.VoidType) {
            return 1;
        }
        else if (type instanceof BasicTypes.TableType) {
            return this.count(type.getRowType());
        }
        else if (type instanceof BasicTypes.DataReference) {
            return this.count(type.getType());
        }
        else if (type instanceof BasicTypes.StructureType) {
            let count = 0;
            for (const c of type.getComponents()) {
                count = count + this.count(c.type);
            }
            return count;
        }
        return 0;
    }
    update(obj) {
        const file = obj.getMainABAPFile();
        if (file === undefined) {
            obj.setDefinition(undefined);
            return;
        }
        const struc = file === null || file === void 0 ? void 0 : file.getStructure();
        if (struc === undefined) {
            obj.setDefinition(undefined);
            return;
        }
        const input = {
            filename: file.getFilename(),
            scope: _current_scope_1.CurrentScope.buildDefault(this.reg, obj),
            issues: [],
        };
        if (obj instanceof interface_1.Interface) {
            const found = struc.findFirstStructure(Structures.Interface);
            if (found) {
                try {
                    const def = new interface_definition_1.InterfaceDefinition(found, input);
                    obj.setDefinition(def);
                }
                catch (_a) {
                    obj.setDefinition(undefined);
                }
            }
            else {
                obj.setDefinition(undefined);
            }
        }
        else {
            const found = struc.findFirstStructure(Structures.ClassDefinition);
            if (found) {
                try {
                    const def = new class_definition_1.ClassDefinition(found, input);
                    obj.setDefinition(def);
                }
                catch (_b) {
                    obj.setDefinition(undefined);
                }
            }
            else {
                obj.setDefinition(undefined);
            }
        }
    }
}
exports.FindGlobalDefinitions = FindGlobalDefinitions;
//# sourceMappingURL=find_global_definitions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/spaghetti_scope.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/spaghetti_scope.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpaghettiScope = exports.SpaghettiScopeNode = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const _reference_1 = __webpack_require__(/*! ./_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const assert_error_1 = __webpack_require__(/*! ./assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class ScopeData {
    constructor() {
        this.data = {
            vars: {},
            cdefs: {},
            idefs: {},
            forms: [], // todo, refactor to object
            types: {},
            extraLikeTypes: {},
            deferred: {},
            references: [],
            sqlConversion: [],
        };
    }
    getData() {
        return this.data;
    }
}
class SpaghettiScopeNode extends ScopeData {
    [Symbol.for("debug.description")]() {
        return `SpaghettiSN ${this.identifier.sname} ${this.identifier.stype}`;
    }
    constructor(identifier, parent) {
        super();
        this.identifier = identifier;
        this.parent = parent;
        this.children = [];
    }
    getParent() {
        return this.parent;
    }
    addChild(node) {
        this.children.push(node);
    }
    getChildren() {
        return this.children;
    }
    getFirstChild() {
        return this.children[0];
    }
    getIdentifier() {
        return this.identifier;
    }
    calcCoverage() {
        if (this.identifier.end === undefined) {
            throw new assert_error_1.AssertError("internal error, caclCoverage");
        }
        return { start: this.identifier.start, end: this.identifier.end };
    }
    setEnd(end) {
        this.identifier.end = end;
    }
    findDeferred(name) {
        let search = this;
        while (search !== undefined) {
            const found = search.getData().deferred[name.toUpperCase()];
            if (found) {
                return {
                    id: new _identifier_1.Identifier(found.token, search.identifier.filename),
                    ooType: found.ooType,
                };
            }
            search = search.getParent();
        }
        return undefined;
    }
    findClassDefinition(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            const c = search.getData().cdefs[upper];
            if (c !== undefined) {
                return c;
            }
            search = search.getParent();
        }
        return undefined;
    }
    listClassDefinitions() {
        let search = this;
        const ret = [];
        while (search !== undefined) {
            ret.push(...Object.values(search.getData().cdefs));
            search = search.getParent();
        }
        return ret;
    }
    listInterfaceDefinitions() {
        let search = this;
        const ret = [];
        while (search !== undefined) {
            ret.push(...Object.values(search.getData().idefs));
            search = search.getParent();
        }
        return ret;
    }
    findFormDefinition(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            for (const form of search.getData().forms) {
                if (form.getName().toUpperCase() === upper) {
                    return form;
                }
            }
            search = search.getParent();
        }
        return undefined;
    }
    findInterfaceDefinition(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            const idef = search.getData().idefs[upper];
            if (idef) {
                return idef;
            }
            search = search.getParent();
        }
        return undefined;
    }
    findType(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            const found = search.getData().types[upper];
            if (found) {
                return found;
            }
            search = search.getParent();
        }
        return undefined;
    }
    findExtraLikeType(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            const data = search.getData();
            if (data.extraLikeTypes[upper]) {
                return data.extraLikeTypes[upper];
            }
            search = search.getParent();
        }
        return undefined;
    }
    findVariable(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            const data = search.getData();
            if (data.vars[upper]) {
                return data.vars[upper];
            }
            search = search.getParent();
        }
        return undefined;
    }
    findWriteReference(pos) {
        for (const r of this.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.DataWriteReference
                && r.position.getStart().equals(pos)) {
                if (r.resolved instanceof _typed_identifier_1.TypedIdentifier) {
                    return r.resolved;
                }
            }
        }
        return undefined;
    }
    findTableReference(pos) {
        for (const r of this.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.TableReference
                && r.position.getStart().equals(pos)
                && r.resolved) {
                return r.resolved.getName();
            }
        }
        return undefined;
    }
    findTableVoidReference(pos) {
        for (const r of this.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.TableVoidReference
                && r.position.getStart().equals(pos)) {
                return true;
            }
        }
        return false;
    }
    // this method is used in the transpiler
    findScopeForVariable(name) {
        let search = this;
        const upper = name.toUpperCase();
        while (search !== undefined) {
            if (search.getData().vars[upper] !== undefined) {
                return search.getIdentifier();
            }
            search = search.getParent();
        }
        return undefined;
    }
}
exports.SpaghettiScopeNode = SpaghettiScopeNode;
class SpaghettiScope {
    constructor(top) {
        this.node = top;
    }
    // list variable definitions across all nodes
    listDefinitions(filename) {
        const ret = [];
        for (const n of this.allNodes()) {
            if (n.getIdentifier().filename === filename) {
                const vars = n.getData().vars;
                for (const v in vars) {
                    if (vars[v].getFilename() === filename) {
                        ret.push({ name: v, identifier: vars[v] });
                    }
                }
            }
        }
        return ret;
    }
    listReadPositions(filename) {
        const ret = [];
        for (const n of this.allNodes()) {
            if (n.getIdentifier().filename === filename) {
                for (const v of n.getData().references) {
                    if (v.referenceType === _reference_1.ReferenceType.DataReadReference && v.position.getFilename() === filename) {
                        ret.push(v.position);
                    }
                }
            }
        }
        return ret;
    }
    listWritePositions(filename) {
        const ret = [];
        for (const n of this.allNodes()) {
            if (n.getIdentifier().filename === filename) {
                for (const v of n.getData().references) {
                    if (v.referenceType === _reference_1.ReferenceType.DataWriteReference && v.position.getFilename() === filename) {
                        ret.push(v.position);
                    }
                }
            }
        }
        return ret;
    }
    lookupPosition(p, filename) {
        if (p === undefined || filename === undefined) {
            return undefined;
        }
        return this.lookupPositionTraverse(p, filename, this.node);
    }
    getFirstChild() {
        return this.node.getFirstChild();
    }
    getTop() {
        return this.node;
    }
    /////////////////////////////
    allNodes() {
        const ret = [];
        const stack = [this.node];
        while (stack.length > 0) {
            const current = stack.pop();
            ret.push(current);
            stack.push(...current.getChildren());
        }
        return ret;
    }
    lookupPositionTraverse(p, filename, node) {
        const coverage = node.calcCoverage();
        if (node.getIdentifier().filename === filename && p.isBetween(coverage.start, coverage.end) === false) {
            return undefined;
        }
        // possible optimization: binary search the nodes
        for (const c of node.getChildren()) {
            const result = this.lookupPositionTraverse(p, filename, c);
            if (result !== undefined) {
                return result;
            }
        }
        if (node.getIdentifier().filename === filename
            && p.isBetween(coverage.start, coverage.end)) {
            return node;
        }
        return undefined;
    }
}
exports.SpaghettiScope = SpaghettiScope;
//# sourceMappingURL=spaghetti_scope.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Add = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Add {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Add = Add;
//# sourceMappingURL=add.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add_corresponding.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add_corresponding.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddCorresponding = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class AddCorresponding {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.AddCorresponding = AddCorresponding;
//# sourceMappingURL=add_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/append.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/append.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Append = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
// todo: issue error for short APPEND if the source is without header line
class Append {
    runSyntax(node, input) {
        let targetType = undefined;
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            targetType = new target_1.Target().runSyntax(target, input);
        }
        const fsTarget = node.findExpressionAfterToken("ASSIGNING");
        if (fsTarget && fsTarget.get() instanceof Expressions.FSTarget) {
            if (!(targetType instanceof basic_1.TableType) && !(targetType instanceof basic_1.VoidType)) {
                const message = "APPEND to non table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const rowType = targetType instanceof basic_1.TableType ? targetType.getRowType() : targetType;
            new fstarget_1.FSTarget().runSyntax(fsTarget, input, rowType);
        }
        const dataTarget = node.findExpressionAfterToken("INTO");
        if (dataTarget && node.concatTokens().toUpperCase().includes(" REFERENCE INTO DATA(")) {
            if (!(targetType instanceof basic_1.TableType) && !(targetType instanceof basic_1.VoidType)) {
                const message = "APPEND to non table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const rowType = targetType instanceof basic_1.TableType ? targetType.getRowType() : targetType;
            new inline_data_1.InlineData().runSyntax(dataTarget, input, new basic_1.DataReference(rowType));
        }
        let source = node.findDirectExpression(Expressions.SimpleSource4);
        if (source === undefined) {
            source = node.findDirectExpression(Expressions.Source);
        }
        if (source) {
            if (targetType !== undefined
                && !(targetType instanceof basic_1.TableType)
                && dataTarget !== target
                && !(targetType instanceof basic_1.VoidType)) {
                const message = "Append, target not a table type";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            let rowType = undefined;
            if (targetType instanceof basic_1.TableType) {
                rowType = targetType.getRowType();
            }
            else if (targetType instanceof basic_1.VoidType) {
                rowType = targetType;
            }
            let sourceType = new source_1.Source().runSyntax(source, input, rowType);
            if (node.findDirectTokenByText("LINES")) {
                // hmm, checking only the row types are compatible will not check the table type, e.g. sorted or hashed
                if (sourceType instanceof basic_1.TableType) {
                    sourceType = sourceType.getRowType();
                }
                if (targetType instanceof basic_1.TableType) {
                    targetType = targetType.getRowType();
                }
                if (new _type_utils_1.TypeUtils(input.scope).isAssignable(sourceType, targetType) === false) {
                    const message = "Incompatible types";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            else {
                if (new _type_utils_1.TypeUtils(input.scope).isAssignable(sourceType, rowType) === false) {
                    const message = "Incompatible types";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
        const from = node.findExpressionAfterToken("FROM");
        if (from && from.get() instanceof Expressions.Source) {
            new source_1.Source().runSyntax(from, input);
        }
        const to = node.findExpressionAfterToken("TO");
        if (to && to.get() instanceof Expressions.Source) {
            new source_1.Source().runSyntax(to, input);
        }
    }
}
exports.Append = Append;
//# sourceMappingURL=append.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assert.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assert.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Assert = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class Assert {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
    }
}
exports.Assert = Assert;
//# sourceMappingURL=assert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assign.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assign.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Assign = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Assign {
    runSyntax(node, input) {
        var _a, _b;
        const assignSource = node.findDirectExpression(Expressions.AssignSource);
        const sources = (assignSource === null || assignSource === void 0 ? void 0 : assignSource.findDirectExpressionsMulti([Expressions.Source, Expressions.SimpleSource3])) || [];
        const theSource = sources[sources.length - 1];
        let sourceType = undefined;
        const firstAssign = assignSource === null || assignSource === void 0 ? void 0 : assignSource.getChildren()[0];
        const secondAssign = assignSource === null || assignSource === void 0 ? void 0 : assignSource.getChildren()[1];
        const thirdAssign = assignSource === null || assignSource === void 0 ? void 0 : assignSource.getChildren()[2];
        if ((secondAssign === null || secondAssign === void 0 ? void 0 : secondAssign.concatTokens()) === "=>" && firstAssign && (thirdAssign === null || thirdAssign === void 0 ? void 0 : thirdAssign.get()) instanceof Expressions.Dynamic) {
            const name = firstAssign.concatTokens();
            const found = input.scope.findClassDefinition(name) || input.scope.findVariable(name);
            if (found === undefined && input.scope.getDDIC().inErrorNamespace(name) && name.startsWith("(") === false) {
                const message = name + " not found, dynamic";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            sourceType = new basic_1.VoidType("Dynamic");
        }
        else {
            sourceType = new source_1.Source().runSyntax(theSource, input);
        }
        if ((assignSource === null || assignSource === void 0 ? void 0 : assignSource.getChildren().length) === 5
            && ((_a = assignSource === null || assignSource === void 0 ? void 0 : assignSource.getFirstChild()) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase()) === "COMPONENT") {
            const componentSource = sources[sources.length - 2];
            const componentType = new source_1.Source().runSyntax(componentSource, input);
            if (new _type_utils_1.TypeUtils(input.scope).isAssignable(componentType, new basic_1.CharacterType(30)) === false) {
                const message = "component name must be charlike";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        if (sourceType === undefined || (assignSource === null || assignSource === void 0 ? void 0 : assignSource.findDirectExpression(Expressions.Dynamic))) {
            sourceType = new basic_1.AnyType();
        }
        for (const d of (assignSource === null || assignSource === void 0 ? void 0 : assignSource.findAllExpressions(Expressions.Dynamic)) || []) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        const target = node.findDirectExpression(Expressions.FSTarget);
        if (target) {
            if (((_b = assignSource === null || assignSource === void 0 ? void 0 : assignSource.getFirstChild()) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase()) === "COMPONENT") {
                new fstarget_1.FSTarget().runSyntax(target, input, new basic_1.AnyType());
            }
            else {
                new fstarget_1.FSTarget().runSyntax(target, input, sourceType);
            }
        }
        for (const s of node.findAllExpressions(Expressions.Source)) {
            if (s === theSource) {
                continue;
            }
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Assign = Assign;
//# sourceMappingURL=assign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/authority_check.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/authority_check.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorityCheck = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class AuthorityCheck {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.AuthorityCheck = AuthorityCheck;
//# sourceMappingURL=authority_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Call = void 0;
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const method_call_chain_1 = __webpack_require__(/*! ../expressions/method_call_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_chain.js");
const method_source_1 = __webpack_require__(/*! ../expressions/method_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_source.js");
const method_call_body_1 = __webpack_require__(/*! ../expressions/method_call_body */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_call_body.js");
const void_type_1 = __webpack_require__(/*! ../../types/basic/void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Call {
    runSyntax(node, input) {
        const children = node.getChildren();
        if (children.length === 2) {
            const first = children[0];
            new method_call_chain_1.MethodCallChain().runSyntax(first, input);
            return;
        }
        const methodSource = children[2];
        if (methodSource === undefined) {
            const message = "Call, child MethodSource not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const methodDef = new method_source_1.MethodSource().runSyntax(methodSource, input);
        const body = children[3];
        if (body instanceof nodes_1.ExpressionNode) {
            // todo, resolve the method definition above and pass, if possible, in case of dynamic pass void
            new method_call_body_1.MethodCallBody().runSyntax(body, input, methodDef || new void_type_1.VoidType("CallTODO"));
        }
    }
}
exports.Call = Call;
//# sourceMappingURL=call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_badi.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_badi.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallBadi = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class CallBadi {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findAllExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
    }
}
exports.CallBadi = CallBadi;
//# sourceMappingURL=call_badi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_function.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_function.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallFunction = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const field_chain_1 = __webpack_require__(/*! ../expressions/field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class CallFunction {
    runSyntax(node, input) {
        // todo, lots of work here, similar to receive.ts
        const name = node.findFirstExpression(Expressions.FunctionName);
        const chain = name === null || name === void 0 ? void 0 : name.findFirstExpression(Expressions.FieldChain);
        if (chain) {
            new field_chain_1.FieldChain().runSyntax(chain, input, _reference_1.ReferenceType.DataReadReference);
        }
        else if (input.scope.getVersion() === version_1.Version.Cloud
            && node.findDirectExpression(Expressions.Destination) === undefined) {
            const functionName = name === null || name === void 0 ? void 0 : name.concatTokens().replace(/'/g, "");
            if (input.scope.findFunctionModule(functionName) === undefined) {
                const message = `Function module "${functionName}" not found/released`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        // just recurse
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findAllExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleSource2)) {
            new source_1.Source().runSyntax(s, input);
        }
        const exceptions = node.findFirstExpression(Expressions.ParameterException);
        for (const s of (exceptions === null || exceptions === void 0 ? void 0 : exceptions.findAllExpressions(Expressions.SimpleFieldChain)) || []) {
            new field_chain_1.FieldChain().runSyntax(s, input, _reference_1.ReferenceType.DataReadReference);
        }
    }
}
exports.CallFunction = CallFunction;
//# sourceMappingURL=call_function.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_kernel.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_kernel.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallKernel = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class CallKernel {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.CallKernel = CallKernel;
//# sourceMappingURL=call_kernel.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transaction.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transaction.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransaction = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class CallTransaction {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.CallTransaction = CallTransaction;
//# sourceMappingURL=call_transaction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transformation.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transformation.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransformation = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class CallTransformation {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        for (const t of node.findAllExpressions(Expressions.Target)) {
            const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.XStringType());
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
    }
}
exports.CallTransformation = CallTransformation;
//# sourceMappingURL=call_transformation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Case = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class Case {
    runSyntax(node, input) {
        // just recurse
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Case = Case;
//# sourceMappingURL=case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case_type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case_type.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CaseType = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class CaseType {
    runSyntax(node, input) {
        // just recurse
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.CaseType = CaseType;
//# sourceMappingURL=case_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/catch.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/catch.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Catch = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Catch {
    runSyntax(node, input) {
        var _a, _b;
        const names = new Set();
        for (const c of node.findDirectExpressions(Expressions.ClassName)) {
            const token = c.getFirstToken();
            const className = token.getStr().toUpperCase();
            const found = input.scope.existsObject(className);
            if (found === null || found === void 0 ? void 0 : found.id) {
                input.scope.addReference(token, found.id, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            }
            else if (input.scope.getDDIC().inErrorNamespace(className) === false) {
                const extra = { ooName: className, ooType: "Void" };
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, extra);
            }
            else {
                const message = "CATCH, unknown class " + className;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, token, message));
                return;
            }
            if (names.has(className)) {
                const message = "Duplicate class name in CATCH: " + className;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            names.add(className);
        }
        const target = node.findDirectExpression(Expressions.Target);
        const firstClassName = (_a = node.findDirectExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr();
        if (target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData)) {
            const token = (_b = target.findFirstExpression(Expressions.TargetField)) === null || _b === void 0 ? void 0 : _b.getFirstToken();
            const found = input.scope.existsObject(firstClassName);
            if (token && firstClassName && (found === null || found === void 0 ? void 0 : found.id)) {
                const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, new basic_1.ObjectReferenceType(found.id), ["inline" /* IdentifierMeta.InlineDefinition */]);
                input.scope.addIdentifier(identifier);
                input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
            }
            else if (token && input.scope.getDDIC().inErrorNamespace(firstClassName) === false) {
                const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, new basic_1.VoidType(firstClassName), ["inline" /* IdentifierMeta.InlineDefinition */]);
                input.scope.addIdentifier(identifier);
                input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
            }
            else if (token) {
                const message = "Catch, could not determine type for \"" + token.getStr() + "\"";
                const identifier = new _typed_identifier_1.TypedIdentifier(token, input.filename, new unknown_type_1.UnknownType(message), ["inline" /* IdentifierMeta.InlineDefinition */]);
                input.scope.addIdentifier(identifier);
                input.scope.addReference(token, identifier, _reference_1.ReferenceType.DataWriteReference, input.filename);
            }
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.Catch = Catch;
//# sourceMappingURL=catch.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/check.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/check.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Check = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class Check {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
    }
}
exports.Check = Check;
//# sourceMappingURL=check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_data.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_data.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassData = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const data_definition_1 = __webpack_require__(/*! ../expressions/data_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/data_definition.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class ClassData {
    runSyntax(node, input) {
        const dd = node.findFirstExpression(Expressions.DataDefinition);
        if (dd) {
            const found = new data_definition_1.DataDefinition().runSyntax(dd, input);
            if (found === undefined) {
                return undefined;
            }
            if ((found === null || found === void 0 ? void 0 : found.getType().isGeneric()) === true
                && (found === null || found === void 0 ? void 0 : found.getType().containsVoid()) === false) {
                const message = "DATA definition cannot be generic, " + found.getName();
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new _typed_identifier_1.TypedIdentifier(found.getToken(), input.filename, new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey));
            }
            const meta = [...found.getMeta(), "static" /* IdentifierMeta.Static */];
            return new _typed_identifier_1.TypedIdentifier(found.getToken(), input.filename, found.getType(), meta, found.getValue());
        }
        const fallback = node.findFirstExpression(Expressions.NamespaceSimpleName);
        if (fallback) {
            return new _typed_identifier_1.TypedIdentifier(fallback.getFirstToken(), input.filename, new unknown_type_1.UnknownType("class data, fallback"));
        }
        return undefined;
    }
}
exports.ClassData = ClassData;
//# sourceMappingURL=class_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_deferred.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_deferred.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDeferred = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ClassDeferred {
    runSyntax(node, input) {
        var _a;
        const name = (_a = node.findFirstExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        input.scope.addDeferred(name, "CLAS");
    }
}
exports.ClassDeferred = ClassDeferred;
//# sourceMappingURL=class_deferred.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_implementation.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_implementation.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassImplementation = void 0;
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const position_1 = __webpack_require__(/*! ../../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _builtin_1 = __webpack_require__(/*! ../_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ClassImplementation {
    runSyntax(node, input) {
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        const className = helper.findClassName(node);
        input.scope.push(_scope_type_1.ScopeType.ClassImplementation, className, node.getFirstToken().getStart(), input.filename);
        const classDefinition = input.scope.findClassDefinition(className);
        if (classDefinition === undefined) {
            const message = "Class definition for \"" + className + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        for (const t of classDefinition.getTypeDefinitions().getAll()) {
            input.scope.addType(t.type);
        }
        const sup = input.scope.findClassDefinition(classDefinition.getSuperClass());
        if (sup) {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(new tokens_1.Identifier(new position_1.Position(1, 1), "super"), _builtin_1.BuiltIn.filename, new basic_1.ObjectReferenceType(sup)));
        }
        else {
            // todo: instead of the void type, do proper typing, ie. only empty constructor method
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(new tokens_1.Identifier(new position_1.Position(1, 1), "super"), _builtin_1.BuiltIn.filename, new basic_1.VoidType("noSuper")));
        }
        input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(new tokens_1.Identifier(new position_1.Position(1, 1), "me"), _builtin_1.BuiltIn.filename, new basic_1.ObjectReferenceType(classDefinition)));
        helper.addAliasedAttributes(classDefinition); // todo, this is not correct, take care of instance vs static
        const classAttributes = classDefinition.getAttributes();
        input.scope.addList(classAttributes.getConstants());
        input.scope.addList(classAttributes.getStatic());
        for (const i of classAttributes.getInstance()) {
            input.scope.addExtraLikeType(i);
        }
        helper.fromSuperClassesAndInterfaces(classDefinition);
    }
}
exports.ClassImplementation = ClassImplementation;
//# sourceMappingURL=class_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_local_friends.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_local_friends.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassLocalFriends = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ClassLocalFriends {
    runSyntax(node, input) {
        const classNames = node.findAllExpressions(Expressions.ClassName);
        const found = classNames[0];
        if (found) {
            const token = found.getFirstToken();
            const name = token.getStr();
            if (input.scope.getParentObj().getType() === "CLAS"
                && name.toUpperCase() !== input.scope.getParentObj().getName().toUpperCase()) {
                const message = `Befriending must be ` + input.scope.getParentObj().getName().toUpperCase();
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            const def = input.scope.findClassDefinition(name);
            if (def) {
                input.scope.addReference(token, def, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            }
            else {
                const message = `Class ${name.toUpperCase()} not found`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        for (let i = 1; i < classNames.length; i++) {
            const className = classNames[i].concatTokens();
            // make sure to check also DEFINITION DEFERRED
            const found = input.scope.existsObject(className);
            if (found === undefined) {
                const message = `Class ${className.toUpperCase()} not found`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.ClassLocalFriends = ClassLocalFriends;
//# sourceMappingURL=class_local_friends.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/clear.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/clear.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Clear = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Clear {
    runSyntax(node, input) {
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Clear = Clear;
//# sourceMappingURL=clear.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/close_dataset.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/close_dataset.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloseDataset = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class CloseDataset {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.CloseDataset = CloseDataset;
//# sourceMappingURL=close_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/collect.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/collect.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Collect = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Collect {
    runSyntax(node, input) {
        const source = node.findDirectExpression(Expressions.Source);
        if (source) {
            new source_1.Source().runSyntax(source, input);
        }
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            new target_1.Target().runSyntax(target, input);
        }
        const fs = node.findDirectExpression(Expressions.FSTarget);
        if (fs) {
            new fstarget_1.FSTarget().runSyntax(fs, input, undefined);
        }
    }
}
exports.Collect = Collect;
//# sourceMappingURL=collect.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/commit_entities.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/commit_entities.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommitEntities = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class CommitEntities {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("CommitEntities"));
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
    }
}
exports.CommitEntities = CommitEntities;
//# sourceMappingURL=commit_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/concatenate.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/concatenate.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Concatenate = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Concatenate {
    runSyntax(node, input) {
        const byteMode = node.findDirectTokenByText("BYTE") !== undefined;
        const linesMode = node.findDirectTokenByText("LINES") !== undefined;
        const target = node.findFirstExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            if (byteMode) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.XStringType());
            }
            else {
                new inline_data_1.InlineData().runSyntax(inline, input, basic_1.StringType.get());
            }
        }
        else if (target) {
            const type = new target_1.Target().runSyntax(target, input);
            const compatible = byteMode ? new _type_utils_1.TypeUtils(input.scope).isHexLike(type) : new _type_utils_1.TypeUtils(input.scope).isCharLikeStrict(type);
            if (compatible === false) {
                const message = "Target type not compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        if (linesMode) {
            for (const s of node.findDirectExpressions(Expressions.Source)) {
                const type = new source_1.Source().runSyntax(s, input);
                if (!(type instanceof basic_1.UnknownType) && !(type instanceof basic_1.VoidType) && !(type instanceof basic_1.TableType)) {
                    const message = "Source must be an internal table";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleSource3)) {
            const type = new source_1.Source().runSyntax(s, input);
            const compatible = byteMode ? new _type_utils_1.TypeUtils(input.scope).isHexLike(type) : new _type_utils_1.TypeUtils(input.scope).isCharLikeStrict(type);
            if (compatible === false) {
                const message = "Source type not compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.Concatenate = Concatenate;
//# sourceMappingURL=concatenate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/condense.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/condense.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Condense = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Condense {
    runSyntax(node, input) {
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Condense = Condense;
//# sourceMappingURL=condense.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/constant.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/constant.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constant = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class Constant {
    runSyntax(node, input) {
        const basic = new basic_types_1.BasicTypes(input);
        const found = basic.simpleType(node);
        if (found) {
            const val = basic.findValue(node);
            const meta = ["read_only" /* IdentifierMeta.ReadOnly */, "static" /* IdentifierMeta.Static */];
            return new _typed_identifier_1.TypedIdentifier(found.getToken(), input.filename, found.getType(), meta, val);
        }
        const fallback = node.findFirstExpression(Expressions.DefinitionName);
        if (fallback) {
            return new _typed_identifier_1.TypedIdentifier(fallback.getFirstToken(), input.filename, new basic_1.UnknownType("constant, fallback"));
        }
        throw new assert_error_1.AssertError("Statement Constant: unexpected structure");
    }
}
exports.Constant = Constant;
//# sourceMappingURL=constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/controls.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/controls.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Controls = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class Controls {
    runSyntax(node, input) {
        const name = node.findDirectExpression(Expressions.NamespaceSimpleName);
        const token = name === null || name === void 0 ? void 0 : name.getFirstToken();
        if (node.findDirectTokenByText("TABSTRIP") && token) {
            const type = new basic_1.StructureType([{ name: "ACTIVETAB", type: new basic_1.CharacterType(132) }]);
            const id = new _typed_identifier_1.TypedIdentifier(token, input.filename, type);
            input.scope.addIdentifier(id);
        }
        if (node.findDirectTokenByText("TABLEVIEW") && token) {
            const cols = new basic_1.StructureType([
                { name: "SCREEN", type: new basic_1.CharacterType(1) }, // todo
                { name: "INDEX", type: basic_1.IntegerType.get() },
                { name: "SELECTED", type: new basic_1.CharacterType(1) },
                { name: "VISLENGTH", type: basic_1.IntegerType.get() },
                { name: "INVISIBLE", type: new basic_1.CharacterType(1) },
            ]);
            const type = new basic_1.StructureType([
                { name: "FIXED_COLS", type: new basic_1.CharacterType(132) },
                { name: "LINES", type: basic_1.IntegerType.get() },
                { name: "TOP_LINE", type: basic_1.IntegerType.get() },
                { name: "CURRENT_LINE", type: basic_1.IntegerType.get() },
                { name: "LEFT_COL", type: basic_1.IntegerType.get() },
                { name: "LINE_SEL_MODE", type: new basic_1.CharacterType(1) },
                { name: "COL_SEL_MODE", type: new basic_1.CharacterType(1) },
                { name: "LINE_SELECTOR", type: new basic_1.CharacterType(1) },
                { name: "H_GRID", type: new basic_1.CharacterType(1) },
                { name: "V_GRID", type: new basic_1.CharacterType(1) },
                { name: "COLS", type: new basic_1.TableType(cols, { withHeader: false, keyType: basic_1.TableKeyType.default }) },
                { name: "INVISIBLE", type: new basic_1.CharacterType(1) },
            ]);
            const id = new _typed_identifier_1.TypedIdentifier(token, input.filename, type);
            input.scope.addIdentifier(id);
        }
    }
}
exports.Controls = Controls;
//# sourceMappingURL=controls.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/convert.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/convert.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Convert = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Convert {
    runSyntax(node, input) {
        // todo, the source must be of a specific type
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        const timeTarget = node.findExpressionAfterToken("TIME");
        if ((timeTarget === null || timeTarget === void 0 ? void 0 : timeTarget.get()) instanceof Expressions.Target) {
            const inline = timeTarget === null || timeTarget === void 0 ? void 0 : timeTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.TimeType());
            }
            else {
                new target_1.Target().runSyntax(timeTarget, input);
            }
        }
        const dateTarget = node.findExpressionAfterToken("DATE");
        if ((dateTarget === null || dateTarget === void 0 ? void 0 : dateTarget.get()) instanceof Expressions.Target) {
            const inline = dateTarget === null || dateTarget === void 0 ? void 0 : dateTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.DateType());
            }
            else {
                new target_1.Target().runSyntax(dateTarget, input);
            }
        }
        const stampTarget = node.findExpressionAfterToken("STAMP");
        if ((stampTarget === null || stampTarget === void 0 ? void 0 : stampTarget.get()) instanceof Expressions.Target) {
            const inline = stampTarget === null || stampTarget === void 0 ? void 0 : stampTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.PackedType(8, 4));
            }
            else {
                new target_1.Target().runSyntax(stampTarget, input);
            }
        }
    }
}
exports.Convert = Convert;
//# sourceMappingURL=convert.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_data.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_data.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateData = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class CreateData {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(t, input);
        }
        const type = node.findDirectExpression(Expressions.TypeName);
        if (type) {
            const found = new basic_types_1.BasicTypes(input).resolveTypeName(type);
            if (found instanceof basic_1.UnknownType) {
                if (node.concatTokens().toUpperCase().includes(" REF TO ")) {
                    const def = input.scope.findObjectDefinition(type.concatTokens());
                    if (def) {
                        input.scope.addReference(type.getFirstToken(), def, _reference_1.ReferenceType.TypeReference, input.filename);
                    }
                    else {
                        const identifier = new _typed_identifier_1.TypedIdentifier(type.getFirstToken(), input.filename, found);
                        input.scope.addReference(type.getFirstToken(), identifier, _reference_1.ReferenceType.TypeReference, input.filename);
                    }
                }
                else {
                    const identifier = new _typed_identifier_1.TypedIdentifier(type.getFirstToken(), input.filename, found);
                    input.scope.addReference(type.getFirstToken(), identifier, _reference_1.ReferenceType.TypeReference, input.filename);
                }
            }
        }
    }
}
exports.CreateData = CreateData;
//# sourceMappingURL=create_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_object.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_object.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CreateObject = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const types_1 = __webpack_require__(/*! ../../types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class CreateObject {
    runSyntax(node, input) {
        let cdef = undefined;
        // CREATE OBJECT, TYPE
        const type = node.findExpressionAfterToken("TYPE");
        if (type && type.get() instanceof Expressions.ClassName) {
            const token = type.getFirstToken();
            const name = token.getStr();
            cdef = input.scope.findClassDefinition(name);
            if (cdef) {
                input.scope.addReference(token, cdef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                if (cdef.isAbstract() === true) {
                    const message = cdef.getName() + " is abstract, cannot be instantiated";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, { ooName: name, ooType: "CLAS" });
            }
            else {
                const message = "TYPE \"" + name + "\" not found";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        // just recurse
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        let first = true;
        for (const t of node.findAllExpressions(Expressions.Target)) {
            const found = new target_1.Target().runSyntax(t, input);
            if (first === true) {
                first = false;
                if (found instanceof basic_1.VoidType) {
                    continue;
                }
                else if (found instanceof basic_1.UnknownType) {
                    const message = "Target type unknown, " + t.concatTokens();
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                else if (!(found instanceof basic_1.ObjectReferenceType)
                    && !(found instanceof basic_1.AnyType)
                    && !(found instanceof basic_1.DataType)
                    && !(found instanceof basic_1.GenericObjectReferenceType)) {
                    const message = "Target must be an object reference, " + t.concatTokens();
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                else if (found instanceof basic_1.GenericObjectReferenceType && type === undefined) {
                    const message = "Generic type, cannot be instantiated";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
                else if (found instanceof basic_1.ObjectReferenceType) {
                    const id = found.getIdentifier();
                    if (id instanceof types_1.InterfaceDefinition && type === undefined) {
                        const message = "Interface reference, cannot be instantiated";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                    else if (found instanceof basic_1.ObjectReferenceType
                        && type === undefined
                        && input.scope.findInterfaceDefinition(found.getQualifiedName())) {
                        const message = "Interface reference, cannot be instantiated";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                    else if (id instanceof types_1.ClassDefinition && cdef === undefined) {
                        cdef = id;
                    }
                    if (type === undefined && id instanceof types_1.ClassDefinition && id.isAbstract() === true) {
                        const message = id.getName() + " is abstract, cannot be instantiated";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                        return;
                    }
                }
            }
        }
        for (const t of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(t, input);
        }
        this.validateParameters(cdef, node, input);
    }
    validateParameters(cdef, node, input) {
        var _a, _b, _c, _d;
        if (cdef === undefined) {
            const sources = (_a = node.findDirectExpression(Expressions.ParameterListS)) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.Source);
            for (const s of sources || []) {
                new source_1.Source().runSyntax(s, input);
            }
            return;
        }
        const methodDef = new _object_oriented_1.ObjectOriented(input.scope).searchMethodName(cdef, "CONSTRUCTOR");
        const methodParameters = (_b = methodDef.method) === null || _b === void 0 ? void 0 : _b.getParameters();
        const allImporting = (methodParameters === null || methodParameters === void 0 ? void 0 : methodParameters.getImporting()) || [];
        const requiredImporting = new Set(methodParameters === null || methodParameters === void 0 ? void 0 : methodParameters.getRequiredParameters().map(i => i.getName().toUpperCase()));
        for (const p of ((_c = node.findDirectExpression(Expressions.ParameterListS)) === null || _c === void 0 ? void 0 : _c.findAllExpressions(Expressions.ParameterS)) || []) {
            const name = (_d = p.findDirectExpression(Expressions.ParameterName)) === null || _d === void 0 ? void 0 : _d.concatTokens().toUpperCase();
            if (name === undefined) {
                continue;
            }
            const source = p.findDirectExpression(Expressions.Source);
            const sourceType = new source_1.Source().runSyntax(source, input);
            const calculated = (source === null || source === void 0 ? void 0 : source.findFirstExpression(Expressions.MethodCallChain)) !== undefined
                || (source === null || source === void 0 ? void 0 : source.findFirstExpression(Expressions.StringTemplate)) !== undefined
                || (source === null || source === void 0 ? void 0 : source.findFirstExpression(Expressions.ArithOperator)) !== undefined;
            const found = allImporting === null || allImporting === void 0 ? void 0 : allImporting.find(p => p.getName().toUpperCase() === name);
            if (found === undefined) {
                const message = `constructor parameter "${name}" does not exist`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (new _type_utils_1.TypeUtils(input.scope).isAssignableStrict(sourceType, found.getType(), calculated) === false) {
                const message = `constructor parameter "${name}" type not compatible`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            requiredImporting.delete(name);
        }
        for (const r of requiredImporting.values()) {
            const message = `constructor parameter "${r}" must be supplied`;
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
    }
}
exports.CreateObject = CreateObject;
//# sourceMappingURL=create_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/data.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/data.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Data = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const data_definition_1 = __webpack_require__(/*! ../expressions/data_definition */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/data_definition.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class Data {
    runSyntax(node, input) {
        const name = node.findFirstExpression(Expressions.DefinitionName);
        const dd = node.findFirstExpression(Expressions.DataDefinition);
        if (dd) {
            const id = new data_definition_1.DataDefinition().runSyntax(dd, input);
            if ((id === null || id === void 0 ? void 0 : id.getType().isGeneric()) === true
                && (id === null || id === void 0 ? void 0 : id.getType().containsVoid()) === false) {
                const message = "DATA definition cannot be generic, " + (name === null || name === void 0 ? void 0 : name.concatTokens());
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new _typed_identifier_1.TypedIdentifier(id.getToken(), input.filename, new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey));
            }
            return id;
        }
        if (name) {
            return new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, new unknown_type_1.UnknownType("data, fallback"));
        }
        return undefined;
    }
}
exports.Data = Data;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_cluster.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_cluster.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteCluster = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class DeleteCluster {
    runSyntax(node, input) {
        var _a;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        const databaseName = node.findExpressionAfterToken("DATABASE");
        if (databaseName) {
            const found = (_a = input.scope.getDDIC()) === null || _a === void 0 ? void 0 : _a.lookupTableOrView(databaseName.concatTokens());
            if (found) {
                input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: found.object });
            }
        }
    }
}
exports.DeleteCluster = DeleteCluster;
//# sourceMappingURL=delete_cluster.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_database.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_database.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteDatabase = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const database_table_1 = __webpack_require__(/*! ../expressions/database_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js");
class DeleteDatabase {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        const dbtab = node.findFirstExpression(Expressions.DatabaseTable);
        if (dbtab !== undefined) {
            new database_table_1.DatabaseTable().runSyntax(dbtab, input);
        }
    }
}
exports.DeleteDatabase = DeleteDatabase;
//# sourceMappingURL=delete_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_internal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_internal.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteInternal = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const component_compare_1 = __webpack_require__(/*! ../expressions/component_compare */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare.js");
const component_cond_1 = __webpack_require__(/*! ../expressions/component_cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class DeleteInternal {
    runSyntax(node, input) {
        var _a;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        let targetType = undefined;
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            let tabl = undefined;
            if (node.getChildren().length === 5 && node.getChildren()[2].concatTokens().toUpperCase() === "FROM") {
                // it might be a database table
                tabl = (_a = input.scope.getDDIC()) === null || _a === void 0 ? void 0 : _a.lookupTableOrView(target.concatTokens());
                if (tabl) {
                    input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: tabl.object });
                }
            }
            if (tabl === undefined) {
                targetType = new target_1.Target().runSyntax(target, input);
                if (targetType instanceof basic_1.TableType) {
                    targetType = targetType.getRowType();
                }
            }
        }
        for (const t of node.findDirectExpressions(Expressions.ComponentCompare)) {
            new component_compare_1.ComponentCompare().runSyntax(t, input, targetType);
        }
        for (const t of node.findDirectExpressions(Expressions.ComponentCond)) {
            new component_cond_1.ComponentCond().runSyntax(t, input, targetType);
        }
    }
}
exports.DeleteInternal = DeleteInternal;
//# sourceMappingURL=delete_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_report.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_report.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DeleteReport = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class DeleteReport {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.DeleteReport = DeleteReport;
//# sourceMappingURL=delete_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/describe.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/describe.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Describe = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const field_chain_1 = __webpack_require__(/*! ../expressions/field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class Describe {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.FieldChain)) {
            new field_chain_1.FieldChain().runSyntax(s, input, _reference_1.ReferenceType.DataReadReference);
        }
        const linesTarget = node.findExpressionAfterToken("LINES");
        if ((linesTarget === null || linesTarget === void 0 ? void 0 : linesTarget.get()) instanceof Expressions.Target) {
            const inline = linesTarget === null || linesTarget === void 0 ? void 0 : linesTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, basic_1.IntegerType.get());
            }
            else {
                new target_1.Target().runSyntax(linesTarget, input);
            }
        }
        const typeTarget = node.findExpressionAfterToken("TYPE");
        if ((typeTarget === null || typeTarget === void 0 ? void 0 : typeTarget.get()) instanceof Expressions.Target) {
            const inline = typeTarget === null || typeTarget === void 0 ? void 0 : typeTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.CharacterType(1));
            }
            else {
                new target_1.Target().runSyntax(typeTarget, input);
            }
        }
        const lengthTarget = node.findExpressionAfterToken("LENGTH");
        if ((lengthTarget === null || lengthTarget === void 0 ? void 0 : lengthTarget.get()) instanceof Expressions.Target) {
            const inline = lengthTarget === null || lengthTarget === void 0 ? void 0 : lengthTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, basic_1.IntegerType.get());
            }
            else {
                new target_1.Target().runSyntax(lengthTarget, input);
            }
        }
        const componentsTarget = node.findExpressionAfterToken("COMPONENTS");
        if ((componentsTarget === null || componentsTarget === void 0 ? void 0 : componentsTarget.get()) instanceof Expressions.Target) {
            const inline = componentsTarget === null || componentsTarget === void 0 ? void 0 : componentsTarget.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, basic_1.IntegerType.get());
            }
            else {
                new target_1.Target().runSyntax(componentsTarget, input);
            }
        }
    }
}
exports.Describe = Describe;
//# sourceMappingURL=describe.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/divide.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/divide.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Divide = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Divide {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Divide = Divide;
//# sourceMappingURL=divide.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/do.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/do.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Do = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Do {
    runSyntax(node, input) {
        const afterDo = node.findExpressionAfterToken("DO");
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            const type = new source_1.Source().runSyntax(s, input);
            if (s === afterDo
                && new _type_utils_1.TypeUtils(input.scope).isAssignable(type, basic_1.IntegerType.get()) === false) {
                const message = "DO TIMES must be numeric";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Do = Do;
//# sourceMappingURL=do.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/editor_call.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/editor_call.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditorCall = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class EditorCall {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(t, input);
        }
    }
}
exports.EditorCall = EditorCall;
//# sourceMappingURL=editor_call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/else_if.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/else_if.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ElseIf = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class ElseIf {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
    }
}
exports.ElseIf = ElseIf;
//# sourceMappingURL=else_if.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/export.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/export.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Export = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Export {
    runSyntax(node, input) {
        var _a;
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        const databaseName = node.findExpressionAfterToken("DATABASE");
        if (databaseName) {
            const found = (_a = input.scope.getDDIC()) === null || _a === void 0 ? void 0 : _a.lookupTableOrView(databaseName.concatTokens());
            if (found) {
                input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: found.object });
            }
        }
    }
}
exports.Export = Export;
//# sourceMappingURL=export.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/fieldsymbol.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/fieldsymbol.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldSymbol = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
class FieldSymbol {
    runSyntax(node, input) {
        var _a;
        const fsname = (_a = node.findFirstExpression(Expressions.FieldSymbol)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        const bfound = new basic_types_1.BasicTypes(input).parseType(node);
        if (bfound && fsname) {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(fsname, input.filename, bfound));
            return;
        }
        if (fsname) {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(fsname, input.filename, new unknown_type_1.UnknownType("Fieldsymbol, fallback")));
        }
    }
}
exports.FieldSymbol = FieldSymbol;
//# sourceMappingURL=fieldsymbol.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/find.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/find.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Find = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Find {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        const rfound = node.findExpressionAfterToken("RESULTS");
        if (rfound && rfound.get() instanceof Expressions.Target) {
            const sub = new basic_1.StructureType([
                { name: "OFFSET", type: basic_1.IntegerType.get() },
                { name: "LENGTH", type: basic_1.IntegerType.get() }
            ], "SUBMATCH_RESULT", "SUBMATCH_RESULT");
            const type = new basic_1.StructureType([
                { name: "LINE", type: basic_1.IntegerType.get() },
                { name: "OFFSET", type: basic_1.IntegerType.get() },
                { name: "LENGTH", type: basic_1.IntegerType.get() },
                { name: "SUBMATCHES", type: new basic_1.TableType(sub, { withHeader: false, keyType: basic_1.TableKeyType.default }) },
            ], "MATCH_RESULT", "MATCH_RESULT");
            if (node.concatTokens().toUpperCase().startsWith("FIND FIRST")) {
                this.inline(rfound, input, type);
            }
            else {
                this.inline(rfound, input, new basic_1.TableType(type, { withHeader: false, keyType: basic_1.TableKeyType.default }, "MATCH_RESULT_TAB"));
            }
        }
        const ofound = node.findExpressionsAfterToken("OFFSET");
        for (const o of ofound) {
            if (o.get() instanceof Expressions.Target) {
                this.inline(o, input, basic_1.IntegerType.get());
            }
        }
        const lfound = node.findExpressionAfterToken("LINE");
        if (lfound && lfound.get() instanceof Expressions.Target) {
            this.inline(lfound, input, basic_1.IntegerType.get());
        }
        const cfound = node.findExpressionAfterToken("COUNT");
        if (cfound && cfound.get() instanceof Expressions.Target) {
            this.inline(cfound, input, basic_1.IntegerType.get());
        }
        const lnfound = node.findExpressionAfterToken("LENGTH");
        if (lnfound && lnfound.get() instanceof Expressions.Target) {
            this.inline(lnfound, input, basic_1.IntegerType.get());
        }
        if (node.findDirectTokenByText("SUBMATCHES")) {
            for (const t of node.findDirectExpressions(Expressions.Target)) {
                if (t === rfound || t === lfound || t === cfound || t === lnfound) {
                    continue;
                }
                else if (ofound.indexOf(t) >= 0) {
                    continue;
                }
                const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
                if (inline) {
                    new inline_data_1.InlineData().runSyntax(inline, input, basic_1.StringType.get());
                }
                else {
                    new target_1.Target().runSyntax(t, input);
                }
            }
        }
    }
    /////////////////////
    inline(node, input, type) {
        const inline = node.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, type);
        }
        else {
            new target_1.Target().runSyntax(node, input);
        }
    }
}
exports.Find = Find;
//# sourceMappingURL=find.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/form.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/form.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Form = void 0;
const form_definition_1 = __webpack_require__(/*! ../../types/form_definition */ "./node_modules/@abaplint/core/build/src/abap/types/form_definition.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const expressions_1 = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Form {
    runSyntax(node, input) {
        var _a;
        const name = (_a = node.findDirectExpression(expressions_1.FormName)) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (name === undefined) {
            const message = "Form, could not find name";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        input.scope.push(_scope_type_1.ScopeType.Form, name, node.getFirstToken().getStart(), input.filename);
        const form = new form_definition_1.FormDefinition(node, input);
        input.scope.addList(form.getUsingParameters());
        input.scope.addList(form.getChangingParameters());
        input.scope.addList(form.getTablesParameters());
    }
}
exports.Form = Form;
//# sourceMappingURL=form.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/format.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/format.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Format = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class Format {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Format = Format;
//# sourceMappingURL=format.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_badi.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_badi.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBadi = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class GetBadi {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const d of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
    }
}
exports.GetBadi = GetBadi;
//# sourceMappingURL=get_badi.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_bit.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_bit.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetBit = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class GetBit {
    runSyntax(node, input) {
        let lastType = undefined;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            lastType = new source_1.Source().runSyntax(s, input);
        }
        if (lastType && new _type_utils_1.TypeUtils(input.scope).isHexLike(lastType) === false) {
            const message = "Input must be byte-like";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(t, input, basic_1.IntegerType.get());
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
    }
}
exports.GetBit = GetBit;
//# sourceMappingURL=get_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_cursor.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_cursor.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetCursor = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class GetCursor {
    runSyntax(node, input) {
        for (const t of node.findAllExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.GetCursor = GetCursor;
//# sourceMappingURL=get_cursor.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_locale.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_locale.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetLocale = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class GetLocale {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.GetLocale = GetLocale;
//# sourceMappingURL=get_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_parameter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_parameter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetParameter = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class GetParameter {
    runSyntax(node, input) {
        const target = node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.CharacterType(40));
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.GetParameter = GetParameter;
//# sourceMappingURL=get_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_reference.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_reference.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetReference = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class GetReference {
    runSyntax(node, input) {
        const s = node.findDirectExpression(Expressions.Source);
        const type = new source_1.Source().runSyntax(s, input);
        const target = node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        // todo: error if inline field symbol
        if (inline) {
            if (type instanceof basic_1.AnyType) {
                const message = "GET REFERENCE generic and inline declaration not possible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            new inline_data_1.InlineData().runSyntax(inline, input, type ? new basic_1.DataReference(type) : undefined);
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.GetReference = GetReference;
//# sourceMappingURL=get_reference.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_run_time.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_run_time.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetRunTime = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class GetRunTime {
    runSyntax(node, input) {
        const target = node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, basic_1.IntegerType.get());
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.GetRunTime = GetRunTime;
//# sourceMappingURL=get_run_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_time.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_time.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GetTime = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class GetTime {
    runSyntax(node, input) {
        const target = node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.PackedType(8, 0));
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.GetTime = GetTime;
//# sourceMappingURL=get_time.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/if.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/if.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.If = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class If {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
    }
}
exports.If = If;
//# sourceMappingURL=if.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Import = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Import {
    runSyntax(node, input) {
        var _a;
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        const databaseName = node.findExpressionAfterToken("DATABASE");
        if (databaseName) {
            const found = (_a = input.scope.getDDIC()) === null || _a === void 0 ? void 0 : _a.lookupTableOrView(databaseName.concatTokens());
            if (found) {
                input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: found.object });
            }
        }
    }
}
exports.Import = Import;
//# sourceMappingURL=import.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import_dynpro.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import_dynpro.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImportDynpro = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class ImportDynpro {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.ImportDynpro = ImportDynpro;
//# sourceMappingURL=import_dynpro.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/include_type.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/include_type.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncludeType = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class IncludeType {
    runSyntax(node, input) {
        var _a, _b;
        const components = [];
        const iname = node.findFirstExpression(Expressions.TypeName);
        if (iname === undefined) {
            throw new assert_error_1.AssertError("IncludeType, unexpected node structure");
        }
        const name = iname.getFirstToken().getStr();
        let ityp = new basic_types_1.BasicTypes(input).parseType(iname);
        const as = (_a = node.findExpressionAfterToken("AS")) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (as && ityp instanceof basic_1.StructureType) {
            ityp = new basic_1.StructureType(ityp.getComponents().concat([{
                    name: as,
                    type: ityp,
                    asInclude: true,
                }]));
        }
        const suffix = (_b = node.findExpressionAfterToken("SUFFIX")) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (suffix && ityp instanceof basic_1.StructureType) {
            const components = [];
            for (const c of ityp.getComponents()) {
                if (c.name === as) {
                    components.push(Object.assign(Object.assign({}, c), { suffix: suffix, asInclude: c.asInclude }));
                    continue;
                }
                components.push({
                    name: c.name + suffix,
                    type: c.type,
                });
            }
            ityp = new basic_1.StructureType(components);
        }
        if (ityp
            && ityp instanceof _typed_identifier_1.TypedIdentifier
            && ityp.getType() instanceof basic_1.StructureType) {
            const stru = ityp.getType();
            components.push(...stru.getComponents());
        }
        else if (ityp && ityp instanceof basic_1.StructureType) {
            components.push(...ityp.getComponents());
        }
        else if (ityp && ityp instanceof basic_1.VoidType) {
            return ityp;
        }
        else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
            return new basic_1.VoidType(name);
        }
        else {
            const message = "IncludeType, type not found \"" + iname.concatTokens() + "\"";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey);
        }
        return components;
    }
}
exports.IncludeType = IncludeType;
//# sourceMappingURL=include_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_database.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_database.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertDatabase = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const database_table_1 = __webpack_require__(/*! ../expressions/database_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js");
class InsertDatabase {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        const dbtab = node.findFirstExpression(Expressions.DatabaseTable);
        if (dbtab !== undefined) {
            new database_table_1.DatabaseTable().runSyntax(dbtab, input);
        }
    }
}
exports.InsertDatabase = InsertDatabase;
//# sourceMappingURL=insert_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_field_group.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_field_group.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertFieldGroup = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class InsertFieldGroup {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource1)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.InsertFieldGroup = InsertFieldGroup;
//# sourceMappingURL=insert_field_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_internal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_internal.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertInternal = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_fs_1 = __webpack_require__(/*! ../expressions/inline_fs */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_fs.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class InsertInternal {
    runSyntax(node, input) {
        let targetType;
        const t = node.findDirectExpression(Expressions.Target);
        if (t) {
            targetType = new target_1.Target().runSyntax(t, input);
        }
        if (!(targetType instanceof basic_1.TableType)
            && !(targetType instanceof basic_1.VoidType)
            && !(targetType instanceof basic_1.AnyType)
            && !(targetType instanceof basic_1.UnknownType)
            && targetType !== undefined) {
            const message = "INSERT target must be a table";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (targetType instanceof basic_1.TableType
            && node.findDirectTokenByText("LINES") === undefined) {
            targetType = targetType.getRowType();
        }
        let source = node.findDirectExpression(Expressions.SimpleSource4);
        if (source === undefined) {
            source = node.findDirectExpression(Expressions.Source);
        }
        const sourceType = source ? new source_1.Source().runSyntax(source, input, targetType) : targetType;
        if (targetType === undefined
            && !(sourceType instanceof basic_1.TableType)
            && !(sourceType instanceof basic_1.VoidType)
            && !(sourceType instanceof basic_1.AnyType)
            && !(sourceType instanceof basic_1.UnknownType)) {
            const message = "INSERT target must be a table";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const afterAssigning = node.findExpressionAfterToken("ASSIGNING");
        if ((afterAssigning === null || afterAssigning === void 0 ? void 0 : afterAssigning.get()) instanceof Expressions.FSTarget) {
            const inlinefs = afterAssigning === null || afterAssigning === void 0 ? void 0 : afterAssigning.findDirectExpression(Expressions.InlineFS);
            if (inlinefs) {
                new inline_fs_1.InlineFS().runSyntax(inlinefs, input, sourceType);
            }
            else {
                new fstarget_1.FSTarget().runSyntax(afterAssigning, input, sourceType);
            }
        }
        if (node.findDirectTokenByText("INITIAL") === undefined) {
            if (new _type_utils_1.TypeUtils(input.scope).isAssignableStrict(sourceType, targetType) === false) {
                const message = "Types not compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (sourceType instanceof basic_1.CharacterType && targetType instanceof basic_1.StringType) {
                // yea, well, INSERT doesnt convert the values automatically, like everything else?
                const message = "Types not compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        const afterInto = node.findExpressionAfterToken("INTO");
        if ((afterInto === null || afterInto === void 0 ? void 0 : afterInto.get()) instanceof Expressions.Target && sourceType) {
            const inline = afterInto.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(afterInto, input, new basic_1.DataReference(sourceType));
            }
            else {
                new target_1.Target().runSyntax(afterInto, input);
            }
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            if (s === source) {
                continue;
            }
            new source_1.Source().runSyntax(s, input, targetType);
        }
    }
}
exports.InsertInternal = InsertInternal;
//# sourceMappingURL=insert_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_report.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_report.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertReport = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class InsertReport {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.InsertReport = InsertReport;
//# sourceMappingURL=insert_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_textpool.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_textpool.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InsertTextpool = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class InsertTextpool {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.InsertTextpool = InsertTextpool;
//# sourceMappingURL=insert_textpool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/interface_deferred.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/interface_deferred.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceDeferred = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class InterfaceDeferred {
    runSyntax(node, input) {
        var _a;
        const name = (_a = node.findFirstExpression(Expressions.InterfaceName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        input.scope.addDeferred(name, "INTF");
    }
}
exports.InterfaceDeferred = InterfaceDeferred;
//# sourceMappingURL=interface_deferred.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/log_point.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/log_point.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LogPoint = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class LogPoint {
    runSyntax(node, input) {
        // just recurse
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.LogPoint = LogPoint;
//# sourceMappingURL=log_point.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Loop = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const inline_fs_1 = __webpack_require__(/*! ../expressions/inline_fs */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_fs.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const component_cond_1 = __webpack_require__(/*! ../expressions/component_cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const loop_group_by_1 = __webpack_require__(/*! ../expressions/loop_group_by */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/loop_group_by.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Loop {
    runSyntax(node, input) {
        const loopTarget = node.findDirectExpression(Expressions.LoopTarget);
        let target = loopTarget === null || loopTarget === void 0 ? void 0 : loopTarget.findDirectExpression(Expressions.Target);
        const targetType = target ? new target_1.Target().runSyntax(target, input) : undefined;
        if (target === undefined) {
            target = node.findDirectExpression(Expressions.FSTarget);
        }
        const write = (loopTarget === null || loopTarget === void 0 ? void 0 : loopTarget.findDirectTokenByText("ASSIGNING")) !== undefined;
        const sources = node.findDirectExpressions(Expressions.Source);
        let firstSource = node.findDirectExpression(Expressions.SimpleSource2);
        if (firstSource === undefined) {
            firstSource = sources[0];
        }
        let sourceType = firstSource ? new source_1.Source().runSyntax(firstSource, input, targetType, write) : undefined;
        let rowType = undefined;
        const concat = node.concatTokens().toUpperCase();
        if (sourceType === undefined) {
            // if its a dynpro table control loop, then dont issue error
            if (concat !== "LOOP.") {
                const message = "No source type determined";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            }
            return;
        }
        else if (sourceType instanceof basic_1.UnknownType) {
            const message = "Loop, not a table type, " + sourceType.getError();
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (sourceType instanceof basic_1.TableType
            && target === undefined
            && sourceType.isWithHeader() === false
            && node.getChildren().length === 4) {
            const message = "Loop, no header line";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (!(sourceType instanceof basic_1.TableType)
            && !(sourceType instanceof basic_1.AnyType)
            && !(sourceType instanceof basic_1.DataType)
            && !(sourceType instanceof basic_1.VoidType)
            && concat.startsWith("LOOP AT GROUP ") === false) {
            const message = "Loop, not a table type";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (loopTarget === undefined
            && sourceType instanceof basic_1.TableType
            && sourceType.isWithHeader() === false) {
            const message = "Loop, no header";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const targetConcat = loopTarget === null || loopTarget === void 0 ? void 0 : loopTarget.concatTokens().toUpperCase();
        if (sourceType instanceof basic_1.TableType) {
            rowType = sourceType.getRowType();
            sourceType = rowType;
            if (targetConcat === null || targetConcat === void 0 ? void 0 : targetConcat.startsWith("REFERENCE INTO ")) {
                sourceType = new basic_1.DataReference(sourceType);
            }
        }
        if (targetConcat
            && targetConcat.startsWith("TRANSPORTING ")
            && node.findDirectTokenByText("WHERE") === undefined) {
            const message = "Loop, TRANSPORTING NO FIELDS only with WHERE";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, sourceType);
        }
        for (const s of sources) {
            if (s === firstSource) {
                continue;
            }
            new source_1.Source().runSyntax(s, input);
        }
        const inlinefs = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineFS);
        if (inlinefs) {
            new inline_fs_1.InlineFS().runSyntax(inlinefs, input, sourceType);
        }
        else {
            const fstarget = loopTarget === null || loopTarget === void 0 ? void 0 : loopTarget.findDirectExpression(Expressions.FSTarget);
            if (fstarget) {
                new fstarget_1.FSTarget().runSyntax(fstarget, input, sourceType);
            }
        }
        for (const t of node.findDirectExpressions(Expressions.ComponentCond)) {
            new component_cond_1.ComponentCond().runSyntax(t, input, rowType);
        }
        for (const t of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(t, input);
        }
        const group = node.findDirectExpression(Expressions.LoopGroupBy);
        if (group) {
            new loop_group_by_1.LoopGroupBy().runSyntax(group, input);
        }
    }
}
exports.Loop = Loop;
//# sourceMappingURL=loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop_at_screen.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop_at_screen.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LoopAtScreen = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class LoopAtScreen {
    runSyntax(node, input) {
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            new target_1.Target().runSyntax(target, input);
        }
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("SCREEN"));
        }
    }
}
exports.LoopAtScreen = LoopAtScreen;
//# sourceMappingURL=loop_at_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/message.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/message.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const message_source_1 = __webpack_require__(/*! ../expressions/message_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/message_source.js");
class Message {
    runSyntax(node, input) {
        const found = node.findExpressionAfterToken("INTO");
        const inline = found === null || found === void 0 ? void 0 : found.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, basic_1.StringType.get());
        }
        else if (found) {
            new target_1.Target().runSyntax(found, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.MessageSource)) {
            new message_source_1.MessageSource().runSyntax(s, input);
        }
    }
}
exports.Message = Message;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/method_implementation.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/method_implementation.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodImplementation = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class MethodImplementation {
    runSyntax(node, input) {
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        const className = input.scope.getName();
        const methodToken = node.findFirstExpression(Expressions.MethodName).getFirstToken();
        const methodName = methodToken === null || methodToken === void 0 ? void 0 : methodToken.getStr();
        const classDefinition = input.scope.findClassDefinition(className);
        if (classDefinition === undefined) {
            const message = "Class definition for \"" + className + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const { method: methodDefinition } = helper.searchMethodName(classDefinition, methodName);
        if (methodDefinition === undefined) {
            const message = "Method definition \"" + methodName + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const start = node.getFirstToken().getStart();
        if (methodDefinition.isStatic() === false) {
            input.scope.push(_scope_type_1.ScopeType.MethodInstance, methodName, start, input.filename);
            input.scope.addList(classDefinition.getAttributes().getInstance());
        }
        input.scope.push(_scope_type_1.ScopeType.Method, methodName, start, input.filename);
        input.scope.addReference(methodToken, methodDefinition, _reference_1.ReferenceType.MethodImplementationReference, input.filename);
        input.scope.addList(methodDefinition.getParameters().getAll());
        for (const i of helper.findInterfaces(classDefinition)) {
            if (methodName.toUpperCase().startsWith(i.name.toUpperCase() + "~") === false) {
                continue;
            }
            const idef = input.scope.findInterfaceDefinition(i.name);
            if (idef === undefined) {
                continue;
            }
            input.scope.addReference(methodToken, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
        }
    }
}
exports.MethodImplementation = MethodImplementation;
//# sourceMappingURL=method_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_database.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_database.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyDatabase = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const database_table_1 = __webpack_require__(/*! ../expressions/database_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class ModifyDatabase {
    runSyntax(node, input) {
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        const dbtab = node.findFirstExpression(Expressions.DatabaseTable);
        if (dbtab !== undefined) {
            if (node.getChildren().length === 5) {
                const found = input.scope.findVariable(dbtab.concatTokens());
                if (found) {
                    input.scope.addReference(dbtab.getFirstToken(), found, _reference_1.ReferenceType.DataWriteReference, input.filename);
                }
                else {
                    new database_table_1.DatabaseTable().runSyntax(dbtab, input);
                }
            }
            else {
                new database_table_1.DatabaseTable().runSyntax(dbtab, input);
            }
        }
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.ModifyDatabase = ModifyDatabase;
//# sourceMappingURL=modify_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_entities.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_entities.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyEntities = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class ModifyEntities {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("ModifyEntities"));
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
    }
}
exports.ModifyEntities = ModifyEntities;
//# sourceMappingURL=modify_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_internal.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_internal.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyInternal = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const component_cond_1 = __webpack_require__(/*! ../expressions/component_cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_cond.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ModifyInternal {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        // there is only one
        const target = node.findFirstExpression(Expressions.Target);
        const targetExpression = target;
        if (targetExpression) {
            // it might be a dynamic target
            const targetType = new target_1.Target().runSyntax(targetExpression, input);
            if (targetType instanceof basic_1.VoidType
                || targetType instanceof basic_1.AnyType
                || targetType instanceof basic_1.UnknownType) {
                // ok
            }
            else if (targetType instanceof basic_1.TableType) {
                if (node.findDirectTokenByText("TABLE")
                    && node.findDirectTokenByText("INDEX")
                    && targetType.isWithHeader() === false) {
                    // MODIFY TABLE INDEX
                    const message = "Table does not have header line";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            else if (targetType instanceof basic_1.StructureType) {
                // it might originate from a TABLES statement
                if (target.concatTokens().toUpperCase() !== targetType.getDDICName()) {
                    const message = "Not an internal table";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
            else {
                const message = "Not an internal table";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        const fstarget = node.findDirectExpression(Expressions.FSTarget);
        if (fstarget) {
            new fstarget_1.FSTarget().runSyntax(fstarget, input, undefined);
        }
        for (const t of node.findDirectExpressions(Expressions.ComponentCond)) {
            new component_cond_1.ComponentCond().runSyntax(t, input);
        }
    }
}
exports.ModifyInternal = ModifyInternal;
//# sourceMappingURL=modify_internal.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_screen.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_screen.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyScreen = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class ModifyScreen {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.ModifyScreen = ModifyScreen;
//# sourceMappingURL=modify_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Move = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Move {
    runSyntax(node, input) {
        const targets = node.findDirectExpressions(Expressions.Target);
        const firstTarget = targets[0];
        const inline = firstTarget === null || firstTarget === void 0 ? void 0 : firstTarget.findDirectExpression(Expressions.InlineData);
        let targetType = undefined;
        if (inline === undefined) {
            targetType = firstTarget ? new target_1.Target().runSyntax(firstTarget, input) : undefined;
            for (const t of targets) {
                if (t === firstTarget) {
                    continue;
                }
                new target_1.Target().runSyntax(t, input);
            }
        }
        const source = node.findDirectExpression(Expressions.Source);
        const sourceType = source ? new source_1.Source().runSyntax(source, input, targetType) : undefined;
        if (sourceType === undefined) {
            const message = "No source type determined";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, sourceType);
            targetType = sourceType;
        }
        if (node.findDirectTokenByText("?=")) {
            if (new _type_utils_1.TypeUtils(input.scope).isCastable(sourceType, targetType) === false) {
                const message = "Incompatible types";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        else if (new _type_utils_1.TypeUtils(input.scope).isAssignable(sourceType, targetType) === false) {
            const message = "Incompatible types";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
    }
}
exports.Move = Move;
//# sourceMappingURL=move.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move_corresponding.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move_corresponding.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MoveCorresponding = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const version_1 = __webpack_require__(/*! ../../../version */ "./node_modules/@abaplint/core/build/src/version.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class MoveCorresponding {
    runSyntax(node, input) {
        const s = node.findDirectExpression(Expressions.Source);
        const t = node.findDirectExpression(Expressions.SimpleTarget);
        if (s === undefined || t === undefined) {
            const message = "MoveCorresponding, source or target not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const sourceType = new source_1.Source().runSyntax(s, input);
        const targetType = new target_1.Target().runSyntax(t, input);
        if (input.scope.getVersion() < version_1.Version.v740sp05 && input.scope.getVersion() !== version_1.Version.Cloud) {
            if (sourceType instanceof basic_1.TableType && sourceType.isWithHeader() === false) {
                const message = "MOVE-CORRESPONDING with tables possible from v740sp05";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            else if (targetType instanceof basic_1.TableType && targetType.isWithHeader() === false) {
                const message = "MOVE-CORRESPONDING with tables possible from v740sp05";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.MoveCorresponding = MoveCorresponding;
//# sourceMappingURL=move_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/multiply.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/multiply.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Multiply = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Multiply {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Multiply = Multiply;
//# sourceMappingURL=multiply.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/open_dataset.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/open_dataset.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OpenDataset = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class OpenDataset {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.OpenDataset = OpenDataset;
//# sourceMappingURL=open_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/pack.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/pack.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Pack = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Pack {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Pack = Pack;
//# sourceMappingURL=pack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/parameter.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/parameter.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameter = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class Parameter {
    runSyntax(node, input) {
        var _a;
        const nameToken = (_a = node.findFirstExpression(Expressions.FieldSub)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (nameToken && nameToken.getStr().length > 8) {
            const message = "Parameter name too long, " + nameToken.getStr();
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (nameToken === undefined) {
            return;
        }
        if (node.findDirectTokenByText("RADIOBUTTON") && node.findDirectTokenByText("LENGTH")) {
            const message = "RADIOBUTTON and LENGTH not possible together";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const bfound = new basic_types_1.BasicTypes(input).parseType(node);
        if (bfound) {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, bfound));
        }
        else {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new basic_1.UnknownType("Parameter, fallback")));
        }
        const magicName = "%_" + nameToken.getStr() + "_%_app_%";
        const magicToken = new tokens_1.Identifier(nameToken.getStart(), magicName);
        input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(magicToken, input.filename, new basic_1.VoidType("PARAMETER magic")));
    }
}
exports.Parameter = Parameter;
//# sourceMappingURL=parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/perform.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/perform.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Perform = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class Perform {
    runSyntax(node, input) {
        if (!(node.get() instanceof Statements.Perform)) {
            throw new assert_error_1.AssertError("checkPerform unexpected node type");
        }
        ////////////////////////////
        // check parameters are defined
        for (const c of node.findDirectExpressions(Expressions.PerformChanging)) {
            for (const s of c.findDirectExpressions(Expressions.Target)) {
                new target_1.Target().runSyntax(s, input);
            }
        }
        for (const t of node.findDirectExpressions(Expressions.PerformTables)) {
            for (const s of t.findDirectExpressions(Expressions.Source)) {
                new source_1.Source().runSyntax(s, input);
            }
        }
        for (const u of node.findDirectExpressions(Expressions.PerformUsing)) {
            for (const s of u.findDirectExpressions(Expressions.Source)) {
                new source_1.Source().runSyntax(s, input);
            }
        }
        ////////////////////////////
        // find FORM definition
        if (node.findFirstExpression(Expressions.IncludeName)) {
            return; // in external program, not checked, todo
        }
        if (node.findFirstExpression(Expressions.Dynamic)) {
            return; // todo, maybe some parts can be checked
        }
        const expr = node.findFirstExpression(Expressions.FormName);
        if (expr === undefined) {
            return; // it might be a dynamic call
        }
        const name = expr.concatTokens();
        const found = input.scope.findFormDefinition(name);
        if (found === undefined) {
            const message = "FORM definition \"" + name + "\" not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, expr.getFirstToken(), message));
            return;
        }
        input.scope.addReference(expr.getFirstToken(), found, _reference_1.ReferenceType.FormReference, input.filename);
        // todo, also check parameters match
    }
}
exports.Perform = Perform;
//# sourceMappingURL=perform.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Raise = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const message_source_1 = __webpack_require__(/*! ../expressions/message_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/message_source.js");
const raise_with_1 = __webpack_require__(/*! ../expressions/raise_with */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/raise_with.js");
const _object_oriented_1 = __webpack_require__(/*! ../_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const method_parameters_1 = __webpack_require__(/*! ../expressions/method_parameters */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_parameters.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Raise {
    runSyntax(node, input) {
        // todo
        var _a, _b, _c, _d, _e, _f;
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        let method;
        const classTok = (_a = node.findDirectExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        const className = classTok === null || classTok === void 0 ? void 0 : classTok.getStr();
        if (classTok && className) {
            const found = input.scope.existsObject(className);
            if (found === null || found === void 0 ? void 0 : found.id) {
                input.scope.addReference(classTok, found.id, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                const def = input.scope.findObjectDefinition(className);
                method = (_b = helper.searchMethodName(def, "CONSTRUCTOR")) === null || _b === void 0 ? void 0 : _b.method;
            }
            else if (input.scope.getDDIC().inErrorNamespace(className) === false) {
                const extra = { ooName: className, ooType: "Void" };
                input.scope.addReference(classTok, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, extra);
                method = new basic_1.VoidType(className);
            }
            else {
                const message = "RAISE, unknown class " + className;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, classTok, message));
                return;
            }
            if (method === undefined) {
                method = new basic_1.VoidType(className);
            }
        }
        const c = node.findExpressionAfterToken("EXCEPTION");
        if (c instanceof nodes_1.ExpressionNode && (c.get() instanceof Expressions.SimpleSource2 || c.get() instanceof Expressions.Source)) {
            const type = new source_1.Source().runSyntax(c, input);
            if (type instanceof basic_1.VoidType) {
                method = type;
            }
            else if (type instanceof basic_1.ObjectReferenceType) {
                const def = input.scope.findObjectDefinition(type.getIdentifierName());
                method = (_c = helper.searchMethodName(def, "CONSTRUCTOR")) === null || _c === void 0 ? void 0 : _c.method;
            }
            else if (type !== undefined) {
                const message = "RAISE EXCEPTION, must be object reference, got " + type.constructor.name;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, c.getFirstToken(), message));
                return;
            }
        }
        if (method === undefined) {
            method = new basic_1.VoidType("Exception");
        }
        // check parameters vs constructor
        const param = node.findDirectExpression(Expressions.ParameterListS);
        if (param) {
            new method_parameters_1.MethodParameters().checkExporting(param, input, method, true);
        }
        for (const s of node.findDirectExpressions(Expressions.RaiseWith)) {
            new raise_with_1.RaiseWith().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.SimpleSource2)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.MessageSource)) {
            new message_source_1.MessageSource().runSyntax(s, input);
        }
        const id = (_d = node.findExpressionAfterToken("ID")) === null || _d === void 0 ? void 0 : _d.concatTokens();
        let number = (_e = node.findDirectExpression(Expressions.MessageNumber)) === null || _e === void 0 ? void 0 : _e.concatTokens();
        if (number === undefined) {
            const num = (_f = node.findExpressionAfterToken("NUMBER")) === null || _f === void 0 ? void 0 : _f.concatTokens();
            if (num === null || num === void 0 ? void 0 : num.startsWith("'")) {
                number = num.substring(1, num.length - 1).toUpperCase();
            }
        }
        if ((id === null || id === void 0 ? void 0 : id.startsWith("'")) && number) {
            const messageClass = id.substring(1, id.length - 1).toUpperCase();
            input.scope.getMSAGReferences().addUsing(input.filename, node.getFirstToken(), messageClass, number);
        }
    }
}
exports.Raise = Raise;
//# sourceMappingURL=raise.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise_event.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise_event.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RaiseEvent = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class RaiseEvent {
    runSyntax(node, input) {
        // todo: only possible in classes
        const f = node.findDirectExpression(Expressions.EventName);
        if (f === null || f === void 0 ? void 0 : f.concatTokens().includes("~")) {
            const name = f.concatTokens().split("~")[0];
            const idef = input.scope.findInterfaceDefinition(name);
            if (idef) {
                input.scope.addReference(f.getFirstToken(), idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            }
        }
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.RaiseEvent = RaiseEvent;
//# sourceMappingURL=raise_event.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/ranges.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/ranges.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Ranges = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class Ranges {
    runSyntax(node, input) {
        var _a;
        const nameToken = (_a = node.findFirstExpression(Expressions.SimpleName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        const typeExpression = node.findFirstExpression(Expressions.SimpleFieldChain2);
        if (typeExpression === undefined) {
            throw new assert_error_1.AssertError("Ranges, unexpected node");
        }
        const found = new basic_types_1.BasicTypes(input).parseType(typeExpression);
        if (found && nameToken) {
            const structure = new basic_1.StructureType([
                { name: "sign", type: new basic_1.CharacterType(1) },
                { name: "option", type: new basic_1.CharacterType(2) },
                { name: "low", type: found },
                { name: "high", type: found },
            ]);
            const type = new basic_1.TableType(structure, { withHeader: true, keyType: basic_1.TableKeyType.default });
            const id = new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, type);
            input.scope.addIdentifier(id);
        }
    }
}
exports.Ranges = Ranges;
//# sourceMappingURL=ranges.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_entities.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_entities.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadEntities = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class ReadEntities {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            const inline = t === null || t === void 0 ? void 0 : t.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, new basic_1.VoidType("ReadEntities"));
            }
            else {
                new target_1.Target().runSyntax(t, input);
            }
        }
    }
}
exports.ReadEntities = ReadEntities;
//# sourceMappingURL=read_entities.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_report.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_report.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadReport = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class ReadReport {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.ReadReport = ReadReport;
//# sourceMappingURL=read_report.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_table.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_table.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadTable = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const fstarget_1 = __webpack_require__(/*! ../expressions/fstarget */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/fstarget.js");
const component_compare_simple_1 = __webpack_require__(/*! ../expressions/component_compare_simple */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/component_compare_simple.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class ReadTable {
    runSyntax(node, input) {
        const concat = node.concatTokens().toUpperCase();
        const sources = node.findDirectExpressions(Expressions.Source);
        let firstSource = node.findDirectExpression(Expressions.SimpleSource2);
        if (firstSource === undefined) {
            firstSource = sources[0];
        }
        const sourceType = firstSource ? new source_1.Source().runSyntax(firstSource, input) : undefined;
        if (sourceType === undefined) {
            const message = "No source type determined, read table";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        else if (!(sourceType instanceof basic_1.TableType) && !(sourceType instanceof basic_1.VoidType)) {
            const message = "Read table, not a table type";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        let rowType = sourceType;
        if (rowType instanceof basic_1.TableType) {
            rowType = rowType.getRowType();
        }
        const components = node.findDirectExpression(Expressions.ComponentCompareSimple);
        if (components !== undefined) {
            new component_compare_simple_1.ComponentCompareSimple().runSyntax(components, input, rowType);
        }
        const indexSource = node.findExpressionAfterToken("INDEX");
        if (indexSource) {
            const indexType = new source_1.Source().runSyntax(indexSource, input);
            if (new _type_utils_1.TypeUtils(input.scope).isAssignable(indexType, basic_1.IntegerType.get()) === false) {
                const message = "READ TABLE, INDEX must be simple";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        const fromSource = node.findExpressionAfterToken("FROM");
        if (fromSource) {
            const fromType = new source_1.Source().runSyntax(fromSource, input);
            if (new _type_utils_1.TypeUtils(input.scope).isAssignable(fromType, rowType) === false) {
                const message = "READ TABLE, FROM must be compatible";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, fromSource.getFirstToken(), message));
                return;
            }
        }
        const afterKey = node.findExpressionAfterToken("KEY");
        for (const s of sources) {
            if (s === firstSource || s === indexSource || s === fromSource) {
                continue;
            }
            const type = new source_1.Source().runSyntax(s, input);
            if (s === afterKey) {
                if (type instanceof basic_1.StringType || type instanceof basic_1.TableType || type instanceof basic_1.ObjectReferenceType) {
                    const message = "Key cannot be string or table or reference";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, s.getFirstToken(), message));
                    return;
                }
            }
        }
        const target = node.findDirectExpression(Expressions.ReadTableTarget);
        if (target) {
            if (concat.includes(" REFERENCE INTO ")) {
                rowType = new basic_1.DataReference(rowType);
            }
            const inline = target.findFirstExpression(Expressions.InlineData);
            const fst = target.findDirectExpression(Expressions.FSTarget);
            const t = target.findFirstExpression(Expressions.Target);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, rowType);
            }
            else if (fst) {
                new fstarget_1.FSTarget().runSyntax(fst, input, rowType);
            }
            else if (t) {
                const targetType = new target_1.Target().runSyntax(t, input);
                if (new _type_utils_1.TypeUtils(input.scope).isAssignable(rowType, targetType) === false) {
                    const message = "Incompatible types";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
        if (target === undefined && concat.includes(" TRANSPORTING NO FIELDS ") === false) {
            // if sourceType is void, assume its with header
            if (sourceType instanceof basic_1.TableType && sourceType.isWithHeader() === false) {
                const message = "READ TABLE, define INTO or TRANSPORTING NO FIELDS";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        const transporting = node.findDirectExpression(Expressions.TransportingFields);
        if (transporting
            && !(rowType instanceof basic_1.VoidType)
            && !(rowType instanceof basic_1.UnknownType)
            && !(rowType instanceof basic_1.AnyType)) {
            if (!(rowType instanceof basic_1.StructureType)) {
                const message = "READ TABLE, source not structured";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            for (const t of (transporting === null || transporting === void 0 ? void 0 : transporting.findDirectExpressions(Expressions.FieldSub)) || []) {
                const field = t.concatTokens();
                if (field.includes("-")) {
                    // todo
                    continue;
                }
                if (rowType.getComponentByName(field) === undefined) {
                    const message = "READ TABLE, field " + field + " not found in source";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
    }
}
exports.ReadTable = ReadTable;
//# sourceMappingURL=read_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_textpool.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_textpool.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReadTextpool = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class ReadTextpool {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.SimpleTarget)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.ReadTextpool = ReadTextpool;
//# sourceMappingURL=read_textpool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/receive.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/receive.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Receive = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class Receive {
    runSyntax(node, input) {
        // todo, lots of work here, similar to call_function.ts
        // just recurse
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findAllExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Receive = Receive;
//# sourceMappingURL=receive.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/replace.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/replace.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Replace = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Replace {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Replace = Replace;
//# sourceMappingURL=replace.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/scan.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/scan.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Scan = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Scan {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Scan = Scan;
//# sourceMappingURL=scan.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/search.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/search.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Search = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class Search {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Search = Search;
//# sourceMappingURL=search.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Select = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const select_1 = __webpack_require__(/*! ../expressions/select */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js");
class Select {
    runSyntax(node, input) {
        const selects = node.findDirectExpressions(Expressions.Select);
        for (let i = 0; i < selects.length; i++) {
            const last = i === selects.length - 1;
            const s = selects[i];
            new select_1.Select().runSyntax(s, input, last === false);
        }
    }
}
exports.Select = Select;
//# sourceMappingURL=select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select_loop.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select_loop.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectLoop = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const select_loop_1 = __webpack_require__(/*! ../expressions/select_loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select_loop.js");
class SelectLoop {
    runSyntax(node, input) {
        const s = node.findDirectExpression(Expressions.SelectLoop);
        if (s) {
            new select_loop_1.SelectLoop().runSyntax(s, input);
        }
    }
}
exports.SelectLoop = SelectLoop;
//# sourceMappingURL=select_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selection_screen.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selection_screen.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionScreen = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class SelectionScreen {
    runSyntax(node, input) {
        const field = node.findFirstExpression(Expressions.InlineField);
        if (field === undefined) {
            return;
        }
        if (field.getFirstToken().getStr().length > 8) {
            const message = "SELECTION-SCREEN name too long, " + field.getFirstToken().getStr();
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, field.getFirstToken(), message));
            return;
        }
        const name = field.getFirstToken();
        const concat = node.concatTokens().toUpperCase();
        if (concat.includes("BEGIN OF TABBED BLOCK")) {
            const type = new basic_1.StructureType([
                { name: "PROG", type: new basic_1.CharacterType(40) },
                { name: "DYNNR", type: new basic_1.CharacterType(4) },
                { name: "ACTIVETAB", type: new basic_1.CharacterType(132) },
            ]);
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(name, input.filename, type, ["selection_screen_tab" /* IdentifierMeta.SelectionScreenTab */]));
        }
        else if (concat.startsWith("SELECTION-SCREEN TAB")) {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(name, input.filename, new basic_1.CharacterType(83), ["selection_screen_tab" /* IdentifierMeta.SelectionScreenTab */]));
        }
        else {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(name, input.filename, new basic_1.CharacterType(83)));
        }
    }
}
exports.SelectionScreen = SelectionScreen;
//# sourceMappingURL=selection_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selectoption.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selectoption.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectOption = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const tokens_1 = __webpack_require__(/*! ../../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class SelectOption {
    runSyntax(node, input) {
        var _a;
        const nameToken = (_a = node.findFirstExpression(Expressions.FieldSub)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (nameToken && nameToken.getStr().length > 8) {
            const message = "Select-option name too long, " + nameToken.getStr();
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, message));
            return;
        }
        else if (nameToken === undefined) {
            return;
        }
        for (const d of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        const nameExpression = node.findFirstExpression(Expressions.FieldChain);
        let found = new basic_types_1.BasicTypes(input).resolveLikeName(nameExpression);
        if (found) {
            if (found instanceof basic_1.StructureType) {
                let length = 0;
                for (const c of found.getComponents()) {
                    if (c.type instanceof basic_1.CharacterType) {
                        length += c.type.getLength();
                    }
                }
                if (length === 0) {
                    found = new basic_1.VoidType("Selectoption, fallback");
                }
                else {
                    found = new basic_1.CharacterType(length);
                }
            }
            const stru = new basic_1.StructureType([
                { name: "SIGN", type: new basic_1.CharacterType(1) },
                { name: "OPTION", type: new basic_1.CharacterType(2) },
                { name: "LOW", type: found },
                { name: "HIGH", type: found },
            ]);
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new basic_1.TableType(stru, { withHeader: true, keyType: basic_1.TableKeyType.default })));
        }
        else {
            input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new basic_1.UnknownType("Select option, fallback")));
        }
        const magicName = "%_" + nameToken.getStr() + "_%_app_%";
        const magicToken = new tokens_1.Identifier(nameToken.getStart(), magicName);
        input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(magicToken, input.filename, new basic_1.VoidType("SELECT-OPTION magic")));
    }
}
exports.SelectOption = SelectOption;
//# sourceMappingURL=selectoption.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_bit.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_bit.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetBit = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class SetBit {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            const typ = new target_1.Target().runSyntax(t, input);
            if (typ && new _type_utils_1.TypeUtils(input.scope).isHexLike(typ) === false) {
                const message = "Input must be byte-like";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, t.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.SetBit = SetBit;
//# sourceMappingURL=set_bit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_handler.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_handler.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetHandler = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const method_source_1 = __webpack_require__(/*! ../expressions/method_source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_source.js");
class SetHandler {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.MethodSource)) {
            new method_source_1.MethodSource().runSyntax(s, input);
        }
    }
}
exports.SetHandler = SetHandler;
//# sourceMappingURL=set_handler.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_locale.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_locale.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetLocale = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SetLocale {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.SetLocale = SetLocale;
//# sourceMappingURL=set_locale.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_parameter.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_parameter.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetParameter = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SetParameter {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.SetParameter = SetParameter;
//# sourceMappingURL=set_parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_pf_status.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_pf_status.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetPFStatus = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SetPFStatus {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.SetPFStatus = SetPFStatus;
//# sourceMappingURL=set_pf_status.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_titlebar.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_titlebar.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SetTitlebar = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SetTitlebar {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.SetTitlebar = SetTitlebar;
//# sourceMappingURL=set_titlebar.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/shift.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/shift.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Shift = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Shift {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        const target = node.findDirectExpression(Expressions.Target);
        if (target === undefined) {
            const message = "Shift, Target not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
            return;
        }
        const targetType = new target_1.Target().runSyntax(target, input);
        if (node.concatTokens().toUpperCase().includes(" IN BYTE MODE")) {
            if (new _type_utils_1.TypeUtils(input.scope).isHexLike(targetType) === false) {
                const message = "Shift, Target not hex like";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
        else {
            if (new _type_utils_1.TypeUtils(input.scope).isCharLike(targetType) === false) {
                const message = "Shift, Target not char like";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.Shift = Shift;
//# sourceMappingURL=shift.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/sort.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/sort.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Sort = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Sort {
    runSyntax(node, input) {
        var _a, _b;
        for (const s of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(s, input);
        }
        const tnode = node.findDirectExpression(Expressions.Target);
        if (tnode) {
            const ttype = new target_1.Target().runSyntax(tnode, input);
            if (ttype instanceof basic_1.TableType) {
                if (((_b = (_a = ttype.getOptions()) === null || _a === void 0 ? void 0 : _a.primaryKey) === null || _b === void 0 ? void 0 : _b.type) === basic_1.TableAccessType.sorted) {
                    const message = `Sorted table, already sorted`;
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, tnode.getFirstToken(), message));
                    return;
                }
                const rowType = ttype.getRowType();
                if (!(rowType instanceof basic_1.VoidType)
                    && !(rowType instanceof basic_1.UnknownType)
                    && !(rowType instanceof basic_1.AnyType)) {
                    for (const component of node.findAllExpressions(Expressions.ComponentChain)) {
                        if (component.getChildren().length > 1) {
                            continue;
                        }
                        const cname = component.concatTokens().toUpperCase();
                        if (cname === "TABLE_LINE") {
                            continue;
                        }
                        else if (!(rowType instanceof basic_1.StructureType)) {
                            const message = "SORT, table row is not structured";
                            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, tnode.getFirstToken(), message));
                            return;
                        }
                        else if (rowType.getComponentByName(cname) === undefined) {
                            const message = `Field ${cname} does not exist in table row structure`;
                            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                            return;
                        }
                    }
                }
            }
            else if (ttype !== undefined
                && !(ttype instanceof basic_1.VoidType)
                && !(ttype instanceof basic_1.UnknownType)
                && !(ttype instanceof basic_1.AnyType)) {
                const message = "SORT, must be a internal table";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, tnode.getFirstToken(), message));
                return;
            }
        }
    }
}
exports.Sort = Sort;
//# sourceMappingURL=sort.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/split.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/split.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Split = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Split {
    runSyntax(node, input) {
        const intoTable = node.findTokenSequencePosition("INTO", "TABLE") !== undefined;
        const type = intoTable ? new basic_1.TableType(basic_1.StringType.get(), { withHeader: false, keyType: basic_1.TableKeyType.default }) : basic_1.StringType.get();
        for (const target of node.findAllExpressions(Expressions.Target)) {
            const inline = target.findDirectExpression(Expressions.InlineData);
            if (inline) {
                new inline_data_1.InlineData().runSyntax(inline, input, type);
            }
            else {
                let targetType = new target_1.Target().runSyntax(target, input);
                if (intoTable) {
                    if (!(targetType instanceof basic_1.TableType)
                        && !(targetType instanceof basic_1.UnknownType)
                        && !(targetType instanceof basic_1.VoidType)) {
                        const message = "Into must be table typed";
                        input.issues.push((0, _syntax_input_1.syntaxIssue)(input, target.getFirstToken(), message));
                        return;
                    }
                    if (targetType instanceof basic_1.TableType) {
                        targetType = targetType.getRowType();
                    }
                }
                if (new _type_utils_1.TypeUtils(input.scope).isCharLikeStrict(targetType) === false) {
                    const message = "Incompatible, target not character like";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return;
                }
            }
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.Split = Split;
//# sourceMappingURL=split.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/static.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/static.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Static = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const type_table_1 = __webpack_require__(/*! ../expressions/type_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table.js");
class Static {
    runSyntax(node, input) {
        const tt = node.findFirstExpression(Expressions.TypeTable);
        if (tt) {
            const ttfound = new type_table_1.TypeTable().runSyntax(node, input);
            if (ttfound) {
                return ttfound;
            }
        }
        const found = new basic_types_1.BasicTypes(input).simpleType(node);
        if (found) {
            return found;
        }
        const fallback = node.findFirstExpression(Expressions.NamespaceSimpleName);
        if (fallback) {
            return new _typed_identifier_1.TypedIdentifier(fallback.getFirstToken(), input.filename, new basic_1.UnknownType("Static, fallback"));
        }
        return undefined;
    }
}
exports.Static = Static;
//# sourceMappingURL=static.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/submit.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/submit.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Submit = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class Submit {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(t, input);
        }
    }
}
exports.Submit = Submit;
//# sourceMappingURL=submit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Subtract = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Subtract {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Subtract = Subtract;
//# sourceMappingURL=subtract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract_corresponding.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract_corresponding.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SubtractCorresponding = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class SubtractCorresponding {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.SubtractCorresponding = SubtractCorresponding;
//# sourceMappingURL=subtract_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/syntax_check.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/syntax_check.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntaxCheck = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class SyntaxCheck {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.SyntaxCheck = SyntaxCheck;
//# sourceMappingURL=syntax_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/system_call.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/system_call.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SystemCall = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class SystemCall {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.SystemCall = SystemCall;
//# sourceMappingURL=system_call.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/tables.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/tables.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Tables = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const unknown_type_1 = __webpack_require__(/*! ../../types/basic/unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class Tables {
    runSyntax(node, input) {
        var _a, _b;
        const nameToken = (_a = node.findFirstExpression(Expressions.Field)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (nameToken === undefined) {
            return undefined;
        }
        let name = nameToken.getStr();
        if (name.startsWith("*")) {
            name = name.substring(1);
        }
        // lookupTableOrView will also give Unknown and Void
        const found = (_b = input.scope.getDDIC()) === null || _b === void 0 ? void 0 : _b.lookupTableOrView(name);
        if (found) {
            input.scope.getDDICReferences().addUsing(input.scope.getParentObj(), { object: found.object, filename: input.filename, token: nameToken });
            if (input.scope.getType() === _scope_type_1.ScopeType.Form || input.scope.getType() === _scope_type_1.ScopeType.FunctionModule) {
                // hoist TABLES definitions to global scope
                input.scope.addNamedIdentifierToParent(nameToken.getStr(), new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, found.type, ["tables" /* IdentifierMeta.Tables */]));
            }
            else {
                input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, found.type, ["tables" /* IdentifierMeta.Tables */]));
            }
            return;
        }
        // this should never happen,
        input.scope.addIdentifier(new _typed_identifier_1.TypedIdentifier(nameToken, input.filename, new unknown_type_1.UnknownType("Tables, fallback")));
    }
}
exports.Tables = Tables;
//# sourceMappingURL=tables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/transfer.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/transfer.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transfer = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Transfer {
    runSyntax(node, input) {
        for (const source of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(source, input);
        }
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.Transfer = Transfer;
//# sourceMappingURL=transfer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/translate.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/translate.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Translate = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Translate {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Translate = Translate;
//# sourceMappingURL=translate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/truncate_dataset.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/truncate_dataset.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TruncateDataset = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class TruncateDataset {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.TruncateDataset = TruncateDataset;
//# sourceMappingURL=truncate_dataset.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/type.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/type.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Type = void 0;
const basic_types_1 = __webpack_require__(/*! ../basic_types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/basic_types.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const type_table_1 = __webpack_require__(/*! ../expressions/type_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/type_table.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Type {
    runSyntax(node, input, qualifiedNamePrefix) {
        const tt = node.findFirstExpression(Expressions.TypeTable);
        if (tt) {
            return new type_table_1.TypeTable().runSyntax(node, input, qualifiedNamePrefix);
        }
        const found = new basic_types_1.BasicTypes(input).simpleType(node, qualifiedNamePrefix);
        if (found) {
            if ((found === null || found === void 0 ? void 0 : found.getType().isGeneric()) === true
                && (found === null || found === void 0 ? void 0 : found.getType().containsVoid()) === false) {
                const message = "TYPES definition cannot be generic, " + found.getName();
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return new _typed_identifier_1.TypedIdentifier(found.getToken(), input.filename, new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey));
            }
            if (input.scope.isGlobalOO() && found.getType() instanceof basic_1.PackedType) {
                const concat = node.concatTokens().toUpperCase();
                if ((concat.includes(" TYPE P ") || concat.includes(" TYPE P."))
                    && concat.includes(" DECIMALS ") === false) {
                    const message = "Specify DECIMALS in OO context for packed";
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new _typed_identifier_1.TypedIdentifier(found.getToken(), input.filename, new basic_1.VoidType(_syntax_input_1.CheckSyntaxKey));
                }
            }
            return found;
        }
        const fallback = node.findFirstExpression(Expressions.NamespaceSimpleName);
        if (fallback) {
            return new _typed_identifier_1.TypedIdentifier(fallback.getFirstToken(), input.filename, new basic_1.UnknownType("Type, fallback"));
        }
        return undefined;
    }
}
exports.Type = Type;
//# sourceMappingURL=type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unassign.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unassign.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unassign = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Unassign {
    runSyntax(node, input) {
        const target = node === null || node === void 0 ? void 0 : node.findDirectExpression(Expressions.TargetFieldSymbol);
        if (target) {
            const token = target.getFirstToken();
            const found = input.scope.findVariable(token.getStr());
            if (found === undefined) {
                const message = `"${token.getStr()}" not found, Unassign`;
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                return;
            }
            input.scope.addReference(token, found, _reference_1.ReferenceType.DataWriteReference, input.filename);
        }
    }
}
exports.Unassign = Unassign;
//# sourceMappingURL=unassign.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unpack.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unpack.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Unpack = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class Unpack {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(t, input);
        }
    }
}
exports.Unpack = Unpack;
//# sourceMappingURL=unpack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/update_database.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/update_database.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UpdateDatabase = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const identifier_1 = __webpack_require__(/*! ../../1_lexer/tokens/identifier */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js");
const database_table_1 = __webpack_require__(/*! ../expressions/database_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/database_table.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
class UpdateDatabase {
    runSyntax(node, input) {
        const dbtab = node.findFirstExpression(Expressions.DatabaseTable);
        if (dbtab !== undefined) {
            new database_table_1.DatabaseTable().runSyntax(dbtab, input);
        }
        const tableName = node.findDirectExpression(Expressions.DatabaseTable);
        const tokenName = tableName === null || tableName === void 0 ? void 0 : tableName.getFirstToken();
        if (tableName && tokenName) {
            // todo, this also finds structures, it should only find transparent tables
            const found = input.scope.getDDIC().lookupTable(tokenName.getStr());
            if (found instanceof basic_1.StructureType) {
                input.scope.push(_scope_type_1.ScopeType.OpenSQL, "UPDATE", tokenName.getStart(), input.filename);
                for (const field of found.getComponents()) {
                    const fieldToken = new identifier_1.Identifier(node.getFirstToken().getStart(), field.name);
                    const id = new _typed_identifier_1.TypedIdentifier(fieldToken, input.filename, field.type);
                    input.scope.addIdentifier(id);
                }
            }
        }
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SimpleSource3)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const d of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(d, input);
        }
        if (input.scope.getType() === _scope_type_1.ScopeType.OpenSQL) {
            input.scope.pop(node.getLastToken().getEnd());
        }
    }
}
exports.UpdateDatabase = UpdateDatabase;
//# sourceMappingURL=update_database.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/wait.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/wait.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Wait = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
class Wait {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const t of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(t, input);
        }
    }
}
exports.Wait = Wait;
//# sourceMappingURL=wait.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.When = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
class When {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
    }
}
exports.When = When;
//# sourceMappingURL=when.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when_type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when_type.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhenType = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const inline_data_1 = __webpack_require__(/*! ../expressions/inline_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/inline_data.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class WhenType {
    runSyntax(node, input) {
        var _a;
        const nameToken = (_a = node.findFirstExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (nameToken === undefined) {
            return undefined;
        }
        let type = undefined;
        const className = nameToken.getStr();
        const found = input.scope.findObjectDefinition(className);
        if (found === undefined && input.scope.getDDIC().inErrorNamespace(className) === false) {
            type = new basic_1.VoidType(className);
        }
        else if (found === undefined) {
            const message = "Class " + className + " not found";
            input.issues.push((0, _syntax_input_1.syntaxIssue)(input, nameToken, message));
            return;
        }
        else {
            type = new basic_1.ObjectReferenceType(found);
        }
        const target = node === null || node === void 0 ? void 0 : node.findDirectExpression(Expressions.Target);
        const inline = target === null || target === void 0 ? void 0 : target.findDirectExpression(Expressions.InlineData);
        if (inline) {
            new inline_data_1.InlineData().runSyntax(inline, input, type);
        }
        else if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.WhenType = WhenType;
//# sourceMappingURL=when_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/while.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/while.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.While = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const cond_1 = __webpack_require__(/*! ../expressions/cond */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/cond.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
class While {
    runSyntax(node, input) {
        for (const s of node.findDirectExpressions(Expressions.Cond)) {
            new cond_1.Cond().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            new source_1.Source().runSyntax(s, input);
        }
        for (const s of node.findDirectExpressions(Expressions.Target)) {
            new target_1.Target().runSyntax(s, input);
        }
    }
}
exports.While = While;
//# sourceMappingURL=while.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.With = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const select_1 = __webpack_require__(/*! ../expressions/select */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js");
const select_loop_1 = __webpack_require__(/*! ../expressions/select_loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select_loop.js");
class With {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Select)) {
            new select_1.Select().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SelectLoop)) {
            new select_loop_1.SelectLoop().runSyntax(s, input);
        }
    }
}
exports.With = With;
//# sourceMappingURL=with.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with_loop.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with_loop.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WithLoop = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const select_1 = __webpack_require__(/*! ../expressions/select */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select.js");
const select_loop_1 = __webpack_require__(/*! ../expressions/select_loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/select_loop.js");
class WithLoop {
    runSyntax(node, input) {
        for (const s of node.findAllExpressions(Expressions.Select)) {
            new select_1.Select().runSyntax(s, input);
        }
        for (const s of node.findAllExpressions(Expressions.SelectLoop)) {
            new select_loop_1.SelectLoop().runSyntax(s, input);
        }
    }
}
exports.WithLoop = WithLoop;
//# sourceMappingURL=with_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/write.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/write.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Write = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const source_1 = __webpack_require__(/*! ../expressions/source */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/source.js");
const target_1 = __webpack_require__(/*! ../expressions/target */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/target.js");
const dynamic_1 = __webpack_require__(/*! ../expressions/dynamic */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/dynamic.js");
const _type_utils_1 = __webpack_require__(/*! ../_type_utils */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_type_utils.js");
const field_chain_1 = __webpack_require__(/*! ../expressions/field_chain */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/field_chain.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Write {
    runSyntax(node, input) {
        // todo, more
        var _a;
        let second = node.getChildren()[1];
        if (second.get() instanceof Expressions.WriteOffsetLength) {
            second = node.getChildren()[2];
        }
        for (const s of node.findDirectExpressions(Expressions.Source)) {
            const type = new source_1.Source().runSyntax(s, input);
            if (s === second
                && new _type_utils_1.TypeUtils(input.scope).isCharLike(type) === false
                && new _type_utils_1.TypeUtils(input.scope).isHexLike(type) === false) {
                const message = "Source not character like";
                input.issues.push((0, _syntax_input_1.syntaxIssue)(input, s.getFirstToken(), message));
                return;
            }
        }
        for (const s of ((_a = node.findDirectExpression(Expressions.WriteOffsetLength)) === null || _a === void 0 ? void 0 : _a.findDirectExpressions(Expressions.SimpleFieldChain2)) || []) {
            new field_chain_1.FieldChain().runSyntax(s, input, _reference_1.ReferenceType.DataReadReference);
        }
        for (const s of node.findAllExpressions(Expressions.Dynamic)) {
            new dynamic_1.Dynamic().runSyntax(s, input);
        }
        const target = node.findDirectExpression(Expressions.Target);
        if (target) {
            new target_1.Target().runSyntax(target, input);
        }
    }
}
exports.Write = Write;
//# sourceMappingURL=write.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/class_data.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/class_data.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassData = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const class_data_1 = __webpack_require__(/*! ../statements/class_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_data.js");
class ClassData {
    runSyntax(node, input) {
        const name = node.findFirstExpression(Expressions.NamespaceSimpleName).getFirstToken();
        const values = {};
        const components = [];
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.ClassData) {
                const found = new class_data_1.ClassData().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                    values[found.getName()] = found.getValue();
                }
            }
            // todo, nested structures and INCLUDES
        }
        return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.StructureType(components), ["static" /* IdentifierMeta.Static */], values);
    }
}
exports.ClassData = ClassData;
//# sourceMappingURL=class_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/constants.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/constants.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Constants = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const constant_1 = __webpack_require__(/*! ../statements/constant */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/constant.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class Constants {
    runSyntax(node, input) {
        var _a;
        const name = (_a = node.findFirstExpression(Expressions.DefinitionName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (name === undefined) {
            throw new assert_error_1.AssertError("Constants, structure, unexpected node");
        }
        const components = [];
        const values = {};
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.Constant) {
                const found = new constant_1.Constant().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                    values[found.getName()] = found.getValue();
                }
            }
            else if (c instanceof nodes_1.StructureNode && ctyp instanceof Structures.Constants) {
                const { type: found, values: val } = new Constants().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                    values[found.getName()] = val;
                }
            }
        }
        if (components.length === 0) {
            return { type: undefined, values };
        }
        const type = new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.StructureType(components), ["read_only" /* IdentifierMeta.ReadOnly */, "static" /* IdentifierMeta.Static */]);
        return { type, values };
    }
}
exports.Constants = Constants;
//# sourceMappingURL=constants.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/data.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/data.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Data = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const data_1 = __webpack_require__(/*! ../statements/data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/data.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class Data {
    runSyntax(node, input) {
        var _a;
        const name = node.findFirstExpression(Expressions.DefinitionName).getFirstToken();
        let table = false;
        const values = {};
        const components = [];
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.Data) {
                const found = new data_1.Data().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                    if (found.getValue() !== undefined) {
                        values[found.getName()] = found.getValue();
                    }
                }
            }
            else if (c instanceof nodes_1.StructureNode && ctyp instanceof Structures.Data) {
                const found = new Data().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                }
            }
            else if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.DataBegin) {
                if (c.findDirectTokenByText("OCCURS")) {
                    table = true;
                }
            }
            else if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.IncludeType) {
                // INCLUDES
                const typeToken = (_a = c.findFirstExpression(Expressions.TypeName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                const typeName = typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStr();
                let foundId = input.scope.findType(typeName);
                if (foundId === undefined) {
                    foundId = input.scope.findVariable(typeName);
                }
                let found = foundId === null || foundId === void 0 ? void 0 : foundId.getType();
                if (found === undefined) {
                    const f = input.scope.getDDIC().lookupTableOrView(typeName).type;
                    if (f instanceof _typed_identifier_1.TypedIdentifier) {
                        found = f.getType();
                    }
                    else {
                        found = f;
                    }
                }
                else {
                    input.scope.addReference(typeToken, foundId, _reference_1.ReferenceType.TypeReference, input.filename);
                }
                if (found instanceof Basic.VoidType) {
                    if (table === true) {
                        const ttyp = new Basic.TableType(found, { withHeader: true, keyType: Basic.TableKeyType.default });
                        return new _typed_identifier_1.TypedIdentifier(name, input.filename, ttyp);
                    }
                    else {
                        return new _typed_identifier_1.TypedIdentifier(name, input.filename, found);
                    }
                }
                if (found instanceof Basic.UnknownType) {
                    return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.UnknownType("unknown type, " + typeName));
                }
                if (!(found instanceof Basic.StructureType)) {
                    const message = "not structured, " + typeName;
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, typeToken, message));
                    return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.VoidType(_syntax_input_1.CheckSyntaxKey));
                }
                for (const c of found.getComponents()) {
                    components.push(c);
                }
            }
        }
        if (table === true) {
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.TableType(new Basic.StructureType(components), { withHeader: true, keyType: Basic.TableKeyType.default }));
        }
        else {
            const val = Object.keys(values).length > 0 ? values : undefined;
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.StructureType(components), undefined, val);
        }
    }
}
exports.Data = Data;
//# sourceMappingURL=data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/statics.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/statics.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Statics = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const static_1 = __webpack_require__(/*! ../statements/static */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/static.js");
const _syntax_input_1 = __webpack_require__(/*! ../_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
// todo, this is much like DATA, refactor?
class Statics {
    runSyntax(node, input) {
        var _a, _b;
        const name = node.findFirstExpression(Expressions.DefinitionName).getFirstToken();
        let table = false;
        const components = [];
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.Static) {
                const found = new static_1.Static().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                }
            }
            else if (c instanceof nodes_1.StructureNode && ctyp instanceof Structures.Statics) {
                const found = new Statics().runSyntax(c, input);
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                }
            }
            else if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.StaticBegin) {
                if (c.findDirectTokenByText("OCCURS")) {
                    table = true;
                }
            }
            else if (c instanceof nodes_1.StatementNode && ctyp instanceof Statements.IncludeType) {
                // INCLUDES
                const typeName = (_a = c.findFirstExpression(Expressions.TypeName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr();
                let found = (_b = input.scope.findType(typeName)) === null || _b === void 0 ? void 0 : _b.getType();
                if (found === undefined) {
                    const f = input.scope.getDDIC().lookupTableOrView(typeName).type;
                    if (f instanceof _typed_identifier_1.TypedIdentifier) {
                        found = f.getType();
                    }
                    else {
                        found = f;
                    }
                }
                if (found instanceof Basic.VoidType) {
                    if (table === true) {
                        const ttyp = new Basic.TableType(found, { withHeader: true, keyType: Basic.TableKeyType.default });
                        return new _typed_identifier_1.TypedIdentifier(name, input.filename, ttyp);
                    }
                    else {
                        return new _typed_identifier_1.TypedIdentifier(name, input.filename, found);
                    }
                }
                if (found instanceof Basic.UnknownType) {
                    return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.UnknownType("unknown type, " + typeName));
                }
                if (!(found instanceof Basic.StructureType)) {
                    const message = "not structured, " + typeName;
                    input.issues.push((0, _syntax_input_1.syntaxIssue)(input, node.getFirstToken(), message));
                    return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.VoidType(_syntax_input_1.CheckSyntaxKey));
                }
                for (const c of found.getComponents()) {
                    components.push(c);
                }
            }
        }
        if (table === true) {
            const ttyp = new Basic.TableType(new Basic.StructureType(components), { withHeader: true, keyType: Basic.TableKeyType.default });
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, ttyp);
        }
        else {
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.StructureType(components));
        }
    }
}
exports.Statics = Statics;
//# sourceMappingURL=statics.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/type_enum.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/type_enum.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeEnum = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _reference_1 = __webpack_require__(/*! ../_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const enum_type_1 = __webpack_require__(/*! ../../types/basic/enum_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/enum_type.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const assert_error_1 = __webpack_require__(/*! ../assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
class TypeEnum {
    runSyntax(node, input) {
        var _a;
        let values = [];
        const types = [];
        if (!(node.get() instanceof Structures.TypeEnum)) {
            throw new assert_error_1.AssertError("TypeEnum, unexpected type");
        }
        const begin = node.findDirectStatement(Statements.TypeEnumBegin);
        if (begin === undefined) {
            throw new assert_error_1.AssertError("TypeEnum, unexpected type, begin");
        }
        for (const type of node.findDirectStatements(Statements.Type)) {
            const expr = type.findFirstExpression(Expressions.NamespaceSimpleName);
            if (expr === undefined) {
                continue;
            }
            const token = expr.getFirstToken();
            // integer is default if BASE TYPE is not specified
            values.push(new _typed_identifier_1.TypedIdentifier(token, input.filename, basic_1.IntegerType.get()));
        }
        for (const type of node.findDirectStatements(Statements.TypeEnum)) {
            const expr = type.findFirstExpression(Expressions.NamespaceSimpleName);
            if (expr === undefined) {
                continue;
            }
            const token = expr.getFirstToken();
            // integer is default if BASE TYPE is not specified
            values.push(new _typed_identifier_1.TypedIdentifier(token, input.filename, basic_1.IntegerType.get()));
        }
        const baseType = (_a = begin.findExpressionAfterToken("TYPE")) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        const baseName = baseType === null || baseType === void 0 ? void 0 : baseType.getStr();
        if (baseType && baseName) {
            const found = input.scope.findType(baseName);
            if (found) {
                input.scope.addReference(baseType, found, _reference_1.ReferenceType.TypeReference, input.filename);
            }
        }
        const name = begin.findFirstExpression(Expressions.NamespaceSimpleName);
        if (name) {
            let qualifiedName = name.concatTokens();
            if (input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition
                || input.scope.getType() === _scope_type_1.ScopeType.Interface) {
                qualifiedName = input.scope.getName() + "=>" + qualifiedName;
            }
            const etype = new enum_type_1.EnumType({ qualifiedName: qualifiedName });
            const id = new _typed_identifier_1.TypedIdentifier(name.getFirstToken(), input.filename, etype, ["enum" /* IdentifierMeta.Enum */]);
            input.scope.addType(id);
            types.push(id);
        }
        const stru = begin.findExpressionAfterToken("STRUCTURE");
        if (stru) {
            const components = [];
            for (const r of values) {
                components.push({
                    name: r.getName(),
                    type: r.getType(),
                });
            }
            values = [];
            const id = new _typed_identifier_1.TypedIdentifier(stru.getFirstToken(), input.filename, new basic_1.StructureType(components), ["enum" /* IdentifierMeta.Enum */]);
            values.push(id);
        }
        return { values, types };
    }
}
exports.TypeEnum = TypeEnum;
//# sourceMappingURL=type_enum.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/types.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/types.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Types = void 0;
const Expressions = __webpack_require__(/*! ../../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const nodes_1 = __webpack_require__(/*! ../../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../../types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const include_type_1 = __webpack_require__(/*! ../statements/include_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/include_type.js");
const type_1 = __webpack_require__(/*! ../statements/type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/type.js");
const Basic = __webpack_require__(/*! ../../types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _scope_type_1 = __webpack_require__(/*! ../_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class Types {
    runSyntax(node, input, qualifiedNamePrefix) {
        const name = node.findFirstExpression(Expressions.NamespaceSimpleName).getFirstToken();
        const components = [];
        let voidd = undefined;
        if (qualifiedNamePrefix === undefined) {
            qualifiedNamePrefix = "";
        }
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StatementNode) {
                if (ctyp instanceof Statements.Type) {
                    const found = new type_1.Type().runSyntax(c, input, qualifiedNamePrefix + name.getStr() + "-");
                    if (found) {
                        components.push({ name: found.getName(), type: found.getType() });
                    }
                }
                else if (ctyp instanceof Statements.IncludeType) {
                    const found = new include_type_1.IncludeType().runSyntax(c, input);
                    if (found instanceof basic_1.VoidType) {
                        voidd = found;
                    }
                    else {
                        components.push(...found);
                    }
                }
            }
            else if (c instanceof nodes_1.StructureNode && ctyp instanceof Structures.Types) {
                const found = new Types().runSyntax(c, input, qualifiedNamePrefix + name.getStr() + "-");
                if (found) {
                    components.push({ name: found.getName(), type: found.getType() });
                }
            }
        }
        if (voidd) {
            return new _typed_identifier_1.TypedIdentifier(name, input.filename, voidd);
        }
        else if (components.length === 0) { // todo, remove this check
            return undefined;
        }
        let qualifiedName = qualifiedNamePrefix + name.getStr();
        if (input.scope.getType() === _scope_type_1.ScopeType.ClassDefinition
            || input.scope.getType() === _scope_type_1.ScopeType.Interface) {
            qualifiedName = input.scope.getName() + "=>" + qualifiedName;
        }
        return new _typed_identifier_1.TypedIdentifier(name, input.filename, new Basic.StructureType(components, qualifiedName));
    }
}
exports.Types = Types;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyntaxLogic = void 0;
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const issue_1 = __webpack_require__(/*! ../../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _current_scope_1 = __webpack_require__(/*! ./_current_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js");
const _scope_type_1 = __webpack_require__(/*! ./_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _object_oriented_1 = __webpack_require__(/*! ./_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _procedural_1 = __webpack_require__(/*! ./_procedural */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_procedural.js");
const objects_1 = __webpack_require__(/*! ../../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../../position */ "./node_modules/@abaplint/core/build/src/position.js");
const data_1 = __webpack_require__(/*! ./structures/data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/data.js");
const type_enum_1 = __webpack_require__(/*! ./structures/type_enum */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/type_enum.js");
const types_1 = __webpack_require__(/*! ./structures/types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/types.js");
const statics_1 = __webpack_require__(/*! ./structures/statics */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/statics.js");
const constants_1 = __webpack_require__(/*! ./structures/constants */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/constants.js");
const class_definition_1 = __webpack_require__(/*! ../types/class_definition */ "./node_modules/@abaplint/core/build/src/abap/types/class_definition.js");
const interface_definition_1 = __webpack_require__(/*! ../types/interface_definition */ "./node_modules/@abaplint/core/build/src/abap/types/interface_definition.js");
const perform_1 = __webpack_require__(/*! ./statements/perform */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/perform.js");
const type_1 = __webpack_require__(/*! ./statements/type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/type.js");
const constant_1 = __webpack_require__(/*! ./statements/constant */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/constant.js");
const static_1 = __webpack_require__(/*! ./statements/static */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/static.js");
const search_1 = __webpack_require__(/*! ./statements/search */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/search.js");
const translate_1 = __webpack_require__(/*! ./statements/translate */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/translate.js");
const modify_internal_1 = __webpack_require__(/*! ./statements/modify_internal */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_internal.js");
const data_2 = __webpack_require__(/*! ./statements/data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/data.js");
const parameter_1 = __webpack_require__(/*! ./statements/parameter */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/parameter.js");
const fieldsymbol_1 = __webpack_require__(/*! ./statements/fieldsymbol */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/fieldsymbol.js");
const tables_1 = __webpack_require__(/*! ./statements/tables */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/tables.js");
const selectoption_1 = __webpack_require__(/*! ./statements/selectoption */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selectoption.js");
const interface_deferred_1 = __webpack_require__(/*! ./statements/interface_deferred */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/interface_deferred.js");
const class_deferred_1 = __webpack_require__(/*! ./statements/class_deferred */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_deferred.js");
const call_1 = __webpack_require__(/*! ./statements/call */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call.js");
const class_implementation_1 = __webpack_require__(/*! ./statements/class_implementation */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_implementation.js");
const method_implementation_1 = __webpack_require__(/*! ./statements/method_implementation */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/method_implementation.js");
const move_1 = __webpack_require__(/*! ./statements/move */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move.js");
const move_corresponding_1 = __webpack_require__(/*! ./statements/move_corresponding */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/move_corresponding.js");
const catch_1 = __webpack_require__(/*! ./statements/catch */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/catch.js");
const loop_1 = __webpack_require__(/*! ./statements/loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop.js");
const read_table_1 = __webpack_require__(/*! ./statements/read_table */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_table.js");
const select_1 = __webpack_require__(/*! ./statements/select */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select.js");
const insert_internal_1 = __webpack_require__(/*! ./statements/insert_internal */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_internal.js");
const split_1 = __webpack_require__(/*! ./statements/split */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/split.js");
const assign_1 = __webpack_require__(/*! ./statements/assign */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assign.js");
const convert_1 = __webpack_require__(/*! ./statements/convert */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/convert.js");
const describe_1 = __webpack_require__(/*! ./statements/describe */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/describe.js");
const read_textpool_1 = __webpack_require__(/*! ./statements/read_textpool */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_textpool.js");
const find_1 = __webpack_require__(/*! ./statements/find */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/find.js");
const message_1 = __webpack_require__(/*! ./statements/message */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/message.js");
const get_time_1 = __webpack_require__(/*! ./statements/get_time */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_time.js");
const get_parameter_1 = __webpack_require__(/*! ./statements/get_parameter */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_parameter.js");
const when_type_1 = __webpack_require__(/*! ./statements/when_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when_type.js");
const if_1 = __webpack_require__(/*! ./statements/if */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/if.js");
const else_if_1 = __webpack_require__(/*! ./statements/else_if */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/else_if.js");
const append_1 = __webpack_require__(/*! ./statements/append */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/append.js");
const selection_screen_1 = __webpack_require__(/*! ./statements/selection_screen */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/selection_screen.js");
const ranges_1 = __webpack_require__(/*! ./statements/ranges */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/ranges.js");
const write_1 = __webpack_require__(/*! ./statements/write */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/write.js");
const case_1 = __webpack_require__(/*! ./statements/case */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case.js");
const case_type_1 = __webpack_require__(/*! ./statements/case_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/case_type.js");
const create_object_1 = __webpack_require__(/*! ./statements/create_object */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_object.js");
const do_1 = __webpack_require__(/*! ./statements/do */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/do.js");
const concatenate_1 = __webpack_require__(/*! ./statements/concatenate */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/concatenate.js");
const call_function_1 = __webpack_require__(/*! ./statements/call_function */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_function.js");
const clear_1 = __webpack_require__(/*! ./statements/clear */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/clear.js");
const replace_1 = __webpack_require__(/*! ./statements/replace */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/replace.js");
const get_bit_1 = __webpack_require__(/*! ./statements/get_bit */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_bit.js");
const raise_1 = __webpack_require__(/*! ./statements/raise */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise.js");
const delete_internal_1 = __webpack_require__(/*! ./statements/delete_internal */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_internal.js");
const receive_1 = __webpack_require__(/*! ./statements/receive */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/receive.js");
const when_1 = __webpack_require__(/*! ./statements/when */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/when.js");
const create_data_1 = __webpack_require__(/*! ./statements/create_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/create_data.js");
const call_transformation_1 = __webpack_require__(/*! ./statements/call_transformation */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transformation.js");
const get_locale_1 = __webpack_require__(/*! ./statements/get_locale */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_locale.js");
const set_locale_1 = __webpack_require__(/*! ./statements/set_locale */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_locale.js");
const sort_1 = __webpack_require__(/*! ./statements/sort */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/sort.js");
const read_report_1 = __webpack_require__(/*! ./statements/read_report */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_report.js");
const authority_check_1 = __webpack_require__(/*! ./statements/authority_check */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/authority_check.js");
const insert_report_1 = __webpack_require__(/*! ./statements/insert_report */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_report.js");
const get_reference_1 = __webpack_require__(/*! ./statements/get_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_reference.js");
const insert_database_1 = __webpack_require__(/*! ./statements/insert_database */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_database.js");
const delete_database_1 = __webpack_require__(/*! ./statements/delete_database */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_database.js");
const import_dynpro_1 = __webpack_require__(/*! ./statements/import_dynpro */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import_dynpro.js");
const syntax_check_1 = __webpack_require__(/*! ./statements/syntax_check */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/syntax_check.js");
const import_1 = __webpack_require__(/*! ./statements/import */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/import.js");
const export_1 = __webpack_require__(/*! ./statements/export */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/export.js");
const scan_1 = __webpack_require__(/*! ./statements/scan */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/scan.js");
const submit_1 = __webpack_require__(/*! ./statements/submit */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/submit.js");
const open_dataset_1 = __webpack_require__(/*! ./statements/open_dataset */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/open_dataset.js");
const close_dataset_1 = __webpack_require__(/*! ./statements/close_dataset */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/close_dataset.js");
const get_run_time_1 = __webpack_require__(/*! ./statements/get_run_time */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_run_time.js");
const update_database_1 = __webpack_require__(/*! ./statements/update_database */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/update_database.js");
const add_1 = __webpack_require__(/*! ./statements/add */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add.js");
const editor_call_1 = __webpack_require__(/*! ./statements/editor_call */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/editor_call.js");
const subtract_1 = __webpack_require__(/*! ./statements/subtract */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract.js");
const add_corresponding_1 = __webpack_require__(/*! ./statements/add_corresponding */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/add_corresponding.js");
const subtract_corresponding_1 = __webpack_require__(/*! ./statements/subtract_corresponding */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/subtract_corresponding.js");
const multiply_1 = __webpack_require__(/*! ./statements/multiply */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/multiply.js");
const divide_1 = __webpack_require__(/*! ./statements/divide */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/divide.js");
const condense_1 = __webpack_require__(/*! ./statements/condense */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/condense.js");
const controls_1 = __webpack_require__(/*! ./statements/controls */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/controls.js");
const while_1 = __webpack_require__(/*! ./statements/while */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/while.js");
const select_loop_1 = __webpack_require__(/*! ./statements/select_loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/select_loop.js");
const check_1 = __webpack_require__(/*! ./statements/check */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/check.js");
const log_point_1 = __webpack_require__(/*! ./statements/log_point */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/log_point.js");
const severity_1 = __webpack_require__(/*! ../../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
const raise_event_1 = __webpack_require__(/*! ./statements/raise_event */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/raise_event.js");
const form_1 = __webpack_require__(/*! ./statements/form */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/form.js");
const assert_1 = __webpack_require__(/*! ./statements/assert */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/assert.js");
const set_parameter_1 = __webpack_require__(/*! ./statements/set_parameter */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_parameter.js");
const class_local_friends_1 = __webpack_require__(/*! ./statements/class_local_friends */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_local_friends.js");
const get_badi_1 = __webpack_require__(/*! ./statements/get_badi */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_badi.js");
const with_1 = __webpack_require__(/*! ./statements/with */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with.js");
const with_loop_1 = __webpack_require__(/*! ./statements/with_loop */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/with_loop.js");
const system_call_1 = __webpack_require__(/*! ./statements/system_call */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/system_call.js");
const collect_1 = __webpack_require__(/*! ./statements/collect */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/collect.js");
const transfer_1 = __webpack_require__(/*! ./statements/transfer */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/transfer.js");
const modify_database_1 = __webpack_require__(/*! ./statements/modify_database */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_database.js");
const truncate_dataset_1 = __webpack_require__(/*! ./statements/truncate_dataset */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/truncate_dataset.js");
const call_badi_1 = __webpack_require__(/*! ./statements/call_badi */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_badi.js");
const call_kernel_1 = __webpack_require__(/*! ./statements/call_kernel */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_kernel.js");
const pack_1 = __webpack_require__(/*! ./statements/pack */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/pack.js");
const unpack_1 = __webpack_require__(/*! ./statements/unpack */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unpack.js");
const format_1 = __webpack_require__(/*! ./statements/format */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/format.js");
const set_pf_status_1 = __webpack_require__(/*! ./statements/set_pf_status */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_pf_status.js");
const set_titlebar_1 = __webpack_require__(/*! ./statements/set_titlebar */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_titlebar.js");
const call_transaction_1 = __webpack_require__(/*! ./statements/call_transaction */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/call_transaction.js");
const set_handler_1 = __webpack_require__(/*! ./statements/set_handler */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_handler.js");
const wait_1 = __webpack_require__(/*! ./statements/wait */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/wait.js");
const delete_report_1 = __webpack_require__(/*! ./statements/delete_report */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_report.js");
const shift_1 = __webpack_require__(/*! ./statements/shift */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/shift.js");
const set_bit_1 = __webpack_require__(/*! ./statements/set_bit */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/set_bit.js");
const modify_screen_1 = __webpack_require__(/*! ./statements/modify_screen */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_screen.js");
const delete_cluster_1 = __webpack_require__(/*! ./statements/delete_cluster */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/delete_cluster.js");
const unassign_1 = __webpack_require__(/*! ./statements/unassign */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/unassign.js");
const insert_textpool_1 = __webpack_require__(/*! ./statements/insert_textpool */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_textpool.js");
const get_cursor_1 = __webpack_require__(/*! ./statements/get_cursor */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/get_cursor.js");
const loop_at_screen_1 = __webpack_require__(/*! ./statements/loop_at_screen */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/loop_at_screen.js");
const insert_field_group_1 = __webpack_require__(/*! ./statements/insert_field_group */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/insert_field_group.js");
const read_entities_1 = __webpack_require__(/*! ./statements/read_entities */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/read_entities.js");
const modify_entities_1 = __webpack_require__(/*! ./statements/modify_entities */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/modify_entities.js");
const commit_entities_1 = __webpack_require__(/*! ./statements/commit_entities */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/commit_entities.js");
const _syntax_input_1 = __webpack_require__(/*! ./_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
const assert_error_1 = __webpack_require__(/*! ./assert_error */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/assert_error.js");
// -----------------------------------
const map = {};
function addToMap(handler) {
    if (map[handler.constructor.name] !== undefined) {
        throw new assert_error_1.AssertError("syntax.ts duplicate statement syntax handler");
    }
    map[handler.constructor.name] = handler;
}
if (Object.keys(map).length === 0) {
    addToMap(new interface_deferred_1.InterfaceDeferred());
    addToMap(new perform_1.Perform());
    addToMap(new class_deferred_1.ClassDeferred());
    addToMap(new call_1.Call());
    addToMap(new set_handler_1.SetHandler());
    addToMap(new class_implementation_1.ClassImplementation());
    addToMap(new method_implementation_1.MethodImplementation());
    addToMap(new move_1.Move());
    addToMap(new get_badi_1.GetBadi());
    addToMap(new call_badi_1.CallBadi());
    addToMap(new get_cursor_1.GetCursor());
    addToMap(new replace_1.Replace());
    addToMap(new truncate_dataset_1.TruncateDataset());
    addToMap(new assert_1.Assert());
    addToMap(new catch_1.Catch());
    addToMap(new loop_1.Loop());
    addToMap(new loop_at_screen_1.LoopAtScreen());
    addToMap(new set_pf_status_1.SetPFStatus());
    addToMap(new set_titlebar_1.SetTitlebar());
    addToMap(new submit_1.Submit());
    addToMap(new insert_textpool_1.InsertTextpool());
    addToMap(new read_table_1.ReadTable());
    addToMap(new syntax_check_1.SyntaxCheck());
    addToMap(new delete_report_1.DeleteReport());
    addToMap(new import_1.Import());
    addToMap(new collect_1.Collect());
    addToMap(new export_1.Export());
    addToMap(new scan_1.Scan());
    addToMap(new transfer_1.Transfer());
    addToMap(new split_1.Split());
    addToMap(new call_function_1.CallFunction());
    addToMap(new delete_internal_1.DeleteInternal());
    addToMap(new delete_cluster_1.DeleteCluster());
    addToMap(new clear_1.Clear());
    addToMap(new receive_1.Receive());
    addToMap(new get_bit_1.GetBit());
    addToMap(new class_local_friends_1.ClassLocalFriends());
    addToMap(new select_1.Select());
    addToMap(new modify_screen_1.ModifyScreen());
    addToMap(new insert_internal_1.InsertInternal());
    addToMap(new pack_1.Pack());
    addToMap(new unpack_1.Unpack());
    addToMap(new assign_1.Assign());
    addToMap(new set_locale_1.SetLocale());
    addToMap(new set_parameter_1.SetParameter());
    addToMap(new convert_1.Convert());
    addToMap(new controls_1.Controls());
    addToMap(new when_1.When());
    addToMap(new insert_database_1.InsertDatabase());
    addToMap(new delete_database_1.DeleteDatabase());
    addToMap(new update_database_1.UpdateDatabase());
    addToMap(new sort_1.Sort());
    addToMap(new wait_1.Wait());
    addToMap(new condense_1.Condense());
    addToMap(new set_bit_1.SetBit());
    addToMap(new open_dataset_1.OpenDataset());
    addToMap(new close_dataset_1.CloseDataset());
    addToMap(new read_report_1.ReadReport());
    addToMap(new do_1.Do());
    addToMap(new describe_1.Describe());
    addToMap(new find_1.Find());
    addToMap(new message_1.Message());
    addToMap(new system_call_1.SystemCall());
    addToMap(new insert_field_group_1.InsertFieldGroup());
    addToMap(new get_time_1.GetTime());
    addToMap(new unassign_1.Unassign());
    addToMap(new case_type_1.CaseType());
    addToMap(new get_parameter_1.GetParameter());
    addToMap(new format_1.Format());
    addToMap(new when_type_1.WhenType());
    addToMap(new if_1.If());
    addToMap(new log_point_1.LogPoint());
    addToMap(new while_1.While());
    addToMap(new with_1.With());
    addToMap(new with_loop_1.WithLoop());
    addToMap(new call_transformation_1.CallTransformation());
    addToMap(new call_transaction_1.CallTransaction());
    addToMap(new get_locale_1.GetLocale());
    addToMap(new get_reference_1.GetReference());
    addToMap(new else_if_1.ElseIf());
    addToMap(new get_run_time_1.GetRunTime());
    addToMap(new create_object_1.CreateObject());
    addToMap(new import_dynpro_1.ImportDynpro());
    addToMap(new create_data_1.CreateData());
    addToMap(new case_1.Case());
    addToMap(new shift_1.Shift());
    addToMap(new raise_1.Raise());
    addToMap(new concatenate_1.Concatenate());
    addToMap(new append_1.Append());
    addToMap(new select_loop_1.SelectLoop());
    addToMap(new write_1.Write());
    addToMap(new move_corresponding_1.MoveCorresponding());
    addToMap(new authority_check_1.AuthorityCheck());
    addToMap(new insert_report_1.InsertReport());
    addToMap(new selection_screen_1.SelectionScreen());
    addToMap(new ranges_1.Ranges());
    addToMap(new add_1.Add());
    addToMap(new raise_event_1.RaiseEvent());
    addToMap(new subtract_1.Subtract());
    addToMap(new add_corresponding_1.AddCorresponding());
    addToMap(new subtract_corresponding_1.SubtractCorresponding());
    addToMap(new multiply_1.Multiply());
    addToMap(new divide_1.Divide());
    addToMap(new check_1.Check());
    addToMap(new modify_database_1.ModifyDatabase());
    addToMap(new form_1.Form());
    addToMap(new selectoption_1.SelectOption());
    addToMap(new tables_1.Tables());
    addToMap(new parameter_1.Parameter());
    addToMap(new fieldsymbol_1.FieldSymbol());
    addToMap(new read_entities_1.ReadEntities());
    addToMap(new modify_entities_1.ModifyEntities());
    addToMap(new commit_entities_1.CommitEntities());
    addToMap(new call_kernel_1.CallKernel());
    addToMap(new search_1.Search());
    addToMap(new translate_1.Translate());
    addToMap(new modify_internal_1.ModifyInternal());
    addToMap(new read_textpool_1.ReadTextpool());
    addToMap(new editor_call_1.EditorCall());
}
// -----------------------------------
class SyntaxLogic {
    constructor(reg, object) {
        this.reg = reg;
        this.issues = [];
        this.object = object;
        this.scope = _current_scope_1.CurrentScope.buildDefault(this.reg, object);
        this.helpers = {
            oooc: new _object_oriented_1.ObjectOriented(this.scope),
            proc: new _procedural_1.Procedural(this.reg, this.scope),
        };
    }
    run() {
        if (this.object.syntaxResult !== undefined) {
            return this.object.syntaxResult;
        }
        this.issues = [];
        this.reg.getDDICReferences().clear(this.object);
        this.reg.getMSAGReferences().clear(this.object);
        if (this.object instanceof objects_1.Program && this.object.isInclude()) {
            // todo, show some kind of error?
            return { issues: [], spaghetti: this.scope.pop(new position_1.Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)) };
        }
        this.traverseObject();
        for (;;) {
            const spaghetti = this.scope.pop(new position_1.Position(Number.MAX_SAFE_INTEGER, Number.MAX_SAFE_INTEGER)); // pop built-in scopes
            if (spaghetti.getTop().getIdentifier().stype === _scope_type_1.ScopeType.BuiltIn) {
                const result = { issues: this.issues, spaghetti };
                this.object.syntaxResult = result;
                return result;
            }
        }
    }
    /////////////////////////////
    traverseObject() {
        const traversal = this.object.getSequencedFiles();
        if (this.object instanceof objects_1.Program
            || this.object instanceof objects_1.FunctionGroup) {
            for (const f of this.object.getSequencedFiles()) {
                // add FORM defintions to the _global object scope
                this.helpers.proc.addAllFormDefinitions(f, this.object);
            }
            const main = this.object.getMainABAPFile();
            if (main !== undefined) {
                let stype = _scope_type_1.ScopeType.Program;
                if (this.object instanceof objects_1.FunctionGroup) {
                    stype = _scope_type_1.ScopeType.FunctionGroup;
                }
                this.scope.push(stype, this.object.getName(), new position_1.Position(1, 1), main.getFilename());
            }
        }
        else if (this.object instanceof objects_1.TypePool) {
            const main = this.object.getMainABAPFile();
            if (main !== undefined) {
                this.scope.push(_scope_type_1.ScopeType.TypePool, this.object.getName(), new position_1.Position(1, 1), main.getFilename());
            }
        }
        for (const file of traversal) {
            this.currentFile = file;
            const structure = this.currentFile.getStructure();
            if (structure === undefined) {
                return this.scope;
            }
            else {
                this.traverse(structure);
            }
        }
        return this.scope;
    }
    newIssue(token, message) {
        const issue = issue_1.Issue.atToken(this.currentFile, token, message, _syntax_input_1.CheckSyntaxKey, severity_1.Severity.Error);
        this.issues.push(issue);
    }
    traverse(node) {
        for (const child of node.getChildren()) {
            const isStructure = child instanceof nodes_1.StructureNode;
            const isStatement = child instanceof nodes_1.StatementNode;
            try {
                if (isStructure) {
                    const gotoNext = this.updateScopeStructure(child);
                    if (gotoNext === true) {
                        continue;
                    }
                }
                else if (isStatement) {
                    this.updateScopeStatement(child);
                }
            }
            catch (e) {
                this.newIssue(child.getFirstToken(), e.message);
                break;
            }
            // walk into INCLUDEs
            if (isStatement && child.get() instanceof Statements.Include) {
                const file = this.helpers.proc.findInclude(child, this.object);
                if (file !== undefined && file.getStructure() !== undefined) {
                    const old = this.currentFile;
                    this.currentFile = file;
                    this.traverse(file.getStructure());
                    this.currentFile = old;
                }
            }
            if (isStructure || isStatement) {
                this.traverse(child);
            }
        }
    }
    /**
     * if this returns true, then the traversal should continue with next child
     */
    updateScopeStructure(node) {
        const filename = this.currentFile.getFilename();
        const stru = node.get();
        const input = {
            scope: this.scope,
            filename,
            issues: this.issues,
        };
        if (stru instanceof Structures.ClassDefinition) {
            new class_definition_1.ClassDefinition(node, input);
            return true;
        }
        else if (stru instanceof Structures.Interface) {
            new interface_definition_1.InterfaceDefinition(node, input);
            return true;
        }
        else if (stru instanceof Structures.Types) {
            this.scope.addType(new types_1.Types().runSyntax(node, input));
            return true;
        }
        else if (stru instanceof Structures.Constants) {
            this.scope.addIdentifier(new constants_1.Constants().runSyntax(node, input).type);
            return true;
        }
        else if (stru instanceof Structures.Data) {
            this.scope.addIdentifier(new data_1.Data().runSyntax(node, input));
            return true;
        }
        else if (stru instanceof Structures.Statics) {
            this.scope.addIdentifier(new statics_1.Statics().runSyntax(node, input));
            return true;
        }
        else if (stru instanceof Structures.TypeEnum) {
            const values = new type_enum_1.TypeEnum().runSyntax(node, input).values;
            this.scope.addList(values);
            return true;
        }
        return false;
    }
    updateScopeStatement(node) {
        const filename = this.currentFile.getFilename();
        const s = node.get();
        const input = {
            scope: this.scope,
            filename,
            issues: this.issues,
        };
        // todo, refactor
        if (s instanceof Statements.Type) {
            this.scope.addType(new type_1.Type().runSyntax(node, input));
            return;
        }
        else if (s instanceof Statements.Constant) {
            this.scope.addIdentifier(new constant_1.Constant().runSyntax(node, input));
            return;
        }
        else if (s instanceof Statements.Static) {
            this.scope.addIdentifier(new static_1.Static().runSyntax(node, input));
            return;
        }
        else if (s instanceof Statements.Data) {
            this.scope.addIdentifier(new data_2.Data().runSyntax(node, input));
            return;
        }
        const name = s.constructor.name;
        if (map[name]) {
            map[name].runSyntax(node, input);
            return;
        }
        if (s instanceof Statements.FunctionModule) {
            this.helpers.proc.findFunctionScope(this.object, node, filename);
        }
        else if (s instanceof Statements.EndForm
            || s instanceof Statements.EndFunction
            || s instanceof Statements.EndClass
            || s instanceof Statements.EndInterface) {
            this.scope.pop(node.getLastToken().getEnd());
        }
        else if (s instanceof Statements.EndMethod) {
            if (this.scope.getType() === _scope_type_1.ScopeType.Method) {
                this.scope.pop(node.getLastToken().getEnd());
            }
            if (this.scope.getType() === _scope_type_1.ScopeType.MethodInstance) {
                this.scope.pop(node.getLastToken().getEnd());
            }
        }
    }
}
exports.SyntaxLogic = SyntaxLogic;
//# sourceMappingURL=syntax.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/abap_file.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/abap_file.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPFile = void 0;
const tokens_1 = __webpack_require__(/*! ./1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _abstract_file_1 = __webpack_require__(/*! ../files/_abstract_file */ "./node_modules/@abaplint/core/build/src/files/_abstract_file.js");
class ABAPFile extends _abstract_file_1.AbstractFile {
    constructor(file, tokens, statements, structure, info) {
        super(file.getFilename());
        this.file = file;
        this.tokens = tokens;
        this.statements = statements;
        this.structure = structure;
        this.info = info;
    }
    getRaw() {
        return this.file.getRaw();
    }
    getInfo() {
        return this.info;
    }
    getRawRows() {
        return this.file.getRawRows();
    }
    getStructure() {
        return this.structure;
    }
    getTokens(withPragmas = true) {
        if (withPragmas === true) {
            return this.tokens;
        }
        else {
            const tokens = [];
            this.tokens.forEach((t) => {
                if (!(t instanceof tokens_1.Pragma)) {
                    tokens.push(t);
                }
            });
            return tokens;
        }
    }
    getStatements() {
        return this.statements;
    }
}
exports.ABAPFile = ABAPFile;
//# sourceMappingURL=abap_file.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/abap_parser.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/abap_parser.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPParser = void 0;
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const lexer_1 = __webpack_require__(/*! ./1_lexer/lexer */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/lexer.js");
const statement_parser_1 = __webpack_require__(/*! ./2_statements/statement_parser */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statement_parser.js");
const structure_parser_1 = __webpack_require__(/*! ./3_structures/structure_parser */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structure_parser.js");
const abap_file_information_1 = __webpack_require__(/*! ./4_file_information/abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/abap_file_information.js");
const abap_file_1 = __webpack_require__(/*! ./abap_file */ "./node_modules/@abaplint/core/build/src/abap/abap_file.js");
class ABAPParser {
    constructor(version, globalMacros, reg) {
        this.version = version ? version : version_1.defaultVersion;
        this.globalMacros = globalMacros ? globalMacros : [];
        this.reg = reg;
    }
    // files is input for a single object
    parse(files) {
        const issues = [];
        const output = [];
        const start = Date.now();
        // 1: lexing
        const b1 = Date.now();
        const lexerResult = files.map(f => new lexer_1.Lexer().run(f));
        const lexingRuntime = Date.now() - b1;
        // 2: statements
        const b2 = Date.now();
        const statementResult = new statement_parser_1.StatementParser(this.version, this.reg).run(lexerResult, this.globalMacros);
        const statementsRuntime = Date.now() - b2;
        // 3: structures
        const b3 = Date.now();
        for (const f of statementResult) {
            const result = structure_parser_1.StructureParser.run(f);
            // 4: file information
            const info = new abap_file_information_1.ABAPFileInformation(result.node, f.file.getFilename());
            output.push(new abap_file_1.ABAPFile(f.file, f.tokens, f.statements, result.node, info));
            issues.push(...result.issues);
        }
        const structuresRuntime = Date.now() - b3;
        const end = Date.now();
        return { issues,
            output,
            runtime: end - start,
            runtimeExtra: { lexing: lexingRuntime, statements: statementsRuntime, structure: structuresRuntime },
        };
    }
}
exports.ABAPParser = ABAPParser;
//# sourceMappingURL=abap_parser.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/artifacts.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/artifacts.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArtifactsABAP = void 0;
const Statements = __webpack_require__(/*! ./2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ./2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const combi_1 = __webpack_require__(/*! ./2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const Structures = __webpack_require__(/*! ./3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
class List {
    constructor() {
        this.words = [];
    }
    add(keywords, source) {
        for (const w of keywords) {
            const index = this.find(w);
            if (index >= 0) {
                this.words[index].source.push(source);
            }
            else {
                this.words.push({ word: w, source: [source] });
            }
        }
    }
    get() {
        return this.words;
    }
    find(keyword) {
        for (let i = 0; i < this.words.length; i++) {
            if (this.words[i].word === keyword) {
                return i;
            }
        }
        return -1;
    }
}
function className(cla) {
    return cla.constructor.name;
}
class ArtifactsABAP {
    static getStructures() {
        const ret = [];
        const list = Structures;
        for (const key in Structures) {
            if (typeof list[key] === "function") {
                ret.push(new list[key]());
            }
        }
        return ret;
    }
    static getExpressions() {
        const ret = [];
        const list = Expressions;
        for (const key in Expressions) {
            if (typeof list[key] === "function") {
                ret.push(list[key]);
            }
        }
        return ret;
    }
    static getStatements() {
        const ret = [];
        const list = Statements;
        for (const key in Statements) {
            if (typeof list[key] === "function") {
                ret.push(new list[key]());
            }
        }
        return ret;
    }
    static getKeywords() {
        const list = new List();
        for (const stat of this.getStatements()) {
            list.add(combi_1.Combi.listKeywords(stat.getMatcher()), "statement_" + className(stat));
        }
        for (const expr of this.getExpressions()) {
            list.add(combi_1.Combi.listKeywords(new expr().getRunnable()), "expression_" + className(expr));
        }
        return list.get();
    }
}
exports.ArtifactsABAP = ArtifactsABAP;
//# sourceMappingURL=artifacts.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/flow/flow_graph.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/flow/flow_graph.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FlowGraph = exports.FLOW_EDGE_TYPE = void 0;
var FLOW_EDGE_TYPE;
(function (FLOW_EDGE_TYPE) {
    FLOW_EDGE_TYPE["true"] = "true";
    FLOW_EDGE_TYPE["false"] = "false";
    FLOW_EDGE_TYPE["undefined"] = "undefined";
})(FLOW_EDGE_TYPE || (exports.FLOW_EDGE_TYPE = FLOW_EDGE_TYPE = {}));
class FlowGraph {
    constructor(counter) {
        this.edges = {};
        this.label = "undefined";
        this.startNode = "start#" + counter;
        this.endNode = "end#" + counter;
    }
    getStart() {
        return this.startNode;
    }
    getLabel() {
        return this.label;
    }
    getEnd() {
        return this.endNode;
    }
    addEdge(from, to, type) {
        if (this.edges[from] === undefined) {
            this.edges[from] = {};
        }
        this.edges[from][to] = type;
    }
    removeEdge(from, to) {
        if (this.edges[from] === undefined) {
            return;
        }
        delete this.edges[from][to];
        if (Object.keys(this.edges[from]).length === 0) {
            delete this.edges[from];
        }
    }
    listEdges() {
        const list = [];
        for (const from of Object.keys(this.edges)) {
            for (const to of Object.keys(this.edges[from])) {
                list.push({ from, to, type: this.edges[from][to] });
            }
        }
        return list;
    }
    listInto(to, skipStart = true) {
        const ret = [];
        for (const e of this.listEdges()) {
            if (skipStart === true && e.from === this.getStart()) {
                continue;
            }
            if (e.to === to) {
                ret.push(e.from);
            }
        }
        return ret;
    }
    listNodes() {
        const set = new Set();
        for (const l of this.listEdges()) {
            set.add(l.from);
            set.add(l.to);
        }
        return Array.from(set.values());
    }
    hasEdges() {
        return Object.keys(this.edges).length > 0;
    }
    /** return value: end node of to graph */
    addGraph(from, to, type) {
        if (to.hasEdges() === false) {
            return from;
        }
        this.addEdge(from, to.getStart(), type);
        to.listEdges().forEach(e => this.addEdge(e.from, e.to, e.type));
        return to.getEnd();
    }
    toJSON() {
        return JSON.stringify(this.edges);
    }
    toTextEdges() {
        let graph = "";
        for (const l of this.listEdges()) {
            const label = l.type === FLOW_EDGE_TYPE.undefined ? "" : ` [label="${l.type}"]`;
            graph += `"${l.from}" -> "${l.to}"${label};\n`;
        }
        return graph.trim();
    }
    setLabel(label) {
        this.label = label;
    }
    toDigraph() {
        return `digraph G {
labelloc="t";
label="${this.label}";
graph [fontname = "helvetica"];
node [fontname = "helvetica", shape="box"];
edge [fontname = "helvetica"];
${this.toTextEdges()}
}`;
    }
    listSources(node) {
        const set = [];
        for (const l of this.listEdges()) {
            if (node === l.to) {
                set.push({ name: l.from, type: l.type });
            }
        }
        return set;
    }
    listTargets(node) {
        const set = [];
        for (const l of this.listEdges()) {
            if (node === l.from) {
                set.push({ name: l.to, type: l.type });
            }
        }
        return set;
    }
    /** removes all nodes containing "#" that have one in-going and one out-going edge */
    reduce() {
        for (const node of this.listNodes()) {
            if (node.includes("#") === false) {
                continue;
            }
            const sources = this.listSources(node);
            const targets = this.listTargets(node);
            if (sources.length > 0 && targets.length > 0) {
                // hash node in the middle of the graph
                for (const s of sources) {
                    this.removeEdge(s.name, node);
                }
                for (const t of targets) {
                    this.removeEdge(node, t.name);
                }
                for (const s of sources) {
                    for (const t of targets) {
                        let type = FLOW_EDGE_TYPE.undefined;
                        if (s.type !== FLOW_EDGE_TYPE.undefined) {
                            type = s.type;
                        }
                        if (t.type !== FLOW_EDGE_TYPE.undefined) {
                            if (type !== FLOW_EDGE_TYPE.undefined) {
                                throw new Error("reduce: cannot merge, different edge types");
                            }
                            type = t.type;
                        }
                        this.addEdge(s.name, t.name, type);
                    }
                }
            }
            if (node.startsWith("end#") && sources.length === 0) {
                for (const t of targets) {
                    this.removeEdge(node, t.name);
                }
            }
        }
        return this;
    }
}
exports.FlowGraph = FlowGraph;
//# sourceMappingURL=flow_graph.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/flow/selection_events.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/flow/selection_events.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DECLARATION_STUFF = exports.SELECTION_EVENTS = void 0;
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
exports.SELECTION_EVENTS = [
    Statements.StartOfSelection,
    Statements.AtSelectionScreen,
    Statements.AtLineSelection,
    Statements.AtUserCommand,
    Statements.EndOfSelection,
    Statements.Initialization,
    Statements.TopOfPage,
    Statements.LoadOfProgram,
    Statements.EndOfPage,
];
exports.DECLARATION_STUFF = [
    Statements.Data,
    Statements.DataBegin,
    Statements.Constant,
    Statements.Tables,
    Statements.Include, // this is not super correct, but anyhow
    Statements.Parameter,
    Statements.SelectionScreen,
    Statements.ConstantBegin,
];
//# sourceMappingURL=selection_events.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/flow/statement_flow.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/flow/statement_flow.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatementFlow = void 0;
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const flow_graph_1 = __webpack_require__(/*! ./flow_graph */ "./node_modules/@abaplint/core/build/src/abap/flow/flow_graph.js");
const objects_1 = __webpack_require__(/*! ../../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const selection_events_1 = __webpack_require__(/*! ./selection_events */ "./node_modules/@abaplint/core/build/src/abap/flow/selection_events.js");
class StatementFlow {
    constructor() {
        this.counter = 0;
    }
    build(stru, obj) {
        var _a, _b, _c, _d;
        const ret = [];
        let name = "";
        const structures = stru.findAllStructuresMulti([
            Structures.Form, Structures.ClassImplementation, Structures.FunctionModule, Structures.Module
        ]);
        for (const s of structures) {
            if (s.get() instanceof Structures.Form) {
                name = "FORM " + ((_a = s.findFirstExpression(Expressions.FormName)) === null || _a === void 0 ? void 0 : _a.concatTokens());
                ret.push(this.run(s, name));
            }
            else if (s.get() instanceof Structures.ClassImplementation) {
                const className = (_b = s.findFirstExpression(Expressions.ClassName)) === null || _b === void 0 ? void 0 : _b.concatTokens();
                for (const method of s.findDirectStructures(Structures.Method)) {
                    const methodName = (_c = method.findFirstExpression(Expressions.MethodName)) === null || _c === void 0 ? void 0 : _c.concatTokens();
                    name = "METHOD " + methodName + ", CLASS " + className;
                    ret.push(this.run(method, name));
                }
            }
            else if (s.get() instanceof Structures.FunctionModule) {
                name = "FUNCTION " + ((_d = s.findFirstExpression(Expressions.Field)) === null || _d === void 0 ? void 0 : _d.concatTokens());
                ret.push(this.run(s, name));
            }
            else if (s.get() instanceof Structures.Module) {
                name = s.getFirstStatement().concatTokens().toUpperCase();
                ret.push(this.run(s, name));
            }
            else {
                throw new Error("StatementFlow, unknown structure");
            }
        }
        if (obj instanceof objects_1.Program || obj instanceof objects_1.FunctionGroup) {
            // find the top level events
            let inEvent = false;
            let collected = [];
            for (const s of stru.getChildren() || []) {
                if (selection_events_1.SELECTION_EVENTS.some(f => s.get() instanceof f)) {
                    if (inEvent === true) {
                        ret.push(this.runEvent(collected, name));
                    }
                    collected = [];
                    inEvent = true;
                    name = s.concatTokens();
                }
                else if (s.get() instanceof Structures.Normal) {
                    collected.push(s);
                }
                else {
                    if (inEvent === true) {
                        ret.push(this.runEvent(collected, name));
                        inEvent = false;
                    }
                    collected = [];
                }
            }
            if (inEvent === true) {
                ret.push(this.runEvent(collected, name));
            }
            else if (collected.length > 0
                && !(obj instanceof objects_1.FunctionGroup)) {
                // implicit START-OF-SELECTION
                ret.push(this.runEvent(collected, "START-OF-SELECTION."));
            }
        }
        return ret.map(f => f.reduce());
    }
    ////////////////////
    runEvent(s, name) {
        this.counter = 1;
        const graph = this.traverseBody(s, { procedureEnd: "end#1" });
        graph.setLabel(name);
        return graph;
    }
    run(s, name) {
        this.counter = 1;
        const graph = this.traverseBody(this.findBody(s), { procedureEnd: "end#1" });
        graph.setLabel(name);
        return graph;
    }
    findBody(f) {
        var _a;
        return ((_a = f.findDirectStructure(Structures.Body)) === null || _a === void 0 ? void 0 : _a.getChildren()) || [];
    }
    buildName(statement) {
        let token = undefined;
        const colon = statement.getColon();
        if (colon === undefined) {
            token = statement.getFirstToken();
        }
        else {
            for (const t of statement.getTokens()) {
                if (t.getStart().isAfter(colon.getEnd())) {
                    token = t;
                    break;
                }
            }
        }
        if (token === undefined) {
            return "tokenError";
        }
        return statement.get().constructor.name +
            ":" + token.getRow() +
            "," + token.getCol();
    }
    traverseBody(children, context) {
        const graph = new flow_graph_1.FlowGraph(this.counter++);
        if (children.length === 0) {
            graph.addEdge(graph.getStart(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            return graph;
        }
        let current = graph.getStart();
        for (const c of children) {
            if (c.get() instanceof Structures.Normal) {
                const firstChild = c.getFirstChild(); // "Normal" only has one child
                if (firstChild instanceof nodes_1.StatementNode) {
                    const name = this.buildName(firstChild);
                    graph.addEdge(current, name, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                    current = name;
                    if (firstChild.get() instanceof Statements.Check) {
                        if (context.loopStart) {
                            graph.addEdge(name, context.loopStart, flow_graph_1.FLOW_EDGE_TYPE.false);
                        }
                        else {
                            graph.addEdge(name, context.procedureEnd, flow_graph_1.FLOW_EDGE_TYPE.false);
                        }
                    }
                    else if (firstChild.get() instanceof Statements.Assert) {
                        graph.addEdge(name, context.procedureEnd, flow_graph_1.FLOW_EDGE_TYPE.false);
                    }
                    else if (firstChild.get() instanceof Statements.Continue && context.loopStart) {
                        graph.addEdge(name, context.loopStart, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                        return graph;
                    }
                    else if (firstChild.get() instanceof Statements.Exit) {
                        if (context.loopEnd) {
                            graph.addEdge(name, context.loopEnd, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                        }
                        else {
                            graph.addEdge(name, context.procedureEnd, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                        }
                        return graph;
                    }
                    else if (firstChild.get() instanceof Statements.Return) {
                        graph.addEdge(name, context.procedureEnd, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                        return graph;
                    }
                }
                else if (firstChild instanceof nodes_1.StructureNode) {
                    const sub = this.traverseStructure(firstChild, context);
                    current = graph.addGraph(current, sub, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                }
            }
        }
        graph.addEdge(current, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
        return graph;
    }
    traverseStructure(n, context) {
        const graph = new flow_graph_1.FlowGraph(this.counter++);
        if (n === undefined) {
            return graph;
        }
        let current = graph.getStart();
        const type = n.get();
        if (type instanceof Structures.If) {
            const ifName = this.buildName(n.findDirectStatement(Statements.If));
            const sub = this.traverseBody(this.findBody(n), context);
            graph.addEdge(current, ifName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addGraph(ifName, sub, flow_graph_1.FLOW_EDGE_TYPE.true);
            graph.addEdge(sub.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            current = ifName;
            for (const e of n.findDirectStructures(Structures.ElseIf)) {
                const elseifst = e.findDirectStatement(Statements.ElseIf);
                if (elseifst === undefined) {
                    continue;
                }
                const elseIfName = this.buildName(elseifst);
                const sub = this.traverseBody(this.findBody(e), context);
                graph.addEdge(current, elseIfName, flow_graph_1.FLOW_EDGE_TYPE.false);
                graph.addGraph(elseIfName, sub, flow_graph_1.FLOW_EDGE_TYPE.true);
                graph.addEdge(sub.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
                current = elseIfName;
            }
            const els = n.findDirectStructure(Structures.Else);
            const elsest = els === null || els === void 0 ? void 0 : els.findDirectStatement(Statements.Else);
            if (els && elsest) {
                const elseName = this.buildName(elsest);
                const sub = this.traverseBody(this.findBody(els), context);
                graph.addEdge(current, elseName, flow_graph_1.FLOW_EDGE_TYPE.false);
                graph.addGraph(elseName, sub, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addEdge(sub.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
            else {
                graph.addEdge(ifName, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.false);
            }
        }
        else if (type instanceof Structures.Loop
            || type instanceof Structures.While
            || type instanceof Structures.With
            || type instanceof Structures.Provide
            || type instanceof Structures.Select
            || type instanceof Structures.LoopAtScreen
            || type instanceof Structures.Do) {
            const loopName = this.buildName(n.getFirstStatement());
            const sub = this.traverseBody(this.findBody(n), Object.assign(Object.assign({}, context), { loopStart: loopName, loopEnd: graph.getEnd() }));
            graph.addEdge(current, loopName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addGraph(loopName, sub, flow_graph_1.FLOW_EDGE_TYPE.true);
            graph.addEdge(sub.getEnd(), loopName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(loopName, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.false);
        }
        else if (type instanceof Structures.Data
            || type instanceof Structures.Constants
            || type instanceof Structures.Types) {
            // these doesnt affect control flow, so just take the first statement
            const statement = n.getFirstStatement();
            const name = this.buildName(statement);
            graph.addEdge(current, name, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(name, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
        }
        else if (type instanceof Structures.AtFirst
            || type instanceof Structures.AtLast
            || type instanceof Structures.At
            || type instanceof Structures.OnChange) {
            const name = this.buildName(n.getFirstStatement());
            const body = this.traverseBody(this.findBody(n), context);
            graph.addEdge(current, name, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addGraph(name, body, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(body.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(current, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
        }
        else if (type instanceof Structures.Try) {
            const tryName = this.buildName(n.getFirstStatement());
            const body = this.traverseBody(this.findBody(n), context);
            graph.addEdge(current, tryName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addGraph(tryName, body, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(body.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            for (const c of n.findDirectStructures(Structures.Catch)) {
                const catchName = this.buildName(c.getFirstStatement());
                const catchBody = this.traverseBody(this.findBody(c), context);
                // TODO: this does not take exceptions into account
                graph.addEdge(body.getEnd(), catchName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addGraph(catchName, catchBody, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addEdge(catchBody.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
            // TODO, handle CLEANUP
        }
        else if (type instanceof Structures.CatchSystemExceptions) {
            // TODO: this is not completely correct
            const catchName = this.buildName(n.getFirstStatement());
            const body = this.traverseBody(this.findBody(n), context);
            graph.addEdge(current, catchName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addGraph(catchName, body, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            graph.addEdge(body.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
        }
        else if (type instanceof Structures.Case) {
            const caseName = this.buildName(n.getFirstStatement());
            graph.addEdge(current, caseName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            let othersFound = false;
            for (const w of n.findDirectStructures(Structures.When)) {
                const first = w.getFirstStatement();
                if (first === undefined) {
                    continue;
                }
                if (first.get() instanceof Statements.WhenOthers) {
                    othersFound = true;
                }
                const firstName = this.buildName(first);
                const sub = this.traverseBody(this.findBody(w), context);
                graph.addEdge(caseName, firstName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addGraph(firstName, sub, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addEdge(sub.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
            if (othersFound === false) {
                graph.addEdge(caseName, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
        }
        else if (type instanceof Structures.CaseType) {
            const caseName = this.buildName(n.getFirstStatement());
            graph.addEdge(current, caseName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
            let othersFound = false;
            for (const w of n.findDirectStructures(Structures.WhenType)) {
                const first = w.getFirstStatement();
                if (first === undefined) {
                    continue;
                }
                if (first.get() instanceof Statements.WhenOthers) {
                    othersFound = true;
                }
                const firstName = this.buildName(first);
                const sub = this.traverseBody(this.findBody(w), context);
                graph.addEdge(caseName, firstName, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addGraph(firstName, sub, flow_graph_1.FLOW_EDGE_TYPE.undefined);
                graph.addEdge(sub.getEnd(), graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
            if (othersFound === false) {
                graph.addEdge(caseName, graph.getEnd(), flow_graph_1.FLOW_EDGE_TYPE.undefined);
            }
        }
        else if (type instanceof Structures.Define) {
            // do nothing
        }
        else {
            console.dir("StatementFlow,todo, " + n.get().constructor.name);
        }
        return graph;
    }
}
exports.StatementFlow = StatementFlow;
//# sourceMappingURL=statement_flow.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/_abstract_node.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/_abstract_node.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractNode = void 0;
class AbstractNode {
    constructor() {
        this.children = [];
    }
    addChild(n) {
        this.children.push(n);
    }
    setChildren(children) {
        this.children = children;
    }
    getChildren() {
        return this.children;
    }
    getFirstChild() {
        return this.children[0];
    }
    getLastChild() {
        return this.children[this.children.length - 1];
    }
}
exports.AbstractNode = AbstractNode;
//# sourceMappingURL=_abstract_node.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/expression_node.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/expression_node.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpressionNode = void 0;
const token_node_1 = __webpack_require__(/*! ./token_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js");
const tokens_1 = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _abstract_node_1 = __webpack_require__(/*! ./_abstract_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/_abstract_node.js");
class ExpressionNode extends _abstract_node_1.AbstractNode {
    constructor(expression) {
        super();
        this.expression = expression;
    }
    get() {
        return this.expression;
    }
    countTokens() {
        let ret = 0;
        for (const c of this.getChildren()) {
            ret = ret + c.countTokens();
        }
        return ret;
    }
    getFirstToken() {
        for (const child of this.getChildren()) {
            return child.getFirstToken();
        }
        throw new Error("ExpressionNode, getFirstToken, no children");
    }
    concatTokensWithLinebreaks() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof tokens_1.Pragma) {
                continue;
            }
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && prev.getStr().length + prev.getCol() === token.getCol()
                && prev.getRow() === token.getRow()) {
                str = str + token.getStr();
            }
            else {
                if (prev && prev.getRow() !== token.getRow()) {
                    str = str + "\n" + token.getStr();
                }
                else {
                    str = str + " " + token.getStr();
                }
            }
            prev = token;
        }
        return str;
    }
    concatTokens() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof tokens_1.Pragma) {
                continue;
            }
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && prev.getStr().length + prev.getCol() === token.getCol()
                && prev.getRow() === token.getRow()) {
                str = str + token.getStr();
            }
            else {
                str = str + " " + token.getStr();
            }
            prev = token;
        }
        return str;
    }
    concatTokensWithoutStringsAndComments() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof tokens_1.Comment
                || token instanceof tokens_1.StringToken
                || token instanceof tokens_1.StringTemplate
                || token instanceof tokens_1.StringTemplateBegin
                || token instanceof tokens_1.StringTemplateMiddle
                || token instanceof tokens_1.StringTemplateEnd) {
                continue;
            }
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && prev.getStr().length + prev.getCol() === token.getCol()
                && prev.getRow() === token.getRow()) {
                str = str + token.getStr();
            }
            else {
                str = str + " " + token.getStr();
            }
            prev = token;
        }
        return str;
    }
    // todo: delete this method?, its slow
    getTokens() {
        const tokens = [];
        for (const c of this.getChildren()) {
            tokens.push(...this.toTokens(c));
        }
        return tokens;
    }
    toTokens(b) {
        const tokens = [];
        if (b instanceof token_node_1.TokenNode) {
            tokens.push(b.get());
            return tokens;
        }
        for (const c of b.getChildren()) {
            if (c instanceof token_node_1.TokenNode) {
                tokens.push(c.get());
            }
            else {
                tokens.push(...this.toTokens(c));
            }
        }
        return tokens;
    }
    getLastToken() {
        const child = this.getLastChild();
        if (child) {
            return child.getLastToken();
        }
        throw new Error("ExpressionNode, getLastToken, no children");
    }
    getAllTokens() {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                ret.push(child.get());
            }
            else {
                ret.push(...child.getAllTokens());
            }
        }
        return ret;
    }
    getDirectTokens() {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                ret.push(child.get());
            }
        }
        return ret;
    }
    findDirectExpression(type) {
        for (const child of this.getChildren()) {
            if (child instanceof ExpressionNode && child.get() instanceof type) {
                return child;
            }
        }
        return undefined;
    }
    findExpressionAfterToken(text) {
        const children = this.getChildren();
        for (let i = 0; i < children.length - 1; i++) {
            const c = children[i];
            const next = children[i + 1];
            if (c instanceof token_node_1.TokenNode
                && c.get().getStr().toUpperCase() === text.toUpperCase()
                && next instanceof ExpressionNode) {
                return next;
            }
        }
        return undefined;
    }
    findDirectExpressions(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof ExpressionNode && child.get() instanceof type) {
                ret.push(child);
            }
        }
        return ret;
    }
    findDirectExpressionsMulti(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof ExpressionNode) {
                for (const t of type) {
                    if (child.get() instanceof t) {
                        ret.push(child);
                        break;
                    }
                }
            }
        }
        return ret;
    }
    findDirectTokenByText(text) {
        const search = text.toUpperCase();
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode && child.get().getStr().toUpperCase() === search) {
                return child.get();
            }
        }
        return undefined;
    }
    findAllExpressionsRecursive(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            ret.push(...child.findAllExpressionsRecursive(type));
        }
        return ret;
    }
    findAllExpressions(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            else {
                ret.push(...child.findAllExpressions(type));
            }
        }
        return ret;
    }
    findAllExpressionsMulti(type, recursive = false) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            const before = ret.length;
            for (const t of type) {
                if (child.get() instanceof t) {
                    ret.push(child);
                }
            }
            if (before === ret.length || recursive === true) {
                ret.push(...child.findAllExpressionsMulti(type, recursive));
            }
        }
        return ret;
    }
    findFirstExpression(type) {
        if (this.get() instanceof type) {
            return this;
        }
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                return child;
            }
            else {
                const res = child.findFirstExpression(type);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
}
exports.ExpressionNode = ExpressionNode;
//# sourceMappingURL=expression_node.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./expression_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/expression_node.js"), exports);
__exportStar(__webpack_require__(/*! ./statement_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/statement_node.js"), exports);
__exportStar(__webpack_require__(/*! ./structure_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/structure_node.js"), exports);
__exportStar(__webpack_require__(/*! ./token_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js"), exports);
__exportStar(__webpack_require__(/*! ./token_node_regex */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node_regex.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/statement_node.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/statement_node.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StatementNode = void 0;
const _abstract_node_1 = __webpack_require__(/*! ./_abstract_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/_abstract_node.js");
const token_node_1 = __webpack_require__(/*! ./token_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js");
const expression_node_1 = __webpack_require__(/*! ./expression_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/expression_node.js");
const comment_1 = __webpack_require__(/*! ../1_lexer/tokens/comment */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/comment.js");
const pragma_1 = __webpack_require__(/*! ../1_lexer/tokens/pragma */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/pragma.js");
const string_1 = __webpack_require__(/*! ../1_lexer/tokens/string */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string.js");
const string_template_middle_1 = __webpack_require__(/*! ../1_lexer/tokens/string_template_middle */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_middle.js");
const string_template_end_1 = __webpack_require__(/*! ../1_lexer/tokens/string_template_end */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_end.js");
const string_template_begin_1 = __webpack_require__(/*! ../1_lexer/tokens/string_template_begin */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template_begin.js");
const string_template_1 = __webpack_require__(/*! ../1_lexer/tokens/string_template */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/string_template.js");
class StatementNode extends _abstract_node_1.AbstractNode {
    constructor(statement, colon, pragmas) {
        super();
        this.statement = statement;
        this.colon = colon;
        if (pragmas) {
            this.pragmas = pragmas;
        }
        else {
            this.pragmas = [];
        }
    }
    get() {
        return this.statement;
    }
    getColon() {
        return this.colon;
    }
    getPragmas() {
        return this.pragmas;
    }
    setChildren(children) {
        if (children.length === 0) {
            throw new Error("statement: zero children");
        }
        this.children = children;
        return this;
    }
    getStart() {
        return this.getFirstToken().getStart();
    }
    getEnd() {
        const last = this.getLastToken();
        return last.getEnd();
    }
    getTokens() {
        const tokens = [];
        for (const c of this.getChildren()) {
            tokens.push(...this.toTokens(c));
        }
        return tokens;
    }
    includesToken(search) {
        for (const t of this.getTokens()) {
            if (t.getStart().equals(search.getStart())) {
                return true;
            }
        }
        return false;
    }
    getTokenNodes() {
        const tokens = [];
        for (const c of this.getChildren()) {
            tokens.push(...this.toTokenNodess(c));
        }
        return tokens;
    }
    concatTokens() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof pragma_1.Pragma) {
                continue;
            }
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && prev.getStr().length + prev.getCol() === token.getCol()
                && prev.getRow() === token.getRow()) {
                str = str + token.getStr();
            }
            else {
                str = str + " " + token.getStr();
            }
            prev = token;
        }
        return str;
    }
    concatTokensVirtual() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof pragma_1.Pragma) {
                continue;
            }
            const vprev = prev === null || prev === void 0 ? void 0 : prev.getStart();
            const vtoke = token === null || token === void 0 ? void 0 : token.getStart();
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && vprev && vtoke
                && prev.getStr().length + vprev.vcol === vtoke.vcol
                && vprev.vrow === vtoke.vrow) {
                str = str + token.getStr();
            }
            else {
                str = str + " " + token.getStr();
            }
            prev = token;
        }
        return str;
    }
    concatTokensWithoutStringsAndComments() {
        let str = "";
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof comment_1.Comment
                || token instanceof string_1.StringToken
                || token instanceof string_template_1.StringTemplate
                || token instanceof string_template_begin_1.StringTemplateBegin
                || token instanceof string_template_middle_1.StringTemplateMiddle
                || token instanceof string_template_end_1.StringTemplateEnd) {
                continue;
            }
            if (str === "") {
                str = token.getStr();
            }
            else if (prev && prev.getStr().length + prev.getCol() === token.getCol()
                && prev.getRow() === token.getRow()) {
                str = str + token.getStr();
            }
            else {
                str = str + " " + token.getStr();
            }
            prev = token;
        }
        return str;
    }
    getTerminator() {
        return this.getLastToken().getStr();
    }
    getFirstToken() {
        for (const child of this.getChildren()) {
            return child.getFirstToken();
        }
        throw new Error("StatementNode, getFirstToken, no children, " + this.get().constructor.name);
    }
    getLastToken() {
        const child = this.getLastChild();
        if (child !== undefined) {
            return child.getLastToken();
        }
        throw new Error("StatementNode, getLastToken, no children");
    }
    findDirectExpression(type) {
        for (const child of this.getChildren()) {
            if (child instanceof expression_node_1.ExpressionNode && child.get() instanceof type) {
                return child;
            }
        }
        return undefined;
    }
    findDirectExpressions(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof expression_node_1.ExpressionNode && child.get() instanceof type) {
                ret.push(child);
            }
        }
        return ret;
    }
    findDirectTokenByText(text) {
        const upper = text.toUpperCase();
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode && child.get().getStr().toUpperCase() === upper) {
                return child.get();
            }
        }
        return undefined;
    }
    findFirstExpression(type) {
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                return child;
            }
            else {
                const res = child.findFirstExpression(type);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
    findAllExpressions(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            else {
                ret.push(...child.findAllExpressions(type));
            }
        }
        return ret;
    }
    findAllExpressionsRecursive(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            ret.push(...child.findAllExpressionsRecursive(type));
        }
        return ret;
    }
    findAllExpressionsMulti(type, recursive = false) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof token_node_1.TokenNode) {
                continue;
            }
            const before = ret.length;
            for (const t of type) {
                if (child.get() instanceof t) {
                    ret.push(child);
                }
            }
            if (before === ret.length || recursive === true) {
                ret.push(...child.findAllExpressionsMulti(type, recursive));
            }
        }
        return ret;
    }
    /**
     * Returns the Position of the first token if the sequence is found,
     * otherwise undefined. Strings and Comments are ignored in this search.
     * @param first - Text of the first Token
     * @param second - Text of the second Token
     */
    findTokenSequencePosition(first, second) {
        let prev;
        for (const token of this.getTokens()) {
            if (token instanceof comment_1.Comment
                || token instanceof string_1.StringToken
                || token instanceof string_template_1.StringTemplate
                || token instanceof string_template_begin_1.StringTemplateBegin
                || token instanceof string_template_middle_1.StringTemplateMiddle
                || token instanceof string_template_end_1.StringTemplateEnd) {
                continue;
            }
            if (prev && token.getStr().toUpperCase() === second && (prev === null || prev === void 0 ? void 0 : prev.getStr().toUpperCase()) === first.toUpperCase()) {
                return prev.getStart();
            }
            else {
                prev = token;
            }
        }
        return undefined;
    }
    findExpressionAfterToken(text) {
        const children = this.getChildren();
        for (let i = 0; i < children.length - 1; i++) {
            const c = children[i];
            const next = children[i + 1];
            if (c instanceof token_node_1.TokenNode
                && c.get().getStr().toUpperCase() === text.toUpperCase()
                && next instanceof expression_node_1.ExpressionNode) {
                return next;
            }
        }
        return undefined;
    }
    findExpressionsAfterToken(text) {
        const children = this.getChildren();
        const ret = [];
        for (let i = 0; i < children.length - 1; i++) {
            const c = children[i];
            const next = children[i + 1];
            if (c instanceof token_node_1.TokenNode
                && c.get().getStr().toUpperCase() === text.toUpperCase()
                && next instanceof expression_node_1.ExpressionNode) {
                ret.push(next);
            }
        }
        return ret;
    }
    ////////////////////////////////
    toTokens(b) {
        const tokens = [];
        if (b instanceof token_node_1.TokenNode) {
            tokens.push(b.get());
            return tokens;
        }
        for (const c of b.getChildren()) {
            if (c instanceof token_node_1.TokenNode) {
                tokens.push(c.get());
            }
            else {
                tokens.push(...this.toTokens(c));
            }
        }
        return tokens;
    }
    toTokenNodess(b) {
        const tokens = [];
        if (b instanceof token_node_1.TokenNode) {
            tokens.push(b);
            return tokens;
        }
        for (const c of b.getChildren()) {
            if (c instanceof token_node_1.TokenNode) {
                tokens.push(c);
            }
            else {
                tokens.push(...this.toTokenNodess(c));
            }
        }
        return tokens;
    }
}
exports.StatementNode = StatementNode;
//# sourceMappingURL=statement_node.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/structure_node.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/structure_node.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructureNode = void 0;
const _abstract_node_1 = __webpack_require__(/*! ./_abstract_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/_abstract_node.js");
const statement_node_1 = __webpack_require__(/*! ./statement_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/statement_node.js");
class StructureNode extends _abstract_node_1.AbstractNode {
    constructor(structure) {
        super();
        this.structure = structure;
    }
    get() {
        return this.structure;
    }
    // todo, remove this method, the logic should never go up in the tree
    findParent(node) {
        for (const child of this.getChildren()) {
            if (child === node) {
                return this;
            }
            else if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            else {
                const res = child.findParent(node);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
    concatTokens() {
        let concat = "";
        for (const child of this.getChildren()) {
            concat = concat + child.concatTokens();
        }
        return concat;
    }
    findDirectStatement(type) {
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode && child.get() instanceof type) {
                return child;
            }
        }
        return undefined;
    }
    findDirectStatements(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode && child.get() instanceof type) {
                ret.push(child);
            }
        }
        return ret;
    }
    findDirectStructures(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof StructureNode && child.get() instanceof type) {
                ret.push(child);
            }
        }
        return ret;
    }
    findFirstStatement(type) {
        for (const child of this.getChildren()) {
            if (child.get() instanceof type) {
                return child;
            }
            else if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            else {
                const res = child.findFirstStatement(type);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
    findFirstExpression(type) {
        for (const child of this.getChildren()) {
            const res = child.findFirstExpression(type);
            if (res) {
                return res;
            }
        }
        return undefined;
    }
    getFirstStatement() {
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                return child;
            }
            return child.getFirstStatement();
        }
        return undefined;
    }
    getFirstToken() {
        const child = this.getFirstChild();
        if (child !== undefined) {
            return child.getFirstToken();
        }
        throw new Error("StructureNode, getFirstToken, unexpected type");
    }
    getLastToken() {
        const child = this.getLastChild();
        if (child !== undefined) {
            return child.getLastToken();
        }
        throw new Error("StructureNode, getLastToken, unexpected type");
    }
    findAllExpressions(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            ret.push(...child.findAllExpressions(type));
        }
        return ret;
    }
    findAllExpressionsRecursive(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                ret.push(...child.findAllExpressionsRecursive(type));
            }
            else {
                ret.push(...child.findAllExpressionsRecursive(type));
            }
        }
        return ret;
    }
    findAllExpressionsMulti(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            ret.push(...child.findAllExpressionsMulti(type));
        }
        return ret;
    }
    findAllStatements(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof StructureNode) {
                ret.push(...child.findAllStatements(type));
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
        }
        return ret;
    }
    findAllStatementNodes() {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                ret.push(child);
            }
            else {
                ret.push(...child.findAllStatementNodes());
            }
        }
        return ret;
    }
    findAllStructuresRecursive(type) {
        const ret = [];
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            ret.push(...child.findAllStructuresRecursive(type));
        }
        return ret;
    }
    findAllStructuresMulti(type) {
        const ret = [];
        for (const t of type) {
            if (this.get() instanceof t) {
                return [this];
            }
        }
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            let found = false;
            for (const t of type) {
                if (this.get() instanceof t) {
                    ret.push(child);
                    found = true;
                }
            }
            if (found === false) {
                ret.push(...child.findAllStructuresMulti(type));
            }
        }
        return ret;
    }
    findAllStructures(type) {
        const ret = [];
        if (this.get() instanceof type) {
            return [this];
        }
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                ret.push(child);
            }
            else {
                ret.push(...child.findAllStructures(type));
            }
        }
        return ret;
    }
    findDirectStructure(type) {
        if (this.get() instanceof type) {
            return this;
        }
        for (const child of this.getChildren()) {
            if (child.get() instanceof type) {
                return child;
            }
        }
        return undefined;
    }
    findFirstStructure(type) {
        if (this.get() instanceof type) {
            return this;
        }
        for (const child of this.getChildren()) {
            if (child instanceof statement_node_1.StatementNode) {
                continue;
            }
            else if (child.get() instanceof type) {
                return child;
            }
            else {
                const res = child.findFirstStructure(type);
                if (res) {
                    return res;
                }
            }
        }
        return undefined;
    }
}
exports.StructureNode = StructureNode;
//# sourceMappingURL=structure_node.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenNode = void 0;
class TokenNode {
    constructor(token) {
        this.token = token;
    }
    addChild(_n) {
        throw new Error("TokenNode, Method not implemented.");
    }
    setChildren(_children) {
        throw new Error("TokenNode, Method not implemented.");
    }
    getChildren() {
        return [];
    }
    concatTokens() {
        return this.token.getStr();
    }
    get() {
        return this.token;
    }
    countTokens() {
        return 1;
    }
    getFirstToken() {
        return this.token;
    }
    getLastToken() {
        return this.token;
    }
}
exports.TokenNode = TokenNode;
//# sourceMappingURL=token_node.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node_regex.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/nodes/token_node_regex.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TokenNodeRegex = void 0;
const token_node_1 = __webpack_require__(/*! ./token_node */ "./node_modules/@abaplint/core/build/src/abap/nodes/token_node.js");
class TokenNodeRegex extends token_node_1.TokenNode {
}
exports.TokenNodeRegex = TokenNodeRegex;
//# sourceMappingURL=token_node_regex.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypedIdentifier = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
class TypedIdentifier extends _identifier_1.Identifier {
    [Symbol.for("debug.description")]() {
        return `${this.constructor.name} ${this.getName()}:${this.getType().constructor.name}`;
    }
    static from(id, type, meta) {
        return new TypedIdentifier(id.getToken(), id.getFilename(), type, meta);
    }
    constructor(token, filename, type, meta, value) {
        super(token, filename);
        if (type instanceof TypedIdentifier) {
            this.type = type.getType();
        }
        else {
            this.type = type;
        }
        this.value = value;
        this.meta = [];
        if (meta) {
            this.meta = meta;
        }
    }
    toText() {
        return "Identifier: ```" + this.getName() + "```";
    }
    getType() {
        return this.type;
    }
    getMeta() {
        return this.meta;
    }
    getValue() {
        return this.value;
    }
}
exports.TypedIdentifier = TypedIdentifier;
//# sourceMappingURL=_typed_identifier.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/alias.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/alias.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Alias = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
class Alias extends _identifier_1.Identifier {
    constructor(token, visibility, component, filename) {
        super(token, filename);
        this.component = component;
        this.visibility = visibility;
    }
    getComponent() {
        return this.component;
    }
    getVisibility() {
        return this.visibility;
    }
}
exports.Alias = Alias;
//# sourceMappingURL=alias.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractType = void 0;
class AbstractType {
    constructor(input) {
        this.data = input;
    }
    getAbstractTypeData() {
        return this.data;
    }
    /** fully qualified symbolic name of the type */
    getQualifiedName() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.qualifiedName;
    }
    getRTTIName() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.RTTIName;
    }
    getDescription() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.description;
    }
    getConversionExit() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.conversionExit;
    }
    getDDICName() {
        var _a;
        return (_a = this.data) === null || _a === void 0 ? void 0 : _a.ddicName;
    }
}
exports.AbstractType = AbstractType;
//# sourceMappingURL=_abstract_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/any_type.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/any_type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AnyType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class AnyType extends _abstract_type_1.AbstractType {
    toText() {
        return "```any```";
    }
    toABAP() {
        return "any";
    }
    isGeneric() {
        return true;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_ANY";
    }
}
exports.AnyType = AnyType;
//# sourceMappingURL=any_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/cgeneric_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/cgeneric_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CGenericType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class CGenericType extends _abstract_type_1.AbstractType {
    toText() {
        return "```c```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("c, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_CGENERIC";
    }
}
exports.CGenericType = CGenericType;
//# sourceMappingURL=cgeneric_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/character_type.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/character_type.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CharacterType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class CharacterType extends _abstract_type_1.AbstractType {
    constructor(length, extra) {
        super(extra);
        if (length <= 0) {
            throw new Error("Bad LENGTH, Character");
        }
        this.length = length;
    }
    cloneType(input) {
        const clone = Object.assign({}, this.getAbstractTypeData());
        if (input.qualifiedName) {
            clone.qualifiedName = input.qualifiedName;
        }
        if (input.ddicName) {
            clone.ddicName = input.ddicName;
        }
        if (input.derivedFromConstant) {
            clone.derivedFromConstant = input.derivedFromConstant;
        }
        return new CharacterType(this.length, clone);
    }
    getLength() {
        return this.length;
    }
    toText() {
        return "```c LENGTH " + this.getLength() + "```";
    }
    toABAP() {
        return "c LENGTH " + this.getLength();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    getIdentifier() {
        return undefined;
    }
    toCDS() {
        return "abap.char( " + this.getLength() + " )";
    }
}
exports.CharacterType = CharacterType;
//# sourceMappingURL=character_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/clike_type.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/clike_type.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CLikeType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class CLikeType extends _abstract_type_1.AbstractType {
    static get() {
        return this.singleton;
    }
    constructor() {
        super();
    }
    toText() {
        return "```clike```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("clike, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_CLIKE";
    }
}
exports.CLikeType = CLikeType;
CLikeType.singleton = new CLikeType();
//# sourceMappingURL=clike_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/csequence_type.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/csequence_type.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CSequenceType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class CSequenceType extends _abstract_type_1.AbstractType {
    toText() {
        return "```csequence```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("csequence, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_CSEQUENCE";
    }
}
exports.CSequenceType = CSequenceType;
//# sourceMappingURL=csequence_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/data_reference_type.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/data_reference_type.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataReference = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
const any_type_1 = __webpack_require__(/*! ./any_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/any_type.js");
class DataReference extends _abstract_type_1.AbstractType {
    constructor(type, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        this.type = type;
    }
    toText(level) {
        return "Data REF TO " + this.type.toText(level + 1);
    }
    getType() {
        return this.type;
    }
    toABAP() {
        const type = this.type.toABAP();
        if (type.includes(" TABLE OF ")) {
            return ""; // hmm, should this return undefined?
        }
        return "REF TO " + this.type.toABAP();
    }
    isGeneric() {
        if (this.type instanceof any_type_1.AnyType) {
            return true;
        }
        return false;
    }
    containsVoid() {
        return this.type.containsVoid();
    }
    toCDS() {
        return "abap.TODO_REFERENCE";
    }
}
exports.DataReference = DataReference;
//# sourceMappingURL=data_reference_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/data_type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/data_type.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class DataType extends _abstract_type_1.AbstractType {
    toText() {
        return "```data```";
    }
    toABAP() {
        return "data";
    }
    isGeneric() {
        return true;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_DATA";
    }
}
exports.DataType = DataType;
//# sourceMappingURL=data_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/date_type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/date_type.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DateType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class DateType extends _abstract_type_1.AbstractType {
    toText() {
        return "```d```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "d";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.dats";
    }
}
exports.DateType = DateType;
//# sourceMappingURL=date_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat16_type.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat16_type.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecFloat16Type = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class DecFloat16Type extends _abstract_type_1.AbstractType {
    toText() {
        return "```decfloat16```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "decfloat16";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.d16n";
    }
}
exports.DecFloat16Type = DecFloat16Type;
//# sourceMappingURL=decfloat16_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat34_type.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat34_type.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecFloat34Type = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class DecFloat34Type extends _abstract_type_1.AbstractType {
    toText() {
        return "```decfloat34```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "decfloat34";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.d34n";
    }
}
exports.DecFloat34Type = DecFloat34Type;
//# sourceMappingURL=decfloat34_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DecFloatType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class DecFloatType extends _abstract_type_1.AbstractType {
    toText() {
        return "```decfloat```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        return "decfloat";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.fltp";
    }
}
exports.DecFloatType = DecFloatType;
//# sourceMappingURL=decfloat_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/enum_type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/enum_type.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnumType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class EnumType extends _abstract_type_1.AbstractType {
    toText() {
        return "enum";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return this.getQualifiedName() || "enum";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_ENUM";
    }
}
exports.EnumType = EnumType;
//# sourceMappingURL=enum_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/float_type.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/float_type.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FloatType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
// this is the ABAP "F" type, which is IEEE?
// todo, same as FloatingPointType ?
class FloatType extends _abstract_type_1.AbstractType {
    toText() {
        return "```f```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "f";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.fltp";
    }
}
exports.FloatType = FloatType;
//# sourceMappingURL=float_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/floating_point_type.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/floating_point_type.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FloatingPointType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
// this is the DDIC floating point type
class FloatingPointType extends _abstract_type_1.AbstractType {
    constructor(length, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        if (length <= 0) {
            throw new Error("Bad LENGTH, Floating Point");
        }
        this.length = length;
    }
    getLength() {
        return this.length;
    }
    toText() {
        return "```f LENGTH " + this.getLength() + "```";
    }
    toABAP() {
        return "f LENGTH " + this.getLength();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.fltp";
    }
}
exports.FloatingPointType = FloatingPointType;
//# sourceMappingURL=floating_point_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/generic_object_reference_type.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/generic_object_reference_type.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GenericObjectReferenceType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class GenericObjectReferenceType extends _abstract_type_1.AbstractType {
    toText() {
        return "```REF TO object```";
    }
    isGeneric() {
        // a DATA definition can be "REF TO object", so its not generic
        return false;
    }
    toABAP() {
        return "REF TO object";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_GENERICOBJECTREF";
    }
}
exports.GenericObjectReferenceType = GenericObjectReferenceType;
//# sourceMappingURL=generic_object_reference_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/hex_type.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/hex_type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HexType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class HexType extends _abstract_type_1.AbstractType {
    constructor(length, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        if (length <= 0) {
            throw new Error("Bad LENGTH, Hex");
        }
        this.length = length;
    }
    getLength() {
        return this.length;
    }
    toText() {
        return "```x LENGTH " + this.getLength() + "```";
    }
    toABAP() {
        return "x LENGTH " + this.getLength();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.raw( " + this.getLength() + " )";
    }
}
exports.HexType = HexType;
//# sourceMappingURL=hex_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/index.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./any_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/any_type.js"), exports);
__exportStar(__webpack_require__(/*! ./cgeneric_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/cgeneric_type.js"), exports);
__exportStar(__webpack_require__(/*! ./character_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/character_type.js"), exports);
__exportStar(__webpack_require__(/*! ./clike_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/clike_type.js"), exports);
__exportStar(__webpack_require__(/*! ./csequence_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/csequence_type.js"), exports);
__exportStar(__webpack_require__(/*! ./data_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/data_reference_type.js"), exports);
__exportStar(__webpack_require__(/*! ./data_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/data_type.js"), exports);
__exportStar(__webpack_require__(/*! ./date_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/date_type.js"), exports);
__exportStar(__webpack_require__(/*! ./decfloat_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat_type.js"), exports);
__exportStar(__webpack_require__(/*! ./decfloat16_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat16_type.js"), exports);
__exportStar(__webpack_require__(/*! ./decfloat34_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/decfloat34_type.js"), exports);
__exportStar(__webpack_require__(/*! ./float_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/float_type.js"), exports);
__exportStar(__webpack_require__(/*! ./floating_point_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/floating_point_type.js"), exports);
__exportStar(__webpack_require__(/*! ./generic_object_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/generic_object_reference_type.js"), exports);
__exportStar(__webpack_require__(/*! ./hex_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/hex_type.js"), exports);
__exportStar(__webpack_require__(/*! ./integer_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/integer_type.js"), exports);
__exportStar(__webpack_require__(/*! ./integer8_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/integer8_type.js"), exports);
__exportStar(__webpack_require__(/*! ./numeric_generic_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_generic_type.js"), exports);
__exportStar(__webpack_require__(/*! ./numeric_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_type.js"), exports);
__exportStar(__webpack_require__(/*! ./object_reference_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/object_reference_type.js"), exports);
__exportStar(__webpack_require__(/*! ./packed_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/packed_type.js"), exports);
__exportStar(__webpack_require__(/*! ./simple_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/simple_type.js"), exports);
__exportStar(__webpack_require__(/*! ./string_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/string_type.js"), exports);
__exportStar(__webpack_require__(/*! ./structure_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js"), exports);
__exportStar(__webpack_require__(/*! ./table_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/table_type.js"), exports);
__exportStar(__webpack_require__(/*! ./time_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/time_type.js"), exports);
__exportStar(__webpack_require__(/*! ./unknown_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js"), exports);
__exportStar(__webpack_require__(/*! ./utc_long_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/utc_long_type.js"), exports);
__exportStar(__webpack_require__(/*! ./void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js"), exports);
__exportStar(__webpack_require__(/*! ./xgeneric_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/xgeneric_type.js"), exports);
__exportStar(__webpack_require__(/*! ./xsequence_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/xsequence_type.js"), exports);
__exportStar(__webpack_require__(/*! ./xstring_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/xstring_type.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/integer8_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/integer8_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Integer8Type = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class Integer8Type extends _abstract_type_1.AbstractType {
    toText() {
        return "```int8```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "int8";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.int8";
    }
}
exports.Integer8Type = Integer8Type;
//# sourceMappingURL=integer8_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/integer_type.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/integer_type.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntegerType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class IntegerType extends _abstract_type_1.AbstractType {
    static get(input) {
        if (input === undefined) {
            return this.singleton;
        }
        return new IntegerType(input);
    }
    constructor(input) {
        super(input);
    }
    /** fully qualified symbolic name of the type */
    getQualifiedName() {
        var _a;
        const qual = (_a = this.data) === null || _a === void 0 ? void 0 : _a.qualifiedName;
        if (qual === undefined) {
            return "I";
        }
        return qual;
    }
    toText() {
        return "```i```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "i";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.int4";
    }
}
exports.IntegerType = IntegerType;
IntegerType.singleton = new IntegerType();
//# sourceMappingURL=integer_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_generic_type.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_generic_type.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumericGenericType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class NumericGenericType extends _abstract_type_1.AbstractType {
    toText() {
        return "```NUMERIC```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("NumericGenericType, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_NUMERICGENERIC";
    }
}
exports.NumericGenericType = NumericGenericType;
//# sourceMappingURL=numeric_generic_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_type.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/numeric_type.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumericType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class NumericType extends _abstract_type_1.AbstractType {
    constructor(length, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        if (length <= 0) {
            throw new Error("Bad LENGTH, Numeric");
        }
        this.length = length;
    }
    getLength() {
        return this.length;
    }
    toText() {
        return "```n LENGTH " + this.getLength() + "```";
    }
    toABAP() {
        return "n LENGTH " + this.getLength();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.numc( " + this.getLength() + " )";
    }
}
exports.NumericType = NumericType;
//# sourceMappingURL=numeric_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/object_reference_type.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/object_reference_type.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectReferenceType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
// use GenericObjectReferenceType for REF TO OBJECT
class ObjectReferenceType extends _abstract_type_1.AbstractType {
    constructor(id, extra) {
        super(extra);
        this.identifier = id;
    }
    getIdentifierName() {
        return this.identifier.getName();
    }
    toText() {
        return "```REF TO " + this.identifier.getName() + "```";
    }
    toABAP() {
        return "REF TO " + this.identifier.getName();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    getIdentifier() {
        return this.identifier;
    }
    toCDS() {
        return "abap.TODO_OBJECTREF";
    }
}
exports.ObjectReferenceType = ObjectReferenceType;
//# sourceMappingURL=object_reference_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/packed_type.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/packed_type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackedType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class PackedType extends _abstract_type_1.AbstractType {
    constructor(length, decimals, extra) {
        super(extra);
        if (length <= 0) {
            throw new Error("Bad LENGTH, Packed");
        }
        else if (decimals < 0) {
            throw new Error("Bad DECIMALS, Packed");
        }
        this.length = length;
        this.decimals = decimals;
    }
    getLength() {
        return this.length;
    }
    getDecimals() {
        return this.decimals;
    }
    toText() {
        return "```p LENGTH " + this.getLength() + " DECIMALS " + this.getDecimals() + "```";
    }
    toABAP() {
        return "p LENGTH " + this.getLength() + " DECIMALS " + this.getDecimals();
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_PACKED";
    }
}
exports.PackedType = PackedType;
//# sourceMappingURL=packed_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/simple_type.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/simple_type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SimpleType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class SimpleType extends _abstract_type_1.AbstractType {
    toText() {
        return "```simple```";
    }
    toABAP() {
        return "simple";
    }
    isGeneric() {
        return true;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_SIMPLE";
    }
}
exports.SimpleType = SimpleType;
//# sourceMappingURL=simple_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/string_type.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/string_type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StringType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class StringType extends _abstract_type_1.AbstractType {
    static get(input) {
        if (input === undefined) {
            return this.singleton;
        }
        return new StringType(input);
    }
    constructor(input) {
        super(input);
    }
    /** fully qualified symbolic name of the type */
    getQualifiedName() {
        var _a;
        const qual = (_a = this.data) === null || _a === void 0 ? void 0 : _a.qualifiedName;
        if (qual === undefined) {
            return "STRING";
        }
        return qual;
    }
    toText() {
        return "```string```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "string";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.string";
    }
}
exports.StringType = StringType;
StringType.singleton = new StringType();
//# sourceMappingURL=string_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StructureType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class StructureType extends _abstract_type_1.AbstractType {
    constructor(components, qualifiedName, ddicName, description) {
        super({
            qualifiedName: qualifiedName,
            ddicName: ddicName,
            description: description,
        });
        if (components.length === 0) {
            throw new Error("Structure does not contain any components");
        }
        this.indexed = {};
        for (const c of components) {
            const upper = c.name.toUpperCase();
            if (this.indexed[upper] !== undefined) {
                throw new Error("Structure, duplicate field name \"" + upper + "\", " + qualifiedName);
            }
            this.indexed[upper] = c.type;
        }
        this.components = components;
    }
    getComponents() {
        return this.components;
    }
    getComponentByName(name) {
        return this.indexed[name.toUpperCase()];
    }
    toText(level) {
        const compo = [];
        for (const c of this.components) {
            compo.push(c.name + " TYPE " + c.type.toText(level + 1));
        }
        const spaces = "  ".repeat(level);
        return "Structure\n" + spaces + "* " + compo.join("\n" + spaces + "* ");
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        const ret = this.getQualifiedName();
        if (ret) {
            return ret;
        }
        return "StructureTypetoABAPtodo";
    }
    containsVoid() {
        return this.getComponents().some(c => { return c.type.containsVoid(); });
    }
    toCDS() {
        return "abap.TODO_STRUCTURE";
    }
}
exports.StructureType = StructureType;
//# sourceMappingURL=structure_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/table_type.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/table_type.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableType = exports.TableKeyType = exports.TableAccessType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
var TableAccessType;
(function (TableAccessType) {
    TableAccessType["standard"] = "STANDARD";
    TableAccessType["sorted"] = "SORTED";
    TableAccessType["hashed"] = "HASHED";
    TableAccessType["index"] = "INDEX";
    TableAccessType["any"] = "ANY";
})(TableAccessType || (exports.TableAccessType = TableAccessType = {}));
var TableKeyType;
(function (TableKeyType) {
    TableKeyType["default"] = "DEFAULT";
    TableKeyType["user"] = "USER";
    TableKeyType["empty"] = "EMPTY";
})(TableKeyType || (exports.TableKeyType = TableKeyType = {}));
class TableType extends _abstract_type_1.AbstractType {
    constructor(rowType, options, qualifiedName, description) {
        var _a;
        super({
            qualifiedName: qualifiedName,
            description: description,
        });
        this.rowType = rowType;
        this.options = options;
        if (((_a = options.primaryKey) === null || _a === void 0 ? void 0 : _a.type) === TableAccessType.standard && options.primaryKey.isUnique === true) {
            throw new Error("STANDARD tables cannot have UNIQUE key");
        }
    }
    getOptions() {
        return this.options;
    }
    isWithHeader() {
        return this.options.withHeader;
    }
    getAccessType() {
        var _a;
        return (_a = this.options.primaryKey) === null || _a === void 0 ? void 0 : _a.type;
    }
    getRowType() {
        return this.rowType;
    }
    toABAP() {
        // todo, this is used for downport, so use default key for now
        return "STANDARD TABLE OF " + this.rowType.toABAP() + " WITH DEFAULT KEY";
    }
    toText(level) {
        const type = this.rowType;
        if (this.options.withHeader === true) {
            return "Table with header of " + type.toText(level + 1);
        }
        else {
            return "Table of " + type.toText(level + 1);
        }
    }
    isGeneric() {
        var _a, _b;
        if (((_a = this.options.primaryKey) === null || _a === void 0 ? void 0 : _a.type) !== TableAccessType.standard
            && this.options.keyType === TableKeyType.user
            && ((_b = this.options.primaryKey) === null || _b === void 0 ? void 0 : _b.keyFields.length) === 0) {
            return true;
        }
        return this.rowType.isGeneric();
    }
    containsVoid() {
        return this.rowType.containsVoid();
    }
    toCDS() {
        return "abap.TODO_TABLE";
    }
}
exports.TableType = TableType;
//# sourceMappingURL=table_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/time_type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/time_type.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TimeType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class TimeType extends _abstract_type_1.AbstractType {
    toText() {
        return "```t```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "t";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.tims";
    }
}
exports.TimeType = TimeType;
//# sourceMappingURL=time_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/unknown_type.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class UnknownType extends _abstract_type_1.AbstractType {
    constructor(error, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        this.error = error;
    }
    getError() {
        return this.error;
    }
    toText() {
        return "Unknown type: " + this.error;
    }
    toABAP() {
        throw new Error("unknown, generic: " + this.error);
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_UNKNOWN";
    }
}
exports.UnknownType = UnknownType;
//# sourceMappingURL=unknown_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/utc_long_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/utc_long_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UTCLongType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class UTCLongType extends _abstract_type_1.AbstractType {
    toText() {
        return "```utclong```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "utclong";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.utcl";
    }
}
exports.UTCLongType = UTCLongType;
//# sourceMappingURL=utc_long_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VoidType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class VoidType extends _abstract_type_1.AbstractType {
    constructor(voided, qualifiedName) {
        super({ qualifiedName: qualifiedName });
        this.voided = voided;
    }
    getVoided() {
        return this.voided;
    }
    toABAP() {
        return this.voided || "VOIDEDtoABAP";
    }
    toText() {
        return "Void(" + this.voided + ")";
    }
    isGeneric() {
        return false;
    }
    containsVoid() {
        return true;
    }
    toCDS() {
        return "abap.TODO_VOID";
    }
}
exports.VoidType = VoidType;
//# sourceMappingURL=void_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/xgeneric_type.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/xgeneric_type.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XGenericType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class XGenericType extends _abstract_type_1.AbstractType {
    toText() {
        return "```x```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("x, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_CGENERIC";
    }
}
exports.XGenericType = XGenericType;
//# sourceMappingURL=xgeneric_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/xsequence_type.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/xsequence_type.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XSequenceType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class XSequenceType extends _abstract_type_1.AbstractType {
    toText() {
        return "```xsequence```";
    }
    isGeneric() {
        return true;
    }
    toABAP() {
        throw new Error("xsequence, generic");
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.TODO_XSEQUENCE";
    }
}
exports.XSequenceType = XSequenceType;
//# sourceMappingURL=xsequence_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/basic/xstring_type.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/basic/xstring_type.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XStringType = void 0;
const _abstract_type_1 = __webpack_require__(/*! ./_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
class XStringType extends _abstract_type_1.AbstractType {
    toText() {
        return "```xstring```";
    }
    isGeneric() {
        return false;
    }
    toABAP() {
        return "xstring";
    }
    containsVoid() {
        return false;
    }
    toCDS() {
        return "abap.rawstring";
    }
}
exports.XStringType = XStringType;
//# sourceMappingURL=xstring_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/class_attribute.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/class_attribute.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassAttribute = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ./_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
class ClassAttribute extends _typed_identifier_1.TypedIdentifier {
    constructor(id, visibility, meta, value) {
        super(id.getToken(), id.getFilename(), id.getType(), meta, value);
        this.visibility = visibility;
    }
    getVisibility() {
        return this.visibility;
    }
}
exports.ClassAttribute = ClassAttribute;
//# sourceMappingURL=class_attribute.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/class_attributes.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/class_attributes.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Attributes = void 0;
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const class_attribute_1 = __webpack_require__(/*! ./class_attribute */ "./node_modules/@abaplint/core/build/src/abap/types/class_attribute.js");
const class_constant_1 = __webpack_require__(/*! ./class_constant */ "./node_modules/@abaplint/core/build/src/abap/types/class_constant.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const class_data_1 = __webpack_require__(/*! ../5_syntax/statements/class_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/class_data.js");
const class_data_2 = __webpack_require__(/*! ../5_syntax/structures/class_data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/class_data.js");
const data_1 = __webpack_require__(/*! ../5_syntax/statements/data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/data.js");
const constant_1 = __webpack_require__(/*! ../5_syntax/statements/constant */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/constant.js");
const data_2 = __webpack_require__(/*! ../5_syntax/structures/data */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/data.js");
const type_enum_1 = __webpack_require__(/*! ../5_syntax/structures/type_enum */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/type_enum.js");
const constants_1 = __webpack_require__(/*! ../5_syntax/structures/constants */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/constants.js");
const type_definitions_1 = __webpack_require__(/*! ./type_definitions */ "./node_modules/@abaplint/core/build/src/abap/types/type_definitions.js");
const types_1 = __webpack_require__(/*! ../5_syntax/structures/types */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/structures/types.js");
const type_1 = __webpack_require__(/*! ../5_syntax/statements/type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/statements/type.js");
const _reference_1 = __webpack_require__(/*! ../5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const alias_1 = __webpack_require__(/*! ./alias */ "./node_modules/@abaplint/core/build/src/abap/types/alias.js");
class Attributes {
    constructor(node, input) {
        this.static = [];
        this.instance = [];
        this.constants = [];
        this.aliases = [];
        this.tlist = [];
        this.filename = input.filename;
        this.parse(node, input);
        this.types = new type_definitions_1.TypeDefinitions(this.tlist);
    }
    getTypes() {
        return this.types;
    }
    getStatic() {
        return this.static;
    }
    getAliases() {
        return this.aliases;
    }
    getAll() {
        let res = [];
        res = res.concat(this.static);
        res = res.concat(this.instance);
        return res;
    }
    getStaticsByVisibility(visibility) {
        const attributes = [];
        for (const attr of this.static) {
            if (attr.getVisibility() === visibility) {
                attributes.push(attr);
            }
        }
        return attributes;
    }
    getInstance() {
        return this.instance;
    }
    getInstancesByVisibility(visibility) {
        const attributes = [];
        for (const attr of this.instance) {
            if (attr.getVisibility() === visibility) {
                attributes.push(attr);
            }
        }
        return attributes;
    }
    getConstants() {
        return this.constants;
    }
    getConstantsByVisibility(visibility) {
        const attributes = [];
        for (const attr of this.constants) {
            if (attr.getVisibility() === visibility) {
                attributes.push(attr);
            }
        }
        return attributes;
    }
    // todo, optimize
    findByName(name) {
        const upper = name.toUpperCase();
        for (const a of this.getStatic()) {
            if (a.getName().toUpperCase() === upper) {
                return a;
            }
        }
        for (const a of this.getInstance()) {
            if (a.getName().toUpperCase() === upper) {
                return a;
            }
        }
        for (const a of this.getConstants()) {
            if (a.getName().toUpperCase() === upper) {
                return a;
            }
        }
        return undefined;
    }
    /////////////////////////////
    parse(node, input) {
        const cdef = node.findDirectStructure(Structures.ClassDefinition);
        if (cdef) {
            this.parseSection(cdef.findDirectStructure(Structures.PublicSection), visibility_1.Visibility.Public, input);
            this.parseSection(cdef.findDirectStructure(Structures.ProtectedSection), visibility_1.Visibility.Protected, input);
            this.parseSection(cdef.findDirectStructure(Structures.PrivateSection), visibility_1.Visibility.Private, input);
            return;
        }
        const idef = node.findDirectStructure(Structures.Interface);
        if (idef) {
            this.parseSection(idef.findDirectStructure(Structures.SectionContents), visibility_1.Visibility.Public, input);
            return;
        }
        throw new Error("MethodDefinition, expected ClassDefinition or InterfaceDefinition");
    }
    parseSection(node, visibility, input) {
        if (node === undefined) {
            return;
        }
        for (const c of node.getChildren()) {
            const ctyp = c.get();
            if (c instanceof nodes_1.StructureNode) {
                if (ctyp instanceof Structures.Data) {
                    const found = new data_2.Data().runSyntax(c, input);
                    if (found !== undefined) {
                        const attr = new class_attribute_1.ClassAttribute(found, visibility, found.getMeta(), found.getValue());
                        this.instance.push(attr);
                        input.scope.addIdentifier(attr);
                    }
                }
                else if (ctyp instanceof Structures.ClassData) {
                    const found = new class_data_2.ClassData().runSyntax(c, input);
                    if (found !== undefined) {
                        const attr = new class_attribute_1.ClassAttribute(found, visibility, found.getMeta(), found.getValue());
                        this.static.push(attr);
                        input.scope.addIdentifier(attr);
                    }
                }
                else if (ctyp instanceof Structures.Constants) {
                    const { type: found, values } = new constants_1.Constants().runSyntax(c, input);
                    if (found !== undefined) {
                        const attr = new class_constant_1.ClassConstant(found, visibility, values);
                        this.constants.push(attr);
                        input.scope.addIdentifier(attr);
                    }
                }
                else if (ctyp instanceof Structures.TypeEnum) {
                    const { values, types } = new type_enum_1.TypeEnum().runSyntax(c, input);
                    for (const v of values) {
                        // for now add ENUM values as constants
                        const attr = new class_constant_1.ClassConstant(v, visibility, "novalueClassAttributeEnum");
                        this.constants.push(attr);
                        input.scope.addIdentifier(attr);
                    }
                    for (const t of types) {
                        this.tlist.push({ type: t, visibility });
                        //            scope.addIdentifier(attr);
                    }
                }
                else if (ctyp instanceof Structures.Types) {
                    const res = new types_1.Types().runSyntax(c, input);
                    if (res) {
                        input.scope.addType(res);
                        this.tlist.push({ type: res, visibility });
                    }
                }
                else {
                    // begin recursion
                    this.parseSection(c, visibility, input);
                }
            }
            else if (c instanceof nodes_1.StatementNode) {
                if (ctyp instanceof Statements.Data) {
                    this.instance.push(this.parseAttribute(c, visibility, input));
                }
                else if (ctyp instanceof Statements.ClassData) {
                    this.static.push(this.parseAttribute(c, visibility, input));
                }
                else if (ctyp instanceof Statements.Aliases) {
                    this.parseAlias(c, visibility, input);
                }
                else if (ctyp instanceof Statements.Constant) {
                    const found = new constant_1.Constant().runSyntax(c, input);
                    if (found) {
                        const attr = new class_constant_1.ClassConstant(found, visibility, found.getValue());
                        this.constants.push(attr);
                        input.scope.addIdentifier(attr);
                    }
                }
                else if (ctyp instanceof Statements.Type) {
                    const res = new type_1.Type().runSyntax(c, input);
                    if (res) {
                        input.scope.addType(res);
                        this.tlist.push({ type: res, visibility });
                    }
                }
            }
        }
    }
    parseAlias(node, visibility, input) {
        const aliasName = node.findFirstExpression(Expressions.SimpleName).getFirstToken();
        const compToken = node.findFirstExpression(Expressions.Field).getFirstToken();
        const compName = compToken.getStr();
        this.aliases.push(new alias_1.Alias(aliasName, visibility, compName, this.filename));
        if (compName.includes("~")) {
            const name = compName.split("~")[0];
            const idef = input.scope.findInterfaceDefinition(name);
            if (idef) {
                input.scope.addReference(compToken, idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename, { ooName: name.toUpperCase(), ooType: "INTF" });
                const foundType = idef.getTypeDefinitions().getByName(compName.split("~")[1]);
                if (foundType) {
                    input.scope.addTypeNamed(aliasName.getStr(), foundType);
                }
                const foundAttribute = idef.getAttributes().findByName(compName.split("~")[1]);
                if (foundAttribute) {
                    input.scope.addNamedIdentifier(aliasName.getStr(), foundAttribute);
                }
            }
        }
    }
    parseAttribute(node, visibility, input) {
        let found = undefined;
        const s = node.get();
        if (s instanceof Statements.Data) {
            found = new data_1.Data().runSyntax(node, input);
        }
        else if (s instanceof Statements.ClassData) {
            found = new class_data_1.ClassData().runSyntax(node, input);
        }
        else {
            throw new Error("ClassAttribute, unexpected node, 1, " + this.filename);
        }
        if (found === undefined) {
            throw new Error("ClassAttribute, unexpected node, " + this.filename);
        }
        input.scope.addIdentifier(found);
        return new class_attribute_1.ClassAttribute(found, visibility, found.getMeta(), found.getValue());
    }
}
exports.Attributes = Attributes;
//# sourceMappingURL=class_attributes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/class_constant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/class_constant.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassConstant = void 0;
const _typed_identifier_1 = __webpack_require__(/*! ./_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
class ClassConstant extends _typed_identifier_1.TypedIdentifier {
    constructor(id, visibility, value) {
        super(id.getToken(), id.getFilename(), id.getType(), ["read_only" /* IdentifierMeta.ReadOnly */, "static" /* IdentifierMeta.Static */], value);
        this.visibility = visibility;
    }
    getVisibility() {
        return this.visibility;
    }
}
exports.ClassConstant = ClassConstant;
//# sourceMappingURL=class_constant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/class_definition.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/class_definition.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassDefinition = void 0;
const method_definitions_1 = __webpack_require__(/*! ./method_definitions */ "./node_modules/@abaplint/core/build/src/abap/types/method_definitions.js");
const expressions_1 = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const class_attributes_1 = __webpack_require__(/*! ./class_attributes */ "./node_modules/@abaplint/core/build/src/abap/types/class_attributes.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const _scope_type_1 = __webpack_require__(/*! ../5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const event_definition_1 = __webpack_require__(/*! ./event_definition */ "./node_modules/@abaplint/core/build/src/abap/types/event_definition.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const _object_oriented_1 = __webpack_require__(/*! ../5_syntax/_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _reference_1 = __webpack_require__(/*! ../5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class ClassDefinition extends _identifier_1.Identifier {
    constructor(node, input) {
        if (!(node.get() instanceof Structures.ClassDefinition)) {
            throw new Error("ClassDefinition, unexpected node type");
        }
        const def = node.findFirstStatement(Statements.ClassDefinition);
        const name = def.findDirectExpression(Expressions.ClassName).getFirstToken();
        super(name, input.filename);
        input.scope.addClassDefinition(this);
        this.events = [];
        this.implementing = [];
        this.globalValue = def.findFirstExpression(Expressions.ClassGlobal) !== undefined;
        this.finalValue = def.findFirstExpression(Expressions.ClassFinal) !== undefined;
        input.scope.push(_scope_type_1.ScopeType.ClassDefinition, name.getStr(), name.getStart(), input.filename);
        this.superClass = this.findSuper(def, input);
        this.friends = this.findFriends(def, input);
        this.parse(input, node);
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        helper.fromSuperClassesAndInterfaces(this);
        this.attributes = new class_attributes_1.Attributes(node, input);
        this.types = this.attributes.getTypes();
        this.aliases = this.attributes.getAliases();
        const events = node.findAllStatements(Statements.Events);
        for (const e of events) {
            this.events.push(new event_definition_1.EventDefinition(e, visibility_1.Visibility.Public, input)); // todo, all these are not Public
        }
        this.methodDefs = new method_definitions_1.MethodDefinitions(node, input);
        input.scope.pop(node.getLastToken().getEnd());
        const concat = def.concatTokens().toUpperCase();
        this.testing = concat.includes(" FOR TESTING");
        this.sharedMemory = concat.includes(" SHARED MEMORY ENABLED");
        this.abstract = (def === null || def === void 0 ? void 0 : def.findDirectTokenByText("ABSTRACT")) !== undefined;
        // perform checks after everything has been initialized
        this.checkMethodsFromSuperClasses(input.scope);
    }
    getFriends() {
        return this.friends;
    }
    getEvents() {
        return this.events;
    }
    getMethodDefinitions() {
        return this.methodDefs;
    }
    getTypeDefinitions() {
        return this.types;
    }
    getSuperClass() {
        return this.superClass;
    }
    getAttributes() {
        return this.attributes;
    }
    isGlobal() {
        return this.globalValue;
    }
    isFinal() {
        return this.finalValue;
    }
    getImplementing() {
        return this.implementing;
    }
    getAliases() {
        return this.aliases;
    }
    isForTesting() {
        return this.testing;
    }
    isAbstract() {
        return this.abstract;
    }
    isSharedMemory() {
        return this.sharedMemory;
    }
    /*
      public getEvents() {
      }
    */
    ///////////////////
    findSuper(def, input) {
        var _a;
        const token = (_a = def === null || def === void 0 ? void 0 : def.findDirectExpression(expressions_1.SuperClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        this.addReference(token, input);
        const name = token === null || token === void 0 ? void 0 : token.getStr();
        return name;
    }
    checkMethodsFromSuperClasses(scope) {
        var _a;
        let sup = this.getSuperClass();
        const names = new Set();
        while (sup !== undefined) {
            const cdef = scope.findClassDefinition(sup);
            for (const m of ((_a = cdef === null || cdef === void 0 ? void 0 : cdef.getMethodDefinitions()) === null || _a === void 0 ? void 0 : _a.getAll()) || []) {
                const name = m.getName().toUpperCase();
                if (m.getVisibility() === visibility_1.Visibility.Private) {
                    continue;
                }
                else if (name === "CONSTRUCTOR" || name === "CLASS_CONSTRUCTOR") {
                    continue;
                }
                names.add(name);
            }
            for (const a of (cdef === null || cdef === void 0 ? void 0 : cdef.getAliases()) || []) {
                names.add(a.getName().toUpperCase());
            }
            sup = cdef === null || cdef === void 0 ? void 0 : cdef.getSuperClass();
        }
        for (const m of this.getMethodDefinitions().getAll()) {
            if (names.has(m.getName().toUpperCase()) && m.isRedefinition() === false) {
                throw new Error(`${m.getName().toUpperCase()} already declared in superclass`);
            }
        }
    }
    findFriends(def, input) {
        var _a;
        const result = [];
        for (const n of ((_a = def === null || def === void 0 ? void 0 : def.findDirectExpression(Expressions.ClassFriends)) === null || _a === void 0 ? void 0 : _a.findDirectExpressions(Expressions.ClassName)) || []) {
            const token = n.getFirstToken();
            this.addReference(token, input);
            const name = token.getStr();
            result.push(name);
        }
        return result;
    }
    addReference(token, input) {
        const name = token === null || token === void 0 ? void 0 : token.getStr();
        if (name) {
            const s = input.scope.findClassDefinition(name);
            if (s) {
                input.scope.addReference(token, s, _reference_1.ReferenceType.ObjectOrientedReference, input.filename, { ooName: name.toUpperCase(), ooType: "CLAS" });
            }
            else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename);
            }
        }
    }
    parse(input, inputNode) {
        var _a;
        for (const node of inputNode.findAllStatements(Statements.InterfaceDef)) {
            const partial = node.findDirectTokenByText("PARTIALLY") !== undefined;
            const token = (_a = node.findFirstExpression(Expressions.InterfaceName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            if (token === undefined) {
                throw new Error("ClassDefinition, unable to find interface token");
            }
            const name = token.getStr().toUpperCase();
            this.implementing.push({ name, partial });
            const intf = input.scope.findInterfaceDefinition(name);
            if (intf) {
                input.scope.addReference(token, intf, _reference_1.ReferenceType.ObjectOrientedReference, input.filename, { ooName: name.toUpperCase(), ooType: "INTF" });
            }
            else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, { ooName: name.toUpperCase(), ooType: "INTF" });
            }
            else {
                input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedUnknownReference, input.filename, { ooName: name.toUpperCase(), ooType: "INTF" });
            }
        }
    }
}
exports.ClassDefinition = ClassDefinition;
//# sourceMappingURL=class_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/class_implementation.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/class_implementation.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassImplementation = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_implementation_1 = __webpack_require__(/*! ./method_implementation */ "./node_modules/@abaplint/core/build/src/abap/types/method_implementation.js");
class ClassImplementation extends _identifier_1.Identifier {
    constructor(node, filename) {
        if (!(node.get() instanceof Structures.ClassImplementation)) {
            throw new Error("ClassImplementation, unexpected node type");
        }
        const name = node.findFirstStatement(Statements.ClassImplementation).findFirstExpression(Expressions.ClassName).getFirstToken();
        super(name, filename);
        this.node = node;
    }
    getMethodImplementations() {
        const ret = [];
        for (const method of this.node.findAllStructures(Structures.Method)) {
            ret.push(new method_implementation_1.MethodImplementation(method, this.filename));
        }
        return ret;
    }
    getMethodImplementation(name) {
        for (const impl of this.getMethodImplementations()) {
            if (impl.getName().toUpperCase() === name.toUpperCase()) {
                return impl;
            }
        }
        return undefined;
    }
}
exports.ClassImplementation = ClassImplementation;
//# sourceMappingURL=class_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/event_definition.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/event_definition.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventDefinition = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const events_1 = __webpack_require__(/*! ../2_statements/statements/events */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/events.js");
const expressions_1 = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_param_1 = __webpack_require__(/*! ../5_syntax/expressions/method_param */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_param.js");
class EventDefinition extends _identifier_1.Identifier {
    constructor(node, _visibility, input) {
        if (!(node.get() instanceof events_1.Events)) {
            throw new Error("MethodDefinition, expected MethodDef as part of input node");
        }
        const found = node.findFirstExpression(Expressions.EventName);
        if (found === undefined) {
            throw new Error("MethodDefinition, expected MethodDef as part of input node");
        }
        super(found.getFirstToken(), input.filename);
        this.parameters = [];
        this.parse(node, input);
    }
    getParameters() {
        return this.parameters;
    }
    ///////////////
    parse(node, input) {
        for (const e of node.findAllExpressions(expressions_1.MethodParam)) {
            this.parameters.push(new method_param_1.MethodParam().runSyntax(e, input, []));
        }
    }
}
exports.EventDefinition = EventDefinition;
//# sourceMappingURL=event_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/form_definition.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/form_definition.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormDefinition = void 0;
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Tokens = __webpack_require__(/*! ../1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ./_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const form_param_1 = __webpack_require__(/*! ../5_syntax/expressions/form_param */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/form_param.js");
const basic_1 = __webpack_require__(/*! ./basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class FormDefinition extends _identifier_1.Identifier {
    constructor(node, input) {
        const st = node instanceof nodes_1.StructureNode ? node.findFirstStatement(Statements.Form) : node;
        // FORMs can contain a dash in the name
        const formName = st.findFirstExpression(Expressions.FormName);
        const pos = formName.getFirstToken().getStart();
        const name = formName.concatTokens();
        const nameToken = new Tokens.Identifier(pos, name);
        super(nameToken, input.filename);
        this.node = st;
        this.tableParameters = this.findTables(input);
        this.usingParameters = this.findType(Expressions.FormUsing, input);
        this.changingParameters = this.findType(Expressions.FormChanging, input);
    }
    getTablesParameters() {
        return this.tableParameters;
    }
    getUsingParameters() {
        return this.usingParameters;
    }
    getChangingParameters() {
        return this.changingParameters;
    }
    ///////////////
    findTables(input) {
        const ret = [];
        const tables = this.node.findFirstExpression(Expressions.FormTables);
        if (tables === undefined) {
            return [];
        }
        for (const param of tables.findAllExpressions(Expressions.FormParam)) {
            if (param.getChildren().length === 1) {
                // untyped TABLES parameter
                ret.push(new _typed_identifier_1.TypedIdentifier(param.getFirstToken(), input.filename, new basic_1.VoidType("FORM:UNTYPED"), ["form_parameter" /* IdentifierMeta.FormParameter */]));
            }
            else {
                const p = new form_param_1.FormParam().runSyntax(param, input);
                let type = p.getType();
                const isStructure = param.findDirectTokenByText("STRUCTURE") !== undefined;
                if (isStructure) {
                    type = new basic_1.TableType(type, { withHeader: true, keyType: basic_1.TableKeyType.default });
                }
                if (type instanceof basic_1.TableType) {
                    type = new basic_1.TableType(type.getRowType(), { withHeader: true, keyType: basic_1.TableKeyType.default });
                }
                else if (!(type instanceof basic_1.UnknownType) && !(type instanceof basic_1.VoidType)) {
                    type = new basic_1.UnknownType("FORM TABLES type must be table type");
                }
                ret.push(new _typed_identifier_1.TypedIdentifier(p.getToken(), input.filename, type, ["form_parameter" /* IdentifierMeta.FormParameter */]));
            }
        }
        return ret;
    }
    findType(type, input) {
        const found = this.node.findFirstExpression(type);
        if (found === undefined) {
            return [];
        }
        return this.findParams(found, input);
    }
    findParams(node, input) {
        const res = [];
        for (const param of node.findAllExpressions(Expressions.FormParam)) {
            const p = new form_param_1.FormParam().runSyntax(param, input);
            res.push(p);
        }
        return res;
    }
}
exports.FormDefinition = FormDefinition;
//# sourceMappingURL=form_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/function_module_definition.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/function_module_definition.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionModuleDefinition = exports.FunctionModuleParameterDirection = void 0;
const xml_utils_1 = __webpack_require__(/*! ../../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
var FunctionModuleParameterDirection;
(function (FunctionModuleParameterDirection) {
    FunctionModuleParameterDirection["importing"] = "importing";
    FunctionModuleParameterDirection["exporting"] = "exporting";
    FunctionModuleParameterDirection["changing"] = "changing";
    FunctionModuleParameterDirection["tables"] = "tables";
})(FunctionModuleParameterDirection || (exports.FunctionModuleParameterDirection = FunctionModuleParameterDirection = {}));
class FunctionModuleDefinition {
    constructor(data) {
        this.parse(data);
    }
    getParameters() {
        return this.parameters;
    }
    getDescription() {
        return this.description;
    }
    getName() {
        return this.name;
    }
    ///////////////
    parse(data) {
        if (data.FUNCNAME === undefined) {
            throw new Error("Function module name undefined");
        }
        this.name = data.FUNCNAME;
        this.description = data.SHORT_TEXT;
        this.parameters = [];
        if (data.IMPORT) {
            for (const param of (0, xml_utils_1.xmlToArray)(data.IMPORT.RSIMP)) {
                if (param.PARAMETER === undefined) {
                    throw new Error("Function module name parameter undefined, importing");
                }
                this.parameters.push({
                    name: param.PARAMETER,
                    direction: FunctionModuleParameterDirection.importing,
                    type: param.TYP || param.DBFIELD,
                    optional: param.OPTIONAL === "X",
                    defaultValue: param.DEFAULT,
                });
            }
        }
        if (data.CHANGING) {
            for (const param of (0, xml_utils_1.xmlToArray)(data.CHANGING.RSCHA)) {
                if (param.PARAMETER === undefined) {
                    throw new Error("Function module name parameter undefined, changing");
                }
                this.parameters.push({
                    name: param.PARAMETER,
                    direction: FunctionModuleParameterDirection.changing,
                    type: param.TYP || param.DBFIELD,
                    optional: param.OPTIONAL === "X",
                    defaultValue: param.DEFAULT,
                });
            }
        }
        if (data.EXPORT) {
            for (const param of (0, xml_utils_1.xmlToArray)(data.EXPORT.RSEXP)) {
                if (param.PARAMETER === undefined) {
                    throw new Error("Function module name parameter undefined, exporting");
                }
                this.parameters.push({
                    name: param.PARAMETER,
                    direction: FunctionModuleParameterDirection.exporting,
                    type: param.TYP || param.DBFIELD,
                    optional: true,
                    defaultValue: undefined,
                });
            }
        }
        if (data.TABLES) {
            for (const param of (0, xml_utils_1.xmlToArray)(data.TABLES.RSTBL)) {
                if (param.PARAMETER === undefined) {
                    throw new Error("Function module name parameter undefined, tables");
                }
                this.parameters.push({
                    name: param.PARAMETER,
                    direction: FunctionModuleParameterDirection.tables,
                    // table types are stored in TYP
                    type: param.DBSTRUCT || param.TYP,
                    optional: param.OPTIONAL === "X",
                    defaultValue: undefined,
                });
            }
        }
    }
}
exports.FunctionModuleDefinition = FunctionModuleDefinition;
//# sourceMappingURL=function_module_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/index.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./class_attribute */ "./node_modules/@abaplint/core/build/src/abap/types/class_attribute.js"), exports);
__exportStar(__webpack_require__(/*! ./class_attributes */ "./node_modules/@abaplint/core/build/src/abap/types/class_attributes.js"), exports);
__exportStar(__webpack_require__(/*! ./class_constant */ "./node_modules/@abaplint/core/build/src/abap/types/class_constant.js"), exports);
__exportStar(__webpack_require__(/*! ./class_definition */ "./node_modules/@abaplint/core/build/src/abap/types/class_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./class_implementation */ "./node_modules/@abaplint/core/build/src/abap/types/class_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./form_definition */ "./node_modules/@abaplint/core/build/src/abap/types/form_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./function_module_definition */ "./node_modules/@abaplint/core/build/src/abap/types/function_module_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./interface_definition */ "./node_modules/@abaplint/core/build/src/abap/types/interface_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./method_definition */ "./node_modules/@abaplint/core/build/src/abap/types/method_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./method_definitions */ "./node_modules/@abaplint/core/build/src/abap/types/method_definitions.js"), exports);
__exportStar(__webpack_require__(/*! ./method_implementation */ "./node_modules/@abaplint/core/build/src/abap/types/method_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/types/method_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./type_definitions */ "./node_modules/@abaplint/core/build/src/abap/types/type_definitions.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/interface_definition.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/interface_definition.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InterfaceDefinition = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const class_attributes_1 = __webpack_require__(/*! ./class_attributes */ "./node_modules/@abaplint/core/build/src/abap/types/class_attributes.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const _scope_type_1 = __webpack_require__(/*! ../5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const event_definition_1 = __webpack_require__(/*! ./event_definition */ "./node_modules/@abaplint/core/build/src/abap/types/event_definition.js");
const method_definitions_1 = __webpack_require__(/*! ./method_definitions */ "./node_modules/@abaplint/core/build/src/abap/types/method_definitions.js");
const _reference_1 = __webpack_require__(/*! ../5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _object_oriented_1 = __webpack_require__(/*! ../5_syntax/_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
class InterfaceDefinition extends _identifier_1.Identifier {
    constructor(node, input) {
        if (!(node.get() instanceof Structures.Interface)) {
            throw new Error("InterfaceDefinition, unexpected node type");
        }
        const name = node.findFirstStatement(Statements.Interface).findFirstExpression(Expressions.InterfaceName).getFirstToken();
        super(name, input.filename);
        input.scope.addInterfaceDefinition(this);
        this.events = [];
        this.implementing = [];
        this.globalValue = node.findFirstExpression(Expressions.ClassGlobal) !== undefined;
        input.scope.push(_scope_type_1.ScopeType.Interface, name.getStr(), node.getFirstToken().getStart(), input.filename);
        this.parse(input, node);
        input.scope.pop(node.getLastToken().getEnd());
    }
    getSuperClass() {
        return undefined;
    }
    getImplementing() {
        return this.implementing;
    }
    getAliases() {
        return this.aliases;
    }
    getEvents() {
        return this.events;
    }
    getAttributes() {
        return this.attributes;
    }
    getTypeDefinitions() {
        return this.typeDefinitions;
    }
    isLocal() {
        return !this.globalValue;
    }
    isGlobal() {
        return this.globalValue;
    }
    getMethodDefinitions() {
        return this.methodDefinitions;
    }
    /////////////////
    checkInterfacesExists(input, node) {
        var _a;
        for (const i of node.findAllStatements(Statements.InterfaceDef)) {
            const token = (_a = i.findDirectExpression(Expressions.InterfaceName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            const name = token === null || token === void 0 ? void 0 : token.getStr();
            if (name) {
                this.implementing.push({ name, partial: false });
                const idef = input.scope.findInterfaceDefinition(name);
                if (idef) {
                    input.scope.addReference(token, idef, _reference_1.ReferenceType.ObjectOrientedReference, this.filename, { ooName: name.toUpperCase(), ooType: "INTF" });
                }
                else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                    input.scope.addReference(token, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, this.filename);
                }
                else {
                    throw new Error("Interface " + name + " unknown");
                }
            }
        }
    }
    parse(input, node) {
        this.checkInterfacesExists(input, node);
        const helper = new _object_oriented_1.ObjectOriented(input.scope);
        helper.fromInterfaces(this);
        // todo, proper sequencing, the statements should be processed line by line
        this.attributes = new class_attributes_1.Attributes(node, input);
        this.typeDefinitions = this.attributes.getTypes();
        this.aliases = this.attributes.getAliases();
        const events = node.findAllStatements(Statements.Events);
        for (const e of events) {
            this.events.push(new event_definition_1.EventDefinition(e, visibility_1.Visibility.Public, input));
        }
        this.methodDefinitions = new method_definitions_1.MethodDefinitions(node, input);
        if (this.methodDefinitions.getByName("CONSTRUCTOR") !== undefined) {
            throw new Error("Interfaces cannot have constructor methods");
        }
    }
}
exports.InterfaceDefinition = InterfaceDefinition;
//# sourceMappingURL=interface_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/message.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/message.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Message = void 0;
class Message {
    constructor(number, message) {
        this.number = number;
        if (this.number === undefined) {
            this.number = "";
        }
        this.message = message;
        if (this.message === undefined) {
            this.message = "";
        }
    }
    getNumber() {
        return this.number;
    }
    getMessage() {
        return this.message;
    }
    getPlaceholderCount() {
        const escaped = (this.getMessage().match(/&&/g) || []).length;
        return (this.getMessage().match(/&/g) || []).length - escaped * 2;
    }
}
exports.Message = Message;
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/method_definition.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/method_definition.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefinition = void 0;
const statements_1 = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const method_parameters_1 = __webpack_require__(/*! ./method_parameters */ "./node_modules/@abaplint/core/build/src/abap/types/method_parameters.js");
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const _reference_1 = __webpack_require__(/*! ../5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class MethodDefinition extends _identifier_1.Identifier {
    // todo: final flag
    constructor(node, visibility, input) {
        var _a, _b;
        if (!(node.get() instanceof statements_1.MethodDef)) {
            throw new Error("MethodDefinition, expected MethodDef as part of input node");
        }
        const found = node.findDirectExpression(Expressions.MethodName);
        if (found === undefined) {
            throw new Error("MethodDefinition, expected MethodDef as part of input node");
        }
        super(found.getFirstToken(), input.filename);
        this.redefinition = false;
        if (node.findDirectExpression(Expressions.Redefinition)) {
            this.redefinition = true;
            const name = found.getFirstToken().getStr();
            if (name.includes("~")) {
                const idef = input.scope.findInterfaceDefinition(name.split("~")[0]);
                if (idef) {
                    input.scope.addReference(found.getFirstToken(), idef, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
                }
            }
        }
        this.eventHandler = false;
        if (node.findDirectExpression(Expressions.EventHandler)) {
            this.eventHandler = true;
        }
        this.abstract = false;
        if (node.findDirectExpression(Expressions.Abstract)) {
            this.abstract = true;
        }
        this.static = false;
        // checks for "CLASS-METHODS"
        if (node.getFirstToken().getStr().toUpperCase().startsWith("CLASS")) {
            this.static = true;
        }
        this.raising = [];
        for (const r of ((_a = node.findDirectExpression(Expressions.MethodDefRaising)) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.ClassName)) || []) {
            const token = r.getFirstToken();
            const name = token.getStr();
            this.raising.push(name);
            const clas = input.scope.findClassDefinition(name);
            if (clas) {
                input.scope.addReference(token, clas, _reference_1.ReferenceType.ObjectOrientedReference, input.filename, { ooName: name.toUpperCase(), ooType: "CLAS" });
            }
            else if (input.scope.getDDIC().inErrorNamespace(name) === false) {
                input.scope.addReference(token, clas, _reference_1.ReferenceType.ObjectOrientedVoidReference, input.filename, { ooName: name.toUpperCase(), ooType: "CLAS" });
            }
            else {
                input.scope.addReference(token, clas, _reference_1.ReferenceType.ObjectOrientedUnknownReference, input.filename, { ooName: name.toUpperCase(), ooType: "CLAS" });
            }
        }
        this.exceptions = [];
        for (const r of ((_b = node.findDirectExpression(Expressions.MethodDefExceptions)) === null || _b === void 0 ? void 0 : _b.findAllExpressions(Expressions.NamespaceSimpleName)) || []) {
            const token = r.getFirstToken();
            const name = token.getStr();
            this.exceptions.push(name);
        }
        this.visibility = visibility;
        this.parameters = new method_parameters_1.MethodParameters(node, input, this.abstract);
    }
    getVisibility() {
        return this.visibility;
    }
    isRedefinition() {
        return this.redefinition;
    }
    isAbstract() {
        return this.abstract;
    }
    isStatic() {
        return this.static;
    }
    isEventHandler() {
        return this.eventHandler;
    }
    getParameters() {
        return this.parameters;
    }
    getRaising() {
        return this.raising;
    }
    getExceptions() {
        return this.exceptions;
    }
}
exports.MethodDefinition = MethodDefinition;
//# sourceMappingURL=method_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/method_definitions.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/method_definitions.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodDefinitions = void 0;
const method_definition_1 = __webpack_require__(/*! ./method_definition */ "./node_modules/@abaplint/core/build/src/abap/types/method_definition.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const statements_1 = __webpack_require__(/*! ../2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const visibility_1 = __webpack_require__(/*! ../4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
class MethodDefinitions {
    constructor(node, input) {
        this.all = {};
        this.all = {};
        this.parse(node, input);
    }
    *getAll() {
        for (const a in this.all) {
            yield this.all[a];
        }
    }
    getByName(name) {
        if (name === undefined) {
            return undefined;
        }
        return this.all[name.toUpperCase()];
    }
    ///////////////////////
    parseInterface(node, input) {
        const defs = node.findAllStatements(statements_1.MethodDef);
        for (const def of defs) {
            const m = new method_definition_1.MethodDefinition(def, visibility_1.Visibility.Public, input);
            this.all[m.getName().toUpperCase()] = m;
        }
    }
    parse(node, input) {
        const idef = node.findDirectStructure(Structures.Interface);
        if (idef) {
            return this.parseInterface(node, input);
        }
        const cdef = node.findDirectStructure(Structures.ClassDefinition);
        if (!cdef) {
            throw new Error("MethodDefinitions, expected ClassDefinition as part of input node");
        }
        const pri = cdef.findDirectStructure(Structures.PrivateSection);
        for (const def of (pri === null || pri === void 0 ? void 0 : pri.findAllStatements(statements_1.MethodDef)) || []) {
            const m = new method_definition_1.MethodDefinition(def, visibility_1.Visibility.Private, input);
            this.all[m.getName().toUpperCase()] = m;
        }
        const pro = node.findDirectStructure(Structures.ProtectedSection);
        for (const def of (pro === null || pro === void 0 ? void 0 : pro.findAllStatements(statements_1.MethodDef)) || []) {
            const m = new method_definition_1.MethodDefinition(def, visibility_1.Visibility.Protected, input);
            this.all[m.getName().toUpperCase()] = m;
        }
        const pub = node.findDirectStructure(Structures.PublicSection);
        for (const def of (pub === null || pub === void 0 ? void 0 : pub.findAllStatements(statements_1.MethodDef)) || []) {
            const m = new method_definition_1.MethodDefinition(def, visibility_1.Visibility.Public, input);
            this.all[m.getName().toUpperCase()] = m;
        }
    }
}
exports.MethodDefinitions = MethodDefinitions;
//# sourceMappingURL=method_definitions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/method_implementation.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/method_implementation.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodImplementation = void 0;
const _identifier_1 = __webpack_require__(/*! ../4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const Structures = __webpack_require__(/*! ../3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class MethodImplementation extends _identifier_1.Identifier {
    constructor(node, filename) {
        if (!(node.get() instanceof Structures.Method)) {
            throw new Error("MethodImplementation, expected Method as part of input node");
        }
        const found = node.findFirstExpression(Expressions.MethodName);
        if (found === undefined) {
            throw new Error("MethodImplementation, expected MethodName as part of input node");
        }
        super(found.getFirstToken(), filename);
    }
}
exports.MethodImplementation = MethodImplementation;
//# sourceMappingURL=method_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/method_parameters.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/method_parameters.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParameters = void 0;
const method_def_1 = __webpack_require__(/*! ../2_statements/statements/method_def */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/method_def.js");
const Expressions = __webpack_require__(/*! ../2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const nodes_1 = __webpack_require__(/*! ../nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ./_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ./basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const method_def_returning_1 = __webpack_require__(/*! ../5_syntax/expressions/method_def_returning */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_def_returning.js");
const method_param_1 = __webpack_require__(/*! ../5_syntax/expressions/method_param */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/expressions/method_param.js");
const _object_oriented_1 = __webpack_require__(/*! ../5_syntax/_object_oriented */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_object_oriented.js");
const _reference_1 = __webpack_require__(/*! ../5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const identifier_1 = __webpack_require__(/*! ../1_lexer/tokens/identifier */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js");
const _scope_type_1 = __webpack_require__(/*! ../5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
// todo:
// this.exceptions = [];
// also consider RAISING vs EXCEPTIONS
class MethodParameters {
    constructor(node, input, abstractMethod) {
        if (!(node.get() instanceof method_def_1.MethodDef)) {
            throw new Error("MethodDefinition, expected MethodDef as part of input node");
        }
        this.importing = [];
        this.exporting = [];
        this.changing = [];
        this.optional = [];
        this.defaults = {};
        this.returning = undefined;
        this.preferred = undefined;
        this.exceptions = [];
        this.filename = input.filename;
        // need the scope for LIKE typing inside method parameters
        const parentName = input.scope.getName();
        input.scope.push(_scope_type_1.ScopeType.MethodDefinition, "method definition", node.getStart(), input.filename);
        this.parse(node, input, parentName, abstractMethod);
        input.scope.pop(node.getEnd());
    }
    getFilename() {
        return this.filename;
    }
    getOptional() {
        return this.optional;
    }
    getAll() {
        const ret = [];
        const returning = this.getReturning();
        if (returning) {
            ret.push(returning);
        }
        ret.push(...this.getImporting());
        ret.push(...this.getExporting());
        ret.push(...this.getChanging());
        return ret;
    }
    getDefaultImporting() {
        if (this.importing.length === 0) {
            return undefined;
        }
        else if (this.importing.length === 1) {
            return this.importing[0].getName().toUpperCase();
        }
        else if (this.preferred) {
            return this.preferred;
        }
        let candidates = this.importing.map(i => i.getName().toUpperCase());
        candidates = candidates.filter(c => this.optional.indexOf(c) < 0);
        if (candidates.length === 1) {
            return candidates[0];
        }
        return undefined;
    }
    getImporting() {
        return this.importing;
    }
    getRequiredParameters() {
        var _a;
        const ret = [];
        for (const i of this.getImporting()) {
            if (this.getOptional().some(o => o.toUpperCase() === i.getName().toUpperCase()) === true) {
                continue;
            }
            else if (((_a = this.preferred) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === i.getName().toUpperCase()) {
                continue;
            }
            ret.push(i);
        }
        for (const i of this.getChanging()) {
            if (this.getOptional().some(o => o.toUpperCase() === i.getName().toUpperCase()) === true) {
                continue;
            }
            ret.push(i);
        }
        return ret;
    }
    getExporting() {
        return this.exporting;
    }
    getChanging() {
        return this.changing;
    }
    getReturning() {
        return this.returning;
    }
    getExceptions() {
        return this.exceptions;
    }
    getParameterDefault(parameter) {
        return this.defaults[parameter.toUpperCase()];
    }
    ///////////////////
    parse(node, input, parentName, abstractMethod) {
        var _a, _b;
        const handler = node.findFirstExpression(Expressions.EventHandler);
        if (handler) {
            const nameToken = (_a = node.findFirstExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            const ooName = nameToken === null || nameToken === void 0 ? void 0 : nameToken.getStr();
            const def = input.scope.findObjectDefinition(ooName);
            const doVoid = def ? false : !input.scope.getDDIC().inErrorNamespace(ooName);
            if (def) {
                input.scope.addReference(nameToken, def, _reference_1.ReferenceType.ObjectOrientedReference, input.filename);
            }
            else if (doVoid && ooName) {
                input.scope.addReference(nameToken, undefined, _reference_1.ReferenceType.ObjectOrientedVoidReference, this.filename, { ooName: ooName.toUpperCase() });
            }
            const eventName = (_b = node.findFirstExpression(Expressions.EventName)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr();
            const event = new _object_oriented_1.ObjectOriented(input.scope).searchEvent(def, eventName);
            for (const p of handler.findAllExpressions(Expressions.MethodParamName)) {
                const token = p.getFirstToken();
                const search = token.getStr().toUpperCase().replace("!", "");
                this.optional.push(search); // all parameters optional for event handlers
                if (search === "SENDER" && def) {
                    this.importing.push(new _typed_identifier_1.TypedIdentifier(token, this.filename, new basic_1.ObjectReferenceType(def), ["event_parameter" /* IdentifierMeta.EventParameter */]));
                    continue;
                }
                const found = event === null || event === void 0 ? void 0 : event.getParameters().find(p => p.getName().toUpperCase() === search);
                if (found) {
                    this.importing.push(new _typed_identifier_1.TypedIdentifier(token, this.filename, found.getType(), ["event_parameter" /* IdentifierMeta.EventParameter */]));
                }
                else if (doVoid) {
                    this.importing.push(new _typed_identifier_1.TypedIdentifier(token, this.filename, new basic_1.VoidType(ooName), ["event_parameter" /* IdentifierMeta.EventParameter */]));
                }
                else {
                    const type = new basic_1.UnknownType(`handler parameter not found "${search}"`);
                    this.importing.push(new _typed_identifier_1.TypedIdentifier(token, this.filename, type, ["event_parameter" /* IdentifierMeta.EventParameter */]));
                }
            }
            return;
        }
        const importing = node.findFirstExpression(Expressions.MethodDefImporting);
        if (importing) {
            this.add(this.importing, importing, input, ["importing" /* IdentifierMeta.MethodImporting */], abstractMethod);
            if (importing.findDirectTokenByText("PREFERRED")) {
                this.preferred = importing.getLastToken().getStr().toUpperCase();
                if (this.preferred.startsWith("!")) {
                    this.preferred = this.preferred.substring(1);
                }
            }
        }
        const exporting = node.findFirstExpression(Expressions.MethodDefExporting);
        if (exporting) {
            this.add(this.exporting, exporting, input, ["exporting" /* IdentifierMeta.MethodExporting */], abstractMethod);
        }
        const changing = node.findFirstExpression(Expressions.MethodDefChanging);
        if (changing) {
            this.add(this.changing, changing, input, ["changing" /* IdentifierMeta.MethodChanging */], abstractMethod);
        }
        const returning = node.findFirstExpression(Expressions.MethodDefReturning);
        if (returning) {
            this.returning = new method_def_returning_1.MethodDefReturning().runSyntax(returning, input, ["returning" /* IdentifierMeta.MethodReturning */]);
        }
        this.workaroundRAP(node, input, parentName);
    }
    workaroundRAP(node, input, parentName) {
        const resultName = node.findExpressionAfterToken("RESULT");
        const isRap = node.findExpressionAfterToken("IMPORTING");
        if (isRap) {
            for (const foo of node.findDirectExpressions(Expressions.MethodParamName)) {
                if (foo === resultName) {
                    continue;
                }
                this.importing.push(new _typed_identifier_1.TypedIdentifier(foo.getFirstToken(), input.filename, new basic_1.VoidType("RapMethodParameter"), ["importing" /* IdentifierMeta.MethodImporting */]));
            }
            const concat = node.concatTokens().toUpperCase();
            if (concat.includes(" FOR VALIDATE ")
                || concat.includes(" FOR BEHAVIOR ")
                || concat.includes(" FOR FEATURES ")
                || concat.includes(" FOR MODIFY ")) {
                const token = isRap.getFirstToken();
                this.exporting.push(new _typed_identifier_1.TypedIdentifier(new identifier_1.Identifier(token.getStart(), "failed"), input.filename, new basic_1.VoidType("RapMethodParameter"), ["exporting" /* IdentifierMeta.MethodExporting */]));
                this.exporting.push(new _typed_identifier_1.TypedIdentifier(new identifier_1.Identifier(token.getStart(), "mapped"), input.filename, new basic_1.VoidType("RapMethodParameter"), ["exporting" /* IdentifierMeta.MethodExporting */]));
                this.exporting.push(new _typed_identifier_1.TypedIdentifier(new identifier_1.Identifier(token.getStart(), "reported"), input.filename, new basic_1.VoidType("RapMethodParameter"), ["exporting" /* IdentifierMeta.MethodExporting */]));
            }
        }
        if (resultName) {
            const token = resultName.getFirstToken();
            this.importing.push(new _typed_identifier_1.TypedIdentifier(token, input.filename, new basic_1.VoidType("RapMethodParameter"), ["exporting" /* IdentifierMeta.MethodExporting */]));
        }
        // its some kind of magic
        if (parentName.toUpperCase() === "CL_ABAP_BEHAVIOR_SAVER") {
            const tempChanging = this.changing.map(c => new _typed_identifier_1.TypedIdentifier(c.getToken(), input.filename, new basic_1.VoidType("RapMethodParameter"), c.getMeta()));
            while (this.changing.length > 0) {
                this.changing.shift();
            }
            this.changing.push(...tempChanging);
            const tempImporting = this.importing.map(c => new _typed_identifier_1.TypedIdentifier(c.getToken(), input.filename, new basic_1.VoidType("RapMethodParameter"), c.getMeta()));
            while (this.importing.length > 0) {
                this.importing.shift();
            }
            this.importing.push(...tempImporting);
        }
    }
    add(target, source, input, meta, abstractMethod) {
        var _a, _b;
        for (const opt of source.findAllExpressions(Expressions.MethodParamOptional)) {
            const p = opt.findDirectExpression(Expressions.MethodParam);
            if (p === undefined) {
                continue;
            }
            const extraMeta = [];
            if (p.getFirstToken().getStr().toUpperCase() === "VALUE" && ((_a = p.getChildren()[1]) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr()) === "(") {
                extraMeta.push("pass_by_value" /* IdentifierMeta.PassByValue */);
            }
            else if (meta.includes("importing" /* IdentifierMeta.MethodImporting */)) {
                extraMeta.push("read_only" /* IdentifierMeta.ReadOnly */);
            }
            if (abstractMethod === true) {
                extraMeta.push("abstract" /* IdentifierMeta.Abstract */);
            }
            const id = new method_param_1.MethodParam().runSyntax(p, input, [...meta, ...extraMeta]);
            input.scope.addIdentifier(id);
            target.push(id);
            if (opt.findDirectTokenByText("OPTIONAL")) {
                const name = target[target.length - 1].getName().toUpperCase();
                this.optional.push(name);
            }
            else if (opt.findFirstExpression(Expressions.Default)) {
                const name = target[target.length - 1].getName().toUpperCase();
                this.optional.push(name);
                const val = (_b = opt.findFirstExpression(Expressions.Default)) === null || _b === void 0 ? void 0 : _b.getLastChild();
                if (val && val instanceof nodes_1.ExpressionNode) {
                    this.defaults[name] = val;
                }
            }
        }
        if (target.length > 0) {
            return;
        }
        const params = source.findAllExpressions(Expressions.MethodParam);
        for (const param of params) {
            target.push(new method_param_1.MethodParam().runSyntax(param, input, meta));
        }
    }
}
exports.MethodParameters = MethodParameters;
//# sourceMappingURL=method_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/abap/types/type_definitions.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/abap/types/type_definitions.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeDefinitions = void 0;
class TypeDefinitions {
    constructor(list) {
        this.map = {};
        this.list = list;
        for (const t of list) {
            // todo, can assumptions be made regarding the case of t.getName()?
            this.map[t.type.getName().toUpperCase()] = t;
        }
    }
    getAll() {
        return this.list;
    }
    getByName(name) {
        var _a;
        return (_a = this.map[name.toUpperCase()]) === null || _a === void 0 ? void 0 : _a.type;
    }
}
exports.TypeDefinitions = TypeDefinitions;
//# sourceMappingURL=type_definitions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/artifacts_objects.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/artifacts_objects.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArtifactsObjects = void 0;
const Objects = __webpack_require__(/*! ./objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _unknown_object_1 = __webpack_require__(/*! ./objects/_unknown_object */ "./node_modules/@abaplint/core/build/src/objects/_unknown_object.js");
class ArtifactsObjects {
    static newObject(name, type) {
        if (this.objectMap === undefined) {
            this.buildObjectMap();
        }
        if (type === undefined || this.objectMap[type] === undefined) {
            return new _unknown_object_1.UnknownObject(name, type);
        }
        else {
            return new this.objectMap[type](name);
        }
    }
    static buildObjectMap() {
        this.objectMap = [];
        const list = Objects;
        for (const key in Objects) {
            if (typeof list[key] === "function") {
                const obj = new list[key]("DUMMY_NAME");
                this.objectMap[obj.getType()] = list[key];
            }
        }
    }
}
exports.ArtifactsObjects = ArtifactsObjects;
//# sourceMappingURL=artifacts_objects.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/artifacts_rules.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/artifacts_rules.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ArtifactsRules = void 0;
const Rules = __webpack_require__(/*! ./rules */ "./node_modules/@abaplint/core/build/src/rules/index.js");
class ArtifactsRules {
    static getRules() {
        const ret = [];
        const list = Rules;
        for (const key in Rules) {
            if (typeof list[key] === "function") {
                const rule = new list[key]();
                // note that configuration is also exported from rules
                if (rule.getMetadata !== undefined) {
                    ret.push(rule);
                }
            }
        }
        return ret;
    }
}
exports.ArtifactsRules = ArtifactsRules;
//# sourceMappingURL=artifacts_rules.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/cds_determine_types.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/cds_determine_types.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSDetermineTypes = void 0;
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class CDSDetermineTypes {
    parseType(reg, parsedData) {
        const ddic = new ddic_1.DDIC(reg);
        if ((parsedData === null || parsedData === void 0 ? void 0 : parsedData.fields.length) === 0) {
            return new basic_1.VoidType("DDLS:todo");
        }
        else {
            const components = [];
            for (const f of (parsedData === null || parsedData === void 0 ? void 0 : parsedData.fields) || []) {
                if (f.prefix !== "") {
                    const source = parsedData.sources.find((s) => { var _a; return ((_a = s.as) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === f.prefix.toUpperCase(); });
                    if ((source === null || source === void 0 ? void 0 : source.name) === undefined) {
                        components.push({
                            name: f.name,
                            type: new basic_1.UnknownType("CDS parser error, unknown source"),
                        });
                        continue;
                    }
                    const lookup = ddic.lookupTableOrView(source.name);
                    if (lookup.type) {
                        if (lookup.type instanceof basic_1.StructureType) {
                            const type = lookup.type.getComponentByName(f.name);
                            if (type) {
                                components.push({
                                    name: f.name,
                                    type: type,
                                });
                            }
                            else {
                                components.push({
                                    name: f.name,
                                    type: new basic_1.UnknownType(f.name + " not found in " + source.name + ", CDSDetermineTypes"),
                                });
                            }
                        }
                        else {
                            // its void or unknown
                            components.push({
                                name: f.name,
                                type: lookup.type,
                            });
                        }
                    }
                    else if (reg.inErrorNamespace(source.name)) {
                        components.push({
                            name: f.name,
                            type: new basic_1.UnknownType(source.name + " not found, CDSDetermineTypes"),
                        });
                    }
                    else {
                        components.push({
                            name: f.name,
                            type: new basic_1.VoidType(source.name),
                        });
                    }
                }
                else {
                    components.push({
                        name: f.name,
                        type: new basic_1.VoidType("DDLS:fieldname"),
                    });
                }
            }
            return new basic_1.StructureType(components, parsedData.definitionName, parsedData.definitionName, parsedData.description);
        }
    }
}
exports.CDSDetermineTypes = CDSDetermineTypes;
//# sourceMappingURL=cds_determine_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/cds_lexer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/cds_lexer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSLexer = void 0;
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
// todo: Keywords must be all uppercase, all lowercase, or in lowercase with an
// uppercase initial letter. Other mixes of uppercase and lowercase are not allowed
class Stream {
    constructor(buffer) {
        this.buffer = buffer;
    }
    takeNext() {
        const next = this.buffer.substring(0, 1);
        this.buffer = this.buffer.substring(1);
        return next;
    }
    peekNext() {
        const next = this.buffer.substring(0, 1);
        return next;
    }
    length() {
        return this.buffer.length;
    }
}
var Mode;
(function (Mode) {
    Mode[Mode["Default"] = 0] = "Default";
    Mode[Mode["String"] = 1] = "String";
    Mode[Mode["SingleLineComment"] = 2] = "SingleLineComment";
    Mode[Mode["MultiLineComment"] = 3] = "MultiLineComment";
})(Mode || (Mode = {}));
class Result {
    constructor() {
        this.result = [];
    }
    add(text, row, col, mode) {
        if (text.length > 0) {
            if (mode === Mode.SingleLineComment) {
                this.result.push(new tokens_1.Comment(new position_1.Position(row, col), text));
            }
            else {
                this.result.push(new tokens_1.Identifier(new position_1.Position(row, col), text));
            }
        }
        return "";
    }
    get() {
        return this.result;
    }
}
class CDSLexer {
    static run(file) {
        const result = new Result();
        let mode = Mode.Default;
        let row = 1;
        let col = 1;
        let build = "";
        const stream = new Stream(file.getRaw().replace(/\r/g, "").replace(/\u00a0/g, " "));
        let next = "";
        while (stream.length() > 0) {
            const prev = next;
            next = stream.takeNext();
            const nextNext = stream.peekNext();
            col++;
            // string handling
            if (mode === Mode.String) {
                build += next;
                if (next === "'") {
                    build = result.add(build, row, col, mode);
                    mode = Mode.Default;
                }
                continue;
            }
            // single line comment handling
            if (mode === Mode.SingleLineComment) {
                if (next === "\n") {
                    build = result.add(build, row, col, mode);
                    mode = Mode.Default;
                }
                else {
                    build += next;
                    continue;
                }
            }
            else if (mode === Mode.Default && next === "/" && nextNext === "/") {
                mode = Mode.SingleLineComment;
                build = result.add(build, row, col, mode);
                build += next;
                continue;
            }
            else if (mode === Mode.Default && next === "-" && nextNext === "-") {
                mode = Mode.SingleLineComment;
                build = result.add(build, row, col, mode);
                build += next;
                continue;
            }
            // multi line comment handling
            if (mode === Mode.MultiLineComment) {
                if (next === "\n") {
                    row++;
                }
                else if (prev === "*" && next === "/") {
                    mode = Mode.Default;
                }
                continue;
            }
            else if (mode === Mode.Default && next === "/" && nextNext === "*") {
                mode = Mode.MultiLineComment;
                build = result.add(build, row, col, mode);
                continue;
            }
            switch (next) {
                case "'":
                    mode = Mode.String;
                    build += next;
                    break;
                case " ":
                    build = result.add(build, row, col, mode);
                    break;
                case "\n":
                    build = result.add(build, row, col, mode);
                    row++;
                    col = 0;
                    break;
                case ";":
                case ":":
                case ",":
                case ".":
                case "{":
                case "}":
                case "(":
                case ")":
                case "[":
                case "]":
                case "=":
                case "<":
                case ">":
                case "+":
                case "-":
                case "*":
                case "/":
                    build = result.add(build, row, col, mode);
                    result.add(next, row, col, mode);
                    break;
                default:
                    build += next;
                    break;
            }
        }
        result.add(build, row, col, mode);
        return result.get();
    }
}
exports.CDSLexer = CDSLexer;
//# sourceMappingURL=cds_lexer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/cds_parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/cds_parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSParser = void 0;
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const combi_1 = __webpack_require__(/*! ../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const cds_lexer_1 = __webpack_require__(/*! ./cds_lexer */ "./node_modules/@abaplint/core/build/src/cds/cds_lexer.js");
const Expressions = __webpack_require__(/*! ./expressions */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
// todo: the names of the ABAP + CDS + DDL expressions might overlap, if overlapping the singleton will fail
class CDSParser {
    parse(file) {
        if (file === undefined) {
            return undefined;
        }
        let tokens = cds_lexer_1.CDSLexer.run(file);
        tokens = tokens.filter(t => !(t instanceof tokens_1.Comment));
        // console.dir(tokens);
        let res = combi_1.Combi.run(new Expressions.CDSDefineView(), tokens, version_1.defaultVersion);
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            res = combi_1.Combi.run(new Expressions.CDSDefineAbstract(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            res = combi_1.Combi.run(new Expressions.CDSDefineProjection(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            res = combi_1.Combi.run(new Expressions.CDSAnnotate(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            res = combi_1.Combi.run(new Expressions.CDSDefineCustom(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            res = combi_1.Combi.run(new Expressions.CDSExtendView(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            return undefined;
        }
        return res[0];
    }
}
exports.CDSParser = CDSParser;
//# sourceMappingURL=cds_parser.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_aggregate.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_aggregate.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAggregate = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSAggregate extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)));
        const value = (0, combi_1.alt)(name, _1.CDSCast, _1.CDSCase);
        return (0, combi_1.seq)((0, combi_1.alt)("MAX", "MIN", "SUM", "AVG", "COUNT"), "(", (0, combi_1.opt)("DISTINCT"), value, ")");
    }
}
exports.CDSAggregate = CDSAggregate;
//# sourceMappingURL=cds_aggregate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotate.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAnnotate = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSAnnotate extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), "ANNOTATE", (0, combi_1.alt)("ENTITY", "VIEW"), _1.CDSName, "WITH", (0, combi_1.str)("{"), (0, combi_1.plus)((0, combi_1.seq)(_1.CDSElement, ";")), (0, combi_1.str)("}"), (0, combi_1.opt)(";"));
    }
}
exports.CDSAnnotate = CDSAnnotate;
//# sourceMappingURL=cds_annotate.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAnnotation = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_annotation_array_1 = __webpack_require__(/*! ./cds_annotation_array */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_array.js");
class CDSAnnotation extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.regex)(/^@\w+$/), (0, combi_1.star)((0, combi_1.seq)(".", (0, combi_1.regex)(/^\w+$/))), (0, combi_1.opt)(":"), (0, combi_1.opt)((0, combi_1.alt)(cds_annotation_array_1.CDSAnnotationArray, _1.CDSAnnotationObject, _1.CDSAnnotationSimple)));
    }
}
exports.CDSAnnotation = CDSAnnotation;
//# sourceMappingURL=cds_annotation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_array.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_array.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAnnotationArray = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_annotation_simple_1 = __webpack_require__(/*! ./cds_annotation_simple */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_simple.js");
class CDSAnnotationArray extends combi_1.Expression {
    getRunnable() {
        const value = (0, combi_1.alt)(cds_annotation_simple_1.CDSAnnotationSimple, _1.CDSAnnotationObject, CDSAnnotationArray);
        const valueList = (0, combi_1.seq)("[", value, (0, combi_1.star)((0, combi_1.seq)(",", value)), "]");
        return valueList;
    }
}
exports.CDSAnnotationArray = CDSAnnotationArray;
//# sourceMappingURL=cds_annotation_array.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_object.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_object.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAnnotationObject = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_annotation_simple_1 = __webpack_require__(/*! ./cds_annotation_simple */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_simple.js");
class CDSAnnotationObject extends combi_1.Expression {
    getRunnable() {
        const value = (0, combi_1.seq)(":", (0, combi_1.alt)(CDSAnnotationObject, _1.CDSAnnotationArray, cds_annotation_simple_1.CDSAnnotationSimple));
        const namedot = (0, combi_1.seq)(_1.CDSName, (0, combi_1.star)((0, combi_1.seq)(".", _1.CDSName)));
        const valueNested = (0, combi_1.seq)("{", namedot, (0, combi_1.opt)(value), (0, combi_1.star)((0, combi_1.seq)(",", namedot, (0, combi_1.opt)(value))), "}");
        return valueNested;
    }
}
exports.CDSAnnotationObject = CDSAnnotationObject;
//# sourceMappingURL=cds_annotation_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_simple.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_simple.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAnnotationSimple = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSAnnotationSimple extends combi_1.Expression {
    getRunnable() {
        const value = (0, combi_1.alt)(_1.CDSString, "true", "false", (0, combi_1.regex)(/^\d+$/), (0, combi_1.seq)((0, combi_1.regex)(/^\d+$/), ".", (0, combi_1.regex)(/^\d+$/)), (0, combi_1.regex)(/^#[\w_]+$/));
        return value;
    }
}
exports.CDSAnnotationSimple = CDSAnnotationSimple;
//# sourceMappingURL=cds_annotation_simple.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_arithmetics.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_arithmetics.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSArithmetics = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_integer_1 = __webpack_require__(/*! ./cds_integer */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_integer.js");
class CDSArithmetics extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)));
        const val = (0, combi_1.alt)(cds_integer_1.CDSInteger, name, _1.CDSFunction, _1.CDSCase, _1.CDSCast, _1.CDSString);
        const operator = (0, combi_1.altPrio)("+", "-", "*", "/");
        return (0, combi_1.seq)(val, operator, val);
    }
}
exports.CDSArithmetics = CDSArithmetics;
//# sourceMappingURL=cds_arithmetics.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_as.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_as.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAs = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSAs extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("AS", _1.CDSName);
    }
}
exports.CDSAs = CDSAs;
//# sourceMappingURL=cds_as.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_association.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_association.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSAssociation = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_cardinality_1 = __webpack_require__(/*! ./cds_cardinality */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cardinality.js");
class CDSAssociation extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("ASSOCIATION", (0, combi_1.opt)(cds_cardinality_1.CDSCardinality), "TO", (0, combi_1.opt)("PARENT"), _1.CDSRelation, "ON", _1.CDSCondition);
    }
}
exports.CDSAssociation = CDSAssociation;
//# sourceMappingURL=cds_association.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cardinality.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_cardinality.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSCardinality = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSCardinality extends combi_1.Expression {
    getRunnable() {
        const cardinality = (0, combi_1.seq)("[", (0, combi_1.alt)("0", "1"), (0, combi_1.opt)((0, combi_1.seq)(".", ".", (0, combi_1.alt)("0", "1", "*"))), "]");
        return cardinality;
    }
}
exports.CDSCardinality = CDSCardinality;
//# sourceMappingURL=cds_cardinality.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_case.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_case.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSCase = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSCase extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.optPrio)((0, combi_1.seq)(".", _1.CDSName)));
        const value = (0, combi_1.alt)(name, _1.CDSString, _1.CDSFunction, CDSCase, _1.CDSCast, _1.CDSArithmetics);
        const simple = (0, combi_1.seq)("CASE", (0, combi_1.alt)(name, _1.CDSFunction), (0, combi_1.plus)((0, combi_1.seq)("WHEN", value, "THEN", value)), "ELSE", value, "END");
        const complex = (0, combi_1.seq)("CASE", (0, combi_1.plus)((0, combi_1.seq)("WHEN", _1.CDSCondition, "THEN", value)), (0, combi_1.opt)((0, combi_1.seq)("ELSE", value)), "END");
        return (0, combi_1.altPrio)(simple, complex);
    }
}
exports.CDSCase = CDSCase;
//# sourceMappingURL=cds_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cast.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_cast.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSCast = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSCast extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)));
        return (0, combi_1.seq)("CAST", "(", (0, combi_1.alt)(name, _1.CDSFunction, _1.CDSCase, CDSCast, _1.CDSString, _1.CDSArithmetics), "AS", _1.CDSType, (0, combi_1.opt)((0, combi_1.seq)("PRESERVING", "TYPE")), ")");
    }
}
exports.CDSCast = CDSCast;
//# sourceMappingURL=cds_cast.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_composition.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_composition.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSComposition = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_cardinality_1 = __webpack_require__(/*! ./cds_cardinality */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cardinality.js");
class CDSComposition extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("COMPOSITION", (0, combi_1.opt)(cds_cardinality_1.CDSCardinality), "OF", _1.CDSRelation);
    }
}
exports.CDSComposition = CDSComposition;
//# sourceMappingURL=cds_composition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_condition.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_condition.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSCondition = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_integer_1 = __webpack_require__(/*! ./cds_integer */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_integer.js");
class CDSCondition extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", (0, combi_1.alt)(_1.CDSName, _1.CDSString))));
        const left = (0, combi_1.alt)(name, _1.CDSFunction);
        const compare = (0, combi_1.seq)(left, (0, combi_1.alt)("=", (0, combi_1.seq)("!", "="), (0, combi_1.seq)("<", ">"), "<", ">", (0, combi_1.seq)(">", "="), (0, combi_1.seq)("<", "="), "LIKE", "NOT LIKE"), (0, combi_1.alt)(left, cds_integer_1.CDSInteger, _1.CDSFunction, _1.CDSString));
        const is = (0, combi_1.seq)(left, "IS", (0, combi_1.optPrio)("NOT"), (0, combi_1.altPrio)("INITIAL", "NULL"));
        const condition = (0, combi_1.alt)(compare, is);
        const paren = (0, combi_1.seq)("(", CDSCondition, ")");
        return (0, combi_1.seq)((0, combi_1.alt)(condition, paren), (0, combi_1.star)((0, combi_1.seq)((0, combi_1.alt)("AND", "OR"), (0, combi_1.alt)(condition, paren))));
    }
}
exports.CDSCondition = CDSCondition;
//# sourceMappingURL=cds_condition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_abstract.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_abstract.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSDefineAbstract = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_name_1 = __webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js");
class CDSDefineAbstract extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), (0, combi_1.opt)((0, combi_1.str)("KEY")), cds_name_1.CDSName, ":", _1.CDSType, ";");
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), (0, combi_1.str)("DEFINE ABSTRACT ENTITY"), cds_name_1.CDSName, (0, combi_1.str)("{"), (0, combi_1.plus)(field), (0, combi_1.str)("}"), (0, combi_1.opt)(";"));
    }
}
exports.CDSDefineAbstract = CDSDefineAbstract;
//# sourceMappingURL=cds_define_abstract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_custom.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_custom.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSDefineCustom = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_name_1 = __webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js");
const cds_type_1 = __webpack_require__(/*! ./cds_type */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_type.js");
class CDSDefineCustom extends combi_1.Expression {
    getRunnable() {
        const field = (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), (0, combi_1.opt)((0, combi_1.str)("KEY")), cds_name_1.CDSName, ":", cds_type_1.CDSType, ";");
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), (0, combi_1.str)("DEFINE"), (0, combi_1.opt)((0, combi_1.str)("ROOT")), (0, combi_1.str)("CUSTOM ENTITY"), cds_name_1.CDSName, (0, combi_1.str)("{"), (0, combi_1.plus)(field), (0, combi_1.str)("}"), (0, combi_1.opt)(";"));
    }
}
exports.CDSDefineCustom = CDSDefineCustom;
//# sourceMappingURL=cds_define_custom.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_projection.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_projection.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSDefineProjection = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/@abaplint/core/build/src/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSDefineProjection extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), "DEFINE", (0, combi_1.opt)("ROOT"), "VIEW", (0, combi_1.ver)(__1.Version.v755, (0, combi_1.opt)("ENTITY")), _1.CDSName, (0, combi_1.opt)(_1.CDSProviderContract), "AS PROJECTION ON", _1.CDSName, (0, combi_1.opt)(_1.CDSAs), (0, combi_1.str)("{"), (0, combi_1.plus)(_1.CDSElement), (0, combi_1.star)((0, combi_1.seq)(",", _1.CDSElement)), (0, combi_1.str)("}"), (0, combi_1.opt)(";"));
    }
}
exports.CDSDefineProjection = CDSDefineProjection;
//# sourceMappingURL=cds_define_projection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_view.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_view.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSDefineView = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/@abaplint/core/build/src/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_name_1 = __webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js");
const cds_select_1 = __webpack_require__(/*! ./cds_select */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_select.js");
const cds_with_parameters_1 = __webpack_require__(/*! ./cds_with_parameters */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_with_parameters.js");
class CDSDefineView extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), "DEFINE", (0, combi_1.opt)("ROOT"), "VIEW", (0, combi_1.ver)(__1.Version.v755, (0, combi_1.opt)("ENTITY")), cds_name_1.CDSName, (0, combi_1.opt)(cds_with_parameters_1.CDSWithParameters), "AS", cds_select_1.CDSSelect, (0, combi_1.opt)(";"));
    }
}
exports.CDSDefineView = CDSDefineView;
//# sourceMappingURL=cds_define_view.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_element.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_element.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSElement = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_as_1 = __webpack_require__(/*! ./cds_as */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_as.js");
const cds_cast_1 = __webpack_require__(/*! ./cds_cast */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cast.js");
class CDSElement extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.starPrio)(_1.CDSAnnotation), (0, combi_1.optPrio)("KEY"), (0, combi_1.altPrio)(_1.CDSAggregate, _1.CDSString, _1.CDSFunction, _1.CDSArithmetics, cds_cast_1.CDSCast, _1.CDSCase, (0, combi_1.seq)(_1.CDSName, ": REDIRECTED TO", (0, combi_1.opt)((0, combi_1.alt)("PARENT", "COMPOSITION CHILD")), _1.CDSName), _1.CDSPrefixedName, (0, combi_1.regex)(/^\d+$/)), (0, combi_1.opt)(cds_as_1.CDSAs));
    }
}
exports.CDSElement = CDSElement;
//# sourceMappingURL=cds_element.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_extend_view.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_extend_view.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSExtendView = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_name_1 = __webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js");
class CDSExtendView extends combi_1.Expression {
    getRunnable() {
        const namedot = (0, combi_1.seq)(cds_name_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", cds_name_1.CDSName)), (0, combi_1.opt)(_1.CDSAs));
        const valueNested = (0, combi_1.seq)("{", namedot, (0, combi_1.star)((0, combi_1.seq)(",", namedot)), "}");
        return (0, combi_1.seq)((0, combi_1.star)(_1.CDSAnnotation), (0, combi_1.str)("EXTEND VIEW"), (0, combi_1.opt)((0, combi_1.str)("ENTITY")), cds_name_1.CDSName, (0, combi_1.str)("WITH"), (0, combi_1.opt)(cds_name_1.CDSName), valueNested, (0, combi_1.opt)(";"));
    }
}
exports.CDSExtendView = CDSExtendView;
//# sourceMappingURL=cds_extend_view.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_function.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_function.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSFunction = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSFunction extends combi_1.Expression {
    getRunnable() {
        const qualified = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)(_1.CDSParameters), (0, combi_1.starPrio)((0, combi_1.seq)(".", _1.CDSName, (0, combi_1.opt)(_1.CDSParameters))));
        const input = (0, combi_1.altPrio)(_1.CDSCast, CDSFunction, _1.CDSArithmetics, _1.CDSCase, _1.CDSString, qualified, (0, combi_1.regex)(/^\d+$/));
        const coalesce = (0, combi_1.seq)("COALESCE", "(", input, ",", input, ")");
        const concat = (0, combi_1.seq)("CONCAT", "(", input, ",", input, ")");
        const concat_with_space = (0, combi_1.seq)("CONCAT_WITH_SPACE", "(", input, ",", input, ",", input, ")");
        const dats_add_days = (0, combi_1.seq)("DATS_ADD_DAYS", "(", input, ",", input, ",", input, ")");
        const dats_add_months = (0, combi_1.seq)("DATS_ADD_MONTHS", "(", input, ",", input, ",", input, ")");
        const dats_days_between = (0, combi_1.seq)("DATS_DAYS_BETWEEN", "(", input, ",", input, ")");
        const dats_is_valid = (0, combi_1.seq)("DATS_IS_VALID", "(", input, ")");
        const substring = (0, combi_1.seq)("SUBSTRING", "(", input, ",", input, ",", input, ")");
        const bintohex = (0, combi_1.seq)("BINTOHEX", "(", input, ")");
        const hextobin = (0, combi_1.seq)("HEXTOBIN", "(", input, ")");
        const tstmp_to_dats = (0, combi_1.seq)("TSTMP_TO_DATS", "(", input, ",", input, ",", input, ",", input, ")");
        const tstmp_to_tims = (0, combi_1.seq)("TSTMP_TO_TIMS", "(", input, ",", input, ",", input, ",", input, ")");
        const tstmp_to_dst = (0, combi_1.seq)("TSTMP_TO_DST", "(", input, ",", input, ",", input, ",", input, ")");
        const dats_tims_to_tstmp = (0, combi_1.seq)("DATS_TIMS_TO_TSTMP", "(", input, ",", input, ",", input, ",", input, ",", input, ")");
        const tstmp_is_valid = (0, combi_1.seq)("TSTMP_IS_VALID", "(", input, ")");
        const tstmp_current_utctimestamp = (0, combi_1.seq)("TSTMP_CURRENT_UTCTIMESTAMP", "(", ")");
        const tstmp_seconds_between = (0, combi_1.seq)("TSTMP_SECONDS_BETWEEN", "(", input, ",", input, ",", input, ")");
        const tstmp_add_seconds = (0, combi_1.seq)("TSTMP_ADD_SECONDS", "(", input, ",", input, ",", input, ")");
        const abap_system_timezone = (0, combi_1.seq)("ABAP_SYSTEM_TIMEZONE", "(", input, ",", input, ")");
        const abap_user_timezone = (0, combi_1.seq)("ABAP_USER_TIMEZONE", "(", input, ",", input, ",", input, ")");
        const mod = (0, combi_1.seq)("MOD", "(", input, ",", input, ")");
        return (0, combi_1.altPrio)(substring, coalesce, tstmp_to_dats, concat, tstmp_to_tims, concat_with_space, dats_is_valid, dats_days_between, tstmp_add_seconds, tstmp_seconds_between, tstmp_current_utctimestamp, tstmp_is_valid, abap_system_timezone, abap_user_timezone, bintohex, hextobin, dats_add_days, dats_add_months, tstmp_to_dst, dats_tims_to_tstmp, mod);
    }
}
exports.CDSFunction = CDSFunction;
//# sourceMappingURL=cds_function.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_group_by.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_group_by.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSGroupBy = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSGroupBy extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.star)((0, combi_1.seq)(".", _1.CDSName)));
        return (0, combi_1.seq)("GROUP BY", name, (0, combi_1.star)((0, combi_1.seq)(",", name)));
    }
}
exports.CDSGroupBy = CDSGroupBy;
//# sourceMappingURL=cds_group_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_having.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_having.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSHaving = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSHaving extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("HAVING", _1.CDSCondition);
    }
}
exports.CDSHaving = CDSHaving;
//# sourceMappingURL=cds_having.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_integer.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_integer.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSInteger = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSInteger extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\d+$/);
    }
}
exports.CDSInteger = CDSInteger;
//# sourceMappingURL=cds_integer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_join.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_join.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSJoin = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_condition_1 = __webpack_require__(/*! ./cds_condition */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_condition.js");
class CDSJoin extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.opt)((0, combi_1.alt)("INNER", "LEFT OUTER", "LEFT OUTER TO ONE")), "JOIN", _1.CDSSource, "ON", cds_condition_1.CDSCondition);
    }
}
exports.CDSJoin = CDSJoin;
//# sourceMappingURL=cds_join.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSName = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSName extends combi_1.Expression {
    getRunnable() {
        const pre = (0, combi_1.seq)("/", (0, combi_1.regex)(/^[\w_]+$/), "/");
        return (0, combi_1.seq)((0, combi_1.opt)(":"), (0, combi_1.opt)(pre), (0, combi_1.regex)(/^\$?#?[\w_]+$/));
    }
}
exports.CDSName = CDSName;
//# sourceMappingURL=cds_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSParameters = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSParameters extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)));
        const value = (0, combi_1.alt)(name, _1.CDSString);
        return (0, combi_1.seq)("[", (0, combi_1.regex)(/\d+/), ":", name, "=", value, (0, combi_1.star)((0, combi_1.seq)("AND", name, "=", value)), "]");
    }
}
exports.CDSParameters = CDSParameters;
//# sourceMappingURL=cds_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters_select.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters_select.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSParametersSelect = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSParametersSelect extends combi_1.Expression {
    getRunnable() {
        const name = (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)));
        const value = (0, combi_1.alt)(name, _1.CDSString);
        const nameValue = (0, combi_1.seq)(name, ":", value);
        return (0, combi_1.seq)("(", nameValue, (0, combi_1.star)((0, combi_1.seq)(",", nameValue)), ")");
    }
}
exports.CDSParametersSelect = CDSParametersSelect;
//# sourceMappingURL=cds_parameters_select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_prefixed_name.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_prefixed_name.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSPrefixedName = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_name_1 = __webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js");
const cds_parameters_1 = __webpack_require__(/*! ./cds_parameters */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters.js");
class CDSPrefixedName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(cds_name_1.CDSName, (0, combi_1.opt)(cds_parameters_1.CDSParameters), (0, combi_1.star)((0, combi_1.seq)(".", cds_name_1.CDSName, (0, combi_1.opt)(cds_parameters_1.CDSParameters))));
    }
}
exports.CDSPrefixedName = CDSPrefixedName;
//# sourceMappingURL=cds_prefixed_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_provider_contract.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_provider_contract.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSProviderContract = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSProviderContract extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("PROVIDER CONTRACT", (0, combi_1.alt)("TRANSACTIONAL_QUERY", "TRANSACTIONAL_INTERFACE", "ANALYTICAL_QUERY"));
    }
}
exports.CDSProviderContract = CDSProviderContract;
//# sourceMappingURL=cds_provider_contract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_relation.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_relation.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSRelation = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSRelation extends combi_1.Expression {
    getRunnable() {
        const pre = (0, combi_1.seq)("/", (0, combi_1.regex)(/^[\w_]+$/), "/");
        return (0, combi_1.seq)((0, combi_1.opt)(pre), (0, combi_1.regex)(/^[\w_]+$/), (0, combi_1.opt)(_1.CDSAs));
    }
}
exports.CDSRelation = CDSRelation;
//# sourceMappingURL=cds_relation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_select.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_select.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSSelect = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const cds_association_1 = __webpack_require__(/*! ./cds_association */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_association.js");
const cds_join_1 = __webpack_require__(/*! ./cds_join */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_join.js");
class CDSSelect extends combi_1.Expression {
    getRunnable() {
        const fields = (0, combi_1.opt)((0, combi_1.seq)((0, combi_1.star)((0, combi_1.seq)(_1.CDSElement, ",")), _1.CDSElement));
        const distinct = (0, combi_1.str)("DISTINCT");
        const elements = (0, combi_1.seq)((0, combi_1.str)("{"), (0, combi_1.plus)(_1.CDSElement), (0, combi_1.star)((0, combi_1.seq)(",", _1.CDSElement)), (0, combi_1.str)("}"));
        return (0, combi_1.seq)("SELECT", (0, combi_1.opt)(distinct), (0, combi_1.opt)(fields), "FROM", _1.CDSSource, (0, combi_1.star)(cds_join_1.CDSJoin), (0, combi_1.star)(_1.CDSComposition), (0, combi_1.star)(cds_association_1.CDSAssociation), (0, combi_1.star)(_1.CDSComposition), (0, combi_1.opt)(elements), (0, combi_1.opt)(_1.CDSWhere), (0, combi_1.opt)(_1.CDSGroupBy), (0, combi_1.opt)(_1.CDSHaving), (0, combi_1.opt)((0, combi_1.seq)("UNION", (0, combi_1.opt)("ALL"), CDSSelect)));
    }
}
exports.CDSSelect = CDSSelect;
//# sourceMappingURL=cds_select.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_source.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_source.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSSource = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSSource extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)(_1.CDSParametersSelect), (0, combi_1.opt)(_1.CDSAs));
    }
}
exports.CDSSource = CDSSource;
//# sourceMappingURL=cds_source.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_string.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_string.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSString = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSString extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^'[\w: -_]*'$/);
    }
}
exports.CDSString = CDSString;
//# sourceMappingURL=cds_string.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_type.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_type.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSType = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSType extends combi_1.Expression {
    getRunnable() {
        const decimals = (0, combi_1.seq)(",", (0, combi_1.regex)(/\d+/));
        return (0, combi_1.seq)(_1.CDSName, (0, combi_1.opt)((0, combi_1.seq)(".", _1.CDSName)), (0, combi_1.opt)((0, combi_1.seq)("(", (0, combi_1.regex)(/\d+/), (0, combi_1.opt)(decimals), ")")));
    }
}
exports.CDSType = CDSType;
//# sourceMappingURL=cds_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_where.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_where.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSWhere = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSWhere extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("WHERE", _1.CDSCondition);
    }
}
exports.CDSWhere = CDSWhere;
//# sourceMappingURL=cds_where.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_with_parameters.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/cds_with_parameters.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSWithParameters = void 0;
const _1 = __webpack_require__(/*! . */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class CDSWithParameters extends combi_1.Expression {
    getRunnable() {
        const param = (0, combi_1.seq)(_1.CDSName, ":", _1.CDSType);
        return (0, combi_1.seq)("WITH PARAMETERS", param, (0, combi_1.star)((0, combi_1.seq)(",", param)));
    }
}
exports.CDSWithParameters = CDSWithParameters;
//# sourceMappingURL=cds_with_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/cds/expressions/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./cds_aggregate */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_aggregate.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_annotate */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotate.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_annotation_array */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_array.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_annotation_object */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_object.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_annotation_simple */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation_simple.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_annotation */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_annotation.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_arithmetics */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_arithmetics.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_as */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_as.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_association */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_association.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_cardinality */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cardinality.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_case */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_case.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_cast */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_cast.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_composition */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_composition.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_condition */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_condition.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_define_abstract */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_abstract.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_define_custom */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_custom.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_define_projection */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_projection.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_define_view */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_define_view.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_element */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_element.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_extend_view */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_extend_view.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_function */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_function.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_group_by */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_group_by.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_having */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_having.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_integer */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_integer.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_join */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_join.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_name.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_parameters_select */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters_select.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_parameters */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_prefixed_name */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_prefixed_name.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_provider_contract */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_provider_contract.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_relation */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_relation.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_select */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_select.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_source */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_source.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_string */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_string.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_type */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_type.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_where */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_where.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_with_parameters */ "./node_modules/@abaplint/core/build/src/cds/expressions/cds_with_parameters.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/config.js":
/*!*********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/config.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Config = void 0;
const version_1 = __webpack_require__(/*! ./version */ "./node_modules/@abaplint/core/build/src/version.js");
const artifacts_rules_1 = __webpack_require__(/*! ./artifacts_rules */ "./node_modules/@abaplint/core/build/src/artifacts_rules.js");
const JSON5 = __webpack_require__(/*! json5 */ "./node_modules/json5/dist/index.mjs");
// assumption: this class is immutable
class Config {
    static getDefault(ver) {
        const rules = {};
        const sorted = artifacts_rules_1.ArtifactsRules.getRules().sort((a, b) => {
            return a.getMetadata().key.localeCompare(b.getMetadata().key);
        });
        for (const rule of sorted) {
            rules[rule.getMetadata().key] = rule.getConfig();
        }
        let version = version_1.defaultVersion;
        if (ver) {
            version = ver;
        }
        // defaults: dont skip anything, report everything. The user can decide to skip stuff
        // its difficult to debug errors not being reported
        const config = {
            global: {
                files: "/src/**/*.*",
                exclude: [],
                noIssues: [],
                skipGeneratedBOPFInterfaces: false,
                skipGeneratedFunctionGroups: false,
                skipGeneratedGatewayClasses: false,
                skipGeneratedPersistentClasses: false,
                skipGeneratedProxyClasses: false,
                skipGeneratedProxyInterfaces: false,
                useApackDependencies: false,
                skipIncludesWithoutMain: false,
            },
            dependencies: [{
                    url: "https://github.com/abaplint/deps",
                    folder: "/deps",
                    files: "/src/**/*.*",
                }],
            syntax: {
                version,
                errorNamespace: "^(Z|Y|LCL\_|TY\_|LIF\_)",
                globalConstants: [],
                globalMacros: [],
            },
            rules: rules,
        };
        return new Config(JSON.stringify(config));
    }
    getEnabledRules() {
        var _a;
        const rules = [];
        for (const rule of artifacts_rules_1.ArtifactsRules.getRules()) {
            const ruleConfig = (_a = this.config["rules"]) === null || _a === void 0 ? void 0 : _a[rule.getMetadata().key];
            const ruleExists = ruleConfig !== undefined;
            if (ruleExists) {
                if (ruleConfig === false) { // "rule": false
                    continue;
                }
                else if (ruleConfig === true) { // "rule": true
                    rules.push(rule);
                }
                else if (typeof ruleConfig === "object") { // "rule": { ...config }
                    rule.setConfig(ruleConfig);
                    rules.push(rule);
                }
            }
        }
        return rules;
    }
    constructor(json) {
        // huh, hack
        if (JSON5.parse === undefined) {
            // @ts-ignore
            JSON5.parse = JSON5.default.parse;
        }
        this.config = JSON5.parse(json);
        if (this.config.global === undefined) {
            this.config.global = Config.getDefault().getGlobal();
        }
        if (this.config.syntax === undefined) {
            this.config.syntax = Config.getDefault().getSyntaxSetttings();
        }
        if (this.config.syntax.globalMacros === undefined) {
            this.config.syntax.globalMacros = [];
        }
        if (this.config.syntax.globalConstants === undefined) {
            this.config.syntax.globalConstants = [];
        }
        else {
            // remove duplicates,
            this.config.syntax.globalConstants = [...new Set(this.config.syntax.globalConstants)];
        }
        if (this.config.global.skipIncludesWithoutMain === undefined) {
            this.config.global.skipIncludesWithoutMain = false;
        }
        this.checkVersion();
    }
    get() {
        return this.config;
    }
    readByKey(rule, key) {
        if (this.config["rules"]) {
            return this.config["rules"][rule] ? this.config["rules"][rule][key] : undefined;
        }
        else {
            return undefined;
        }
    }
    readByRule(rule) {
        return this.config["rules"][rule];
    }
    getGlobal() {
        return this.config.global;
    }
    getSyntaxSetttings() {
        return this.config.syntax;
    }
    getVersion() {
        if (this.config.global === undefined || this.config.syntax.version === undefined) {
            return version_1.defaultVersion;
        }
        return this.config.syntax.version;
    }
    checkVersion() {
        if (this.config.syntax.version === undefined) {
            return; // handled in getVersion
        }
        let match = false;
        const vers = version_1.Version;
        for (const v in version_1.Version) {
            if (vers[v] === this.config.syntax.version) {
                match = true;
                break;
            }
        }
        if (match === false) {
            this.config.syntax.version = version_1.defaultVersion;
        }
    }
}
exports.Config = Config;
//# sourceMappingURL=config.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddic.js":
/*!*******************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddic.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDIC = void 0;
const Types = __webpack_require__(/*! ./abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const basic_1 = __webpack_require__(/*! ./abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class DDIC {
    constructor(reg) {
        this.reg = reg;
    }
    // the class might be local with a local super class with a global exception class as super
    // todo: returns true for both local and global exception classes
    isException(def, _obj) {
        var _a;
        if (def === undefined) {
            return false;
        }
        if (def.name.toUpperCase() === "CX_ROOT") {
            return true;
        }
        let superClassName = def.superClassName;
        if (superClassName === undefined) {
            return false;
        }
        let i = 0;
        // max depth, make sure not to hit cyclic super class defintions
        while (i++ < 10 && superClassName !== undefined) {
            const found = this.reg.getObject("CLAS", superClassName);
            if (found === undefined) {
                break;
            }
            const superDef = (_a = found.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getInfo().getClassDefinitionByName(superClassName);
            if (superDef === undefined) {
                break;
            }
            if (superDef.superClassName) {
                superClassName = superDef.superClassName;
            }
            else {
                break;
            }
        }
        // todo, this should check for "CX_ROOT"
        const isException = ((superClassName === null || superClassName === void 0 ? void 0 : superClassName.match(/^.?cx_.*$/i)) || (superClassName === null || superClassName === void 0 ? void 0 : superClassName.match(/^\/.+\/cx_.*$/i))) ? true : false;
        return isException;
    }
    lookupBuiltinType(name, length, decimals, qualifiedName) {
        switch (name) {
            case "STRING":
                return Types.StringType.get({ qualifiedName: qualifiedName || name });
            case "XSTRING":
                return new Types.XStringType({ qualifiedName: qualifiedName || name });
            case "D":
                return new Types.DateType({ qualifiedName: qualifiedName || name });
            case "T":
                return new Types.TimeType({ qualifiedName: qualifiedName || name });
            case "XSEQUENCE":
                return new Types.XSequenceType({ qualifiedName: qualifiedName });
            case "CLIKE":
                return Types.CLikeType.get();
            case "DECFLOAT":
                return new Types.DecFloatType({ qualifiedName: qualifiedName });
            case "ANY":
                return new Types.AnyType({ qualifiedName: qualifiedName });
            case "SIMPLE":
                return new Types.SimpleType({ qualifiedName: qualifiedName });
            case "%_C_POINTER":
                return new Types.HexType(8, qualifiedName);
            case "TABLE":
                return new Types.TableType(new Types.AnyType(), { withHeader: false, keyType: Types.TableKeyType.default });
            case "DATA":
                return new Types.DataType({ qualifiedName: qualifiedName });
            case "NUMERIC":
                return new Types.NumericGenericType({ qualifiedName: qualifiedName });
            case "UTCLONG": // todo, take version into account
                return new Types.UTCLongType({ qualifiedName: qualifiedName });
            case "DECFLOAT16":
                return new Types.DecFloat16Type({ qualifiedName: qualifiedName });
            case "DECFLOAT34":
                return new Types.DecFloat34Type({ qualifiedName: qualifiedName });
            case "CSEQUENCE":
                return new Types.CSequenceType({ qualifiedName: qualifiedName });
            case "I":
                return Types.IntegerType.get({ qualifiedName: qualifiedName || name });
            case "INT8": // todo, take version into account
                return new Types.Integer8Type({ qualifiedName: qualifiedName || name });
            case "F":
                return new Types.FloatType({ qualifiedName: qualifiedName || name });
            case "P":
                if (length && decimals) {
                    return new Types.PackedType(length, decimals, { qualifiedName: qualifiedName });
                }
                else if (length) {
                    return new Types.PackedType(length, 0, { qualifiedName: qualifiedName });
                }
                else {
                    return new Types.PackedType(1, 0, { qualifiedName: qualifiedName });
                }
            case "C":
                if (length) {
                    return new Types.CharacterType(length, { qualifiedName: qualifiedName });
                }
                else {
                    return new Types.CharacterType(1, { qualifiedName: qualifiedName });
                }
            case "X":
                if (length) {
                    return new Types.HexType(length, qualifiedName);
                }
                else {
                    return new Types.HexType(1, qualifiedName);
                }
            case "N":
                if (length) {
                    return new Types.NumericType(length, qualifiedName);
                }
                else {
                    return new Types.NumericType(1, qualifiedName);
                }
        }
        return undefined;
    }
    inErrorNamespace(name) {
        if (name === undefined) {
            return true;
        }
        return this.reg.inErrorNamespace(name);
    }
    lookupObject(name) {
        const clas = this.reg.getObject("CLAS", name);
        const globalClas = clas === null || clas === void 0 ? void 0 : clas.getIdentifier();
        if (globalClas) {
            return {
                type: new basic_1.ObjectReferenceType(globalClas, { qualifiedName: name, RTTIName: "\\CLASS=" + name }),
                object: clas,
            };
        }
        const intf = this.reg.getObject("INTF", name);
        const globalIntf = intf === null || intf === void 0 ? void 0 : intf.getIdentifier();
        if (globalIntf) {
            return {
                type: new basic_1.ObjectReferenceType(globalIntf, { qualifiedName: name, RTTIName: "\\INTERFACE=" + name }),
                object: intf,
            };
        }
        if (this.inErrorNamespace(name) === true) {
            return { type: new basic_1.UnknownType(name) };
        }
        else {
            return { type: new basic_1.VoidType(name) };
        }
    }
    lookupNoVoid(name) {
        const foundTABL = this.reg.getObject("TABL", name);
        if (foundTABL) {
            return { type: foundTABL.parseType(this.reg), object: foundTABL };
        }
        const foundVIEW = this.reg.getObject("VIEW", name);
        if (foundVIEW) {
            return { type: foundVIEW.parseType(this.reg), object: foundVIEW };
        }
        const foundTTYP = this.reg.getObject("TTYP", name);
        if (foundTTYP) {
            return { type: foundTTYP.parseType(this.reg), object: foundTTYP };
        }
        const foundDTEL = this.reg.getObject("DTEL", name);
        if (foundDTEL) {
            return { type: foundDTEL.parseType(this.reg), object: foundDTEL };
        }
        const foundDDLS = this.lookupDDLS(name);
        if (foundDDLS) {
            return foundDDLS;
        }
        return undefined;
    }
    lookupDDLS(name) {
        var _a;
        if (name === undefined) {
            return undefined;
        }
        const upper = name.toUpperCase();
        for (const obj of this.reg.getObjectsByType("DDLS")) {
            const ddls = obj;
            if (ddls.getSQLViewName() === upper || ((_a = ddls.getDefinitionName()) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === upper) {
                return { type: ddls.parseType(this.reg), object: ddls };
            }
        }
        return undefined;
    }
    /** lookup with voiding and unknown types */
    lookup(name) {
        const found = this.lookupNoVoid(name);
        if (found) {
            return found;
        }
        if (this.reg.inErrorNamespace(name)) {
            return { type: new Types.UnknownType(name + " not found, lookup") };
        }
        else {
            return { type: new Types.VoidType(name) };
        }
    }
    lookupDomain(name, dataElement, description) {
        const found = this.reg.getObject("DOMA", name);
        if (found) {
            return { type: found.parseType(this.reg, dataElement, description), object: found };
        }
        else if (this.reg.inErrorNamespace(name)) {
            return { type: new Types.UnknownType(name + ", lookupDomain"), object: undefined };
        }
        else {
            return { type: new Types.VoidType(name), object: undefined };
        }
    }
    lookupDataElement(name) {
        if (name === undefined) {
            return { type: new Types.UnknownType("undefined, lookupDataElement") };
        }
        const found = this.reg.getObject("DTEL", name);
        if (found) {
            return { type: found.parseType(this.reg), object: found };
        }
        else if (this.reg.inErrorNamespace(name)) {
            return { type: new Types.UnknownType(name + " not found, lookupDataElement") };
        }
        else {
            return { type: new Types.VoidType(name) };
        }
    }
    lookupTableOrView(name) {
        if (name === undefined) {
            return { type: new Types.UnknownType("undefined, lookupTableOrView") };
        }
        const foundTABL = this.reg.getObject("TABL", name);
        if (foundTABL) {
            return { type: foundTABL.parseType(this.reg), object: foundTABL };
        }
        const foundDDLS = this.lookupDDLS(name);
        if (foundDDLS) {
            return foundDDLS;
        }
        return this.lookupView(name);
    }
    /** this method only looks up the object, does not parse the type */
    lookupTableOrView2(name) {
        if (name === undefined) {
            return undefined;
        }
        const foundTABL = this.reg.getObject("TABL", name);
        if (foundTABL) {
            return foundTABL;
        }
        const foundVIEW = this.reg.getObject("VIEW", name);
        if (foundVIEW) {
            return foundVIEW;
        }
        const foundDDLS = this.lookupDDLS(name);
        if (foundDDLS) {
            return foundDDLS.object;
        }
        return undefined;
    }
    lookupTable(name) {
        if (name === undefined) {
            return new Types.UnknownType("undefined, lookupTable");
        }
        const found = this.reg.getObject("TABL", name);
        if (found) {
            return found.parseType(this.reg);
        }
        else if (this.reg.inErrorNamespace(name)) {
            return new Types.UnknownType(name + " not found, lookupTable");
        }
        else {
            return new Types.VoidType(name);
        }
    }
    lookupView(name) {
        if (name === undefined) {
            return { type: new Types.UnknownType("undefined, lookupView") };
        }
        const found = this.reg.getObject("VIEW", name);
        if (found) {
            return { type: found.parseType(this.reg), object: found };
        }
        else if (this.reg.inErrorNamespace(name)) {
            return { type: new Types.UnknownType(name + " not found, lookupView") };
        }
        else {
            return { type: new Types.VoidType(name) };
        }
    }
    lookupTableType(name) {
        if (name === undefined) {
            return { type: new Types.UnknownType("undefined, lookupTableType") };
        }
        const found = this.reg.getObject("TTYP", name);
        if (found) {
            return { type: found.parseType(this.reg), object: found };
        }
        else if (this.reg.inErrorNamespace(name)) {
            return { type: new Types.UnknownType(name + " not found, lookupTableType") };
        }
        else {
            return { type: new Types.VoidType(name) };
        }
    }
    textToType(input) {
        // todo: support short strings, and length of different integers, NUMC vs CHAR, min/max length
        const extra = {
            qualifiedName: input.qualifiedName,
            conversionExit: input.conversionExit,
            ddicName: input.ddicName,
            description: input.description,
        };
        switch (input.text) {
            case "DEC": // 1 <= len <= 31
            case "D16F": // 1 <= len <= 31
            case "D16D":
            case "D34F": // 1 <= len <= 31
            case "DF16_DEC": // 1 <= len <= 31
            case "DF34_DEC": // 1 <= len <= 31
            case "CURR": // 1 <= len <= 31
            case "QUAN": // 1 <= len <= 31
                if (input.length === undefined) {
                    return new Types.UnknownType(input.text + " unknown length, " + input.infoText, input.infoText);
                }
                else if (input.decimals === undefined) {
                    return new Types.PackedType(parseInt(input.length, 10), 0, extra);
                }
                return new Types.PackedType(parseInt(input.length, 10), parseInt(input.decimals, 10), extra);
            case "ACCP":
                return new Types.CharacterType(6, extra); // YYYYMM
            case "LANG":
                return new Types.CharacterType(1, extra);
            case "CLNT":
                return new Types.CharacterType(3, extra);
            case "CUKY":
                return new Types.CharacterType(5, extra);
            case "UNIT": // 2 <= len <= 3
                return new Types.CharacterType(3, extra);
            case "UTCLONG":
                return new Types.CharacterType(27, extra);
            case "NUMC": // 1 <= len <= 255
                if (input.length === undefined) {
                    return new Types.UnknownType(input.text + " unknown length", input.infoText);
                }
                return new Types.NumericType(parseInt(input.length, 10), input.qualifiedName);
            case "CHAR": // 1 <= len <= 30000 (1333 for table fields)
            case "LCHR": // 256 <= len <= 32000
                if (input.length === undefined) {
                    return new Types.UnknownType(input.text + " unknown length", input.infoText);
                }
                return new Types.CharacterType(parseInt(input.length, 10), extra);
            case "RAW": // 1 <= len <= 32000
            case "LRAW": // 256 <= len <= 32000
                if (input.length === undefined) {
                    return new Types.UnknownType(input.text + " unknown length", input.infoText);
                }
                return new Types.HexType(parseInt(input.length, 10), input.qualifiedName);
            case "TIMN": // Native HANA
            case "TIMS":
                return new Types.TimeType({ qualifiedName: input.qualifiedName }); //HHMMSS
            case "DECFLOAT16": // len = 16
            case "DECFLOAT34": // len = 34
            case "D16R": // len = 16
            case "D34R": // len = 34
            case "DF16_RAW": // len = 16
            case "DF34_RAW": // len = 34
            case "FLTP": // len = 16
                if (input.length === undefined) {
                    return new Types.UnknownType(input.text + " unknown length", input.infoText);
                }
                return new Types.FloatingPointType(parseInt(input.length, 10), input.qualifiedName);
            case "DATN": // Native HANA
            case "DATS":
                return new Types.DateType({ qualifiedName: input.qualifiedName }); //YYYYMMDD
            case "INT1":
            case "INT2":
            case "INT4":
                return Types.IntegerType.get({ qualifiedName: input.qualifiedName });
            case "INT8":
                return new Types.Integer8Type({ qualifiedName: input.qualifiedName });
            case "SSTR": // 1 <= len <= 1333
            case "SSTRING": // 1 <= len <= 1333
            case "STRG": // 256 <= len
            case "STRING": // 256 <= len
                return Types.StringType.get({ qualifiedName: input.qualifiedName });
            case "RSTR": // 256 <= len
            case "RAWSTRING": // 256 <= len
            case "GEOM_EWKB":
                return new Types.XStringType({ qualifiedName: input.qualifiedName });
            case "D16S":
            case "D34S":
            case "DF16_SCL":
            case "DF34_SCL":
            case "PREC":
            case "VARC":
                return new Types.UnknownType(input.text + " is an obsolete data type", input.infoText);
            default:
                return new Types.UnknownType(input.text + " unknown", input.infoText);
        }
    }
}
exports.DDIC = DDIC;
//# sourceMappingURL=ddic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddic_references.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddic_references.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDICReferences = void 0;
class DDICReferences {
    constructor() {
        this.nameTypeIndex = {};
        this.filenameIndex = {};
    }
    setUsing(obj, using) {
        this.clear(obj);
        for (const u of using) {
            this.addUsing(obj, u);
        }
    }
    addUsing(obj, using) {
        if (using === undefined) {
            return;
        }
        // add to name and type index
        const newName = obj.getName().toUpperCase();
        const newType = obj.getType();
        if (this.nameTypeIndex[newName] === undefined) {
            this.nameTypeIndex[newName] = {};
        }
        if (this.nameTypeIndex[newName][newType] === undefined) {
            this.nameTypeIndex[newName][newType] = [];
        }
        this.nameTypeIndex[newName][newType].push(using);
        // add to filename index
        if (using.filename && using.token) {
            if (this.filenameIndex[using.filename] === undefined) {
                this.filenameIndex[using.filename] = {};
            }
            if (this.filenameIndex[using.filename][using.token.getRow()] === undefined) {
                this.filenameIndex[using.filename][using.token.getRow()] = [];
            }
            this.filenameIndex[using.filename][using.token.getRow()].push(using);
        }
    }
    clear(obj) {
        var _a, _b;
        // remove from filenameIndex first
        for (const u of this.listUsing(obj)) {
            if (u.filename && u.token) {
                const found = (_a = this.filenameIndex[u.filename]) === null || _a === void 0 ? void 0 : _a[u.token.getRow()];
                if (found) {
                    found.pop(); // TODODOD, this assumes there is max one reference on each line
                }
            }
        }
        // remove from name + type index
        const name = obj.getName().toUpperCase();
        const type = obj.getType();
        if ((_b = this.nameTypeIndex[name]) === null || _b === void 0 ? void 0 : _b[type]) {
            this.nameTypeIndex[name][type] = [];
        }
    }
    listByFilename(filename, line) {
        var _a;
        return ((_a = this.filenameIndex[filename]) === null || _a === void 0 ? void 0 : _a[line]) || [];
    }
    listUsing(obj) {
        var _a;
        const newName = obj.getName().toUpperCase();
        const newType = obj.getType();
        const found = (_a = this.nameTypeIndex[newName]) === null || _a === void 0 ? void 0 : _a[newType];
        if (found !== undefined) {
            return found;
        }
        else {
            return [];
        }
    }
    listWhereUsed(obj) {
        // todo, add reverse index, this is slow
        const ret = [];
        const searchName = obj.getName().toUpperCase();
        const searchType = obj.getType();
        for (const name in this.nameTypeIndex) {
            for (const type in this.nameTypeIndex[name]) {
                for (const f of this.nameTypeIndex[name][type]) {
                    if (f.object && f.object.getType() === searchType && f.object.getName() === searchName) {
                        ret.push({ type, name, token: f.token, filename: f.filename });
                    }
                }
            }
        }
        return ret;
    }
}
exports.DDICReferences = DDICReferences;
//# sourceMappingURL=ddic_references.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/ddl_lexer.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/ddl_lexer.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLLexer = void 0;
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class DDLLexer {
    static run(file) {
        const step1 = [];
        const lines = file.getRaw().replace(/\r/g, "").split("\n");
        for (const l of lines) {
            if (l.startsWith("@")) {
                continue; // skip annotations for now
            }
            step1.push(...l.split(" "));
        }
        const step2 = [];
        for (const t of step1) {
            if (t === "") {
                continue;
            }
            else if (t.endsWith(";")) {
                step2.push(t.substr(0, t.length - 1));
                step2.push(";");
            }
            else {
                step2.push(t);
            }
        }
        return step2.map(t => new tokens_1.Identifier(new position_1.Position(1, 1), t));
    }
}
exports.DDLLexer = DDLLexer;
//# sourceMappingURL=ddl_lexer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/ddl_parser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/ddl_parser.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLParser = exports.DDLKind = void 0;
const combi_1 = __webpack_require__(/*! ../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const ddl_lexer_1 = __webpack_require__(/*! ./ddl_lexer */ "./node_modules/@abaplint/core/build/src/ddl/ddl_lexer.js");
const Expressions = __webpack_require__(/*! ./expressions */ "./node_modules/@abaplint/core/build/src/ddl/expressions/index.js");
var DDLKind;
(function (DDLKind) {
    DDLKind["Structure"] = "structure";
    DDLKind["Table"] = "table";
})(DDLKind || (exports.DDLKind = DDLKind = {}));
class DDLParser {
    parse(file) {
        const tokens = ddl_lexer_1.DDLLexer.run(file);
        let res = combi_1.Combi.run(new Expressions.DDLStructure(), tokens, version_1.defaultVersion);
        if (res === undefined) {
            res = combi_1.Combi.run(new Expressions.DDLTable(), tokens, version_1.defaultVersion);
        }
        if (res === undefined || !(res[0] instanceof nodes_1.ExpressionNode)) {
            return undefined;
        }
        return this.parsedToResult(res[0]);
    }
    parsedToResult(node) {
        var _a, _b;
        const fields = [];
        let found = node.findDirectExpressions(Expressions.DDLStructureField);
        found = found.concat(node.findDirectExpressions(Expressions.DDLTableField));
        found = found.concat(node.findDirectExpressions(Expressions.DDLInclude));
        for (const f of found) {
            const name = ((_a = f.findDirectExpression(Expressions.DDLName)) === null || _a === void 0 ? void 0 : _a.concatTokens()) || "";
            if (f.get() instanceof Expressions.DDLInclude) {
                fields.push({
                    name: ".INCLUDE",
                    type: name,
                    key: false,
                    notNull: false,
                });
            }
            else {
                const type = ((_b = f.findDirectExpression(Expressions.DDLType)) === null || _b === void 0 ? void 0 : _b.concatTokens()) || "";
                fields.push({
                    name,
                    type,
                    key: false,
                    notNull: false,
                });
            }
        }
        const result = {
            name: node.findDirectExpression(Expressions.DDLName).concatTokens(),
            kind: node.get() instanceof Expressions.DDLStructure ? DDLKind.Structure : DDLKind.Table,
            fields,
        };
        return result;
    }
}
exports.DDLParser = DDLParser;
//# sourceMappingURL=ddl_parser.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_include.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_include.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLInclude = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const ddl_name_1 = __webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js");
class DDLInclude extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("INCLUDE", ddl_name_1.DDLName, ";");
    }
}
exports.DDLInclude = DDLInclude;
//# sourceMappingURL=ddl_include.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLName = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class DDLName extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^\w+$/);
    }
}
exports.DDLName = DDLName;
//# sourceMappingURL=ddl_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLStructure = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const ddl_structure_field_1 = __webpack_require__(/*! ./ddl_structure_field */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure_field.js");
const ddl_name_1 = __webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js");
const ddl_include_1 = __webpack_require__(/*! ./ddl_include */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_include.js");
class DDLStructure extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("DEFINE STRUCTURE", ddl_name_1.DDLName, "{", (0, combi_1.plusPrio)((0, combi_1.altPrio)(ddl_structure_field_1.DDLStructureField, ddl_include_1.DDLInclude)), "}");
    }
}
exports.DDLStructure = DDLStructure;
//# sourceMappingURL=ddl_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure_field.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure_field.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLStructureField = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const ddl_name_1 = __webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js");
const ddl_type_1 = __webpack_require__(/*! ./ddl_type */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_type.js");
class DDLStructureField extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)(ddl_name_1.DDLName, ":", ddl_type_1.DDLType, ";");
    }
}
exports.DDLStructureField = DDLStructureField;
//# sourceMappingURL=ddl_structure_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLTable = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const ddl_include_1 = __webpack_require__(/*! ./ddl_include */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_include.js");
const ddl_name_1 = __webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js");
const ddl_table_field_1 = __webpack_require__(/*! ./ddl_table_field */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table_field.js");
class DDLTable extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)("DEFINE TABLE", ddl_name_1.DDLName, "{", (0, combi_1.plusPrio)((0, combi_1.altPrio)(ddl_table_field_1.DDLTableField, ddl_include_1.DDLInclude)), "}");
    }
}
exports.DDLTable = DDLTable;
//# sourceMappingURL=ddl_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table_field.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table_field.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLTableField = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const ddl_name_1 = __webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js");
const ddl_type_1 = __webpack_require__(/*! ./ddl_type */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_type.js");
class DDLTableField extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.seq)((0, combi_1.optPrio)("KEY"), ddl_name_1.DDLName, ":", ddl_type_1.DDLType, (0, combi_1.optPrio)("NOT NULL"), ";");
    }
}
exports.DDLTableField = DDLTableField;
//# sourceMappingURL=ddl_table_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_type.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_type.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DDLType = void 0;
const combi_1 = __webpack_require__(/*! ../../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
class DDLType extends combi_1.Expression {
    getRunnable() {
        return (0, combi_1.regex)(/^(abap\.)?\w+(\(\d+\))?$/);
    }
}
exports.DDLType = DDLType;
//# sourceMappingURL=ddl_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/ddl/expressions/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/ddl/expressions/index.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./ddl_include */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_include.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_name */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_name.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_structure_field */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure_field.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_structure */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_table_field */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table_field.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_table */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_table.js"), exports);
__exportStar(__webpack_require__(/*! ./ddl_type */ "./node_modules/@abaplint/core/build/src/ddl/expressions/ddl_type.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/edit_helper.js":
/*!**************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/edit_helper.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EditHelper = exports.EditDraft = void 0;
exports.applyEditSingle = applyEditSingle;
exports.applyEditList = applyEditList;
const position_1 = __webpack_require__(/*! ./position */ "./node_modules/@abaplint/core/build/src/position.js");
const memory_file_1 = __webpack_require__(/*! ./files/memory_file */ "./node_modules/@abaplint/core/build/src/files/memory_file.js");
class EditDraft {
    constructor(file) {
        this.start = undefined;
        this.end = undefined;
        this.rows = file.getRawRows();
        this.file = file;
    }
    /** replace existing text, insert text wont work */
    replace(pos, value) {
        if (this.start === undefined || pos.isBefore(this.start)) {
            this.start = pos;
        }
        const end = new position_1.Position(pos.getRow(), pos.getCol() + value.length);
        if (this.end === undefined || end.isAfter(this.end)) {
            this.end = end;
        }
        const str = this.rows[pos.getRow() - 1];
        this.rows[pos.getRow() - 1] = str.substr(0, pos.getCol() - 1) + value + str.substr(pos.getCol() + value.length - 1);
    }
    toEdit() {
        if (this.start === undefined) {
            throw "EditDraft, start undefined";
        }
        else if (this.end === undefined) {
            throw "EditDraft, end undefined";
        }
        let value = "";
        for (let row = this.start.getRow(); row <= this.end.getRow(); row++) {
            if (row === this.start.getRow() && row === this.end.getRow()) {
                // first and last row
                value = this.rows[row - 1].substring(this.start.getCol() - 1, this.end.getCol() - 1);
            }
            else if (row === this.start.getRow()) {
                // first row
                value = this.rows[row - 1].substring(this.start.getCol() - 1);
            }
            else if (row === this.end.getRow()) {
                // last row
                value += "\n" + this.rows[row - 1].substring(0, this.end.getCol() - 1);
            }
            else {
                // middle row
                value += "\n" + this.rows[row - 1];
            }
        }
        return EditHelper.replaceRange(this.file, this.start, this.end, value);
    }
}
exports.EditDraft = EditDraft;
class EditHelper {
    static mergeList(fixes) {
        const results = {};
        for (const f of fixes) {
            for (const filename in f) {
                if (results[filename] === undefined) {
                    results[filename] = [];
                }
                results[filename] = results[filename].concat(f[filename]);
            }
        }
        return results;
    }
    static merge(fix1, fix2) {
        const ret = {};
        for (const k of Object.keys(fix1)) {
            if (ret[k] === undefined) {
                ret[k] = [];
            }
            ret[k] = ret[k].concat(fix1[k]);
        }
        for (const k of Object.keys(fix2)) {
            if (ret[k] === undefined) {
                ret[k] = [];
            }
            ret[k] = ret[k].concat(fix2[k]);
        }
        return ret;
    }
    static findStatement(token, file) {
        if (file === undefined) {
            return undefined;
        }
        for (const s of file.getStatements()) {
            if (s.includesToken(token)) {
                return s;
            }
        }
        return undefined;
    }
    static deleteStatement(file, statement) {
        const scolon = statement.getColon();
        if (scolon === undefined) {
            return EditHelper.deleteRange(file, statement.getFirstToken().getStart(), statement.getLastToken().getEnd());
        }
        let setPrevious = true;
        let setNext = true;
        /** previous statement in the chain */
        let previousStatement = undefined;
        /** next statement in the chain */
        let nextStatement = undefined;
        for (const s of file.getStatements()) {
            const colon = s.getColon();
            if (colon === undefined) {
                continue;
            }
            else if (s === statement) {
                setPrevious = false;
                setNext = true;
                continue;
            }
            else if (setPrevious === true) {
                if (scolon.getStart().equals(colon.getStart())) {
                    previousStatement = s;
                }
            }
            else if (setNext === true) {
                if (scolon.getStart().equals(colon.getStart())) {
                    nextStatement = s;
                }
                break;
            }
        }
        if (previousStatement === undefined && nextStatement === undefined) {
            // the statement to be deleted is the only one in the chain
            return EditHelper.deleteRange(file, statement.getFirstToken().getStart(), statement.getLastToken().getEnd());
        }
        // the start of deletion should happen for tokens after the colon
        let startDelete = statement.getFirstToken().getStart();
        for (const t of statement.getTokens()) {
            if (t.getStart().isAfter(scolon.getEnd())) {
                startDelete = t.getStart();
                break;
            }
        }
        const colon = statement.getColon();
        if (statement.getLastToken().getStr() === "." && previousStatement) {
            // last statement in chain
            const edit1 = EditHelper.replaceToken(file, previousStatement.getLastToken(), ".");
            const edit2 = EditHelper.deleteRange(file, previousStatement.getLastToken().getEnd(), statement.getLastToken().getEnd());
            return EditHelper.merge(edit1, edit2);
        }
        else if (previousStatement === undefined && colon && nextStatement) {
            // first statement in chain
            return EditHelper.deleteRange(file, this.firstAfterColon(statement), this.firstAfterColon(nextStatement));
        }
        else {
            // middle statement
            return EditHelper.deleteRange(file, startDelete, this.firstAfterColon(nextStatement));
        }
    }
    static firstAfterColon(statement) {
        const colon = statement.getColon().getStart();
        for (const t of statement.getTokens()) {
            if (t.getStart().isAfter(colon)) {
                return t.getStart();
            }
        }
        throw new Error("firstAfterColon, emtpy statement?");
    }
    static deleteToken(file, token) {
        const filename = file.getFilename();
        const range = { start: token.getStart(), end: token.getEnd() };
        return { [filename]: [{ range, newText: "" }] };
    }
    static deleteRange(file, start, end) {
        const filename = file.getFilename();
        const range = { start, end };
        return { [filename]: [{ range, newText: "" }] };
    }
    static insertAt(file, pos, text) {
        const filename = file.getFilename();
        const range = { start: pos, end: pos };
        return { [filename]: [{ range, newText: text }] };
    }
    static replaceToken(file, token, text) {
        return this.replaceRange(file, token.getStart(), token.getEnd(), text);
    }
    static replaceRange(file, start, end, text) {
        const filename = file.getFilename();
        const range = { start, end };
        return { [filename]: [{ range, newText: text }] };
    }
}
exports.EditHelper = EditHelper;
function applyEditSingle(reg, edit) {
    var _a;
    for (const filename in edit) {
        let rows = (_a = reg.getFileByName(filename)) === null || _a === void 0 ? void 0 : _a.getRawRows();
        if (rows === undefined) {
            throw new Error("applyEdit, file not found");
        }
        for (const e of edit[filename]) {
            if (e.range.start.getRow() === e.range.end.getRow()) {
                const line = rows[e.range.start.getRow() - 1];
                rows[e.range.start.getRow() - 1] =
                    line.substr(0, e.range.start.getCol() - 1) +
                        e.newText +
                        line.substr(e.range.end.getCol() - 1);
            }
            else {
                const first = rows[e.range.start.getRow() - 1];
                let res = first.substr(0, e.range.start.getCol() - 1) + e.newText;
                const last = rows[e.range.end.getRow() - 1];
                res = res + last.substr(e.range.end.getCol() - 1);
                // delete middle lines
                rows.splice(e.range.start.getRow(), e.range.end.getRow() - e.range.start.getRow());
                // clean up
                rows[e.range.start.getRow() - 1] = res;
                rows = rows.join("\n").split("\n"); // if the edit contained newlines and multiple edits
            }
        }
        const result = new memory_file_1.MemoryFile(filename, rows.join("\n"));
        reg.updateFile(result);
    }
}
/** returns list of filenames which were changed */
function applyEditList(reg, edits) {
    const ret = [];
    let length = 0;
    const merged = {};
    for (const e of edits) {
        for (const f in e) {
            if (merged[f] === undefined) {
                merged[f] = [];
                length = length + 1;
            }
            merged[f] = merged[f].concat(e[f]);
        }
    }
    for (const f in merged) {
        const singleFile = {};
        // sort, start with the last position first
        singleFile[f] = merged[f].sort((a, b) => {
            let val = b.range.start.getRow() - a.range.start.getRow();
            if (val === 0) {
                val = b.range.start.getCol() - a.range.start.getCol();
            }
            return val;
        });
        applyEditSingle(reg, singleFile);
        ret.push(f);
    }
    return ret;
}
//# sourceMappingURL=edit_helper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/files/_abstract_file.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/files/_abstract_file.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractFile = void 0;
class AbstractFile {
    constructor(filename) {
        this.filename = filename;
    }
    getFilename() {
        return this.filename;
    }
    baseName() {
        let name = this.getFilename();
        let index = name.lastIndexOf("\\");
        if (index) {
            index = index + 1;
        }
        name = name.substring(index);
        index = name.lastIndexOf("/");
        if (index) {
            index = index + 1;
        }
        return name.substring(index);
    }
    getObjectType() {
        var _a;
        const split = this.baseName().split(".");
        return (_a = split[1]) === null || _a === void 0 ? void 0 : _a.toUpperCase();
    }
    getObjectName() {
        const split = this.baseName().split(".");
        // handle url escaped namespace
        split[0] = split[0].replace(/%23/g, "#");
        // handle additional escaping
        split[0] = split[0].replace(/%3e/g, ">");
        split[0] = split[0].replace(/%3c/g, "<");
        // handle abapGit namespace
        split[0] = split[0].toUpperCase().replace(/#/g, "/");
        // handle AFF namespace
        split[0] = split[0].replace("(", "/");
        split[0] = split[0].replace(")", "/");
        return split[0];
    }
}
exports.AbstractFile = AbstractFile;
//# sourceMappingURL=_abstract_file.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/files/memory_file.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/files/memory_file.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MemoryFile = void 0;
const _abstract_file_1 = __webpack_require__(/*! ./_abstract_file */ "./node_modules/@abaplint/core/build/src/files/_abstract_file.js");
class MemoryFile extends _abstract_file_1.AbstractFile {
    constructor(filename, raw) {
        super(filename);
        this.raw = raw;
    }
    getRaw() {
        return this.raw;
    }
    getRawRows() {
        return this.raw.split("\n");
    }
}
exports.MemoryFile = MemoryFile;
//# sourceMappingURL=memory_file.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPFile = exports.RulesRunner = exports.SpaghettiScope = exports.SyntaxLogic = exports.ABAPObject = exports.Tokens = exports.ExpressionsCDS = exports.CDSParser = exports.LanguageServerTypes = exports.DDLParser = exports.FLOW_EDGE_TYPE = exports.FlowGraph = exports.StatementFlow = exports.NativeSQL = exports.MacroContent = exports.MacroCall = exports.applyEditList = exports.applyEditSingle = exports.SpaghettiScopeNode = exports.AbstractFile = exports.Token = exports.ScopeType = exports.BasicTypes = exports.TypedIdentifier = exports.AbstractType = exports.VirtualPosition = exports.Comment = exports.Unknown = exports.Empty = exports.Identifier = exports.Nodes = exports.Types = exports.Expressions = exports.Statements = exports.Structures = exports.SkipLogic = exports.Objects = exports.ArtifactsRules = exports.ArtifactsObjects = exports.ArtifactsABAP = exports.BuiltIn = exports.MethodLengthStats = exports.LanguageServer = exports.Registry = exports.CyclomaticComplexityStats = exports.ReferenceType = exports.Version = exports.Config = exports.Issue = exports.MemoryFile = void 0;
exports.LSPEdit = exports.RuleTag = exports.Severity = exports.Visibility = exports.Info = exports.Diagnostics = exports.Rename = exports.PrettyPrinter = exports.Position = exports.CurrentScope = void 0;
const issue_1 = __webpack_require__(/*! ./issue */ "./node_modules/@abaplint/core/build/src/issue.js");
Object.defineProperty(exports, "Issue", ({ enumerable: true, get: function () { return issue_1.Issue; } }));
const config_1 = __webpack_require__(/*! ./config */ "./node_modules/@abaplint/core/build/src/config.js");
Object.defineProperty(exports, "Config", ({ enumerable: true, get: function () { return config_1.Config; } }));
const version_1 = __webpack_require__(/*! ./version */ "./node_modules/@abaplint/core/build/src/version.js");
Object.defineProperty(exports, "Version", ({ enumerable: true, get: function () { return version_1.Version; } }));
const registry_1 = __webpack_require__(/*! ./registry */ "./node_modules/@abaplint/core/build/src/registry.js");
Object.defineProperty(exports, "Registry", ({ enumerable: true, get: function () { return registry_1.Registry; } }));
const method_length_stats_1 = __webpack_require__(/*! ./utils/method_length_stats */ "./node_modules/@abaplint/core/build/src/utils/method_length_stats.js");
Object.defineProperty(exports, "MethodLengthStats", ({ enumerable: true, get: function () { return method_length_stats_1.MethodLengthStats; } }));
const language_server_1 = __webpack_require__(/*! ./lsp/language_server */ "./node_modules/@abaplint/core/build/src/lsp/language_server.js");
Object.defineProperty(exports, "LanguageServer", ({ enumerable: true, get: function () { return language_server_1.LanguageServer; } }));
const LanguageServerTypes = __webpack_require__(/*! ./lsp/_interfaces */ "./node_modules/@abaplint/core/build/src/lsp/_interfaces.js");
exports.LanguageServerTypes = LanguageServerTypes;
const artifacts_1 = __webpack_require__(/*! ./abap/artifacts */ "./node_modules/@abaplint/core/build/src/abap/artifacts.js");
Object.defineProperty(exports, "ArtifactsABAP", ({ enumerable: true, get: function () { return artifacts_1.ArtifactsABAP; } }));
const artifacts_objects_1 = __webpack_require__(/*! ./artifacts_objects */ "./node_modules/@abaplint/core/build/src/artifacts_objects.js");
Object.defineProperty(exports, "ArtifactsObjects", ({ enumerable: true, get: function () { return artifacts_objects_1.ArtifactsObjects; } }));
const artifacts_rules_1 = __webpack_require__(/*! ./artifacts_rules */ "./node_modules/@abaplint/core/build/src/artifacts_rules.js");
Object.defineProperty(exports, "ArtifactsRules", ({ enumerable: true, get: function () { return artifacts_rules_1.ArtifactsRules; } }));
const _abap_object_1 = __webpack_require__(/*! ./objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
Object.defineProperty(exports, "ABAPObject", ({ enumerable: true, get: function () { return _abap_object_1.ABAPObject; } }));
const syntax_1 = __webpack_require__(/*! ./abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
Object.defineProperty(exports, "SyntaxLogic", ({ enumerable: true, get: function () { return syntax_1.SyntaxLogic; } }));
const spaghetti_scope_1 = __webpack_require__(/*! ./abap/5_syntax/spaghetti_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/spaghetti_scope.js");
Object.defineProperty(exports, "SpaghettiScope", ({ enumerable: true, get: function () { return spaghetti_scope_1.SpaghettiScope; } }));
Object.defineProperty(exports, "SpaghettiScopeNode", ({ enumerable: true, get: function () { return spaghetti_scope_1.SpaghettiScopeNode; } }));
const _typed_identifier_1 = __webpack_require__(/*! ./abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
Object.defineProperty(exports, "TypedIdentifier", ({ enumerable: true, get: function () { return _typed_identifier_1.TypedIdentifier; } }));
const _abstract_type_1 = __webpack_require__(/*! ./abap/types/basic/_abstract_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/_abstract_type.js");
Object.defineProperty(exports, "AbstractType", ({ enumerable: true, get: function () { return _abstract_type_1.AbstractType; } }));
const _scope_type_1 = __webpack_require__(/*! ./abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
Object.defineProperty(exports, "ScopeType", ({ enumerable: true, get: function () { return _scope_type_1.ScopeType; } }));
const _current_scope_1 = __webpack_require__(/*! ./abap/5_syntax/_current_scope */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_current_scope.js");
Object.defineProperty(exports, "CurrentScope", ({ enumerable: true, get: function () { return _current_scope_1.CurrentScope; } }));
const Objects = __webpack_require__(/*! ./objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
exports.Objects = Objects;
const abstract_token_1 = __webpack_require__(/*! ./abap/1_lexer/tokens/abstract_token */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/abstract_token.js");
Object.defineProperty(exports, "Token", ({ enumerable: true, get: function () { return abstract_token_1.AbstractToken; } }));
const Statements = __webpack_require__(/*! ./abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
exports.Statements = Statements;
const Expressions = __webpack_require__(/*! ./abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
exports.Expressions = Expressions;
const ExpressionsCDS = __webpack_require__(/*! ./cds/expressions */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
exports.ExpressionsCDS = ExpressionsCDS;
const Structures = __webpack_require__(/*! ./abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
exports.Structures = Structures;
const Nodes = __webpack_require__(/*! ./abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
exports.Nodes = Nodes;
const BasicTypes = __webpack_require__(/*! ./abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
exports.BasicTypes = BasicTypes;
const Types = __webpack_require__(/*! ./abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
exports.Types = Types;
const Tokens = __webpack_require__(/*! ./abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
exports.Tokens = Tokens;
const position_1 = __webpack_require__(/*! ./position */ "./node_modules/@abaplint/core/build/src/position.js");
Object.defineProperty(exports, "Position", ({ enumerable: true, get: function () { return position_1.Position; } }));
const virtual_position_1 = __webpack_require__(/*! ./virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
Object.defineProperty(exports, "VirtualPosition", ({ enumerable: true, get: function () { return virtual_position_1.VirtualPosition; } }));
const _abstract_file_1 = __webpack_require__(/*! ./files/_abstract_file */ "./node_modules/@abaplint/core/build/src/files/_abstract_file.js");
Object.defineProperty(exports, "AbstractFile", ({ enumerable: true, get: function () { return _abstract_file_1.AbstractFile; } }));
const pretty_printer_1 = __webpack_require__(/*! ./pretty_printer/pretty_printer */ "./node_modules/@abaplint/core/build/src/pretty_printer/pretty_printer.js");
Object.defineProperty(exports, "PrettyPrinter", ({ enumerable: true, get: function () { return pretty_printer_1.PrettyPrinter; } }));
const _statement_1 = __webpack_require__(/*! ./abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
Object.defineProperty(exports, "Empty", ({ enumerable: true, get: function () { return _statement_1.Empty; } }));
Object.defineProperty(exports, "Unknown", ({ enumerable: true, get: function () { return _statement_1.Unknown; } }));
Object.defineProperty(exports, "Comment", ({ enumerable: true, get: function () { return _statement_1.Comment; } }));
Object.defineProperty(exports, "MacroCall", ({ enumerable: true, get: function () { return _statement_1.MacroCall; } }));
Object.defineProperty(exports, "MacroContent", ({ enumerable: true, get: function () { return _statement_1.MacroContent; } }));
Object.defineProperty(exports, "NativeSQL", ({ enumerable: true, get: function () { return _statement_1.NativeSQL; } }));
const edit_helper_1 = __webpack_require__(/*! ./edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
Object.defineProperty(exports, "applyEditSingle", ({ enumerable: true, get: function () { return edit_helper_1.applyEditSingle; } }));
Object.defineProperty(exports, "applyEditList", ({ enumerable: true, get: function () { return edit_helper_1.applyEditList; } }));
const _reference_1 = __webpack_require__(/*! ./abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
Object.defineProperty(exports, "ReferenceType", ({ enumerable: true, get: function () { return _reference_1.ReferenceType; } }));
const _builtin_1 = __webpack_require__(/*! ./abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
Object.defineProperty(exports, "BuiltIn", ({ enumerable: true, get: function () { return _builtin_1.BuiltIn; } }));
const abap_file_1 = __webpack_require__(/*! ./abap/abap_file */ "./node_modules/@abaplint/core/build/src/abap/abap_file.js");
Object.defineProperty(exports, "ABAPFile", ({ enumerable: true, get: function () { return abap_file_1.ABAPFile; } }));
const memory_file_1 = __webpack_require__(/*! ./files/memory_file */ "./node_modules/@abaplint/core/build/src/files/memory_file.js");
Object.defineProperty(exports, "MemoryFile", ({ enumerable: true, get: function () { return memory_file_1.MemoryFile; } }));
const renamer_1 = __webpack_require__(/*! ./objects/rename/renamer */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer.js");
Object.defineProperty(exports, "Rename", ({ enumerable: true, get: function () { return renamer_1.Renamer; } }));
const Info = __webpack_require__(/*! ./abap/4_file_information/_abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js");
exports.Info = Info;
const visibility_1 = __webpack_require__(/*! ./abap/4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
Object.defineProperty(exports, "Visibility", ({ enumerable: true, get: function () { return visibility_1.Visibility; } }));
const _identifier_1 = __webpack_require__(/*! ./abap/4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
Object.defineProperty(exports, "Identifier", ({ enumerable: true, get: function () { return _identifier_1.Identifier; } }));
const severity_1 = __webpack_require__(/*! ./severity */ "./node_modules/@abaplint/core/build/src/severity.js");
Object.defineProperty(exports, "Severity", ({ enumerable: true, get: function () { return severity_1.Severity; } }));
const ddl_parser_1 = __webpack_require__(/*! ./ddl/ddl_parser */ "./node_modules/@abaplint/core/build/src/ddl/ddl_parser.js");
Object.defineProperty(exports, "DDLParser", ({ enumerable: true, get: function () { return ddl_parser_1.DDLParser; } }));
const cds_parser_1 = __webpack_require__(/*! ./cds/cds_parser */ "./node_modules/@abaplint/core/build/src/cds/cds_parser.js");
Object.defineProperty(exports, "CDSParser", ({ enumerable: true, get: function () { return cds_parser_1.CDSParser; } }));
const rules_runner_1 = __webpack_require__(/*! ./rules_runner */ "./node_modules/@abaplint/core/build/src/rules_runner.js");
Object.defineProperty(exports, "RulesRunner", ({ enumerable: true, get: function () { return rules_runner_1.RulesRunner; } }));
const _irule_1 = __webpack_require__(/*! ./rules/_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
Object.defineProperty(exports, "RuleTag", ({ enumerable: true, get: function () { return _irule_1.RuleTag; } }));
const cyclomatic_complexity_stats_1 = __webpack_require__(/*! ./utils/cyclomatic_complexity_stats */ "./node_modules/@abaplint/core/build/src/utils/cyclomatic_complexity_stats.js");
Object.defineProperty(exports, "CyclomaticComplexityStats", ({ enumerable: true, get: function () { return cyclomatic_complexity_stats_1.CyclomaticComplexityStats; } }));
const skip_logic_1 = __webpack_require__(/*! ./skip_logic */ "./node_modules/@abaplint/core/build/src/skip_logic.js");
Object.defineProperty(exports, "SkipLogic", ({ enumerable: true, get: function () { return skip_logic_1.SkipLogic; } }));
const diagnostics_1 = __webpack_require__(/*! ./lsp/diagnostics */ "./node_modules/@abaplint/core/build/src/lsp/diagnostics.js");
Object.defineProperty(exports, "Diagnostics", ({ enumerable: true, get: function () { return diagnostics_1.Diagnostics; } }));
const _edit_1 = __webpack_require__(/*! ./lsp/_edit */ "./node_modules/@abaplint/core/build/src/lsp/_edit.js");
Object.defineProperty(exports, "LSPEdit", ({ enumerable: true, get: function () { return _edit_1.LSPEdit; } }));
const statement_flow_1 = __webpack_require__(/*! ./abap/flow/statement_flow */ "./node_modules/@abaplint/core/build/src/abap/flow/statement_flow.js");
Object.defineProperty(exports, "StatementFlow", ({ enumerable: true, get: function () { return statement_flow_1.StatementFlow; } }));
const flow_graph_1 = __webpack_require__(/*! ./abap/flow/flow_graph */ "./node_modules/@abaplint/core/build/src/abap/flow/flow_graph.js");
Object.defineProperty(exports, "FlowGraph", ({ enumerable: true, get: function () { return flow_graph_1.FlowGraph; } }));
Object.defineProperty(exports, "FLOW_EDGE_TYPE", ({ enumerable: true, get: function () { return flow_graph_1.FLOW_EDGE_TYPE; } }));
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/issue.js":
/*!********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/issue.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Issue = void 0;
const position_1 = __webpack_require__(/*! ./position */ "./node_modules/@abaplint/core/build/src/position.js");
const virtual_position_1 = __webpack_require__(/*! ./virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const severity_1 = __webpack_require__(/*! ./severity */ "./node_modules/@abaplint/core/build/src/severity.js");
class Issue {
    //////////////////////////
    static atRow(file, row, message, key, severity) {
        const start = new position_1.Position(row, 1);
        const end = new position_1.Position(row, file.getRawRows()[row - 1].length + 1);
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: file.getFilename(),
            message,
            key,
            start,
            end,
            severity,
        });
    }
    static atStatement(file, statement, message, key, severity, fix, alternativeFixes) {
        return this.atRange(file, statement.getStart(), statement.getEnd(), message, key, severity, fix, alternativeFixes);
    }
    static atPosition(file, start, message, key, severity, fix) {
        const row = start.getRow();
        const end = new position_1.Position(row, file.getRawRows()[row - 1].length + 1);
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: file.getFilename(),
            message,
            key,
            start,
            end,
            defaultFix: fix,
            severity,
        });
    }
    static atRowRange(file, row, startCol, endCol, message, key, severity, fix) {
        const start = new position_1.Position(row, startCol);
        const end = new position_1.Position(row, endCol);
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: file.getFilename(),
            message,
            key,
            start,
            end,
            defaultFix: fix,
            severity,
        });
    }
    static atRange(file, start, end, message, key, severity, fix, alternativeFixes) {
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: file.getFilename(),
            message,
            key,
            start,
            end,
            defaultFix: fix,
            severity,
            alternativeFixes,
        });
    }
    static atToken(file, token, message, key, severity, fix) {
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: file.getFilename(),
            message,
            key,
            start: token.getStart(),
            end: token.getEnd(),
            severity,
            defaultFix: fix,
        });
    }
    static atTokenFilename(filename, token, message, key, severity, fix) {
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: filename,
            message,
            key,
            start: token.getStart(),
            end: token.getEnd(),
            severity,
            defaultFix: fix,
        });
    }
    static atIdentifier(identifier, message, key, severity, fix) {
        severity = severity !== null && severity !== void 0 ? severity : severity_1.Severity.Error;
        return new Issue({
            filename: identifier.getFilename(),
            message,
            key,
            start: identifier.getStart(),
            end: identifier.getEnd(),
            severity,
            defaultFix: fix,
        });
    }
    constructor(data) {
        this.data = data;
        if (this.data.start instanceof virtual_position_1.VirtualPosition) {
            // no quick fixes inside macros
            this.data.defaultFix = undefined;
        }
        if (this.data.start.getCol() < 1) {
            throw new Error("issue, start col < 1");
        }
        else if (this.data.end.getCol() < 1) {
            throw new Error("issue, end col < 1");
        }
    }
    getData() {
        return this.data;
    }
    getMessage() {
        return this.data.message;
    }
    getKey() {
        return this.data.key;
    }
    getStart() {
        return this.data.start;
    }
    getEnd() {
        return this.data.end;
    }
    getFilename() {
        return this.data.filename;
    }
    getDefaultFix() {
        return this.data.defaultFix;
    }
    getAlternativeFixes() {
        return this.data.alternativeFixes;
    }
    getSeverity() {
        return this.data.severity;
    }
}
exports.Issue = Issue;
//# sourceMappingURL=issue.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/_edit.js":
/*!************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/_edit.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPEdit = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
class LSPEdit {
    static mapEdits(edits) {
        const workspace = { changes: {} };
        for (const edit of edits) {
            for (const filename in edit) {
                if (workspace.changes[filename] === undefined) {
                    workspace.changes[filename] = [];
                }
                workspace.changes[filename] = workspace.changes[filename].concat(this.mapText(edit[filename]));
            }
        }
        return workspace;
    }
    static mapEdit(edit) {
        const workspace = { changes: {} };
        for (const filename in edit) {
            workspace.changes[filename] = this.mapText(edit[filename]);
        }
        return workspace;
    }
    static mapText(edit) {
        const result = [];
        for (const e of edit) {
            const range = LServer.Range.create(e.range.start.getRow() - 1, e.range.start.getCol() - 1, e.range.end.getRow() - 1, e.range.end.getCol() - 1);
            result.push({ range, newText: e.newText });
        }
        return result;
    }
}
exports.LSPEdit = LSPEdit;
//# sourceMappingURL=_edit.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/_interfaces.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/_interfaces.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=_interfaces.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js":
/*!**************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/_lookup.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPLookup = void 0;
/* eslint-disable max-len */
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _builtin_1 = __webpack_require__(/*! ../abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const include_graph_1 = __webpack_require__(/*! ../utils/include_graph */ "./node_modules/@abaplint/core/build/src/utils/include_graph.js");
class LSPLookup {
    static lookup(cursor, reg, obj) {
        var _a, _b;
        const inc = this.findInclude(cursor, reg);
        if (inc) {
            const found = this.ABAPFileResult(inc);
            return { hover: "Include", definition: found, implementation: found };
        }
        const fm = this.findFunctionModule(cursor);
        if (fm) {
            return { hover: "Function Module " + fm };
        }
        let main = obj;
        if (obj instanceof objects_1.Program && obj.isInclude()) {
            // todo: this is slow
            const ig = new include_graph_1.IncludeGraph(reg);
            const mains = ig.listMainForInclude(cursor.identifier.getFilename());
            if (mains.length === 1) {
                // yea, well, or it has to be a popup
                main = reg.findObjectForFile(reg.getFileByName(mains[0])) || obj;
            }
        }
        const bottomScope = new syntax_1.SyntaxLogic(reg, main).run().spaghetti.lookupPosition(cursor.identifier.getStart(), cursor.identifier.getFilename());
        if (bottomScope === undefined) {
            return undefined;
        }
        const clas = bottomScope.findClassDefinition(cursor.token.getStr());
        if (clas && clas.getStart().equals(cursor.token.getStart())) {
            const found = _lsp_utils_1.LSPUtils.identiferToLocation(clas);
            return {
                hover: "Class Definition, " + cursor.token.getStr(),
                definition: found,
                definitionId: clas,
                implementation: undefined,
                scope: bottomScope,
            };
        }
        const intf = bottomScope.findInterfaceDefinition(cursor.token.getStr());
        if (intf && intf.getStart().equals(cursor.token.getStart())) {
            const found = _lsp_utils_1.LSPUtils.identiferToLocation(intf);
            return {
                hover: "Interface Definition, " + cursor.token.getStr(),
                definition: found,
                definitionId: intf,
                implementation: undefined,
                scope: bottomScope,
            };
        }
        const type = bottomScope.findType(cursor.token.getStr());
        if (type !== undefined && type.getStart().equals(cursor.token.getStart())) {
            const found = _lsp_utils_1.LSPUtils.identiferToLocation(type);
            const hover = "Type Definition, " + cursor.token.getStr() + "\n\n" + this.dumpType(type);
            return { hover, definition: found, definitionId: type, scope: bottomScope };
        }
        const method = this.findMethodDefinition(cursor, bottomScope.getParent());
        if (method !== undefined && method.getStart().equals(cursor.token.getStart())) {
            const found = _lsp_utils_1.LSPUtils.identiferToLocation(method);
            const hover = "Method Definition \"" + method.getName() + "\"";
            return { hover, definition: found, definitionId: method, scope: bottomScope };
        }
        let hoverValue = "";
        const ddicRefs = reg.getDDICReferences().listByFilename(cursor.identifier.getFilename(), cursor.identifier.getStart().getRow());
        for (const d of ddicRefs) {
            if (d.object && d.token && d.token.getStart().equals(cursor.identifier.getStart())) {
                hoverValue += `DDIC: ${d.object.getType()} ${d.object.getName()}`;
            }
        }
        const variable = bottomScope.findVariable(cursor.token.getStr());
        if (variable !== undefined && variable.getStart().equals(cursor.token.getStart())) {
            const hover = "Variable Definition\n\n" + this.dumpType(variable);
            if (hoverValue !== "") {
                hoverValue = hover + "\n_________________\n" + hoverValue;
            }
            else {
                hoverValue = hover;
            }
            let location = undefined;
            if (variable.getMeta().includes("built-in" /* IdentifierMeta.BuiltIn */) === false) {
                location = _lsp_utils_1.LSPUtils.identiferToLocation(variable);
            }
            return { hover: hoverValue, definition: location, implementation: location, definitionId: variable, scope: bottomScope };
        }
        // TODO: this can be optimized, no need to loop through all the defintions, the scope knows the name of the object?
        for (const c of [...bottomScope.listClassDefinitions(), ...bottomScope.listInterfaceDefinitions()]) {
            for (const m of ((_a = c.getMethodDefinitions()) === null || _a === void 0 ? void 0 : _a.getAll()) || []) {
                for (const p of ((_b = m.getParameters()) === null || _b === void 0 ? void 0 : _b.getAll()) || []) {
                    if (p.getStart().equals(cursor.token.getStart())) {
                        const found = _lsp_utils_1.LSPUtils.identiferToLocation(p);
                        return {
                            hover: "Method Parameter: " + cursor.token.getStr().replace("!", ""),
                            definition: found,
                            definitionId: p,
                            implementation: undefined,
                            scope: bottomScope,
                        };
                    }
                }
            }
        }
        const refs = this.searchReferences(bottomScope, cursor.token);
        if (refs.length > 0) {
            for (const ref of refs) {
                if (hoverValue !== "") {
                    hoverValue += "\n_________________\n";
                }
                hoverValue += this.referenceHover(ref, bottomScope, reg);
            }
            let definition = undefined;
            let implementation = undefined;
            if (refs[0].resolved) {
                definition = _lsp_utils_1.LSPUtils.identiferToLocation(refs[0].resolved);
                if (definition.uri === _builtin_1.BuiltIn.filename) {
                    definition = undefined;
                }
                if (refs[0].resolved instanceof types_1.FormDefinition) {
                    implementation = definition;
                }
            }
            return {
                hover: hoverValue,
                definition: definition,
                implementation: implementation,
                definitionId: refs[0].resolved,
                scope: bottomScope,
            };
        }
        if (cursor.snode.get() instanceof _statement_1.MacroCall) {
            const macroDefinition = reg.getMacroReferences().findDefinitionByUsage(cursor.identifier.getFilename(), cursor.snode.getFirstToken());
            if (macroDefinition) {
                return {
                    hover: "Macro Call",
                    definition: {
                        uri: macroDefinition === null || macroDefinition === void 0 ? void 0 : macroDefinition.filename,
                        range: _lsp_utils_1.LSPUtils.tokenToRange(macroDefinition.token),
                    },
                };
            }
        }
        if (hoverValue !== "") {
            return { hover: hoverValue, scope: bottomScope };
        }
        return undefined;
    }
    ////////////////////////////////////////////
    static dumpType(variable) {
        let value = variable.toText() + "\n\nType: " + variable.getType().toText(0);
        if (variable.getValue()) {
            value += "\n\nValue: ```" + variable.getValue() + "```";
        }
        if (variable.getMeta().length > 0) {
            value += "\n\nMeta: " + variable.getMeta().join(", ");
        }
        if (variable.getType().containsVoid() === true) {
            value += "\n\nContains Void types";
        }
        if (variable.getType().getQualifiedName()) {
            value += "\n\nQualified Type Name: ```" + variable.getType().getQualifiedName() + "```";
        }
        if (variable.getType().getRTTIName()) {
            value += "\n\nRTTI Name: ```" + variable.getType().getRTTIName() + "```";
        }
        if (variable.getType().isGeneric() === true) {
            value += "\n\nIs Generic Type";
        }
        if (variable.getType().getConversionExit() !== undefined) {
            value += "\n\nConversion Exit: ```" + variable.getType().getConversionExit() + "```";
        }
        if (variable.getType().getDDICName() !== undefined) {
            value += "\n\nDDIC Name: ```" + variable.getType().getDDICName() + "```";
        }
        if (variable.getType().getDescription() !== undefined) {
            value += "\n\nDescription: " + variable.getType().getDescription();
        }
        return value;
    }
    static referenceHover(ref, scope, reg) {
        var _a, _b, _c, _d, _e;
        let name = "";
        if (ref.resolved) {
            name = "```" + ref.resolved.getName() + "```";
        }
        let ret = `${ref.referenceType} ${name}`;
        if (ref.referenceType === _reference_1.ReferenceType.MethodReference && ((_a = ref.extra) === null || _a === void 0 ? void 0 : _a.ooName)) {
            let cdef = scope.findClassDefinition(ref.extra.ooName);
            if (cdef === undefined) {
                cdef = scope.findInterfaceDefinition(ref.extra.ooName);
            }
            if (cdef === undefined) {
                cdef = (_b = reg.getObject("CLAS", ref.extra.ooName)) === null || _b === void 0 ? void 0 : _b.getDefinition();
            }
            if (cdef === undefined) {
                cdef = (_c = reg.getObject("INTF", ref.extra.ooName)) === null || _c === void 0 ? void 0 : _c.getDefinition();
            }
            ret += "\n\n" + this.hoverMethod(ref.position.getName(), cdef);
        }
        else if (ref.resolved instanceof _typed_identifier_1.TypedIdentifier) {
            ret += "\n\n" + this.dumpType(ref.resolved);
        }
        else if (ref.referenceType === _reference_1.ReferenceType.BuiltinMethodReference) {
            const builtinDef = new _builtin_1.BuiltIn().searchBuiltin((_e = (_d = ref.resolved) === null || _d === void 0 ? void 0 : _d.getName()) === null || _e === void 0 ? void 0 : _e.toUpperCase());
            if (builtinDef === undefined) {
                return "Error: builtin method signature not found";
            }
            ret += "\n\n" + this.methodParameters(builtinDef);
        }
        if (ref.resolved) {
            ret += "\n\n(Resolved)";
        }
        if (ref.extra !== undefined && Object.keys(ref.extra).length > 0) {
            ret += "\n\nExtra: " + JSON.stringify(ref.extra);
        }
        return ret;
    }
    static hoverMethod(method, classDef) {
        if (classDef === undefined) {
            return "class not found";
        }
        const methodDef = classDef.getMethodDefinitions().getByName(method);
        if (methodDef === undefined) {
            return "method not found in definition";
        }
        return this.methodParameters(methodDef);
    }
    static methodParameters(methodDef) {
        let ret = "";
        const parameters = methodDef.getParameters();
        const importing = parameters.getImporting();
        if (importing.length > 0) {
            ret += "IMPORTING\n";
            for (const p of importing) {
                ret += this.singleParameter(p);
            }
        }
        const exporting = parameters.getExporting();
        if (exporting.length > 0) {
            ret += "EXPORTING\n";
            for (const p of exporting) {
                ret += this.singleParameter(p);
            }
        }
        const changing = parameters.getChanging();
        if (changing.length > 0) {
            ret += "CHANGING\n";
            for (const p of changing) {
                ret += this.singleParameter(p);
            }
        }
        const r = parameters.getReturning();
        if (r) {
            ret += "RETURNING\n" + this.singleParameter(r);
        }
        if (methodDef.getRaising().length > 0) {
            ret += "RAISING\n";
            for (const p of methodDef.getRaising()) {
                ret += "* " + p + "\n";
            }
        }
        return ret;
    }
    static singleParameter(p) {
        let extra = p.getMeta().join(", ");
        if (extra !== "") {
            extra = "(Meta: " + extra + ")";
        }
        return "* " + p.getName() + extra + " TYPE " + p.getType().toText(1) + "\n\n";
    }
    static searchReferences(scope, token) {
        const ret = [];
        for (const r of scope.getData().references) {
            if (r.position.getStart().equals(token.getStart())) {
                ret.push(r);
            }
        }
        const parent = scope.getParent();
        if (parent) {
            ret.push(...this.searchReferences(parent, token));
        }
        return ret;
    }
    static ABAPFileResult(abap) {
        return {
            uri: abap.getFilename(),
            range: LServer.Range.create(0, 0, 0, 0),
        };
    }
    static findMethodDefinition(found, scope) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (scope === undefined) {
            return undefined;
        }
        if ((scope.getIdentifier().stype !== _scope_type_1.ScopeType.ClassDefinition
            && scope.getIdentifier().stype !== _scope_type_1.ScopeType.Interface)
            || !(found.snode.get() instanceof Statements.MethodDef)) {
            return undefined;
        }
        const nameToken = (_a = found.snode.findFirstExpression(Expressions.MethodName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        if (nameToken === undefined) {
            return undefined;
        }
        if (found.snode.findFirstExpression(Expressions.Redefinition)) {
            return undefined;
        }
        // check the cursor is at the right token
        if (nameToken.getStart().getCol() !== found.token.getStart().getCol()
            || nameToken.getStart().getRow() !== found.token.getStart().getRow()) {
            return undefined;
        }
        if (scope.getIdentifier().stype === _scope_type_1.ScopeType.ClassDefinition) {
            const def = (_d = (_c = (_b = scope.getParent()) === null || _b === void 0 ? void 0 : _b.findClassDefinition(scope.getIdentifier().sname)) === null || _c === void 0 ? void 0 : _c.getMethodDefinitions()) === null || _d === void 0 ? void 0 : _d.getByName(nameToken.getStr());
            return def;
        }
        else {
            const def = (_g = (_f = (_e = scope.getParent()) === null || _e === void 0 ? void 0 : _e.findInterfaceDefinition(scope.getIdentifier().sname)) === null || _f === void 0 ? void 0 : _f.getMethodDefinitions()) === null || _g === void 0 ? void 0 : _g.getByName(nameToken.getStr());
            return def;
        }
    }
    static findFunctionModule(found) {
        if (!(found.snode.get() instanceof Statements.CallFunction)) {
            return undefined;
        }
        const name = found.snode.findFirstExpression(Expressions.FunctionName);
        if (name === undefined) {
            return undefined;
        }
        // check the cursor is at the right token
        const token = name.getFirstToken();
        if (token.getStart().getCol() !== found.token.getStart().getCol()
            || token.getStart().getRow() !== found.token.getStart().getRow()) {
            return undefined;
        }
        return token.getStr();
    }
    static findInclude(found, reg) {
        if (!(found.snode.get() instanceof Statements.Include)) {
            return;
        }
        const name = found.snode.findFirstExpression(Expressions.IncludeName);
        if (name === undefined) {
            return undefined;
        }
        // check the cursor is at the right token
        const token = name.getFirstToken();
        if (token.getStart().getCol() !== found.token.getStart().getCol()
            || token.getStart().getRow() !== found.token.getStart().getRow()) {
            return undefined;
        }
        const obj = reg.getObject("PROG", token.getStr());
        if (obj) {
            return obj.getABAPFiles()[0];
        }
        return undefined;
    }
}
exports.LSPLookup = LSPLookup;
//# sourceMappingURL=_lookup.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LSPUtils = void 0;
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _identifier_1 = __webpack_require__(/*! ../abap/4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
class LSPUtils {
    static getABAPFile(reg, filename) {
        const file = reg.getFileByName(filename);
        if (file === undefined) {
            return undefined;
        }
        const obj = reg.findObjectForFile(file);
        obj === null || obj === void 0 ? void 0 : obj.parse();
        if (obj instanceof _abap_object_1.ABAPObject) {
            for (const abapfile of obj.getABAPFiles()) {
                if (abapfile.getFilename().toUpperCase() === filename.toUpperCase()) {
                    return abapfile;
                }
            }
        }
        return undefined;
    }
    static tokenToRange(token) {
        return LServer.Range.create(token.getStart().getRow() - 1, token.getStart().getCol() - 1, token.getEnd().getRow() - 1, token.getEnd().getCol() - 1);
    }
    static positionToLS(pos) {
        return LServer.Position.create(pos.getRow() - 1, pos.getCol() - 1);
    }
    static identiferToLocation(identifier) {
        return {
            uri: identifier.getFilename(),
            range: LSPUtils.tokenToRange(identifier.getToken()),
        };
    }
    static findCursor(reg, pos) {
        const file = LSPUtils.getABAPFile(reg, pos.textDocument.uri);
        if (file === undefined) {
            return undefined;
        }
        const search = new position_1.Position(pos.position.line + 1, pos.position.character + 1);
        for (const statement of file.getStatements()) {
            const res = this.buildStack(statement, search, [statement]);
            if (res !== undefined) {
                return {
                    token: res.token,
                    identifier: new _identifier_1.Identifier(res.token, file.getFilename()),
                    stack: res.stack,
                    snode: statement
                };
            }
        }
        return undefined;
    }
    static buildStack(node, search, parents) {
        const stack = parents;
        for (const c of node.getChildren()) {
            if (c instanceof nodes_1.TokenNode) {
                const token = c.getFirstToken();
                if (token.getRow() === search.getRow()
                    && token.getCol() <= search.getCol()
                    && token.getCol() + token.getStr().length > search.getCol()) {
                    return { token, stack };
                }
            }
            else {
                const res = this.buildStack(c, search, stack.concat([c]));
                if (res !== undefined) {
                    return res;
                }
            }
        }
        return undefined;
    }
}
exports.LSPUtils = LSPUtils;
//# sourceMappingURL=_lsp_utils.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/code_actions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/code_actions.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeActions = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./node_modules/@abaplint/core/build/src/lsp/diagnostics.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _edit_1 = __webpack_require__(/*! ./_edit */ "./node_modules/@abaplint/core/build/src/lsp/_edit.js");
class CodeActions {
    constructor(reg) {
        this.reg = reg;
    }
    find(params) {
        const diag = new diagnostics_1.Diagnostics(this.reg);
        const issues = diag.findIssues(params.textDocument);
        const totals = {};
        const shown = new Set();
        const ret = [];
        for (const i of issues) {
            const fix = i.getDefaultFix();
            if (fix !== undefined) {
                if (totals[i.getKey()] === undefined) {
                    totals[i.getKey()] = 1;
                }
                else {
                    totals[i.getKey()]++;
                }
                if (this.inRange(i, params.range) === true) {
                    ret.push({
                        title: "Apply fix, " + i.getKey(),
                        kind: LServer.CodeActionKind.QuickFix,
                        diagnostics: [diagnostics_1.Diagnostics.mapDiagnostic(i)],
                        isPreferred: true,
                        edit: _edit_1.LSPEdit.mapEdit(fix),
                    });
                    shown.add(i.getKey());
                }
            }
            for (const alternative of i.getAlternativeFixes() || []) {
                if (this.inRange(i, params.range) === true) {
                    ret.push({
                        title: alternative.description,
                        kind: LServer.CodeActionKind.QuickFix,
                        diagnostics: [diagnostics_1.Diagnostics.mapDiagnostic(i)],
                        isPreferred: true,
                        edit: _edit_1.LSPEdit.mapEdit(alternative.edit),
                    });
                    shown.add(i.getKey());
                }
            }
        }
        for (const s of shown) {
            if (totals[s] > 1) {
                const foo = this.fixAlls(s, issues);
                ret.push(foo);
            }
        }
        return ret;
    }
    //////////////////////
    fixAlls(key, issues) {
        const diagnostics = [];
        const fixes = [];
        for (const i of issues) {
            if (i.getKey() !== key) {
                continue;
            }
            const fix = i.getDefaultFix();
            if (fix === undefined) {
                continue;
            }
            fixes.push(fix);
            diagnostics.push(diagnostics_1.Diagnostics.mapDiagnostic(i));
        }
        return {
            title: "Fix all, " + key,
            kind: LServer.CodeActionKind.QuickFix,
            diagnostics,
            isPreferred: true,
            edit: _edit_1.LSPEdit.mapEdits(fixes),
        };
    }
    inRange(i, range) {
        const start = new position_1.Position(range.start.line + 1, range.start.character + 1);
        const end = new position_1.Position(range.end.line + 1, range.end.character + 1);
        return i.getStart().isBetween(start, end)
            || i.getEnd().isBetween(start, end)
            || start.isBetween(i.getStart(), i.getEnd())
            || end.isBetween(i.getStart(), i.getEnd())
            || end.equals(i.getEnd());
    }
}
exports.CodeActions = CodeActions;
//# sourceMappingURL=code_actions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/code_lens.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/code_lens.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CodeLens = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
class CodeLens {
    constructor(reg) {
        this.reg = reg;
    }
    list(textDocument, settings = { messageText: true, dynamicExceptions: true }) {
        var _a;
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return [];
        }
        const obj = this.reg.findObjectForFile(file);
        if (obj === undefined || !(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const top = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop();
        const ret = [];
        if (settings.messageText === true) {
            const list = this.reg.getMSAGReferences().listByFilename(file.getFilename());
            for (const l of list) {
                const msag = this.reg.getObject("MSAG", l.messageClass);
                if (msag === undefined) {
                    continue;
                }
                const text = (_a = msag.getByNumber(l.number)) === null || _a === void 0 ? void 0 : _a.getMessage();
                if (text === undefined) {
                    continue;
                }
                ret.push({
                    range: _lsp_utils_1.LSPUtils.tokenToRange(l.token),
                    command: LServer.Command.create(text, "")
                });
            }
        }
        if (settings.dynamicExceptions === true) {
            for (const ref of this.findMethodReferences(top, file)) {
                if (!(ref.resolved instanceof types_1.MethodDefinition)) {
                    continue;
                }
                let text = "";
                for (const e of ref.resolved.getRaising()) {
                    if (this.isDynamicException(e, top)) {
                        if (text === "") {
                            text = "Dynamic Exceptions: ";
                        }
                        else {
                            text += " & ";
                        }
                        text += e.toUpperCase();
                    }
                }
                if (text !== "") {
                    ret.push({
                        range: _lsp_utils_1.LSPUtils.tokenToRange(ref.position.getToken()),
                        command: LServer.Command.create(text, "")
                    });
                }
            }
        }
        return ret;
    }
    isDynamicException(name, top) {
        var _a;
        // todo: this method only works with global exceptions?
        let current = name;
        while (current !== undefined) {
            if (current.toUpperCase() === "CX_DYNAMIC_CHECK") {
                return true;
            }
            current = (_a = top.findClassDefinition(current)) === null || _a === void 0 ? void 0 : _a.getSuperClass();
        }
        return false;
    }
    findMethodReferences(node, file) {
        const ret = [];
        if (node.getIdentifier().filename === file.getFilename()) {
            for (const r of node.getData().references) {
                if (r.referenceType === _reference_1.ReferenceType.MethodReference) {
                    ret.push(r);
                }
            }
        }
        for (const c of node.getChildren()) {
            ret.push(...this.findMethodReferences(c, file));
        }
        return ret;
    }
}
exports.CodeLens = CodeLens;
//# sourceMappingURL=code_lens.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/definition.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/definition.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Definition = void 0;
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const _lookup_1 = __webpack_require__(/*! ./_lookup */ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js");
// go to definition
class Definition {
    constructor(reg) {
        this.reg = reg;
    }
    find(textDocument, position) {
        var _a;
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return undefined;
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return undefined;
        }
        const found = _lsp_utils_1.LSPUtils.findCursor(this.reg, { textDocument, position });
        if (found === undefined) {
            return undefined;
        }
        return (_a = _lookup_1.LSPLookup.lookup(found, this.reg, obj)) === null || _a === void 0 ? void 0 : _a.definition;
    }
}
exports.Definition = Definition;
//# sourceMappingURL=definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/diagnostics.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/diagnostics.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Diagnostics = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const severity_1 = __webpack_require__(/*! ../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
class Diagnostics {
    constructor(reg) {
        this.reg = reg;
    }
    findIssues(textDocument) {
        this.reg.parse();
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri); // todo, this sould also run for xml files
        if (file === undefined) {
            return [];
        }
        const obj = this.reg.findObjectForFile(file);
        if (obj === undefined) {
            return [];
        }
        let issues = this.reg.findIssuesObject(obj);
        issues = issues.filter(i => i.getFilename() === file.getFilename());
        return issues;
    }
    static mapDiagnostic(issue) {
        const diagnosic = {
            severity: this.mapSeverity(issue.getSeverity()),
            range: {
                start: { line: issue.getStart().getRow() - 1, character: issue.getStart().getCol() - 1 },
                end: { line: issue.getEnd().getRow() - 1, character: issue.getEnd().getCol() - 1 },
            },
            code: issue.getKey(),
            codeDescription: { href: "https://rules.abaplint.org/" + issue.getKey() + "/" },
            message: issue.getMessage().toString(),
            source: "abaplint",
        };
        return diagnosic;
    }
    find(textDocument) {
        const issues = this.findIssues(textDocument);
        const diagnostics = [];
        for (const issue of issues) {
            diagnostics.push(Diagnostics.mapDiagnostic(issue));
        }
        return diagnostics;
    }
    static mapSeverity(severity) {
        switch (severity) {
            case severity_1.Severity.Error:
                return LServer.DiagnosticSeverity.Error;
            case severity_1.Severity.Warning:
                return LServer.DiagnosticSeverity.Warning;
            case severity_1.Severity.Info:
                return LServer.DiagnosticSeverity.Information;
            default:
                return LServer.DiagnosticSeverity.Error;
        }
    }
}
exports.Diagnostics = Diagnostics;
//# sourceMappingURL=diagnostics.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/dump_scope.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/dump_scope.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DumpScope = void 0;
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class DumpScope {
    static dump(spaghetti) {
        let ret = "<hr>Spaghetti Scope:<br><br>\n";
        ret = ret + this.traverseSpaghetti(spaghetti.getTop(), 0);
        return ret;
    }
    static traverseSpaghetti(node, indent) {
        const identifier = node.getIdentifier();
        const coverage = node.calcCoverage();
        const sident = "&nbsp".repeat(indent * 2);
        let ret = sident + "<u>" + identifier.stype + ", <tt>" + identifier.sname + "</tt>";
        ret += ", (" + coverage.start.getRow() + ", " + coverage.start.getCol() + ")";
        if (coverage.end.getRow() === Number.MAX_SAFE_INTEGER
            && coverage.end.getCol() === Number.MAX_SAFE_INTEGER) {
            ret += ", (max, max)";
        }
        else {
            ret += ", (" + coverage.end.getRow() + ", " + coverage.end.getCol() + ")";
        }
        ret += "</u><br>";
        if (node.getIdentifier().stype === _scope_type_1.ScopeType.BuiltIn) {
            ret += sident + node.getData().types.length + " type definitions<br>";
            ret += sident + node.getData().vars.length + " data definitions<br>";
        }
        else {
            ret = ret + this.dumpNode(node, indent);
        }
        ret = ret + "<br>";
        for (const c of node.getChildren()) {
            ret = ret + this.traverseSpaghetti(c, indent + 1);
        }
        return ret;
    }
    static dumpNode(node, indent) {
        let ret = "";
        const sident = "&nbsp;".repeat(indent * 2);
        const types = node.getData().types;
        if (Object.keys(types).length === 0) {
            ret = ret + sident + "0 type definitions<br>";
        }
        else {
            ret = ret + sident + "Types:<br>";
        }
        for (const name in types) {
            const identifier = types[name];
            ret = ret + sident + "<tt>" + this.escape(name) + "</tt>";
            const pos = identifier.getStart();
            ret = ret + "(" + pos.getRow().toString() + ", " + pos.getCol().toString() + ") ";
            ret = ret + identifier.getType().toText(0);
            ret = ret + "<br>";
        }
        const vars = node.getData().vars;
        if (Object.keys(vars).length === 0) {
            ret = ret + sident + "0 data definitions<br>";
        }
        else {
            ret = ret + sident + "Data:<br>";
        }
        for (const name in vars) {
            const identifier = vars[name];
            ret = ret + sident + "<tt>" + this.escape(name.toLowerCase()) + "</tt>";
            const pos = identifier.getStart();
            ret = ret + "(" + pos.getRow().toString() + ", " + pos.getCol().toString() + ") ";
            ret = ret + identifier.getType().toText(0);
            const meta = identifier.getMeta();
            if (meta) {
                ret = ret + ", " + meta;
            }
            ret = ret + "<br>";
        }
        ret += sident + Object.keys(node.getData().cdefs).length + " class definitions<br>";
        ret += sident + node.getData().idefs.length + " interface definitions<br>";
        ret += sident + node.getData().forms.length + " form definitions<br>";
        ret += sident + node.getData().references.length + " references<br>";
        for (const r of node.getData().references) {
            ret += sident + "&nbsp;&nbsp;" + r.referenceType + ", line " + r.position.getStart().getRow() + " " + this.escape(r.position.getFilename()) + " " + this.escape(r.position.getName()) + "<br>";
        }
        return ret;
    }
    // todo, refactor, this method exists in multiple classes
    static escape(str) {
        str = str.replace(/&/g, "&amp;");
        str = str.replace(/>/g, "&gt;");
        str = str.replace(/</g, "&lt;");
        str = str.replace(/"/g, "&quot;");
        str = str.replace(/'/g, "&#039;");
        return str;
    }
}
exports.DumpScope = DumpScope;
//# sourceMappingURL=dump_scope.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/help.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/help.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Help = void 0;
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const dump_scope_1 = __webpack_require__(/*! ./dump_scope */ "./node_modules/@abaplint/core/build/src/lsp/dump_scope.js");
class Help {
    static find(reg, textDocument, position) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(reg, textDocument.uri);
        if (file === undefined) {
            return "file not found";
        }
        else {
            return this.dumpABAP(file, reg, textDocument, position);
        }
    }
    /////////////////////////////////////////////////
    static dumpABAP(file, reg, textDocument, position) {
        let content = "";
        content = `
    <a href="#_tokens" rel="no-refresh">Tokens</a> |
    <a href="#_statements" rel="no-refresh">Statements</a> |
    <a href="#_structure" rel="no-refresh">Structure</a> |
    <a href="#_files" rel="no-refresh">Files</a> |
    <a href="#_info" rel="no-refresh">Info Dump</a>
    <hr>
    ` +
            "<tt>" + textDocument.uri + " (" +
            (position.line + 1) + ", " +
            (position.character + 1) + ")</tt>";
        content = content + "<hr>";
        content = content + this.cursorInformation(reg, textDocument, position, file);
        content = content + this.fileInformation(file);
        content = content + "<hr>";
        content = content + this.dumpFiles(reg);
        content = content + "<hr>";
        content = content + this.dumpInfo(file);
        return content;
    }
    static dumpInfo(file) {
        const info = file.getInfo();
        const dump = {
            classDefinitions: info.listClassDefinitions(),
            classImplementations: info.listClassImplementations(),
            interfaceDefinitions: info.listInterfaceDefinitions(),
            forms: info.listFormDefinitions(),
        };
        const text = JSON.stringify(dump, null, 2);
        return `<h3 id="_info">Info Dump</h3><pre>` + text + "</pre>";
    }
    static cursorInformation(reg, textDocument, position, file) {
        let ret = "";
        const found = _lsp_utils_1.LSPUtils.findCursor(reg, { textDocument, position });
        if (found !== undefined) {
            ret = "Statement: " + this.linkToStatement(found.snode.get()) + "<br>\n" +
                "Token: " + found.token.constructor.name + "<br>\n" +
                this.fullPath(file, found.token).value;
        }
        else {
            ret = "No token found at cursor position";
        }
        const obj = reg.getObject(file.getObjectType(), file.getObjectName());
        if (obj instanceof _abap_object_1.ABAPObject) {
            const spaghetti = new syntax_1.SyntaxLogic(reg, obj).run().spaghetti;
            ret = ret + dump_scope_1.DumpScope.dump(spaghetti);
            if (found !== undefined) {
                ret = ret + "<hr>Spaghetti Scope by Cursor Position:<br><br>\n";
                const lookup = spaghetti.lookupPosition(found.token.getStart(), textDocument.uri);
                if (lookup) {
                    const identifier = lookup.getIdentifier();
                    ret = ret + "<u>" + identifier.stype + ", <tt>" + identifier.sname + "</tt>, " + identifier.filename;
                    ret = ret + ", (" + identifier.start.getRow() + ", " + identifier.start.getCol() + ")</u><br>";
                }
                else {
                    ret = ret + "Not found";
                }
            }
        }
        return ret;
    }
    static fullPath(file, token) {
        const structure = file.getStructure();
        if (structure === undefined) {
            return { value: "", keyword: false };
        }
        const found = this.traverse(structure, "", token);
        if (found === undefined) {
            return { value: "", keyword: false };
        }
        return { value: "\n\n" + found.value, keyword: found.keyword };
    }
    static traverse(node, parents, search) {
        let local = parents;
        if (local !== "") {
            local = local + " -> ";
        }
        if (node instanceof nodes_1.StructureNode) {
            local = local + "Structure: " + this.linkToStructure(node.get());
        }
        else if (node instanceof nodes_1.StatementNode) {
            local = local + "Statement: " + this.linkToStatement(node.get());
        }
        else if (node instanceof nodes_1.ExpressionNode) {
            local = local + "Expression: " + this.linkToExpression(node.get());
        }
        else if (node instanceof nodes_1.TokenNode) {
            local = local + "Token: " + node.get().constructor.name;
            const token = node.get();
            if (token.getStr() === search.getStr()
                && token.getCol() === search.getCol()
                && token.getRow() === search.getRow()) {
                const keyword = !(node instanceof nodes_1.TokenNodeRegex);
                return { value: local, keyword };
            }
        }
        else {
            throw new Error("hover, traverse, unexpected node type");
        }
        for (const child of node.getChildren()) {
            const ret = this.traverse(child, local, search);
            if (ret) {
                return ret;
            }
        }
        return undefined;
    }
    static fileInformation(file) {
        let content = "";
        content = content + `<hr><h3 id="_tokens">Tokens</h3>\n`;
        content = content + this.tokens(file);
        content = content + `<hr><h3 id="_statements">Statements</h3>\n`;
        content = content + this.buildStatements(file);
        content = content + `<hr><h3 id="_structure">Structure</h3>\n`;
        const structure = file.getStructure();
        if (structure !== undefined) {
            content = content + this.buildStructure([structure]);
        }
        else {
            content = content + "structure undefined";
        }
        return content;
    }
    static escape(str) {
        str = str.replace(/&/g, "&amp;");
        str = str.replace(/>/g, "&gt;");
        str = str.replace(/</g, "&lt;");
        str = str.replace(/"/g, "&quot;");
        str = str.replace(/'/g, "&#039;");
        return str;
    }
    static linkToStatement(statement) {
        return `<a href="https://syntax.abaplint.org/#/statement/${statement.constructor.name}" target="_blank">${statement.constructor.name}</a>\n`;
    }
    static linkToStructure(structure) {
        return `<a href="https://syntax.abaplint.org/#/structure/${structure.constructor.name}" target="_blank">${structure.constructor.name}</a>\n`;
    }
    static linkToExpression(expression) {
        return `<a href="https://syntax.abaplint.org/#/expression/${expression.constructor.name}" target="_blank">${expression.constructor.name}</a>\n`;
    }
    static outputNodes(nodes) {
        let ret = "<ul>";
        for (const node of nodes) {
            let extra = "";
            switch (node.constructor.name) {
                case "TokenNode":
                case "TokenNodeRegex":
                    // @ts-ignore
                    extra = node.get().constructor.name + ", \"" + node.get().getStr() + "\"";
                    break;
                case "ExpressionNode":
                    extra = this.linkToExpression(node.get()) + this.outputNodes(node.getChildren());
                    break;
                default:
                    break;
            }
            ret = ret + "<li>" + node.constructor.name + ", " + extra + "</li>";
        }
        return ret + "</ul>";
    }
    static tokens(file) {
        let inner = "<table><tr><td><b>String</b></td><td><b>Type</b></td><td><b>Row</b></td><td><b>Column</b></td></tr>";
        for (const token of file.getTokens()) {
            inner = inner + "<tr><td><tt>" +
                this.escape(token.getStr()) + "</tt></td><td>" +
                token.constructor.name + "</td><td align=\"right\">" +
                token.getRow() + "</td><td align=\"right\">" +
                token.getCol() + "</td></tr>";
        }
        inner = inner + "</table>";
        return inner;
    }
    static buildStatements(file) {
        let output = "";
        for (const statement of file.getStatements()) {
            const row = statement.getStart().getRow();
            // getting the class name only works if uglify does not mangle names
            output = output +
                row + ": " +
                this.linkToStatement(statement.get()) +
                "</div></b>\n" + this.outputNodes(statement.getChildren());
        }
        return output;
    }
    static buildStructure(nodes) {
        let output = "<ul>";
        for (const node of nodes) {
            if (node instanceof nodes_1.StructureNode) {
                output = output + "<li>" + this.linkToStructure(node.get()) + ", Structure " + this.buildStructure(node.getChildren()) + "</li>";
            }
            else if (node instanceof nodes_1.StatementNode) {
                output = output + "<li>" + this.linkToStatement(node.get()) + ", Statement</li>";
            }
        }
        return output + "</ul>";
    }
    static dumpFiles(reg) {
        let output = `<h3 id="_files">Files</h3><table>\n`;
        for (const o of reg.getObjects()) {
            if (reg.isDependency(o) === true) {
                continue;
            }
            output = output + "<tr><td valign=\"top\">" + o.getType() + " " + o.getName() + "</td><td>";
            for (const f of o.getFiles()) {
                output = output + f.getFilename() + "<br>";
            }
            output = output + "</td></tr>\n";
        }
        return output + "</table>\n";
    }
}
exports.Help = Help;
//# sourceMappingURL=help.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/highlight.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/highlight.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Highlight = void 0;
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
class Highlight {
    constructor(reg) {
        this.reg = reg;
    }
    listDefinitionPositions(textDocument) {
        const spaghetti = this.runSyntax(textDocument);
        if (spaghetti === undefined) {
            return [];
        }
        const defs = spaghetti.listDefinitions(textDocument.uri);
        const ret = [];
        for (const d of defs) {
            ret.push(_lsp_utils_1.LSPUtils.tokenToRange(d.identifier.getToken()));
        }
        return ret;
    }
    listReadPositions(textDocument) {
        const spaghetti = this.runSyntax(textDocument);
        if (spaghetti === undefined) {
            return [];
        }
        const reads = spaghetti.listReadPositions(textDocument.uri);
        const ret = [];
        for (const d of reads) {
            ret.push(_lsp_utils_1.LSPUtils.tokenToRange(d.getToken()));
        }
        return ret;
    }
    listWritePositions(textDocument) {
        const spaghetti = this.runSyntax(textDocument);
        if (spaghetti === undefined) {
            return [];
        }
        const writes = spaghetti.listWritePositions(textDocument.uri);
        const ret = [];
        for (const d of writes) {
            ret.push(_lsp_utils_1.LSPUtils.tokenToRange(d.getToken()));
        }
        return ret;
    }
    ////////////////////////
    runSyntax(textDocument) {
        const obj = this.findObject(textDocument);
        if (obj === undefined) {
            return undefined;
        }
        return new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
    }
    findObject(textDocument) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return undefined;
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (obj instanceof _abap_object_1.ABAPObject) {
            return obj;
        }
        else {
            return undefined;
        }
    }
}
exports.Highlight = Highlight;
//# sourceMappingURL=highlight.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/hover.js":
/*!************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/hover.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Hover = void 0;
const Tokens = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const _lookup_1 = __webpack_require__(/*! ./_lookup */ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class Hover {
    constructor(reg) {
        this.reg = reg;
    }
    find(pos) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, pos.textDocument.uri);
        if (file === undefined) {
            return undefined;
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return undefined;
        }
        const found = _lsp_utils_1.LSPUtils.findCursor(this.reg, pos);
        if (found === undefined) {
            return undefined;
        }
        else if (found.token instanceof Tokens.StringTemplate
            || found.token instanceof Tokens.StringTemplateBegin
            || found.token instanceof Tokens.StringTemplateEnd
            || found.token instanceof Tokens.StringTemplateMiddle) {
            return { kind: LServer.MarkupKind.Markdown, value: "String Template" };
        }
        else if (found.snode.get() instanceof _statement_1.MacroCall) {
            return { kind: LServer.MarkupKind.Markdown, value: "Macro Call" };
        }
        else if (found.snode.get() instanceof Statements.Define && found.stack.length === 2) {
            return { kind: LServer.MarkupKind.Markdown, value: "Macro Name" };
        }
        else if (found.token instanceof Tokens.Comment) {
            let type = "Comment";
            if (found.token.getStr().startsWith(`"!`)) {
                type = "ABAP Doc Comment";
            }
            return { kind: LServer.MarkupKind.Markdown, value: type };
        }
        const lookup = _lookup_1.LSPLookup.lookup(found, this.reg, obj);
        if (lookup === null || lookup === void 0 ? void 0 : lookup.hover) {
            return { kind: LServer.MarkupKind.Markdown, value: lookup.hover };
        }
        if (found.token instanceof Tokens.StringToken) {
            return { kind: LServer.MarkupKind.Markdown, value: "String" };
        }
        return undefined;
    }
}
exports.Hover = Hover;
//# sourceMappingURL=hover.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/implementation.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/implementation.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Implementation = void 0;
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const _lookup_1 = __webpack_require__(/*! ./_lookup */ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
// note: finding implementations might be slow, ie finding method implementations currently searches the full registry
// go to implementation
class Implementation {
    constructor(reg) {
        this.reg = reg;
    }
    find(textDocument, position) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return [];
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const found = _lsp_utils_1.LSPUtils.findCursor(this.reg, { textDocument, position });
        if (found === undefined) {
            return [];
        }
        const lookup = _lookup_1.LSPLookup.lookup(found, this.reg, obj);
        if (lookup === null || lookup === void 0 ? void 0 : lookup.implementation) {
            return [lookup === null || lookup === void 0 ? void 0 : lookup.implementation];
        }
        if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) instanceof types_1.MethodDefinition) {
            return this.findMethodImplementations(lookup.definitionId);
        }
        return [];
    }
    findMethodImplementations(def) {
        const ret = [];
        // note that this searches _everything_
        for (const obj of this.reg.getObjects()) {
            if (this.reg.isDependency(obj) || !(obj instanceof _abap_object_1.ABAPObject)) {
                continue;
            }
            const found = this.searchReferences(new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop(), def);
            ret.push(...found);
        }
        return ret;
    }
    searchReferences(scope, id) {
        const ret = [];
        for (const r of scope.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.MethodImplementationReference
                && r.resolved
                && r.resolved.getFilename() === id.getFilename()
                && r.resolved.getStart().equals(id.getStart())) {
                ret.push(_lsp_utils_1.LSPUtils.identiferToLocation(r.position));
            }
        }
        for (const c of scope.getChildren()) {
            ret.push(...this.searchReferences(c, id));
        }
        return ret;
    }
}
exports.Implementation = Implementation;
//# sourceMappingURL=implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/inlay_hints.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/inlay_hints.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlayHints = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
class InlayHints {
    constructor(reg) {
        this.reg = reg;
    }
    list(textDocument, settings = { inferredTypes: true }) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return [];
        }
        const obj = this.reg.findObjectForFile(file);
        if (obj === undefined || !(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const top = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop();
        const ret = [];
        if (settings.inferredTypes === true) {
            const implicit = this.findImplicitReferences(top);
            for (const i of implicit) {
                let label = undefined;
                if (i.resolved instanceof _typed_identifier_1.TypedIdentifier) {
                    label = "TYPE " + i.resolved.getType().toABAP();
                }
                else if (i.resolved instanceof types_1.ClassDefinition) {
                    label = "TYPE REF TO " + i.resolved.getName();
                }
                if (label === undefined) {
                    continue;
                }
                ret.push({
                    label: label,
                    tooltip: "Inferred type",
                    kind: LServer.InlayHintKind.Type,
                    paddingLeft: true,
                    paddingRight: true,
                    position: _lsp_utils_1.LSPUtils.positionToLS(i.position.getEnd()),
                });
            }
        }
        return ret;
    }
    findImplicitReferences(node) {
        const ret = [];
        for (const r of node.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.InferredType ||
                r.referenceType === _reference_1.ReferenceType.DataWriteReference) {
                ret.push(r);
            }
        }
        for (const c of node.getChildren()) {
            ret.push(...this.findImplicitReferences(c));
        }
        return ret;
    }
}
exports.InlayHints = InlayHints;
//# sourceMappingURL=inlay_hints.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/language_server.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/language_server.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LanguageServer = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const symbols_1 = __webpack_require__(/*! ./symbols */ "./node_modules/@abaplint/core/build/src/lsp/symbols.js");
const hover_1 = __webpack_require__(/*! ./hover */ "./node_modules/@abaplint/core/build/src/lsp/hover.js");
const diagnostics_1 = __webpack_require__(/*! ./diagnostics */ "./node_modules/@abaplint/core/build/src/lsp/diagnostics.js");
const help_1 = __webpack_require__(/*! ./help */ "./node_modules/@abaplint/core/build/src/lsp/help.js");
const pretty_printer_1 = __webpack_require__(/*! ../pretty_printer/pretty_printer */ "./node_modules/@abaplint/core/build/src/pretty_printer/pretty_printer.js");
const definition_1 = __webpack_require__(/*! ./definition */ "./node_modules/@abaplint/core/build/src/lsp/definition.js");
const rename_1 = __webpack_require__(/*! ./rename */ "./node_modules/@abaplint/core/build/src/lsp/rename.js");
const highlight_1 = __webpack_require__(/*! ./highlight */ "./node_modules/@abaplint/core/build/src/lsp/highlight.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const code_actions_1 = __webpack_require__(/*! ./code_actions */ "./node_modules/@abaplint/core/build/src/lsp/code_actions.js");
const references_1 = __webpack_require__(/*! ./references */ "./node_modules/@abaplint/core/build/src/lsp/references.js");
const implementation_1 = __webpack_require__(/*! ./implementation */ "./node_modules/@abaplint/core/build/src/lsp/implementation.js");
const semantic_1 = __webpack_require__(/*! ./semantic */ "./node_modules/@abaplint/core/build/src/lsp/semantic.js");
const statement_flow_1 = __webpack_require__(/*! ../abap/flow/statement_flow */ "./node_modules/@abaplint/core/build/src/abap/flow/statement_flow.js");
const code_lens_1 = __webpack_require__(/*! ./code_lens */ "./node_modules/@abaplint/core/build/src/lsp/code_lens.js");
const inlay_hints_1 = __webpack_require__(/*! ./inlay_hints */ "./node_modules/@abaplint/core/build/src/lsp/inlay_hints.js");
// note Ranges are zero based in LSP,
// https://github.com/microsoft/language-server-protocol/blob/main/versions/protocol-2-x.md#range
// but 1 based in abaplint
// the types in this file are not completely correct
// see https://github.com/microsoft/vscode-languageserver-node/issues/354
class LanguageServer {
    constructor(reg) {
        this.reg = reg;
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentSymbol
    documentSymbol(params) {
        return new symbols_1.Symbols(this.reg).find(params.textDocument.uri);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_hover
    hover(params) {
        const hover = new hover_1.Hover(this.reg).find(params);
        if (hover) {
            return { contents: hover };
        }
        return undefined;
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_definition
    gotoDefinition(params) {
        return new definition_1.Definition(this.reg).find(params.textDocument, params.position);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_formatting
    documentFormatting(params) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, params.textDocument.uri);
        if (file === undefined) {
            return [];
        }
        const text = new pretty_printer_1.PrettyPrinter(file, this.reg.getConfig()).run();
        const rows = file.getRawRows();
        if (text === file.getRaw()) {
            return [];
        }
        else {
            return [{
                    range: LServer.Range.create(0, 0, rows.length, rows[rows.length - 1].length + 1),
                    newText: text,
                }];
        }
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_publishDiagnostics
    diagnostics(textDocument) {
        return new diagnostics_1.Diagnostics(this.reg).find(textDocument);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_prepareRename
    prepareRename(params) {
        return new rename_1.Rename(this.reg).prepareRename(params);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_rename
    rename(params) {
        return new rename_1.Rename(this.reg).rename(params);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_codeAction
    codeActions(params) {
        return new code_actions_1.CodeActions(this.reg).find(params);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_documentHighlight
    documentHighlight(_params) {
        // todo, implement
        return [];
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_implementation
    implementation(params) {
        return new implementation_1.Implementation(this.reg).find(params.textDocument, params.position);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-14/#textDocument_references
    references(params) {
        return new references_1.References(this.reg).references(params);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#semanticTokensLegend
    static semanticTokensLegend() {
        return semantic_1.SemanticHighlighting.semanticTokensLegend();
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#semanticTokensRangeParams
    semanticTokensRange(range) {
        return new semantic_1.SemanticHighlighting(this.reg).semanticTokensRange(range);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_codeLens
    codeLens(textDocument, settings) {
        return new code_lens_1.CodeLens(this.reg).list(textDocument, settings);
    }
    // https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_inlayHint
    inlayHints(textDocument, settings) {
        return new inlay_hints_1.InlayHints(this.reg).list(textDocument, settings);
    }
    ////////////////////////////////////////
    //  ______      _
    // |  ____|    | |
    // | |__  __  _| |_ _ __ __   ___
    // |  __| \ \/ / __| '__/ _` / __|
    // | |____ >  <| |_| | | (_| \__ \
    // |______/_/\_\\__|_|  \__,_|___/
    // extras, abaplint specific
    ////////////////////////////////////////
    help(textDocument, position) {
        return help_1.Help.find(this.reg, textDocument, position);
    }
    listDefinitionPositions(textDocument) {
        return new highlight_1.Highlight(this.reg).listDefinitionPositions(textDocument);
    }
    listReadPositions(textDocument) {
        return new highlight_1.Highlight(this.reg).listReadPositions(textDocument);
    }
    listWritePositions(textDocument) {
        return new highlight_1.Highlight(this.reg).listWritePositions(textDocument);
    }
    dumpStatementFlows(textDocument) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, textDocument.uri);
        if (file === undefined) {
            return "file not found";
        }
        const obj = this.reg.findObjectForFile(file);
        if (obj === undefined) {
            return "obj not found";
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return "empty structure";
        }
        const graphs = new statement_flow_1.StatementFlow().build(stru, obj);
        const wiz = graphs.map(g => g.toDigraph());
        return JSON.stringify(wiz);
    }
}
exports.LanguageServer = LanguageServer;
//# sourceMappingURL=language_server.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/references.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/references.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.References = void 0;
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _lookup_1 = __webpack_require__(/*! ./_lookup */ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
class References {
    constructor(reg) {
        this.reg = reg;
    }
    references(pos) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, pos.textDocument.uri);
        if (file === undefined) {
            return [];
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const found = _lsp_utils_1.LSPUtils.findCursor(this.reg, pos);
        if ((found === null || found === void 0 ? void 0 : found.identifier) === undefined) {
            return [];
        }
        const lookup = _lookup_1.LSPLookup.lookup(found, this.reg, obj);
        if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) === undefined || (lookup === null || lookup === void 0 ? void 0 : lookup.scope) === undefined) {
            return [];
        }
        const locs = this.search(lookup.definitionId, lookup.scope);
        return locs.map(_lsp_utils_1.LSPUtils.identiferToLocation);
    }
    ////////////////////////////////////////////
    // todo, cleanup this mehtod, some of the method parameters are not used anymore?
    search(identifier, node, exitAfterFound = false, removeDuplicates = true) {
        let ret = [];
        // todo, this first assumes that the identifier is a variable?
        const stype = node.getIdentifier().stype;
        if (stype === _scope_type_1.ScopeType.Method || stype === _scope_type_1.ScopeType.FunctionModule || stype === _scope_type_1.ScopeType.Form) {
            ret = this.findReferences(node, identifier);
        }
        if (ret.length > 1 && exitAfterFound === true) {
            return ret;
        }
        for (const o of this.reg.getObjects()) {
            if (o instanceof _abap_object_1.ABAPObject) {
                if (this.reg.isDependency(o)) {
                    continue; // do not search in dependencies
                }
                ret.push(...this.findReferences(new syntax_1.SyntaxLogic(this.reg, o).run().spaghetti.getTop(), identifier));
            }
        }
        // remove duplicates, might be a changing(read and write) position
        if (removeDuplicates === true) {
            return this.removeDuplicates(ret);
        }
        else {
            return ret;
        }
    }
    removeDuplicates(arr) {
        const values = {};
        return arr.filter(item => {
            const val = item.getStart().getCol() + "_" + item.getStart().getRow() + "_" + item.getFilename();
            const exists = values[val];
            values[val] = true;
            return !exists;
        });
    }
    findReferences(node, identifier) {
        var _a;
        const ret = [];
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.BuiltIn) {
            const upper = identifier.getName().toUpperCase();
            // this is for finding the definitions
            const vars = node.getData().vars;
            const vid = vars[upper];
            if (vid === null || vid === void 0 ? void 0 : vid.equals(identifier)) {
                ret.push(vid);
            }
            // this is for finding the definitions
            const types = node.getData().types;
            const tid = types[upper];
            if (tid === null || tid === void 0 ? void 0 : tid.equals(identifier)) {
                ret.push(tid);
            }
            for (const r of node.getData().references) {
                if ((_a = r.resolved) === null || _a === void 0 ? void 0 : _a.equals(identifier)) {
                    ret.push(r.position);
                }
            }
        }
        for (const c of node.getChildren()) {
            ret.push(...this.findReferences(c, identifier));
        }
        return ret;
    }
}
exports.References = References;
//# sourceMappingURL=references.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/rename.js":
/*!*************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/rename.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Rename = exports.RenameType = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _lookup_1 = __webpack_require__(/*! ./_lookup */ "./node_modules/@abaplint/core/build/src/lsp/_lookup.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const references_1 = __webpack_require__(/*! ./references */ "./node_modules/@abaplint/core/build/src/lsp/references.js");
const renamer_1 = __webpack_require__(/*! ../objects/rename/renamer */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer.js");
const definition_1 = __webpack_require__(/*! ./definition */ "./node_modules/@abaplint/core/build/src/lsp/definition.js");
var RenameType;
(function (RenameType) {
    RenameType[RenameType["GlobalClass"] = 1] = "GlobalClass";
    RenameType[RenameType["Variable"] = 2] = "Variable";
    RenameType[RenameType["GlobalInterface"] = 3] = "GlobalInterface";
    RenameType[RenameType["Method"] = 4] = "Method";
})(RenameType || (exports.RenameType = RenameType = {}));
class Rename {
    constructor(reg) {
        this.reg = reg;
    }
    prepareRename(params) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, params.textDocument.uri);
        if (file === undefined) {
            return undefined;
        }
        const obj = this.reg.getObject(file.getObjectType(), file.getObjectName());
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return undefined;
        }
        const cursor = _lsp_utils_1.LSPUtils.findCursor(this.reg, params);
        if (cursor === undefined) {
            return undefined;
        }
        const range = _lsp_utils_1.LSPUtils.tokenToRange(cursor.token);
        let placeholder = cursor.token.getStr();
        if (placeholder.startsWith("!")) {
            placeholder = placeholder.substring(1);
            range.start.character += 1;
        }
        const lookup = _lookup_1.LSPLookup.lookup(cursor, this.reg, obj);
        if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) instanceof _typed_identifier_1.TypedIdentifier) {
            return { range, placeholder, type: RenameType.Variable, file };
        }
        else if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) instanceof types_1.ClassDefinition) {
            return { range, placeholder, type: RenameType.GlobalClass, file };
        }
        else if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) instanceof types_1.InterfaceDefinition) {
            return { range, placeholder, type: RenameType.GlobalInterface, file };
        }
        else if ((lookup === null || lookup === void 0 ? void 0 : lookup.definitionId) instanceof types_1.MethodDefinition) {
            return { range, placeholder, type: RenameType.Method, file };
        }
        return undefined;
    }
    rename(params) {
        const prepare = this.prepareRename(params);
        if (prepare === undefined) {
            return undefined;
        }
        switch (prepare.type) {
            case RenameType.GlobalClass:
                return new renamer_1.Renamer(this.reg).buildEdits("CLAS", prepare.placeholder, params.newName);
            case RenameType.GlobalInterface:
                return new renamer_1.Renamer(this.reg).buildEdits("INTF", prepare.placeholder, params.newName);
            case RenameType.Variable:
                return this.renameVariable(params);
            case RenameType.Method:
                return this.renameMethod(params);
            default:
                return undefined;
        }
    }
    ////
    renameVariable(params) {
        var _a;
        const workspace = { documentChanges: [] };
        const refs = new references_1.References(this.reg).references(params);
        for (const r of refs) {
            const doc = { uri: r.uri, version: 1 };
            const edit = LServer.TextDocumentEdit.create(doc, [LServer.TextEdit.replace(r.range, params.newName)]);
            (_a = workspace.documentChanges) === null || _a === void 0 ? void 0 : _a.push(edit);
        }
        return workspace;
    }
    renameMethod(params) {
        var _a, _b;
        const workspace = { documentChanges: [] };
        const refs = new references_1.References(this.reg).references(params);
        for (const r of refs) {
            const doc = { uri: r.uri, version: 1 };
            const edit = LServer.TextDocumentEdit.create(doc, [LServer.TextEdit.replace(r.range, params.newName)]);
            (_a = workspace.documentChanges) === null || _a === void 0 ? void 0 : _a.push(edit);
        }
        const def = new definition_1.Definition(this.reg).find(params.textDocument, params.position);
        if (def) {
            const doc = { uri: params.textDocument.uri, version: 1 };
            const edit = LServer.TextDocumentEdit.create(doc, [LServer.TextEdit.replace(def === null || def === void 0 ? void 0 : def.range, params.newName)]);
            (_b = workspace.documentChanges) === null || _b === void 0 ? void 0 : _b.push(edit);
        }
        return workspace;
    }
}
exports.Rename = Rename;
//# sourceMappingURL=rename.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/semantic.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/semantic.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SemanticHighlighting = void 0;
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const SOURCE_ABAP = "source.abap";
const BLOCK_ABAP = "storage.type.block.abap";
class SemanticHighlighting {
    constructor(reg) {
        this.reg = reg;
        SemanticHighlighting.initLegend();
    }
    static semanticTokensLegend() {
        // https://code.visualstudio.com/api/language-extensions/semantic-highlight-guide#semantic-token-scope-map
        // https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#semanticTokenTypes
        this.initLegend();
        return {
            tokenTypes: SemanticHighlighting.tokenTypes,
            tokenModifiers: [],
        };
    }
    static initLegend() {
        if (SemanticHighlighting.tokenTypes.length === 0) {
            SemanticHighlighting.tokenTypeMap = {};
            SemanticHighlighting.tokenTypeMap[SOURCE_ABAP] = SemanticHighlighting.tokenTypes.length;
            SemanticHighlighting.tokenTypes.push(SOURCE_ABAP);
            SemanticHighlighting.tokenTypeMap[BLOCK_ABAP] = SemanticHighlighting.tokenTypes.length;
            SemanticHighlighting.tokenTypes.push(BLOCK_ABAP);
            for (const t in LServer.SemanticTokenTypes) {
                SemanticHighlighting.tokenTypeMap[t] = SemanticHighlighting.tokenTypes.length;
                SemanticHighlighting.tokenTypes.push(t);
            }
        }
    }
    // https://microsoft.github.io/language-server-protocol/specifications/specification-3-17/#textDocument_semanticTokens
    semanticTokensRange(range) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, range.textDocument.uri);
        if (file === undefined) {
            return { data: [] };
        }
        const rangeStartPosition = new position_1.Position(range.start.line + 1, range.start.character + 1);
        const rangeEndPosition = new position_1.Position(range.end.line + 1, range.end.character + 1);
        const tokens = [];
        for (const s of file.getStatements()) {
            if (s.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
                continue;
            }
            else if (s.getFirstToken().getStart().isAfter(rangeEndPosition)) {
                break;
            }
            else if (s.getLastToken().getEnd().isBefore(rangeStartPosition)) {
                continue;
            }
            const statementInstance = s.get();
            for (const t of s.getTokenNodes()) {
                const tokenInstance = t.get();
                let tokenType = LServer.SemanticTokenTypes.keyword;
                if (tokenInstance instanceof tokens_1.Punctuation) {
                    tokenType = SOURCE_ABAP;
                }
                else if (statementInstance instanceof Statements.Public
                    || statementInstance instanceof Statements.Private
                    || statementInstance instanceof Statements.Protected
                    || statementInstance instanceof Statements.ClassDefinition
                    || statementInstance instanceof Statements.ClassImplementation
                    || statementInstance instanceof Statements.MethodImplementation
                    || statementInstance instanceof Statements.EndMethod
                    || statementInstance instanceof Statements.EndClass
                    || statementInstance instanceof Statements.Interface
                    || statementInstance instanceof Statements.EndInterface
                    || statementInstance instanceof Statements.Form
                    || statementInstance instanceof Statements.EndForm) {
                    tokenType = BLOCK_ABAP;
                }
                else if (tokenInstance instanceof tokens_1.StringToken
                    || tokenInstance instanceof tokens_1.StringTemplate
                    || tokenInstance instanceof tokens_1.StringTemplateBegin
                    || tokenInstance instanceof tokens_1.StringTemplateEnd
                    || tokenInstance instanceof tokens_1.StringTemplateMiddle) {
                    tokenType = LServer.SemanticTokenTypes.string;
                }
                else if (tokenInstance instanceof tokens_1.Comment) {
                    tokenType = LServer.SemanticTokenTypes.comment;
                }
                else if (t instanceof nodes_1.TokenNodeRegex) {
                    tokenType = SOURCE_ABAP;
                }
                const token = t.getFirstToken();
                tokens.push({
                    line: token.getStart().getRow() - 1,
                    startChar: token.getStart().getCol() - 1,
                    length: token.getStr().length,
                    tokenType: tokenType,
                    tokenModifiers: [],
                });
            }
        }
        return { data: this.encodeTokens(tokens) };
    }
    encodeTokens(tokens) {
        const ret = [];
        let prevLine = undefined;
        let prevChar = undefined;
        for (const t of tokens) {
            if (prevLine === undefined) {
                ret.push(t.line);
            }
            else {
                ret.push(t.line - prevLine);
            }
            if (prevLine === t.line && prevChar) {
                ret.push(t.startChar - prevChar);
            }
            else {
                ret.push(t.startChar); // todo, delta?
            }
            ret.push(t.length);
            ret.push(SemanticHighlighting.tokenTypeMap[t.tokenType]);
            ret.push(0); // no modifier logic implemented yet
            prevLine = t.line;
            prevChar = t.startChar;
        }
        return ret;
    }
}
exports.SemanticHighlighting = SemanticHighlighting;
SemanticHighlighting.tokenTypes = [];
//# sourceMappingURL=semantic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/lsp/symbols.js":
/*!**************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/lsp/symbols.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Symbols = void 0;
/* eslint-disable max-len */
const LServer = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ./_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
class Symbols {
    constructor(reg) {
        this.reg = reg;
    }
    find(uri) {
        const file = _lsp_utils_1.LSPUtils.getABAPFile(this.reg, uri);
        if (file === undefined) {
            return [];
        }
        const ret = [];
        ret.push(...this.outputClasses(file));
        ret.push(...this.outputForms(file));
        return ret;
    }
    selectionRange(identifier) {
        const pos = identifier.getStart();
        const str = identifier.getName();
        return LServer.Range.create(pos.getRow() - 1, pos.getCol() - 1, pos.getRow() - 1, pos.getCol() - 1 + str.length);
    }
    range(identifer) {
        const start = identifer.getStart();
        const end = identifer.getEnd();
        return LServer.Range.create(start.getRow() - 1, start.getCol() - 1, end.getRow() - 1, end.getCol() - 1);
    }
    newSymbolRanged(identifier, kind, children, range) {
        const symbol = {
            name: identifier.getName(),
            kind: kind,
            range: range,
            selectionRange: this.selectionRange(identifier),
            children,
        };
        return symbol;
    }
    newSymbol(identifier, kind, children) {
        const symbol = {
            name: identifier.getName(),
            kind: kind,
            range: this.range(identifier),
            selectionRange: this.selectionRange(identifier),
            children,
        };
        return symbol;
    }
    outputForms(file) {
        const ret = [];
        for (const form of file.getInfo().listFormDefinitions()) {
            const symbol = this.newSymbol(form.identifier, LServer.SymbolKind.Function, []);
            ret.push(symbol);
        }
        return ret;
    }
    outputClasses(file) {
        const ret = [];
        for (const cla of file.getInfo().listClassDefinitions()) {
            const children = [];
            children.push(...this.outputClassAttributes(cla.attributes));
            const symbol = this.newSymbol(cla.identifier, LServer.SymbolKind.Class, children);
            ret.push(symbol);
        }
        for (const cla of file.getInfo().listClassImplementations()) {
            const children = [];
            children.push(...this.outputMethodImplementations(cla.methods, file));
            const symbol = this.newSymbol(cla.identifier, LServer.SymbolKind.Class, children);
            ret.push(symbol);
        }
        return ret;
    }
    outputMethodImplementations(methods, file) {
        const ret = [];
        for (const method of methods) {
            const start = method.getStart();
            let end = undefined;
            for (const s of file.getStatements()) {
                if (s.getFirstToken().getStart().isBefore(start)) {
                    continue;
                }
                if (s.get() instanceof statements_1.EndMethod) {
                    end = s.getLastToken().getEnd();
                    break;
                }
            }
            if (end === undefined) {
                continue;
            }
            const range = LServer.Range.create(start.getRow() - 1, start.getCol() - 1, end.getRow() - 1, end.getCol() - 1);
            const symbol = this.newSymbolRanged(method, LServer.SymbolKind.Method, [], range);
            ret.push(symbol);
        }
        return ret;
    }
    outputClassAttributes(attr) {
        if (attr === undefined) {
            return [];
        }
        const ret = [];
        for (const id of attr) {
            ret.push(this.newSymbol(id.identifier, LServer.SymbolKind.Property, []));
        }
        // todo, also add constants
        return ret;
    }
}
exports.Symbols = Symbols;
//# sourceMappingURL=symbols.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/macro_references.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/macro_references.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MacroReferences = void 0;
class MacroReferences {
    constructor() {
        this.definitions = {};
        this.references = {};
    }
    addDefinition(ref, start, end) {
        if (this.definitions[ref.filename] === undefined) {
            this.definitions[ref.filename] = [];
        }
        else if (this.definitions[ref.filename].find((d) => d.token.getStart().equals(ref.token.getStart()))) {
            return;
        }
        this.definitions[ref.filename].push({ token: ref.token, start, end });
    }
    getDefinitionRange(filename, token) {
        for (const d of this.definitions[filename] || []) {
            if (d.token.getStart().equals(token.getStart())) {
                return { start: d.start, end: d.end };
            }
        }
        return undefined;
    }
    addReference(ref) {
        if (this.references[ref.filename] === undefined) {
            this.references[ref.filename] = [];
        }
        this.references[ref.filename].push(ref);
    }
    listDefinitionsByFile(filename) {
        const ret = [];
        for (const d of this.definitions[filename] || []) {
            ret.push(d.token);
        }
        return ret;
    }
    listUsagesbyMacro(filename, token) {
        const ret = [];
        const tokenStr = token.getStr().toUpperCase();
        for (const ref of this.references[filename] || []) {
            if (ref.token.getStr().toUpperCase() === tokenStr) {
                ret.push(ref);
            }
        }
        return ret;
    }
    clear(filename) {
        delete this.definitions[filename];
        delete this.references[filename];
    }
    findDefinitionByUsage(filename, token) {
        const tokenStr = token.getStr().toUpperCase();
        for (const ref of this.references[filename] || []) {
            if (ref.token.getStart().equals(token.getStart())) {
                for (const d of this.definitions[ref.filename] || []) {
                    if (d.token.getStr().toUpperCase() === tokenStr) {
                        return {
                            filename: ref.filename,
                            token: d.token,
                        };
                    }
                }
            }
        }
        return undefined;
    }
}
exports.MacroReferences = MacroReferences;
//# sourceMappingURL=macro_references.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/msag_references.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/msag_references.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MSAGReferences = void 0;
class MSAGReferences {
    constructor() {
        this.nameNumberIndex = {};
        this.filenameIndex = {};
    }
    addUsing(filename, token, messageClass, number) {
        if (number.length !== 3) {
            return;
        }
        if (this.filenameIndex[filename] === undefined) {
            this.filenameIndex[filename] = [];
        }
        this.filenameIndex[filename].push({
            token: token,
            messageClass: messageClass,
            number: number,
        });
        if (this.nameNumberIndex[messageClass] === undefined) {
            this.nameNumberIndex[messageClass] = {};
        }
        if (this.nameNumberIndex[messageClass][number] === undefined) {
            this.nameNumberIndex[messageClass][number] = [];
        }
        this.nameNumberIndex[messageClass][number].push({
            filename: filename,
            token: token,
        });
    }
    clear(obj) {
        for (const file of obj.getFiles()) {
            const filename = file.getFilename();
            for (const fIndex of this.filenameIndex[filename] || []) {
                // this should be okay for performance, each message should be referenced less than 10 times typically
                this.nameNumberIndex[fIndex.messageClass][fIndex.number] =
                    this.nameNumberIndex[fIndex.messageClass][fIndex.number].filter(i => i.filename !== filename);
            }
            delete this.filenameIndex[filename];
        }
    }
    listByFilename(filename) {
        return this.filenameIndex[filename] || [];
    }
    listByMessage(messageClass, number) {
        var _a;
        return ((_a = this.nameNumberIndex[messageClass]) === null || _a === void 0 ? void 0 : _a[number]) || [];
    }
}
exports.MSAGReferences = MSAGReferences;
//# sourceMappingURL=msag_references.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/_abap_object.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
const abap_parser_1 = __webpack_require__(/*! ../abap/abap_parser */ "./node_modules/@abaplint/core/build/src/abap/abap_parser.js");
class ABAPObject extends _abstract_object_1.AbstractObject {
    [Symbol.for("debug.description")]() {
        return `${this.constructor.name} ${this.getName()}`;
    }
    constructor(name) {
        super(name);
        this.parsed = [];
        this.texts = undefined;
    }
    static is(x) {
        return !!x && x instanceof ABAPObject;
    }
    parse(version, globalMacros, reg) {
        if (this.isDirty() === false) {
            return { updated: false, runtime: 0 };
        }
        const abapFiles = this.getFiles().filter(f => f.getFilename().endsWith(".abap"));
        const result = new abap_parser_1.ABAPParser(version, globalMacros, reg).parse(abapFiles);
        this.parsed = result.output;
        this.old = result.issues;
        this.dirty = false;
        return { updated: true, runtime: result.runtime, runtimeExtra: result.runtimeExtra };
    }
    setDirty() {
        this.syntaxResult = undefined;
        this.texts = undefined;
        super.setDirty();
    }
    getABAPFiles() {
        return this.parsed;
    }
    getABAPFileByName(filename) {
        for (const p of this.parsed) {
            if (p.getFilename() === filename) {
                return p;
            }
        }
        return undefined;
    }
    getMainABAPFile() {
        // todo, uris, https://github.com/abaplint/abaplint/issues/673
        const search = this.getName().replace(/\//g, "#").toLowerCase() + "." + this.getType().toLowerCase() + ".abap";
        for (const file of this.getABAPFiles()) {
            if (file.getFilename().endsWith(search)) {
                return file;
            }
        }
        // uri fallback,
        for (const file of this.getABAPFiles()) {
            if (file.getFilename().endsWith(".abap")) {
                return file;
            }
        }
        return undefined;
    }
    getTexts() {
        if (this.texts === undefined) {
            this.findTexts(this.parseRaw2());
        }
        return this.texts;
    }
    findTexts(parsed) {
        var _a, _b, _c, _d;
        this.texts = {};
        if (((_d = (_c = (_b = (_a = parsed === null || parsed === void 0 ? void 0 : parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.TPOOL) === null || _d === void 0 ? void 0 : _d.item) === undefined) {
            return;
        }
        for (const t of (0, xml_utils_1.xmlToArray)(parsed.abapGit["asx:abap"]["asx:values"].TPOOL.item)) {
            if ((t === null || t === void 0 ? void 0 : t.ID) === "I") {
                if (t.KEY === undefined) {
                    throw new Error("findTexts, undefined");
                }
                const key = t.KEY;
                if (key === undefined) {
                    continue;
                }
                this.texts[key.toUpperCase()] = t.ENTRY ? (0, xml_utils_1.unescape)(t.ENTRY) : "";
            }
        }
    }
}
exports.ABAPObject = ABAPObject;
//# sourceMappingURL=_abap_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/_abstract_object.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AbstractObject = void 0;
const fast_xml_parser_1 = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
const _identifier_1 = __webpack_require__(/*! ../abap/4_file_information/_identifier */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_identifier.js");
const identifier_1 = __webpack_require__(/*! ../abap/1_lexer/tokens/identifier */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/identifier.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class AbstractObject {
    constructor(name) {
        this.name = name;
        this.files = [];
        this.old = [];
        this.dirty = false;
    }
    getParsingIssues() {
        return this.old;
    }
    parse(_version, _globalMacros, _reg) {
        return { updated: false, runtime: 0 };
    }
    getName() {
        return this.name;
    }
    setDirty() {
        this.dirty = true;
    }
    addFile(file) {
        this.setDirty();
        this.files.push(file);
    }
    getFiles() {
        return this.files;
    }
    containsFile(filename) {
        for (const f of this.files) {
            if (f.getFilename() === filename) {
                return true;
            }
        }
        return false;
    }
    removeFile(file) {
        this.setDirty();
        for (let i = 0; i < this.files.length; i++) {
            if (this.files[i].getFilename() === file.getFilename()) {
                this.files.splice(i, 1);
                return;
            }
        }
        throw new Error("removeFile: file not found");
    }
    isDirty() {
        return this.dirty;
    }
    getIdentifier() {
        // this method can be redefined in each object type to give a better result
        const file = this.getXMLFile();
        if (file === undefined) {
            return undefined;
        }
        return new _identifier_1.Identifier(new identifier_1.Identifier(new position_1.Position(1, 1), this.getName()), file.getFilename());
    }
    getXMLFile() {
        // todo, https://github.com/abaplint/abaplint/issues/673 uris
        const expected1 = this.getName().toLowerCase().replace(/\//g, "#") + "." + this.getType().toLowerCase() + ".xml";
        const expected2 = this.getName().toLowerCase().replace(/\//g, "%23") + "." + this.getType().toLowerCase() + ".xml";
        for (const file of this.getFiles()) {
            if (file.getFilename().endsWith(expected1) || file.getFilename().endsWith(expected2)) {
                return file;
            }
        }
        // uri fallback, assume there is only one xml file
        for (const file of this.getFiles()) {
            if (file.getFilename().endsWith(".xml")) {
                return file;
            }
        }
        return undefined;
    }
    getXML() {
        const file = this.getXMLFile();
        if (file) {
            return file.getRaw();
        }
        return undefined;
    }
    updateFile(file) {
        this.setDirty();
        for (let i = 0; i < this.files.length; i++) {
            if (this.files[i].getFilename() === file.getFilename()) {
                this.files[i] = file;
                return;
            }
        }
        throw new Error("updateFile: file not found");
    }
    parseRaw2() {
        const xml = this.getXML();
        if (xml === undefined) {
            return undefined;
        }
        try {
            return new fast_xml_parser_1.XMLParser({ parseTagValue: false, ignoreAttributes: true, trimValues: false }).parse(xml);
        }
        catch (_a) {
            return undefined;
        }
    }
}
exports.AbstractObject = AbstractObject;
//# sourceMappingURL=_abstract_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/_dynpros.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/_dynpros.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.parseDynpros = parseDynpros;
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
function parseDynpros(parsed) {
    var _a, _b, _c, _d;
    const dynpros = [];
    const xmlDynpros = (_c = (_b = (_a = parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.DYNPROS;
    if (xmlDynpros !== undefined) {
        for (const d of (0, xml_utils_1.xmlToArray)(xmlDynpros.item)) {
            const fields = [];
            for (const f of (0, xml_utils_1.xmlToArray)((_d = d.FIELDS) === null || _d === void 0 ? void 0 : _d.RPY_DYFATC)) {
                fields.push({
                    name: f.NAME,
                    type: f.TYPE,
                    length: f.LENGTH,
                });
            }
            dynpros.push({
                number: d.HEADER.SCREEN,
                description: d.HEADER.DESCRIPT,
                nextScreen: d.HEADER.NEXTSCREEN,
                fields: fields,
            });
        }
    }
    return dynpros;
}
//# sourceMappingURL=_dynpros.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/_unknown_object.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/_unknown_object.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const severity_1 = __webpack_require__(/*! ../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
class UnknownObject extends _abstract_object_1.AbstractObject {
    constructor(name, type) {
        super(name);
        this.type = type;
    }
    getType() {
        return this.type;
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    getDescription() {
        return undefined;
    }
    getParsingIssues() {
        const pos = new position_1.Position(1, 1);
        const file = this.getFiles()[0];
        const message = "Unknown object type, currently not supported in abaplint, open issue on github";
        const issue = issue_1.Issue.atPosition(file, pos, message, "parser_error", severity_1.Severity.Error);
        return [issue];
    }
}
exports.UnknownObject = UnknownObject;
//# sourceMappingURL=_unknown_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/abap_query_functional_area.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/abap_query_functional_area.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPQueryFunctionalArea = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ABAPQueryFunctionalArea extends _abstract_object_1.AbstractObject {
    getType() {
        return "AQSG";
    }
    getAllowedNaming() {
        return {
            maxLength: 60, // todo
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ABAPQueryFunctionalArea = ABAPQueryFunctionalArea;
//# sourceMappingURL=abap_query_functional_area.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/abap_query_query.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/abap_query_query.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPQueryQuery = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ABAPQueryQuery extends _abstract_object_1.AbstractObject {
    getType() {
        return "AQQU";
    }
    getAllowedNaming() {
        return {
            maxLength: 60, // todo
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ABAPQueryQuery = ABAPQueryQuery;
//# sourceMappingURL=abap_query_query.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/activation_variant.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/activation_variant.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ActivationVariant = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ActivationVariant extends _abstract_object_1.AbstractObject {
    getType() {
        return "AVAR";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ActivationVariant = ActivationVariant;
//# sourceMappingURL=activation_variant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/api_release_state.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/api_release_state.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.APIReleaseState = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class APIReleaseState extends _abstract_object_1.AbstractObject {
    getType() {
        return "APIS";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.APIReleaseState = APIReleaseState;
//# sourceMappingURL=api_release_state.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/application_job_catalog_entry.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/application_job_catalog_entry.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationJobCatalogEntry = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ApplicationJobCatalogEntry extends _abstract_object_1.AbstractObject {
    getType() {
        return "SAJC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ApplicationJobCatalogEntry = ApplicationJobCatalogEntry;
//# sourceMappingURL=application_job_catalog_entry.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/application_job_template.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/application_job_template.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationJobTemplate = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ApplicationJobTemplate extends _abstract_object_1.AbstractObject {
    getType() {
        return "SAJT";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ApplicationJobTemplate = ApplicationJobTemplate;
//# sourceMappingURL=application_job_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/application_log_object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/application_log_object.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ApplicationLogObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ApplicationLogObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "APLO";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ApplicationLogObject = ApplicationLogObject;
//# sourceMappingURL=application_log_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/assignment_service_to_authorization_group.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/assignment_service_to_authorization_group.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AssignmentServiceToAuthorizationGroup = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AssignmentServiceToAuthorizationGroup extends _abstract_object_1.AbstractObject {
    getType() {
        return "SUSH";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.AssignmentServiceToAuthorizationGroup = AssignmentServiceToAuthorizationGroup;
//# sourceMappingURL=assignment_service_to_authorization_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/atc_check_category.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/atc_check_category.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ATCCheckCategory = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ATCCheckCategory extends _abstract_object_1.AbstractObject {
    getType() {
        return "CHKC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ATCCheckCategory = ATCCheckCategory;
//# sourceMappingURL=atc_check_category.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/atc_check_object.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/atc_check_object.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ATCCheckObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ATCCheckObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "CHKO";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ATCCheckObject = ATCCheckObject;
//# sourceMappingURL=atc_check_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/atc_check_variant.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/atc_check_variant.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ATCCheckVariant = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ATCCheckVariant extends _abstract_object_1.AbstractObject {
    getType() {
        return "CHKV";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ATCCheckVariant = ATCCheckVariant;
//# sourceMappingURL=atc_check_variant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/authorization_check_field.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/authorization_check_field.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorizationCheckField = void 0;
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AuthorizationCheckField extends _abstract_object_1.AbstractObject {
    getType() {
        return "AUTH";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDescription() {
        // todo
        return undefined;
    }
    getDataElementName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.rollname;
    }
    parseType(reg) {
        var _a;
        this.parse();
        const references = [];
        const ddic = new ddic_1.DDIC(reg);
        if ((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.rollname) {
            const found = ddic.lookupDataElement(this.parsedXML.rollname);
            if (found.object) {
                references.push({ object: found.object });
                reg.getDDICReferences().setUsing(this, references);
                return found.type;
            }
            else if (ddic.inErrorNamespace(this.parsedXML.rollname)) {
                return new basic_1.UnknownType(this.parsedXML.rollname + " not found");
            }
            else {
                return new basic_1.VoidType(this.parsedXML.rollname);
            }
        }
        else {
            return new basic_1.UnknownType("Parsing error");
        }
    }
    parse() {
        var _a;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.rollname = (_a = parsed.abapGit["asx:abap"]["asx:values"].AUTHX) === null || _a === void 0 ? void 0 : _a.ROLLNAME;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.AuthorizationCheckField = AuthorizationCheckField;
//# sourceMappingURL=authorization_check_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/authorization_group.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/authorization_group.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorizationGroup = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AuthorizationGroup extends _abstract_object_1.AbstractObject {
    getType() {
        return "SUCU";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.AuthorizationGroup = AuthorizationGroup;
//# sourceMappingURL=authorization_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/authorization_object.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/authorization_object.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorizationObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AuthorizationObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "SUSO";
    }
    getAllowedNaming() {
        return {
            maxLength: 10,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.AuthorizationObject = AuthorizationObject;
//# sourceMappingURL=authorization_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/authorization_object_class.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/authorization_object_class.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorizationObjectClass = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AuthorizationObjectClass extends _abstract_object_1.AbstractObject {
    getType() {
        return "SUSC";
    }
    getAllowedNaming() {
        return {
            maxLength: 4,
            allowNamespace: false,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.AuthorizationObjectClass = AuthorizationObjectClass;
//# sourceMappingURL=authorization_object_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/authorization_object_extension.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/authorization_object_extension.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AuthorizationObjectExtension = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class AuthorizationObjectExtension extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA3";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.AuthorizationObjectExtension = AuthorizationObjectExtension;
//# sourceMappingURL=authorization_object_extension.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/behavior_definition.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/behavior_definition.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BehaviorDefinition = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BehaviorDefinition extends _abstract_object_1.AbstractObject {
    getType() {
        return "BDEF";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BehaviorDefinition = BehaviorDefinition;
//# sourceMappingURL=behavior_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/bsp_application.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/bsp_application.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BSPApplication = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BSPApplication extends _abstract_object_1.AbstractObject {
    getType() {
        return "WAPA";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BSPApplication = BSPApplication;
//# sourceMappingURL=bsp_application.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_add_in_implementation.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_add_in_implementation.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessAddInImplementation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessAddInImplementation extends _abstract_object_1.AbstractObject {
    getType() {
        return "SXCI";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessAddInImplementation = BusinessAddInImplementation;
//# sourceMappingURL=business_add_in_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_catalog.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_catalog.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessCatalog = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessCatalog extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA1";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessCatalog = BusinessCatalog;
//# sourceMappingURL=business_catalog.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_catalog_app_assignment.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_catalog_app_assignment.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessCatalogAppAssignment = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessCatalogAppAssignment extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA7";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessCatalogAppAssignment = BusinessCatalogAppAssignment;
//# sourceMappingURL=business_catalog_app_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_configuration_set.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_configuration_set.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessConfigurationSet = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessConfigurationSet extends _abstract_object_1.AbstractObject {
    getType() {
        return "SCP1";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessConfigurationSet = BusinessConfigurationSet;
//# sourceMappingURL=business_configuration_set.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_function_assignment.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_function_assignment.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessFunctionAssignment = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessFunctionAssignment extends _abstract_object_1.AbstractObject {
    getType() {
        return "SFBF";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessFunctionAssignment = BusinessFunctionAssignment;
//# sourceMappingURL=business_function_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_function_set_assignment.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_function_set_assignment.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessFunctionSetAssignment = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessFunctionSetAssignment extends _abstract_object_1.AbstractObject {
    getType() {
        return "SFBS";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessFunctionSetAssignment = BusinessFunctionSetAssignment;
//# sourceMappingURL=business_function_set_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_object_model.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_object_model.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessObjectModel = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessObjectModel extends _abstract_object_1.AbstractObject {
    getType() {
        return "BOBF";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessObjectModel = BusinessObjectModel;
//# sourceMappingURL=business_object_model.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/business_object_type.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/business_object_type.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BusinessObjectType = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class BusinessObjectType extends _abstract_object_1.AbstractObject {
    getType() {
        return "SOBJ";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.BusinessObjectType = BusinessObjectType;
//# sourceMappingURL=business_object_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/cds_metadata_extension.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/cds_metadata_extension.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSMetadataExtension = void 0;
const cds_parser_1 = __webpack_require__(/*! ../cds/cds_parser */ "./node_modules/@abaplint/core/build/src/cds/cds_parser.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CDSMetadataExtension extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parserError = undefined;
        this.parsedData = undefined;
    }
    getType() {
        return "DDLX";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    hasParserError() {
        return this.parserError;
    }
    parse() {
        if (this.isDirty() === false) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedData = {
            tree: undefined,
        };
        this.parsedData.tree = new cds_parser_1.CDSParser().parse(this.findSourceFile());
        if (this.parsedData.tree === undefined) {
            this.parserError = true;
        }
        this.dirty = false;
        return { updated: true, runtime: Date.now() - start };
    }
    getDescription() {
        // todo
        return undefined;
    }
    findSourceFile() {
        return this.getFiles().find(f => f.getFilename().endsWith(".asddlxs") || f.getFilename().endsWith(".acds"));
    }
}
exports.CDSMetadataExtension = CDSMetadataExtension;
//# sourceMappingURL=cds_metadata_extension.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/change_document.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/change_document.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeDocument = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ChangeDocument extends _abstract_object_1.AbstractObject {
    getType() {
        return "CHDO";
    }
    getAllowedNaming() {
        return {
            maxLength: 15,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ChangeDocument = ChangeDocument;
//# sourceMappingURL=change_document.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/chapter_of_book_structure.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/chapter_of_book_structure.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChapterOfBookStructure = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ChapterOfBookStructure extends _abstract_object_1.AbstractObject {
    getType() {
        return "DSYS";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ChapterOfBookStructure = ChapterOfBookStructure;
//# sourceMappingURL=chapter_of_book_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/checkpoint_group.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/checkpoint_group.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckpointGroup = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CheckpointGroup extends _abstract_object_1.AbstractObject {
    getType() {
        return "ACID";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CheckpointGroup = CheckpointGroup;
//# sourceMappingURL=checkpoint_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/class.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/class.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Class = exports.ClassCategory = void 0;
const _abap_object_1 = __webpack_require__(/*! ./_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
var ClassCategory;
(function (ClassCategory) {
    ClassCategory["Test"] = "05";
    ClassCategory["Persistent"] = "10";
    ClassCategory["PersistentFactory"] = "11";
    ClassCategory["Exception"] = "40";
    ClassCategory["SharedObject"] = "45";
})(ClassCategory || (exports.ClassCategory = ClassCategory = {}));
class Class extends _abap_object_1.ABAPObject {
    constructor() {
        super(...arguments);
        this.def = undefined;
        this.parsedXML = undefined;
    }
    getType() {
        return "CLAS";
    }
    getSequencedFiles() {
        const sequence = [".clas.locals_def.abap", ".clas.locals_imp.abap", ".clas.abap", ".clas.testclasses.abap"];
        const copy = this.getABAPFiles().slice().sort((a, b) => {
            const aValue = sequence.findIndex((s) => a.getFilename().endsWith(s));
            const bValue = sequence.findIndex((s) => b.getFilename().endsWith(s));
            return aValue - bValue;
        });
        return copy;
    }
    setDefinition(def) {
        this.def = def;
    }
    getDefinition() {
        return this.def;
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.def = undefined;
        this.parsedXML = undefined;
        super.setDirty();
    }
    getClassDefinition() {
        var _a;
        return (_a = this.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getInfo().getClassDefinitionByName(this.getName());
    }
    getIdentifier() {
        var _a;
        return (_a = this.getClassDefinition()) === null || _a === void 0 ? void 0 : _a.identifier;
    }
    // -------------------
    getDescription() {
        var _a;
        this.parseXML();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    getNameFromXML() {
        var _a;
        this.parseXML();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.name;
    }
    getCategory() {
        var _a;
        this.parseXML();
        // https://blog.mariusschulz.com/2017/10/27/typescript-2-4-string-enums#no-reverse-mapping-for-string-valued-enum-members
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.category;
    }
    getLocalsImpFile() {
        for (const file of this.getABAPFiles()) {
            if (file.getFilename().endsWith(".clas.locals_imp.abap")) {
                return file;
            }
        }
        return undefined;
    }
    getTestclassFile() {
        for (const file of this.getABAPFiles()) {
            if (file.getFilename().endsWith(".clas.testclasses.abap")) {
                return file;
            }
        }
        return undefined;
    }
    /////////////////////////
    parseXML() {
        if (this.parsedXML !== undefined) {
            return;
        }
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit["asx:abap"] === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return;
        }
        const vseo = parsed.abapGit["asx:abap"]["asx:values"].VSEOCLASS;
        if (vseo === undefined) {
            return;
        }
        this.parsedXML.category = vseo.CATEGORY;
        this.parsedXML.description = vseo.DESCRIPT ? vseo.DESCRIPT : "";
        this.parsedXML.name = vseo.CLSNAME ? vseo.CLSNAME : "";
    }
}
exports.Class = Class;
//# sourceMappingURL=class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/classification.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/classification.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Classification = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Classification extends _abstract_object_1.AbstractObject {
    getType() {
        return "AVAS";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Classification = Classification;
//# sourceMappingURL=classification.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/communication_scenario.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/communication_scenario.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommunicationScenario = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CommunicationScenario extends _abstract_object_1.AbstractObject {
    getType() {
        return "SCO1";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CommunicationScenario = CommunicationScenario;
//# sourceMappingURL=communication_scenario.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/composite_enhancement_implementation.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/composite_enhancement_implementation.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompositeEnhancementImplementation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CompositeEnhancementImplementation extends _abstract_object_1.AbstractObject {
    getType() {
        return "ENHC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CompositeEnhancementImplementation = CompositeEnhancementImplementation;
//# sourceMappingURL=composite_enhancement_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/composite_enhancement_spot.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/composite_enhancement_spot.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CompositeEnhancementSpot = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CompositeEnhancementSpot extends _abstract_object_1.AbstractObject {
    getType() {
        return "ENSC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CompositeEnhancementSpot = CompositeEnhancementSpot;
//# sourceMappingURL=composite_enhancement_spot.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/concepts_of_package.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/concepts_of_package.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConceptsOfPackage = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ConceptsOfPackage extends _abstract_object_1.AbstractObject {
    getType() {
        return "SOTS";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
            customRegex: new RegExp(/^(\/[A-Z_\d]{3,8}\/)?[A-Z_-\d<> ]+$/i),
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ConceptsOfPackage = ConceptsOfPackage;
//# sourceMappingURL=concepts_of_package.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/customer_enhancement_project.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/customer_enhancement_project.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomerEnhancementProject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CustomerEnhancementProject extends _abstract_object_1.AbstractObject {
    getType() {
        return "CMOD";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CustomerEnhancementProject = CustomerEnhancementProject;
//# sourceMappingURL=customer_enhancement_project.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/customizing_attributes.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/customizing_attributes.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomizingAttributes = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CustomizingAttributes extends _abstract_object_1.AbstractObject {
    getType() {
        return "CUS2";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CustomizingAttributes = CustomizingAttributes;
//# sourceMappingURL=customizing_attributes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/customizing_img_activity.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/customizing_img_activity.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomizingImgActivity = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CustomizingImgActivity extends _abstract_object_1.AbstractObject {
    getType() {
        return "CUS0";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CustomizingImgActivity = CustomizingImgActivity;
//# sourceMappingURL=customizing_img_activity.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/customizing_transaction.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/customizing_transaction.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CustomizingTransaction = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class CustomizingTransaction extends _abstract_object_1.AbstractObject {
    getType() {
        return "CUS1";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.CustomizingTransaction = CustomizingTransaction;
//# sourceMappingURL=customizing_transaction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/data_control.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/data_control.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataControl = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class DataControl extends _abstract_object_1.AbstractObject {
    getType() {
        return "DCLS";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.DataControl = DataControl;
//# sourceMappingURL=data_control.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/data_definition.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/data_definition.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataDefinition = void 0;
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const cds_determine_types_1 = __webpack_require__(/*! ../cds/cds_determine_types */ "./node_modules/@abaplint/core/build/src/cds/cds_determine_types.js");
const cds_parser_1 = __webpack_require__(/*! ../cds/cds_parser */ "./node_modules/@abaplint/core/build/src/cds/cds_parser.js");
const expressions_1 = __webpack_require__(/*! ../cds/expressions */ "./node_modules/@abaplint/core/build/src/cds/expressions/index.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class DataDefinition extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parserError = undefined;
        this.parsedData = undefined;
    }
    getType() {
        return "DDLS";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getSQLViewName() {
        var _a;
        this.parse();
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.sqlViewName;
    }
    getDefinitionName() {
        var _a;
        this.parse();
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.definitionName;
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.description;
    }
    parseType(reg) {
        this.parse();
        return new cds_determine_types_1.CDSDetermineTypes().parseType(reg, this.parsedData);
    }
    getParsedData() {
        return this.parsedData;
    }
    listSources() {
        var _a;
        this.parse();
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.sources;
    }
    setDirty() {
        this.parsedData = undefined;
        this.parserError = undefined;
        super.setDirty();
    }
    findSourceFile() {
        return this.getFiles().find(f => f.getFilename().endsWith(".asddls") || f.getFilename().endsWith(".acds"));
    }
    hasParserError() {
        return this.parserError;
    }
    parse() {
        var _a, _b;
        if (this.isDirty() === false) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedData = {
            sqlViewName: undefined,
            definitionName: undefined,
            description: this.findDescription(),
            fields: [],
            sources: [],
            relations: [],
            associations: [],
            tree: undefined,
        };
        this.findSQLViewName();
        this.parsedData.tree = new cds_parser_1.CDSParser().parse(this.findSourceFile());
        if (this.parsedData.tree) {
            for (const c of ((_a = this.parsedData.tree) === null || _a === void 0 ? void 0 : _a.getChildren()) || []) {
                if (c.get() instanceof expressions_1.CDSAnnotation) {
                    continue;
                }
                if (c instanceof nodes_1.ExpressionNode) {
                    this.parsedData.definitionName = (_b = c.findFirstExpression(expressions_1.CDSName)) === null || _b === void 0 ? void 0 : _b.concatTokens().replace(/ /g, "");
                    break;
                }
            }
            this.findSourcesAndRelations(this.parsedData.tree);
            this.findFieldNames(this.parsedData.tree);
        }
        else {
            this.parserError = true;
        }
        this.dirty = false;
        return { updated: true, runtime: Date.now() - start };
    }
    getTree() {
        var _a;
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.tree;
    }
    //////////
    findSQLViewName() {
        var _a;
        const match = (_a = this.findSourceFile()) === null || _a === void 0 ? void 0 : _a.getRaw().match(/@AbapCatalog\.sqlViewName: '([\w/]+)'/);
        if (match) {
            this.parsedData.sqlViewName = match[1].toUpperCase();
        }
    }
    findDescription() {
        var _a;
        const match = (_a = this.findSourceFile()) === null || _a === void 0 ? void 0 : _a.getRaw().match(/@EndUserText\.label: '([\w,.:-=#%&() ]+)'/);
        if (match) {
            return match[1];
        }
        return undefined;
    }
    findFieldNames(tree) {
        var _a, _b;
        let expr = tree.findFirstExpression(expressions_1.CDSSelect);
        if (expr === undefined) {
            expr = tree.findFirstExpression(expressions_1.CDSAnnotate);
        }
        if (expr === undefined) {
            expr = tree.findFirstExpression(expressions_1.CDSDefineProjection);
        }
        for (const e of (expr === null || expr === void 0 ? void 0 : expr.findDirectExpressions(expressions_1.CDSElement)) || []) {
            let prefix = "";
            let found = (_a = e.findDirectExpression(expressions_1.CDSAs)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(expressions_1.CDSName);
            if (found === undefined) {
                const list = e.findAllExpressions(expressions_1.CDSName);
                if (e.concatTokens().toUpperCase().includes(" REDIRECTED TO ")) {
                    found = list[0];
                }
                else {
                    found = list[list.length - 1];
                    if (list.length > 1) {
                        prefix = list[0].concatTokens();
                    }
                }
            }
            if (found === undefined) {
                continue;
            }
            const name = found === null || found === void 0 ? void 0 : found.concatTokens();
            if ((_b = this.parsedData) === null || _b === void 0 ? void 0 : _b.associations.some(a => { var _a; return a.name.toUpperCase() === name.toUpperCase() || ((_a = a.as) === null || _a === void 0 ? void 0 : _a.toUpperCase()) === name.toUpperCase(); })) {
                continue;
            }
            const annotations = [];
            for (const a of e.findDirectExpressions(expressions_1.CDSAnnotation)) {
                annotations.push(a.concatTokens());
            }
            this.parsedData.fields.push({
                name: name,
                annotations: annotations,
                prefix: prefix,
                key: e.findDirectTokenByText("KEY") !== undefined,
            });
        }
    }
    findSourcesAndRelations(tree) {
        var _a, _b, _c, _d, _e, _f, _g;
        for (const e of tree.findAllExpressions(expressions_1.CDSSource)) {
            const name = ((_a = e.getFirstChild()) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase().replace(/ /g, "")) || "ERROR";
            const as = (_c = (_b = e.findDirectExpression(expressions_1.CDSAs)) === null || _b === void 0 ? void 0 : _b.findDirectExpression(expressions_1.CDSName)) === null || _c === void 0 ? void 0 : _c.concatTokens().toUpperCase();
            this.parsedData.sources.push({ name, as });
        }
        for (const e of tree.findAllExpressions(expressions_1.CDSRelation)) {
            const name = e.getFirstToken().getStr();
            const as = (_e = (_d = e.findDirectExpression(expressions_1.CDSAs)) === null || _d === void 0 ? void 0 : _d.findDirectExpression(expressions_1.CDSName)) === null || _e === void 0 ? void 0 : _e.getFirstToken().getStr();
            this.parsedData.relations.push({ name, as });
        }
        for (const e of tree.findAllExpressions(expressions_1.CDSAssociation)) {
            const j = e.findDirectExpression(expressions_1.CDSRelation);
            if (j === undefined) {
                continue;
            }
            const name = j.getFirstToken().getStr();
            const as = (_g = (_f = j.findDirectExpression(expressions_1.CDSAs)) === null || _f === void 0 ? void 0 : _f.findDirectExpression(expressions_1.CDSName)) === null || _g === void 0 ? void 0 : _g.getFirstToken().getStr();
            this.parsedData.associations.push({
                name: name || "ERROR",
                as: as,
            });
        }
    }
}
exports.DataDefinition = DataDefinition;
//# sourceMappingURL=data_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/data_element.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/data_element.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DataElement = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const Types = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class DataElement extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parsedXML = undefined;
    }
    getType() {
        return "DTEL";
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDomainName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.domname;
    }
    getTexts() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.texts;
    }
    parseType(reg) {
        var _a;
        const references = [];
        let lookup = undefined;
        if (this.parsedXML === undefined) {
            lookup = { type: new Types.UnknownType("Data Element " + this.getName() + ", parser error") };
        }
        else {
            const ddic = new ddic_1.DDIC(reg);
            if (this.parsedXML.refkind === "D") {
                if (this.parsedXML.domname === undefined || this.parsedXML.domname === "") {
                    lookup = { type: new Types.UnknownType("DOMNAME unexpectely empty in " + this.getName()) };
                }
                else {
                    lookup = ddic.lookupDomain(this.parsedXML.domname, this.getName(), this.getDescription());
                }
            }
            else if (this.parsedXML.refkind === "R") {
                if (this.parsedXML.domname === undefined || this.parsedXML.domname === "") {
                    lookup = { type: new Types.UnknownType("DOMNAME unexpectely empty in " + this.getName()) };
                }
                else {
                    lookup = ddic.lookupObject(this.parsedXML.domname);
                }
            }
            else {
                if (this.parsedXML.datatype === undefined || this.parsedXML.datatype === "") {
                    lookup = { type: new Types.UnknownType("DATATYPE unexpectely empty in " + this.getName()) };
                }
                else {
                    lookup = { type: ddic.textToType({
                            text: this.parsedXML.datatype,
                            length: this.parsedXML.leng,
                            decimals: this.parsedXML.decimals,
                            infoText: this.getName(),
                            qualifiedName: this.getName(),
                            conversionExit: undefined,
                            ddicName: this.getName(),
                            description: (_a = this.parsedXML.texts) === null || _a === void 0 ? void 0 : _a.heading,
                        }) };
                }
            }
        }
        if (lookup.object) {
            references.push({ object: lookup.object });
        }
        reg.getDDICReferences().setUsing(this, references);
        return lookup.type;
    }
    parse() {
        var _a, _b, _c;
        if (this.parsedXML !== undefined) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return { updated: false, runtime: 0 };
        }
        const dd04v = (_c = (_b = (_a = parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.DD04V;
        this.parsedXML = {
            description: dd04v === null || dd04v === void 0 ? void 0 : dd04v.DDTEXT,
            refkind: dd04v === null || dd04v === void 0 ? void 0 : dd04v.REFKIND,
            domname: dd04v === null || dd04v === void 0 ? void 0 : dd04v.DOMNAME,
            datatype: dd04v === null || dd04v === void 0 ? void 0 : dd04v.DATATYPE,
            leng: dd04v === null || dd04v === void 0 ? void 0 : dd04v.LENG,
            decimals: dd04v === null || dd04v === void 0 ? void 0 : dd04v.DECIMALS,
            texts: {
                short: dd04v === null || dd04v === void 0 ? void 0 : dd04v.SCRTEXT_S,
                medium: dd04v === null || dd04v === void 0 ? void 0 : dd04v.SCRTEXT_M,
                long: dd04v === null || dd04v === void 0 ? void 0 : dd04v.SCRTEXT_L,
                heading: dd04v === null || dd04v === void 0 ? void 0 : dd04v.REPTEXT,
            },
        };
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.DataElement = DataElement;
//# sourceMappingURL=data_element.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/dialog_module.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/dialog_module.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DialogModule = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class DialogModule extends _abstract_object_1.AbstractObject {
    getType() {
        return "DIAL";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.DialogModule = DialogModule;
//# sourceMappingURL=dialog_module.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/documentation.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/documentation.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Documentation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Documentation extends _abstract_object_1.AbstractObject {
    getType() {
        return "DOCV";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Documentation = Documentation;
//# sourceMappingURL=documentation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/domain.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/domain.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Domain = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const Types = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class Domain extends _abstract_object_1.AbstractObject {
    getType() {
        return "DOMA";
    }
    getDescription() {
        var _a;
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    getConversionExit() {
        var _a;
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.conversionExit;
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    parseType(reg, dataElement, description) {
        // dont cache the DOMA parsed type, they are cached on DTEL level
        // also note that the type carries the name of the DTEL
        if (this.parsedXML === undefined) {
            this.parse();
        }
        if (this.parsedXML === undefined) {
            return new Types.UnknownType("Domain " + this.getName() + " parser error", this.getName());
        }
        const ddic = new ddic_1.DDIC(reg);
        return ddic.textToType({
            text: this.parsedXML.datatype,
            length: this.parsedXML.length,
            decimals: this.parsedXML.decimals,
            infoText: this.getName(),
            qualifiedName: dataElement,
            conversionExit: this.parsedXML.conversionExit,
            ddicName: dataElement,
            description: description,
        });
    }
    parse() {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return { updated: false, runtime: 0 };
        }
        const dd01v = (_c = (_b = (_a = parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.DD01V;
        const dd07v_tab = (0, xml_utils_1.xmlToArray)((_g = (_f = (_e = (_d = parsed.abapGit) === null || _d === void 0 ? void 0 : _d["asx:abap"]) === null || _e === void 0 ? void 0 : _e["asx:values"]) === null || _f === void 0 ? void 0 : _f.DD07V_TAB) === null || _g === void 0 ? void 0 : _g.DD07V);
        const values = [];
        for (const ddo7v of dd07v_tab) {
            const value = {
                description: ddo7v === null || ddo7v === void 0 ? void 0 : ddo7v.DDTEXT,
                low: ddo7v === null || ddo7v === void 0 ? void 0 : ddo7v.DOMVALUE_L,
                high: ddo7v === null || ddo7v === void 0 ? void 0 : ddo7v.DOMVALUE_H,
                language: ddo7v === null || ddo7v === void 0 ? void 0 : ddo7v.DDLANGUAGE,
            };
            values.push(value);
        }
        this.parsedXML = {
            description: dd01v === null || dd01v === void 0 ? void 0 : dd01v.DDTEXT,
            datatype: dd01v === null || dd01v === void 0 ? void 0 : dd01v.DATATYPE,
            length: dd01v === null || dd01v === void 0 ? void 0 : dd01v.LENG,
            conversionExit: dd01v === null || dd01v === void 0 ? void 0 : dd01v.CONVEXIT,
            decimals: dd01v === null || dd01v === void 0 ? void 0 : dd01v.DECIMALS,
            values: values,
        };
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
    getFixedValues() {
        var _a, _b;
        return (_b = (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.values) !== null && _b !== void 0 ? _b : [];
    }
}
exports.Domain = Domain;
//# sourceMappingURL=domain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_configuration.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/ecatt_test_configuration.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EcattTestConfiguration = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EcattTestConfiguration extends _abstract_object_1.AbstractObject {
    getType() {
        return "ECTC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.EcattTestConfiguration = EcattTestConfiguration;
//# sourceMappingURL=ecatt_test_configuration.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_data_container.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/ecatt_test_data_container.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EcattTestDataContainer = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EcattTestDataContainer extends _abstract_object_1.AbstractObject {
    getType() {
        return "ECTD";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.EcattTestDataContainer = EcattTestDataContainer;
//# sourceMappingURL=ecatt_test_data_container.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_script.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/ecatt_test_script.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EcattTestScript = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EcattTestScript extends _abstract_object_1.AbstractObject {
    getType() {
        return "ECAT";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.EcattTestScript = EcattTestScript;
//# sourceMappingURL=ecatt_test_script.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/enhancement_implementation.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/enhancement_implementation.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancementImplementation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EnhancementImplementation extends _abstract_object_1.AbstractObject {
    getType() {
        return "ENHO";
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getClassName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.className;
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    parse() {
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.className = parsed.abapGit["asx:abap"]["asx:values"].CLASS;
        this.parsedXML.description = parsed.abapGit["asx:abap"]["asx:values"].SHORTTEXT;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.EnhancementImplementation = EnhancementImplementation;
//# sourceMappingURL=enhancement_implementation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/enhancement_spot.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/enhancement_spot.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EnhancementSpot = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class EnhancementSpot extends _abstract_object_1.AbstractObject {
    getType() {
        return "ENHS";
    }
    getDescription() {
        // todo
        return undefined;
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.badis = undefined;
        super.setDirty();
    }
    listBadiDefinitions() {
        if (this.badis === undefined) {
            this.badis = this.parseXML();
        }
        return this.badis;
    }
    /////////////////
    parseXML() {
        var _a, _b;
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return [];
        }
        const ret = [];
        for (const b of (0, xml_utils_1.xmlToArray)((_b = (_a = parsed.abapGit["asx:abap"]["asx:values"]) === null || _a === void 0 ? void 0 : _a.BADI_DATA) === null || _b === void 0 ? void 0 : _b.ENH_BADI_DATA)) {
            ret.push({
                name: b.BADI_NAME,
                interface: b.INTERFACE_NAME,
            });
        }
        return ret;
    }
}
exports.EnhancementSpot = EnhancementSpot;
//# sourceMappingURL=enhancement_spot.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/event_binding.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/event_binding.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventBinding = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EventBinding extends _abstract_object_1.AbstractObject {
    getType() {
        return "EVTB";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.EventBinding = EventBinding;
//# sourceMappingURL=event_binding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/event_consumer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/event_consumer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EventConsumer = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class EventConsumer extends _abstract_object_1.AbstractObject {
    getType() {
        return "EEEC";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.EventConsumer = EventConsumer;
//# sourceMappingURL=event_consumer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/extension_index.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/extension_index.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExtensionIndex = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ExtensionIndex extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parsedXML = undefined;
    }
    getType() {
        return "XINX";
    }
    getAllowedNaming() {
        return {
            maxLength: 33,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.ddtext;
    }
    getTableName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.sqltab;
    }
    parse() {
        var _a, _b, _c, _d, _e;
        if (this.parsedXML !== undefined) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return { updated: false, runtime: 0 };
        }
        const xinx = (_c = (_b = (_a = parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.XINX;
        this.parsedXML = {
            sqltab: (_d = xinx === null || xinx === void 0 ? void 0 : xinx.DD12V) === null || _d === void 0 ? void 0 : _d.SQLTAB,
            ddtext: (_e = xinx === null || xinx === void 0 ? void 0 : xinx.DD12V) === null || _e === void 0 ? void 0 : _e.DDTEXT,
        };
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.ExtensionIndex = ExtensionIndex;
//# sourceMappingURL=extension_index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/field_catalog.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/field_catalog.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FieldCatalog = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class FieldCatalog extends _abstract_object_1.AbstractObject {
    getType() {
        return "ASFC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.FieldCatalog = FieldCatalog;
//# sourceMappingURL=field_catalog.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/form_object_form.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/form_object_form.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormObjectForm = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class FormObjectForm extends _abstract_object_1.AbstractObject {
    getType() {
        return "SFPF";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.FormObjectForm = FormObjectForm;
//# sourceMappingURL=form_object_form.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/form_object_interface.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/form_object_interface.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormObjectInterface = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class FormObjectInterface extends _abstract_object_1.AbstractObject {
    getType() {
        return "SFPI";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.FormObjectInterface = FormObjectInterface;
//# sourceMappingURL=form_object_interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/format_type.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/format_type.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormatType = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class FormatType extends _abstract_object_1.AbstractObject {
    getType() {
        return "SPLO";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.FormatType = FormatType;
//# sourceMappingURL=format_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/function_group.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/function_group.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionGroup = void 0;
const _abap_object_1 = __webpack_require__(/*! ./_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
const fast_xml_parser_1 = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
const _dynpros_1 = __webpack_require__(/*! ./_dynpros */ "./node_modules/@abaplint/core/build/src/objects/_dynpros.js");
class FunctionGroup extends _abap_object_1.ABAPObject {
    constructor() {
        super(...arguments);
        this.includes = undefined;
        this.modules = undefined;
        this.description = undefined;
        this.dynpros = undefined;
    }
    getType() {
        return "FUGR";
    }
    getDescription() {
        if (this.description === undefined) {
            this.parseXML();
        }
        return this.description;
    }
    setDirty() {
        super.setDirty();
        this.includes = undefined;
        this.modules = undefined;
    }
    getAllowedNaming() {
        return {
            maxLength: 26,
            allowNamespace: true,
        };
    }
    getDynpros() {
        if (this.dynpros === undefined) {
            this.parseXML();
        }
        return this.dynpros || [];
    }
    getSequencedFiles() {
        const main = this.getMainABAPFile();
        if (main === undefined) {
            return [];
        }
        const sequence = [main];
        for (const m of this.getModules()) {
            const search = "." + m.getName().toLocaleLowerCase().replace(/\//g, "#") + ".abap";
            for (const f of this.getABAPFiles()) {
                if (f.getFilename().toLocaleLowerCase().endsWith(search)) {
                    if (sequence.indexOf(f) < 0) {
                        sequence.push(f);
                    }
                    break;
                }
            }
        }
        return sequence;
    }
    getModules() {
        if (this.modules === undefined) {
            this.parseXML();
        }
        if (this.modules === undefined) {
            throw new Error("getIncludes, undefined");
        }
        return this.modules;
    }
    getIncludeFiles() {
        const ret = [];
        const includes = this.getIncludes();
        for (const f of this.getABAPFiles()) {
            for (const i of includes) {
                const namespaced = i.startsWith("/") && i.includes("/L");
                let search = i;
                if (namespaced) {
                    search = search.replace(/\//g, "#");
                }
                if ((i.startsWith("L") || namespaced) && f.getFilename().includes(search.toLowerCase())) {
                    ret.push({ file: f, name: i });
                }
                // fix for URL encoded? Uris
                if (namespaced) {
                    search = i.replace(/\//g, "%23");
                    if (f.getFilename().includes(search.toLowerCase())) {
                        ret.push({ file: f, name: i });
                    }
                }
            }
        }
        return ret;
    }
    getInclude(name) {
        const upper = name.toUpperCase();
        const includes = this.getIncludeFiles();
        for (const i of includes) {
            if (i.name.toUpperCase() === upper) {
                return i.file;
            }
        }
        return undefined;
    }
    getMainABAPFile() {
        const regex = new RegExp(/\.fugr\.(#\w+#)?sapl/, "i");
        for (const f of this.getABAPFiles()) {
            if (regex.test(f.getFilename())) {
                return f;
            }
        }
        return undefined;
    }
    getIncludes() {
        if (this.includes === undefined) {
            this.parseXML();
        }
        if (this.includes === undefined) {
            throw new Error("getIncludes, undefined");
        }
        return this.includes;
    }
    getModule(name) {
        for (const mod of this.getModules()) {
            if (mod.getName().toUpperCase() === name.toUpperCase()) {
                return mod;
            }
        }
        return undefined;
    }
    getTexts() {
        if (this.texts === undefined) {
            const found = this.findTextFile();
            if (found === undefined) {
                return {};
            }
            const parsed = new fast_xml_parser_1.XMLParser({ parseTagValue: false, ignoreAttributes: true, trimValues: false }).parse(found.getRaw());
            this.findTexts(parsed);
        }
        return this.texts;
    }
    /////////////////////////////////
    parseXML() {
        var _a, _b, _c;
        this.includes = [];
        this.modules = [];
        const parsed = this.parseRaw2();
        if (parsed === undefined) {
            return;
        }
        this.description = (_a = parsed.abapGit["asx:abap"]["asx:values"]) === null || _a === void 0 ? void 0 : _a.AREAT;
        this.dynpros = (0, _dynpros_1.parseDynpros)(parsed);
        // INCLUDES
        const includes = (_b = parsed.abapGit["asx:abap"]["asx:values"]) === null || _b === void 0 ? void 0 : _b.INCLUDES;
        if (includes !== undefined) {
            for (const i of (0, xml_utils_1.xmlToArray)(includes.SOBJ_NAME)) {
                this.includes.push(i);
            }
        }
        // FUNCTION MODULES
        const functions = (_c = parsed.abapGit["asx:abap"]["asx:values"]) === null || _c === void 0 ? void 0 : _c.FUNCTIONS;
        for (const module of (0, xml_utils_1.xmlToArray)(functions === null || functions === void 0 ? void 0 : functions.item)) {
            this.modules.push(new types_1.FunctionModuleDefinition(module));
        }
    }
    findTextFile() {
        const search = this.getName() + ".fugr.sapl" + this.getName() + ".xml";
        for (const f of this.getFiles()) {
            if (f.getFilename().includes(search.toLowerCase())) {
                return f;
            }
        }
        return undefined;
    }
}
exports.FunctionGroup = FunctionGroup;
//# sourceMappingURL=function_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_model.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_model.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayModel = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayModel extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWMO";
    }
    getAllowedNaming() {
        return {
            maxLength: 36,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayModel = GatewayModel;
//# sourceMappingURL=gateway_model.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_model_metadata.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_model_metadata.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayModelMetadata = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayModelMetadata extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWOM";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayModelMetadata = GatewayModelMetadata;
//# sourceMappingURL=gateway_model_metadata.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_project.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_project.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayProject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayProject extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWPR";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayProject = GatewayProject;
//# sourceMappingURL=gateway_project.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_service.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_service.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayService extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWSV";
    }
    getAllowedNaming() {
        return {
            maxLength: 39,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayService = GatewayService;
//# sourceMappingURL=gateway_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_service_groups_metadata.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_service_groups_metadata.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayServiceGroupsMetadata = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayServiceGroupsMetadata extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWSG";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayServiceGroupsMetadata = GatewayServiceGroupsMetadata;
//# sourceMappingURL=gateway_service_groups_metadata.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/gateway_vocabulary_annotation.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/gateway_vocabulary_annotation.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GatewayVocabularyAnnotation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GatewayVocabularyAnnotation extends _abstract_object_1.AbstractObject {
    getType() {
        return "IWVB";
    }
    getAllowedNaming() {
        return {
            maxLength: 36,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GatewayVocabularyAnnotation = GatewayVocabularyAnnotation;
//# sourceMappingURL=gateway_vocabulary_annotation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/general_hierarchy_storage_extrension_name.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/general_hierarchy_storage_extrension_name.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeneralHierarchyStorageExtrensionName = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GeneralHierarchyStorageExtrensionName extends _abstract_object_1.AbstractObject {
    getType() {
        return "SHI5";
    }
    getAllowedNaming() {
        return {
            maxLength: 15,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GeneralHierarchyStorageExtrensionName = GeneralHierarchyStorageExtrensionName;
//# sourceMappingURL=general_hierarchy_storage_extrension_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/general_storage_structure.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/general_storage_structure.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeneralStorageStructure = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GeneralStorageStructure extends _abstract_object_1.AbstractObject {
    getType() {
        return "SHI3";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GeneralStorageStructure = GeneralStorageStructure;
//# sourceMappingURL=general_storage_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/general_text.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/general_text.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GeneralText = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class GeneralText extends _abstract_object_1.AbstractObject {
    getType() {
        return "DOCT";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.GeneralText = GeneralText;
//# sourceMappingURL=general_text.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/http_service.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/http_service.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.HttpService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class HttpService extends _abstract_object_1.AbstractObject {
    getType() {
        return "HTTP";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.HttpService = HttpService;
//# sourceMappingURL=http_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/iac_binary_data.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/iac_binary_data.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IACBinaryData = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IACBinaryData extends _abstract_object_1.AbstractObject {
    getType() {
        return "IAMU";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IACBinaryData = IACBinaryData;
//# sourceMappingURL=iac_binary_data.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/iac_language_resource.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/iac_language_resource.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IACLanguageResource = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IACLanguageResource extends _abstract_object_1.AbstractObject {
    getType() {
        return "IARP";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IACLanguageResource = IACLanguageResource;
//# sourceMappingURL=iac_language_resource.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/iac_service.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/iac_service.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IACService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IACService extends _abstract_object_1.AbstractObject {
    getType() {
        return "IASP";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IACService = IACService;
//# sourceMappingURL=iac_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/iac_template.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/iac_template.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IACTemplate = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IACTemplate extends _abstract_object_1.AbstractObject {
    getType() {
        return "IATU";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IACTemplate = IACTemplate;
//# sourceMappingURL=iac_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/iam_app.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/iam_app.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IAMApp = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IAMApp extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA6";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IAMApp = IAMApp;
//# sourceMappingURL=iam_app.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/icf_service.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/icf_service.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ICFService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class ICFService extends _abstract_object_1.AbstractObject {
    getType() {
        return "SICF";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDescription() {
        // todo
        return undefined;
    }
    getURL() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.url;
    }
    getHandlerList() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.handlers;
    }
    parse() {
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        const table = parsed.abapGit["asx:abap"]["asx:values"].ICFHANDLER_TABLE;
        this.parsedXML.handlers = [];
        for (const h of (0, xml_utils_1.xmlToArray)(table)) {
            if (h.ICFHANDLER !== undefined) {
                this.parsedXML.handlers.push(h.ICFHANDLER.ICFHANDLER);
            }
        }
        this.parsedXML.url = parsed.abapGit["asx:abap"]["asx:values"].URL;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.ICFService = ICFService;
//# sourceMappingURL=icf_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/idoc.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/idoc.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Idoc = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Idoc extends _abstract_object_1.AbstractObject {
    getType() {
        return "IDOC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Idoc = Idoc;
//# sourceMappingURL=idoc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/idoc_extension.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/idoc_extension.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdocExtension = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class IdocExtension extends _abstract_object_1.AbstractObject {
    getType() {
        return "IEXT";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: false,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.IdocExtension = IdocExtension;
//# sourceMappingURL=idoc_extension.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/inbound_service.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/inbound_service.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InboundService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class InboundService extends _abstract_object_1.AbstractObject {
    getType() {
        return "SCO2";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.InboundService = InboundService;
//# sourceMappingURL=inbound_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./abap_query_functional_area */ "./node_modules/@abaplint/core/build/src/objects/abap_query_functional_area.js"), exports);
__exportStar(__webpack_require__(/*! ./abap_query_query */ "./node_modules/@abaplint/core/build/src/objects/abap_query_query.js"), exports);
__exportStar(__webpack_require__(/*! ./activation_variant */ "./node_modules/@abaplint/core/build/src/objects/activation_variant.js"), exports);
__exportStar(__webpack_require__(/*! ./api_release_state */ "./node_modules/@abaplint/core/build/src/objects/api_release_state.js"), exports);
__exportStar(__webpack_require__(/*! ./application_job_catalog_entry */ "./node_modules/@abaplint/core/build/src/objects/application_job_catalog_entry.js"), exports);
__exportStar(__webpack_require__(/*! ./application_job_template */ "./node_modules/@abaplint/core/build/src/objects/application_job_template.js"), exports);
__exportStar(__webpack_require__(/*! ./application_log_object */ "./node_modules/@abaplint/core/build/src/objects/application_log_object.js"), exports);
__exportStar(__webpack_require__(/*! ./assignment_service_to_authorization_group */ "./node_modules/@abaplint/core/build/src/objects/assignment_service_to_authorization_group.js"), exports);
__exportStar(__webpack_require__(/*! ./atc_check_category */ "./node_modules/@abaplint/core/build/src/objects/atc_check_category.js"), exports);
__exportStar(__webpack_require__(/*! ./atc_check_object */ "./node_modules/@abaplint/core/build/src/objects/atc_check_object.js"), exports);
__exportStar(__webpack_require__(/*! ./atc_check_variant */ "./node_modules/@abaplint/core/build/src/objects/atc_check_variant.js"), exports);
__exportStar(__webpack_require__(/*! ./authorization_check_field */ "./node_modules/@abaplint/core/build/src/objects/authorization_check_field.js"), exports);
__exportStar(__webpack_require__(/*! ./authorization_group */ "./node_modules/@abaplint/core/build/src/objects/authorization_group.js"), exports);
__exportStar(__webpack_require__(/*! ./authorization_object_class */ "./node_modules/@abaplint/core/build/src/objects/authorization_object_class.js"), exports);
__exportStar(__webpack_require__(/*! ./authorization_object_extension */ "./node_modules/@abaplint/core/build/src/objects/authorization_object_extension.js"), exports);
__exportStar(__webpack_require__(/*! ./authorization_object */ "./node_modules/@abaplint/core/build/src/objects/authorization_object.js"), exports);
__exportStar(__webpack_require__(/*! ./behavior_definition */ "./node_modules/@abaplint/core/build/src/objects/behavior_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./bsp_application */ "./node_modules/@abaplint/core/build/src/objects/bsp_application.js"), exports);
__exportStar(__webpack_require__(/*! ./business_add_in_implementation */ "./node_modules/@abaplint/core/build/src/objects/business_add_in_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./business_catalog_app_assignment */ "./node_modules/@abaplint/core/build/src/objects/business_catalog_app_assignment.js"), exports);
__exportStar(__webpack_require__(/*! ./business_catalog */ "./node_modules/@abaplint/core/build/src/objects/business_catalog.js"), exports);
__exportStar(__webpack_require__(/*! ./business_configuration_set */ "./node_modules/@abaplint/core/build/src/objects/business_configuration_set.js"), exports);
__exportStar(__webpack_require__(/*! ./business_function_assignment */ "./node_modules/@abaplint/core/build/src/objects/business_function_assignment.js"), exports);
__exportStar(__webpack_require__(/*! ./business_function_set_assignment */ "./node_modules/@abaplint/core/build/src/objects/business_function_set_assignment.js"), exports);
__exportStar(__webpack_require__(/*! ./business_object_model */ "./node_modules/@abaplint/core/build/src/objects/business_object_model.js"), exports);
__exportStar(__webpack_require__(/*! ./business_object_type */ "./node_modules/@abaplint/core/build/src/objects/business_object_type.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_metadata_extension */ "./node_modules/@abaplint/core/build/src/objects/cds_metadata_extension.js"), exports);
__exportStar(__webpack_require__(/*! ./change_document */ "./node_modules/@abaplint/core/build/src/objects/change_document.js"), exports);
__exportStar(__webpack_require__(/*! ./chapter_of_book_structure */ "./node_modules/@abaplint/core/build/src/objects/chapter_of_book_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./checkpoint_group */ "./node_modules/@abaplint/core/build/src/objects/checkpoint_group.js"), exports);
__exportStar(__webpack_require__(/*! ./class */ "./node_modules/@abaplint/core/build/src/objects/class.js"), exports);
__exportStar(__webpack_require__(/*! ./classification */ "./node_modules/@abaplint/core/build/src/objects/classification.js"), exports);
__exportStar(__webpack_require__(/*! ./communication_scenario */ "./node_modules/@abaplint/core/build/src/objects/communication_scenario.js"), exports);
__exportStar(__webpack_require__(/*! ./composite_enhancement_implementation */ "./node_modules/@abaplint/core/build/src/objects/composite_enhancement_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./composite_enhancement_spot */ "./node_modules/@abaplint/core/build/src/objects/composite_enhancement_spot.js"), exports);
__exportStar(__webpack_require__(/*! ./concepts_of_package */ "./node_modules/@abaplint/core/build/src/objects/concepts_of_package.js"), exports);
__exportStar(__webpack_require__(/*! ./customer_enhancement_project */ "./node_modules/@abaplint/core/build/src/objects/customer_enhancement_project.js"), exports);
__exportStar(__webpack_require__(/*! ./customizing_attributes */ "./node_modules/@abaplint/core/build/src/objects/customizing_attributes.js"), exports);
__exportStar(__webpack_require__(/*! ./customizing_img_activity */ "./node_modules/@abaplint/core/build/src/objects/customizing_img_activity.js"), exports);
__exportStar(__webpack_require__(/*! ./customizing_transaction */ "./node_modules/@abaplint/core/build/src/objects/customizing_transaction.js"), exports);
__exportStar(__webpack_require__(/*! ./data_control */ "./node_modules/@abaplint/core/build/src/objects/data_control.js"), exports);
__exportStar(__webpack_require__(/*! ./data_definition */ "./node_modules/@abaplint/core/build/src/objects/data_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./data_element */ "./node_modules/@abaplint/core/build/src/objects/data_element.js"), exports);
__exportStar(__webpack_require__(/*! ./dialog_module */ "./node_modules/@abaplint/core/build/src/objects/dialog_module.js"), exports);
__exportStar(__webpack_require__(/*! ./documentation */ "./node_modules/@abaplint/core/build/src/objects/documentation.js"), exports);
__exportStar(__webpack_require__(/*! ./domain */ "./node_modules/@abaplint/core/build/src/objects/domain.js"), exports);
__exportStar(__webpack_require__(/*! ./ecatt_test_configuration */ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./ecatt_test_data_container */ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_data_container.js"), exports);
__exportStar(__webpack_require__(/*! ./ecatt_test_script */ "./node_modules/@abaplint/core/build/src/objects/ecatt_test_script.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement_implementation */ "./node_modules/@abaplint/core/build/src/objects/enhancement_implementation.js"), exports);
__exportStar(__webpack_require__(/*! ./enhancement_spot */ "./node_modules/@abaplint/core/build/src/objects/enhancement_spot.js"), exports);
__exportStar(__webpack_require__(/*! ./event_binding */ "./node_modules/@abaplint/core/build/src/objects/event_binding.js"), exports);
__exportStar(__webpack_require__(/*! ./event_binding */ "./node_modules/@abaplint/core/build/src/objects/event_binding.js"), exports);
__exportStar(__webpack_require__(/*! ./event_consumer */ "./node_modules/@abaplint/core/build/src/objects/event_consumer.js"), exports);
__exportStar(__webpack_require__(/*! ./extension_index */ "./node_modules/@abaplint/core/build/src/objects/extension_index.js"), exports);
__exportStar(__webpack_require__(/*! ./field_catalog */ "./node_modules/@abaplint/core/build/src/objects/field_catalog.js"), exports);
__exportStar(__webpack_require__(/*! ./form_object_form */ "./node_modules/@abaplint/core/build/src/objects/form_object_form.js"), exports);
__exportStar(__webpack_require__(/*! ./form_object_interface */ "./node_modules/@abaplint/core/build/src/objects/form_object_interface.js"), exports);
__exportStar(__webpack_require__(/*! ./format_type */ "./node_modules/@abaplint/core/build/src/objects/format_type.js"), exports);
__exportStar(__webpack_require__(/*! ./function_group */ "./node_modules/@abaplint/core/build/src/objects/function_group.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_model_metadata */ "./node_modules/@abaplint/core/build/src/objects/gateway_model_metadata.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_model */ "./node_modules/@abaplint/core/build/src/objects/gateway_model.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_project */ "./node_modules/@abaplint/core/build/src/objects/gateway_project.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_service_groups_metadata */ "./node_modules/@abaplint/core/build/src/objects/gateway_service_groups_metadata.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_service */ "./node_modules/@abaplint/core/build/src/objects/gateway_service.js"), exports);
__exportStar(__webpack_require__(/*! ./gateway_vocabulary_annotation */ "./node_modules/@abaplint/core/build/src/objects/gateway_vocabulary_annotation.js"), exports);
__exportStar(__webpack_require__(/*! ./general_hierarchy_storage_extrension_name */ "./node_modules/@abaplint/core/build/src/objects/general_hierarchy_storage_extrension_name.js"), exports);
__exportStar(__webpack_require__(/*! ./general_storage_structure */ "./node_modules/@abaplint/core/build/src/objects/general_storage_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./general_text */ "./node_modules/@abaplint/core/build/src/objects/general_text.js"), exports);
__exportStar(__webpack_require__(/*! ./http_service */ "./node_modules/@abaplint/core/build/src/objects/http_service.js"), exports);
__exportStar(__webpack_require__(/*! ./iac_binary_data */ "./node_modules/@abaplint/core/build/src/objects/iac_binary_data.js"), exports);
__exportStar(__webpack_require__(/*! ./iac_language_resource */ "./node_modules/@abaplint/core/build/src/objects/iac_language_resource.js"), exports);
__exportStar(__webpack_require__(/*! ./iac_service */ "./node_modules/@abaplint/core/build/src/objects/iac_service.js"), exports);
__exportStar(__webpack_require__(/*! ./iac_template */ "./node_modules/@abaplint/core/build/src/objects/iac_template.js"), exports);
__exportStar(__webpack_require__(/*! ./iam_app */ "./node_modules/@abaplint/core/build/src/objects/iam_app.js"), exports);
__exportStar(__webpack_require__(/*! ./icf_service */ "./node_modules/@abaplint/core/build/src/objects/icf_service.js"), exports);
__exportStar(__webpack_require__(/*! ./idoc_extension */ "./node_modules/@abaplint/core/build/src/objects/idoc_extension.js"), exports);
__exportStar(__webpack_require__(/*! ./idoc */ "./node_modules/@abaplint/core/build/src/objects/idoc.js"), exports);
__exportStar(__webpack_require__(/*! ./inbound_service */ "./node_modules/@abaplint/core/build/src/objects/inbound_service.js"), exports);
__exportStar(__webpack_require__(/*! ./info_object */ "./node_modules/@abaplint/core/build/src/objects/info_object.js"), exports);
__exportStar(__webpack_require__(/*! ./interface */ "./node_modules/@abaplint/core/build/src/objects/interface.js"), exports);
__exportStar(__webpack_require__(/*! ./lock_object */ "./node_modules/@abaplint/core/build/src/objects/lock_object.js"), exports);
__exportStar(__webpack_require__(/*! ./maintenance_and_transport_object */ "./node_modules/@abaplint/core/build/src/objects/maintenance_and_transport_object.js"), exports);
__exportStar(__webpack_require__(/*! ./message_class */ "./node_modules/@abaplint/core/build/src/objects/message_class.js"), exports);
__exportStar(__webpack_require__(/*! ./messaging_channel */ "./node_modules/@abaplint/core/build/src/objects/messaging_channel.js"), exports);
__exportStar(__webpack_require__(/*! ./mime_object */ "./node_modules/@abaplint/core/build/src/objects/mime_object.js"), exports);
__exportStar(__webpack_require__(/*! ./namespace */ "./node_modules/@abaplint/core/build/src/objects/namespace.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_api */ "./node_modules/@abaplint/core/build/src/objects/neptune_api.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_app */ "./node_modules/@abaplint/core/build/src/objects/neptune_app.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_custom_color */ "./node_modules/@abaplint/core/build/src/objects/neptune_custom_color.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_custom_js_helper */ "./node_modules/@abaplint/core/build/src/objects/neptune_custom_js_helper.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_documentation */ "./node_modules/@abaplint/core/build/src/objects/neptune_documentation.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_enhancement */ "./node_modules/@abaplint/core/build/src/objects/neptune_enhancement.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_launchpad_layout */ "./node_modules/@abaplint/core/build/src/objects/neptune_launchpad_layout.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_launchpad */ "./node_modules/@abaplint/core/build/src/objects/neptune_launchpad.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_login_page */ "./node_modules/@abaplint/core/build/src/objects/neptune_login_page.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_media_library */ "./node_modules/@abaplint/core/build/src/objects/neptune_media_library.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_media_pack */ "./node_modules/@abaplint/core/build/src/objects/neptune_media_pack.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_metadata */ "./node_modules/@abaplint/core/build/src/objects/neptune_metadata.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_mobile_client */ "./node_modules/@abaplint/core/build/src/objects/neptune_mobile_client.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_odata */ "./node_modules/@abaplint/core/build/src/objects/neptune_odata.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_policy */ "./node_modules/@abaplint/core/build/src/objects/neptune_policy.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_rfc_mapping */ "./node_modules/@abaplint/core/build/src/objects/neptune_rfc_mapping.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_rich_text_template */ "./node_modules/@abaplint/core/build/src/objects/neptune_rich_text_template.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_splash_screen */ "./node_modules/@abaplint/core/build/src/objects/neptune_splash_screen.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_sticky_banner */ "./node_modules/@abaplint/core/build/src/objects/neptune_sticky_banner.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_tile_group */ "./node_modules/@abaplint/core/build/src/objects/neptune_tile_group.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_tile_layout */ "./node_modules/@abaplint/core/build/src/objects/neptune_tile_layout.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_tile */ "./node_modules/@abaplint/core/build/src/objects/neptune_tile.js"), exports);
__exportStar(__webpack_require__(/*! ./neptune_url_alias */ "./node_modules/@abaplint/core/build/src/objects/neptune_url_alias.js"), exports);
__exportStar(__webpack_require__(/*! ./number_range */ "./node_modules/@abaplint/core/build/src/objects/number_range.js"), exports);
__exportStar(__webpack_require__(/*! ./oauth2_profile */ "./node_modules/@abaplint/core/build/src/objects/oauth2_profile.js"), exports);
__exportStar(__webpack_require__(/*! ./object_characteristic */ "./node_modules/@abaplint/core/build/src/objects/object_characteristic.js"), exports);
__exportStar(__webpack_require__(/*! ./outbound_service */ "./node_modules/@abaplint/core/build/src/objects/outbound_service.js"), exports);
__exportStar(__webpack_require__(/*! ./package_interface */ "./node_modules/@abaplint/core/build/src/objects/package_interface.js"), exports);
__exportStar(__webpack_require__(/*! ./package */ "./node_modules/@abaplint/core/build/src/objects/package.js"), exports);
__exportStar(__webpack_require__(/*! ./parameter */ "./node_modules/@abaplint/core/build/src/objects/parameter.js"), exports);
__exportStar(__webpack_require__(/*! ./personalization_object */ "./node_modules/@abaplint/core/build/src/objects/personalization_object.js"), exports);
__exportStar(__webpack_require__(/*! ./program */ "./node_modules/@abaplint/core/build/src/objects/program.js"), exports);
__exportStar(__webpack_require__(/*! ./proxy_object */ "./node_modules/@abaplint/core/build/src/objects/proxy_object.js"), exports);
__exportStar(__webpack_require__(/*! ./push_channel */ "./node_modules/@abaplint/core/build/src/objects/push_channel.js"), exports);
__exportStar(__webpack_require__(/*! ./query_user_group */ "./node_modules/@abaplint/core/build/src/objects/query_user_group.js"), exports);
__exportStar(__webpack_require__(/*! ./restriction_field */ "./node_modules/@abaplint/core/build/src/objects/restriction_field.js"), exports);
__exportStar(__webpack_require__(/*! ./restriction_type */ "./node_modules/@abaplint/core/build/src/objects/restriction_type.js"), exports);
__exportStar(__webpack_require__(/*! ./rfc_service */ "./node_modules/@abaplint/core/build/src/objects/rfc_service.js"), exports);
__exportStar(__webpack_require__(/*! ./sapscript_style */ "./node_modules/@abaplint/core/build/src/objects/sapscript_style.js"), exports);
__exportStar(__webpack_require__(/*! ./sapscript */ "./node_modules/@abaplint/core/build/src/objects/sapscript.js"), exports);
__exportStar(__webpack_require__(/*! ./screen_variant */ "./node_modules/@abaplint/core/build/src/objects/screen_variant.js"), exports);
__exportStar(__webpack_require__(/*! ./search_help */ "./node_modules/@abaplint/core/build/src/objects/search_help.js"), exports);
__exportStar(__webpack_require__(/*! ./service_binding */ "./node_modules/@abaplint/core/build/src/objects/service_binding.js"), exports);
__exportStar(__webpack_require__(/*! ./service_definition */ "./node_modules/@abaplint/core/build/src/objects/service_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./shared_memory */ "./node_modules/@abaplint/core/build/src/objects/shared_memory.js"), exports);
__exportStar(__webpack_require__(/*! ./smart_form */ "./node_modules/@abaplint/core/build/src/objects/smart_form.js"), exports);
__exportStar(__webpack_require__(/*! ./smart_style */ "./node_modules/@abaplint/core/build/src/objects/smart_style.js"), exports);
__exportStar(__webpack_require__(/*! ./standard_task */ "./node_modules/@abaplint/core/build/src/objects/standard_task.js"), exports);
__exportStar(__webpack_require__(/*! ./switch_assignment_hierarchy */ "./node_modules/@abaplint/core/build/src/objects/switch_assignment_hierarchy.js"), exports);
__exportStar(__webpack_require__(/*! ./switch_assignments */ "./node_modules/@abaplint/core/build/src/objects/switch_assignments.js"), exports);
__exportStar(__webpack_require__(/*! ./table_type */ "./node_modules/@abaplint/core/build/src/objects/table_type.js"), exports);
__exportStar(__webpack_require__(/*! ./table */ "./node_modules/@abaplint/core/build/src/objects/table.js"), exports);
__exportStar(__webpack_require__(/*! ./technical_job_definition */ "./node_modules/@abaplint/core/build/src/objects/technical_job_definition.js"), exports);
__exportStar(__webpack_require__(/*! ./transaction_variant */ "./node_modules/@abaplint/core/build/src/objects/transaction_variant.js"), exports);
__exportStar(__webpack_require__(/*! ./transaction */ "./node_modules/@abaplint/core/build/src/objects/transaction.js"), exports);
__exportStar(__webpack_require__(/*! ./transformation */ "./node_modules/@abaplint/core/build/src/objects/transformation.js"), exports);
__exportStar(__webpack_require__(/*! ./type_pool */ "./node_modules/@abaplint/core/build/src/objects/type_pool.js"), exports);
__exportStar(__webpack_require__(/*! ./view_cluster */ "./node_modules/@abaplint/core/build/src/objects/view_cluster.js"), exports);
__exportStar(__webpack_require__(/*! ./view */ "./node_modules/@abaplint/core/build/src/objects/view.js"), exports);
__exportStar(__webpack_require__(/*! ./virtual_end_point */ "./node_modules/@abaplint/core/build/src/objects/virtual_end_point.js"), exports);
__exportStar(__webpack_require__(/*! ./web_dynpro_application_configuration */ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_application_configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./web_dynpro_application */ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_application.js"), exports);
__exportStar(__webpack_require__(/*! ./web_dynpro_component_configuration */ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_component_configuration.js"), exports);
__exportStar(__webpack_require__(/*! ./web_dynpro_component */ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_component.js"), exports);
__exportStar(__webpack_require__(/*! ./web_mime */ "./node_modules/@abaplint/core/build/src/objects/web_mime.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/info_object.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/info_object.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InfoObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class InfoObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "IOBJ";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.InfoObject = InfoObject;
//# sourceMappingURL=info_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/interface.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/interface.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Interface = void 0;
const _abap_object_1 = __webpack_require__(/*! ./_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class Interface extends _abap_object_1.ABAPObject {
    constructor() {
        super(...arguments);
        this.def = undefined;
        this.parsedXML = undefined;
    }
    getType() {
        return "INTF";
    }
    setDefinition(def) {
        this.def = def;
    }
    getSequencedFiles() {
        const main = this.getMainABAPFile();
        if (main === undefined) {
            return [];
        }
        return [main];
    }
    getDefinition() {
        return this.def;
    }
    getInterface() {
        var _a;
        return (_a = this.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getInfo().getInterfaceDefinitionByName(this.getName());
    }
    getIdentifier() {
        var _a;
        return (_a = this.getInterface()) === null || _a === void 0 ? void 0 : _a.identifier;
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.def = undefined;
        this.parsedXML = undefined;
        super.setDirty();
    }
    getNameFromXML() {
        var _a;
        this.parseXML();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.name;
    }
    getDescription() {
        var _a;
        this.parseXML();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    /////////////////////////
    parseXML() {
        if (this.parsedXML !== undefined) {
            return;
        }
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return;
        }
        const vseo = parsed.abapGit["asx:abap"]["asx:values"].VSEOINTERF;
        if (vseo === undefined) {
            this.parsedXML.description = "";
            this.parsedXML.name = "";
        }
        else {
            this.parsedXML.description = vseo.DESCRIPT ? vseo.DESCRIPT : "";
            this.parsedXML.name = vseo.CLSNAME ? vseo.CLSNAME : "";
        }
    }
}
exports.Interface = Interface;
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/lock_object.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/lock_object.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LockObject = void 0;
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class LockObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "ENQU";
    }
    getAllowedNaming() {
        return {
            maxLength: 16,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getPrimaryTable() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.primaryTable;
    }
    parseType(reg) {
        var _a;
        this.parse();
        const references = [];
        const ddic = new ddic_1.DDIC(reg);
        if ((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.primaryTable) {
            const found = ddic.lookupTableOrView2(this.parsedXML.primaryTable);
            if (found) {
                references.push({ object: found });
                reg.getDDICReferences().setUsing(this, references);
                return found.parseType(reg);
            }
            else if (ddic.inErrorNamespace(this.parsedXML.primaryTable)) {
                return new basic_1.UnknownType(this.parsedXML.primaryTable + " not found");
            }
            else {
                return new basic_1.VoidType(this.parsedXML.primaryTable);
            }
        }
        else {
            return new basic_1.UnknownType("Parsing error");
        }
    }
    parse() {
        var _a, _b;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.primaryTable = (_a = parsed.abapGit["asx:abap"]["asx:values"].DD25V) === null || _a === void 0 ? void 0 : _a.ROOTTAB;
        this.parsedXML.description = (_b = parsed.abapGit["asx:abap"]["asx:values"].DD25V) === null || _b === void 0 ? void 0 : _b.DDTEXT;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
}
exports.LockObject = LockObject;
//# sourceMappingURL=lock_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/maintenance_and_transport_object.js":
/*!*******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/maintenance_and_transport_object.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaintenanceAndTransportObject = void 0;
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class MaintenanceAndTransportObject extends _abstract_object_1.AbstractObject {
    setDirty() {
        super.setDirty();
        this.parsedXML = undefined;
    }
    getType() {
        return "TOBJ";
    }
    getDescription() {
        // todo
        return undefined;
    }
    getAllowedNaming() {
        return {
            maxLength: 31,
            allowNamespace: true,
        };
    }
    getArea() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.area;
    }
    getObjectName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.objectName;
    }
    getObjectType() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.objectType;
    }
    parseType(reg) {
        var _a, _b, _c;
        this.parse();
        const references = [];
        const ddic = new ddic_1.DDIC(reg);
        if (((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.objectName) && this.parsedXML.objectType === "S") {
            const found = ddic.lookupTableOrView2(this.parsedXML.objectName);
            if (found) {
                references.push({ object: found });
                reg.getDDICReferences().setUsing(this, references);
                return found.parseType(reg);
            }
            else if (ddic.inErrorNamespace(this.parsedXML.objectName)) {
                return new basic_1.UnknownType(this.parsedXML.objectName + " not found");
            }
            else {
                return new basic_1.VoidType(this.parsedXML.objectName);
            }
        }
        else if (((_b = this.parsedXML) === null || _b === void 0 ? void 0 : _b.objectType) !== "S" && ((_c = this.parsedXML) === null || _c === void 0 ? void 0 : _c.objectName)) {
            return new basic_1.VoidType(this.parsedXML.objectName);
        }
        else {
            return new basic_1.UnknownType("Parsing error");
        }
    }
    parse() {
        var _a, _b, _c, _d;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.area = (_b = (_a = parsed.abapGit["asx:abap"]["asx:values"].TOBJ) === null || _a === void 0 ? void 0 : _a.TVDIR) === null || _b === void 0 ? void 0 : _b.AREA;
        this.parsedXML.objectName = (_c = parsed.abapGit["asx:abap"]["asx:values"].OBJH) === null || _c === void 0 ? void 0 : _c.OBJECTNAME;
        this.parsedXML.objectType = (_d = parsed.abapGit["asx:abap"]["asx:values"].OBJH) === null || _d === void 0 ? void 0 : _d.OBJECTTYPE;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.MaintenanceAndTransportObject = MaintenanceAndTransportObject;
//# sourceMappingURL=maintenance_and_transport_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/message_class.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/message_class.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageClass = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const message_1 = __webpack_require__(/*! ../abap/types/message */ "./node_modules/@abaplint/core/build/src/abap/types/message.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class MessageClass extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parsedMessages = undefined;
    }
    getType() {
        return "MSAG";
    }
    getDescription() {
        this.parseXML();
        // todo
        return undefined;
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedMessages = undefined;
        super.setDirty();
    }
    getMessages() {
        this.parseXML();
        const msg = this.parsedMessages;
        return msg ? msg : [];
    }
    getByNumber(num) {
        this.parseXML();
        // todo, optimize performance,
        for (const message of this.getMessages()) {
            if (message.getNumber() === num) {
                return message;
            }
        }
        return undefined;
    }
    /////////////////////////////////
    parseXML() {
        var _a, _b;
        if (this.parsedMessages !== undefined) {
            return;
        }
        this.parsedMessages = [];
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return;
        }
        const t100 = (_b = (_a = parsed === null || parsed === void 0 ? void 0 : parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]["asx:values"]) === null || _b === void 0 ? void 0 : _b.T100;
        if (t100 === undefined) {
            return;
        }
        for (const msg of (0, xml_utils_1.xmlToArray)(t100.T100)) {
            this.parsedMessages.push(new message_1.Message(msg.MSGNR, (0, xml_utils_1.unescape)(msg.TEXT)));
        }
    }
}
exports.MessageClass = MessageClass;
//# sourceMappingURL=message_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/messaging_channel.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/messaging_channel.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessagingChannel = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class MessagingChannel extends _abstract_object_1.AbstractObject {
    getType() {
        return "SAMC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.MessagingChannel = MessagingChannel;
//# sourceMappingURL=messaging_channel.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/mime_object.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/mime_object.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MIMEObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class MIMEObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "SMIM";
    }
    getURL() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.URL;
    }
    getClass() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.CLASS;
    }
    isFolder() {
        var _a;
        return ((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.FOLDER) === "X";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: false,
        };
    }
    getDataFile() {
        const main = this.getXMLFile();
        for (const f of this.getFiles()) {
            if (f.getFilename() !== (main === null || main === void 0 ? void 0 : main.getFilename())) {
                return f;
            }
        }
        return undefined;
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDescription() {
        // this object type does not have a description
        return undefined;
    }
    parse() {
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.URL = parsed.abapGit["asx:abap"]["asx:values"].URL;
        this.parsedXML.CLASS = parsed.abapGit["asx:abap"]["asx:values"].CLASS;
        this.parsedXML.FOLDER = parsed.abapGit["asx:abap"]["asx:values"].FOLDER;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.MIMEObject = MIMEObject;
//# sourceMappingURL=mime_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/namespace.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/namespace.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Namespace = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Namespace extends _abstract_object_1.AbstractObject {
    getType() {
        return "NSPC";
    }
    getAllowedNaming() {
        return {
            maxLength: 10,
            allowNamespace: true,
            customRegex: new RegExp(/^\/[A-Z_\d]{3,8}\/$/i),
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Namespace = Namespace;
//# sourceMappingURL=namespace.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_api.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_api.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneAPI = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneAPI extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN02";
    }
    getAllowedNaming() {
        return {
            maxLength: 100,
            allowNamespace: true,
            customRegex: /.*/i,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneAPI = NeptuneAPI;
//# sourceMappingURL=neptune_api.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_app.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_app.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneApp = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneApp extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN01";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneApp = NeptuneApp;
//# sourceMappingURL=neptune_app.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_custom_color.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_custom_color.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneCustomColor = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneCustomColor extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN13";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneCustomColor = NeptuneCustomColor;
//# sourceMappingURL=neptune_custom_color.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_custom_js_helper.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_custom_js_helper.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneCustomJSHelper = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneCustomJSHelper extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN15";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneCustomJSHelper = NeptuneCustomJSHelper;
//# sourceMappingURL=neptune_custom_js_helper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_documentation.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_documentation.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneDocumentation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneDocumentation extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN16";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneDocumentation = NeptuneDocumentation;
//# sourceMappingURL=neptune_documentation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_enhancement.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_enhancement.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneEnhancement = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneEnhancement extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN09";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneEnhancement = NeptuneEnhancement;
//# sourceMappingURL=neptune_enhancement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_launchpad.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_launchpad.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneLaunchpad = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneLaunchpad extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN03";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneLaunchpad = NeptuneLaunchpad;
//# sourceMappingURL=neptune_launchpad.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_launchpad_layout.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_launchpad_layout.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneLaunchpadLayout = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneLaunchpadLayout extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN07";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneLaunchpadLayout = NeptuneLaunchpadLayout;
//# sourceMappingURL=neptune_launchpad_layout.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_login_page.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_login_page.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneLoginPage = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneLoginPage extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN10";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneLoginPage = NeptuneLoginPage;
//# sourceMappingURL=neptune_login_page.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_media_library.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_media_library.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneMediaLibrary = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneMediaLibrary extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN18";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneMediaLibrary = NeptuneMediaLibrary;
//# sourceMappingURL=neptune_media_library.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_media_pack.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_media_pack.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneMediaPack = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneMediaPack extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN19";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneMediaPack = NeptuneMediaPack;
//# sourceMappingURL=neptune_media_pack.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_metadata.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_metadata.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneMetadata = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneMetadata extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN00";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneMetadata = NeptuneMetadata;
//# sourceMappingURL=neptune_metadata.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_mobile_client.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_mobile_client.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneMobileClient = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneMobileClient extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN22";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneMobileClient = NeptuneMobileClient;
//# sourceMappingURL=neptune_mobile_client.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_odata.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_odata.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneOData = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneOData extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN21";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneOData = NeptuneOData;
//# sourceMappingURL=neptune_odata.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_policy.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_policy.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptunePolicy = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptunePolicy extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN06";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptunePolicy = NeptunePolicy;
//# sourceMappingURL=neptune_policy.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_rfc_mapping.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_rfc_mapping.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneRFCMapping = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneRFCMapping extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN17";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneRFCMapping = NeptuneRFCMapping;
//# sourceMappingURL=neptune_rfc_mapping.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_rich_text_template.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_rich_text_template.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneRichTextTemplate = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneRichTextTemplate extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN14";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneRichTextTemplate = NeptuneRichTextTemplate;
//# sourceMappingURL=neptune_rich_text_template.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_splash_screen.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_splash_screen.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneSplashScreen = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneSplashScreen extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN12";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneSplashScreen = NeptuneSplashScreen;
//# sourceMappingURL=neptune_splash_screen.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_sticky_banner.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_sticky_banner.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneStickyBanner = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneStickyBanner extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN11";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneStickyBanner = NeptuneStickyBanner;
//# sourceMappingURL=neptune_sticky_banner.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_tile.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_tile.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneTile = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneTile extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN05";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneTile = NeptuneTile;
//# sourceMappingURL=neptune_tile.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_tile_group.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_tile_group.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneTileGroup = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneTileGroup extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN04";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneTileGroup = NeptuneTileGroup;
//# sourceMappingURL=neptune_tile_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_tile_layout.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_tile_layout.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneTileLayout = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneTileLayout extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN08";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneTileLayout = NeptuneTileLayout;
//# sourceMappingURL=neptune_tile_layout.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/neptune_url_alias.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/neptune_url_alias.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NeptuneURLAlias = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NeptuneURLAlias extends _abstract_object_1.AbstractObject {
    getType() {
        return "ZN20";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.NeptuneURLAlias = NeptuneURLAlias;
//# sourceMappingURL=neptune_url_alias.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/number_range.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/number_range.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NumberRange = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class NumberRange extends _abstract_object_1.AbstractObject {
    getType() {
        return "NROB";
    }
    getAllowedNaming() {
        return {
            maxLength: 10,
            allowNamespace: true,
        };
    }
    getDomain() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.domain;
    }
    getPercentage() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.percentage;
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    parse() {
        var _a, _b, _c, _d, _e, _f;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return { updated: false, runtime: 0 };
        }
        const text = (_c = (_b = (_a = parsed.abapGit) === null || _a === void 0 ? void 0 : _a["asx:abap"]) === null || _b === void 0 ? void 0 : _b["asx:values"]) === null || _c === void 0 ? void 0 : _c.TEXT;
        this.parsedXML.description = text === null || text === void 0 ? void 0 : text.TXT;
        const attributes = (_f = (_e = (_d = parsed.abapGit) === null || _d === void 0 ? void 0 : _d["asx:abap"]) === null || _e === void 0 ? void 0 : _e["asx:values"]) === null || _f === void 0 ? void 0 : _f.ATTRIBUTES;
        this.parsedXML.domain = attributes === null || attributes === void 0 ? void 0 : attributes.DOMLEN;
        this.parsedXML.percentage = parseFloat((attributes === null || attributes === void 0 ? void 0 : attributes.PERCENTAGE) || "");
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
}
exports.NumberRange = NumberRange;
//# sourceMappingURL=number_range.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/oauth2_profile.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/oauth2_profile.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Oauth2Profile = void 0;
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Oauth2Profile extends _abstract_object_1.AbstractObject {
    getType() {
        return "OA2P";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
    listScopes() {
        var _a, _b, _c;
        const ret = [];
        const parsed = super.parseRaw2();
        for (const t of (0, xml_utils_1.xmlToArray)((_c = (_b = (_a = parsed.abapGit["asx:abap"]["asx:values"]) === null || _a === void 0 ? void 0 : _a.PROFILE) === null || _b === void 0 ? void 0 : _b.T_SCOPES) === null || _c === void 0 ? void 0 : _c.OA2P_SCOPES)) {
            ret.push(t.SCOPE);
        }
        return ret;
    }
}
exports.Oauth2Profile = Oauth2Profile;
//# sourceMappingURL=oauth2_profile.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/object_characteristic.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/object_characteristic.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectCharacteristic = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ObjectCharacteristic extends _abstract_object_1.AbstractObject {
    getType() {
        return "CHAR";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ObjectCharacteristic = ObjectCharacteristic;
//# sourceMappingURL=object_characteristic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/outbound_service.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/outbound_service.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OutboundService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class OutboundService extends _abstract_object_1.AbstractObject {
    getType() {
        return "SCO3";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.OutboundService = OutboundService;
//# sourceMappingURL=outbound_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/package.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/package.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Package = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Package extends _abstract_object_1.AbstractObject {
    getType() {
        return "DEVC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Package = Package;
//# sourceMappingURL=package.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/package_interface.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/package_interface.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PackageInterface = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class PackageInterface extends _abstract_object_1.AbstractObject {
    getType() {
        return "PINF";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.PackageInterface = PackageInterface;
//# sourceMappingURL=package_interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/parameter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/parameter.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parameter = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Parameter extends _abstract_object_1.AbstractObject {
    getType() {
        return "PARA";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Parameter = Parameter;
//# sourceMappingURL=parameter.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/personalization_object.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/personalization_object.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PersonalizationObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class PersonalizationObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "PERS";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.PersonalizationObject = PersonalizationObject;
//# sourceMappingURL=personalization_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/program.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/program.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Program = void 0;
const _abap_object_1 = __webpack_require__(/*! ./_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _dynpros_1 = __webpack_require__(/*! ./_dynpros */ "./node_modules/@abaplint/core/build/src/objects/_dynpros.js");
class Program extends _abap_object_1.ABAPObject {
    getType() {
        return "PROG";
    }
    getSequencedFiles() {
        const main = this.getMainABAPFile();
        if (main === undefined) {
            return [];
        }
        return [main];
    }
    getDescription() {
        // todo
        return undefined;
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    isInclude() {
        this.parseXML();
        return this.parsedXML.isInclude;
    }
    isModulePool() {
        this.parseXML();
        return this.parsedXML.isModulePool;
    }
    getDynpros() {
        this.parseXML();
        return this.parsedXML.dynpros || [];
    }
    ////////////////////////////
    parseXML() {
        if (this.parsedXML !== undefined) {
            return;
        }
        const file = this.getXMLFile();
        const parsed = this.parseRaw2();
        if (parsed === undefined) {
            this.parsedXML = {
                isInclude: false,
                isModulePool: false,
                dynpros: [],
            };
            return;
        }
        const dynpros = (0, _dynpros_1.parseDynpros)(parsed);
        this.parsedXML = {
            isInclude: file ? file.getRaw().includes("<SUBC>I</SUBC>") : false,
            isModulePool: file ? file.getRaw().includes("<SUBC>M</SUBC>") : false,
            dynpros: dynpros,
        };
    }
}
exports.Program = Program;
//# sourceMappingURL=program.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/proxy_object.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/proxy_object.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ProxyObject = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ProxyObject extends _abstract_object_1.AbstractObject {
    getType() {
        return "SPRX";
    }
    getAllowedNaming() {
        return {
            maxLength: 34,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ProxyObject = ProxyObject;
//# sourceMappingURL=proxy_object.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/push_channel.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/push_channel.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushChannel = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class PushChannel extends _abstract_object_1.AbstractObject {
    getType() {
        return "SAPC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.PushChannel = PushChannel;
//# sourceMappingURL=push_channel.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/query_user_group.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/query_user_group.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.QueryUserGroup = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class QueryUserGroup extends _abstract_object_1.AbstractObject {
    getType() {
        return "AQBG";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.QueryUserGroup = QueryUserGroup;
//# sourceMappingURL=query_user_group.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_data_element.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_data_element.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameDataElement = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameDataElement {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.DataElement)) {
            throw new Error("RenameDataElement, not a data element");
        }
        let changes = [];
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "ROLLNAME", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICCodeReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTABLReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTTYPReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICAUTHReferences(obj, oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameDataElement = RenameDataElement;
//# sourceMappingURL=rename_data_element.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_domain.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_domain.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameDomain = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameDomain {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.Domain)) {
            throw new Error("RenameDomain, not a domain");
        }
        let changes = [];
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "DOMNAME", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICDTELReferences(obj, oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameDomain = RenameDomain;
//# sourceMappingURL=rename_domain.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_global_class.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_global_class.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameGlobalClass = void 0;
const Statements = __webpack_require__(/*! ../../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _lsp_utils_1 = __webpack_require__(/*! ../../lsp/_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameGlobalClass {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.Class)) {
            throw new Error("not a class");
        }
        const main = obj.getMainABAPFile();
        if (main === undefined) {
            throw new Error(`Main file not found, ${obj.getType()} ${obj.getName()}`);
        }
        let changes = [];
        // todo, this is actually the same as "id" ?
        {
            const edits = [];
            for (const s of main.getStatements()) {
                if (s.get() instanceof Statements.ClassDefinition) {
                    const exp = s.findFirstExpression(Expressions.ClassName);
                    if (exp === undefined) {
                        continue;
                    }
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(_lsp_utils_1.LSPUtils.tokenToRange(exp.getFirstToken()), newName.toLowerCase()));
                }
                else if (s.get() instanceof Statements.ClassImplementation) {
                    const exp = s.findFirstExpression(Expressions.ClassName);
                    if (exp === undefined) {
                        continue;
                    }
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(_lsp_utils_1.LSPUtils.tokenToRange(exp.getFirstToken()), newName.toLowerCase()));
                }
            }
            changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: main.getFilename(), version: 1 }, edits));
        }
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "CLSNAME", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameReferences(obj.getIdentifier(), oldName, newName));
        changes = changes.concat(helper.renameDDICTABLReferences(obj, oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameGlobalClass = RenameGlobalClass;
//# sourceMappingURL=rename_global_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_global_interface.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_global_interface.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameGlobalInterface = void 0;
const Statements = __webpack_require__(/*! ../../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const _lsp_utils_1 = __webpack_require__(/*! ../../lsp/_lsp_utils */ "./node_modules/@abaplint/core/build/src/lsp/_lsp_utils.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
const interface_1 = __webpack_require__(/*! ../interface */ "./node_modules/@abaplint/core/build/src/objects/interface.js");
class RenameGlobalInterface {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof interface_1.Interface)) {
            throw new Error("not an interface");
        }
        const main = obj.getMainABAPFile();
        if (main === undefined) {
            throw new Error("Main file not found");
        }
        let changes = [];
        // todo, this is actually the same as "id" ?
        {
            const edits = [];
            for (const s of main.getStatements()) {
                if (s.get() instanceof Statements.Interface) {
                    const exp = s.findFirstExpression(Expressions.InterfaceName);
                    if (exp === undefined) {
                        continue;
                    }
                    edits.push(vscode_languageserver_types_1.TextEdit.replace(_lsp_utils_1.LSPUtils.tokenToRange(exp.getFirstToken()), newName.toLowerCase()));
                }
            }
            changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: main.getFilename(), version: 1 }, edits));
        }
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "CLSNAME", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameReferences(obj.getIdentifier(), oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameGlobalInterface = RenameGlobalInterface;
//# sourceMappingURL=rename_global_interface.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_message_class.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_message_class.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameMessageClass = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameMessageClass {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.MessageClass)) {
            throw new Error("RenameMessageClass, not a message class");
        }
        let changes = [];
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "ARBGB", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        for (const message of obj.getMessages()) {
            for (const ref of this.reg.getMSAGReferences().listByMessage(obj.getName(), message.getNumber())) {
                const file = this.reg.getFileByName(ref.filename);
                if (file === undefined) {
                    continue;
                }
                const rows = file.getRawRows();
                const i = ref.token.getRow() - 1;
                const index = rows[i].indexOf(oldName.toLowerCase());
                if (index >= 0) {
                    const range = vscode_languageserver_types_1.Range.create(i, index, i, index + oldName.length);
                    changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: file.getFilename(), version: 1 }, [vscode_languageserver_types_1.TextEdit.replace(range, newName.toLowerCase())]));
                }
            }
        }
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameMessageClass = RenameMessageClass;
//# sourceMappingURL=rename_message_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_table.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_table.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameTable = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameTable {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.Table)) {
            throw new Error("RenameTable, not a table");
        }
        let changes = [];
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "TABNAME", oldName, newName));
        changes = changes.concat(helper.buildXMLFileEdits(obj, "FORTABLE", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICCodeReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTABLReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTTYPReferences(obj, oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameTable = RenameTable;
//# sourceMappingURL=rename_table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/rename_table_type.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/rename_table_type.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenameTableType = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const renamer_helper_1 = __webpack_require__(/*! ./renamer_helper */ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js");
class RenameTableType {
    constructor(reg) {
        this.reg = reg;
    }
    buildEdits(obj, oldName, newName) {
        if (!(obj instanceof __1.TableType)) {
            throw new Error("RenameTableType, not a table type");
        }
        let changes = [];
        const helper = new renamer_helper_1.RenamerHelper(this.reg);
        changes = changes.concat(helper.buildXMLFileEdits(obj, "TYPENAME", oldName, newName));
        changes = changes.concat(helper.renameFiles(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICCodeReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTABLReferences(obj, oldName, newName));
        changes = changes.concat(helper.renameDDICTTYPReferences(obj, oldName, newName));
        return {
            documentChanges: changes,
        };
    }
}
exports.RenameTableType = RenameTableType;
//# sourceMappingURL=rename_table_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/renamer.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/renamer.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Renamer = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const memory_file_1 = __webpack_require__(/*! ../../files/memory_file */ "./node_modules/@abaplint/core/build/src/files/memory_file.js");
const rename_data_element_1 = __webpack_require__(/*! ./rename_data_element */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_data_element.js");
const rename_domain_1 = __webpack_require__(/*! ./rename_domain */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_domain.js");
const rename_global_class_1 = __webpack_require__(/*! ./rename_global_class */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_global_class.js");
const rename_global_interface_1 = __webpack_require__(/*! ./rename_global_interface */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_global_interface.js");
const rename_table_1 = __webpack_require__(/*! ./rename_table */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_table.js");
const rename_table_type_1 = __webpack_require__(/*! ./rename_table_type */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_table_type.js");
const rename_message_class_1 = __webpack_require__(/*! ./rename_message_class */ "./node_modules/@abaplint/core/build/src/objects/rename/rename_message_class.js");
class Renamer {
    constructor(reg) {
        this.reg = reg;
    }
    /** Applies the renaming to the objects and files in the registry,
     *  after renaming the registry is not parsed */
    rename(type, oldName, newName) {
        const edits = this.buildEdits(type, oldName, newName);
        if (edits === undefined) {
            throw new Error("no changes could be determined");
        }
        else if (edits.changes) {
            throw new Error("only documentChanges expected");
        }
        const result = this.apply(edits);
        this.reg.findIssues(); // hmm, this builds the ddic references
        return result;
    }
    /** Builds edits, but does not apply to registry, used by LSP */
    buildEdits(type, oldName, newName) {
        this.reg.parse(); // the registry must be parsed to dermine references
        const obj = this.reg.getObject(type, oldName);
        if (obj === undefined) {
            throw new Error("rename, object not found");
        }
        else if (newName.length > obj.getAllowedNaming().maxLength) {
            // todo, also do not allow strange characters and spaces
            throw new Error("Name not allowed");
        }
        const r = this.factory(type);
        return r.buildEdits(obj, oldName.toUpperCase(), newName);
    }
    //////////////////
    factory(type) {
        switch (type) {
            case "CLAS":
                return new rename_global_class_1.RenameGlobalClass(this.reg);
            case "DTEL":
                return new rename_data_element_1.RenameDataElement(this.reg);
            case "DOMA":
                return new rename_domain_1.RenameDomain(this.reg);
            case "TABL":
                return new rename_table_1.RenameTable(this.reg);
            case "TTYP":
                return new rename_table_type_1.RenameTableType(this.reg);
            case "INTF":
                return new rename_global_interface_1.RenameGlobalInterface(this.reg);
            case "MSAG":
                return new rename_message_class_1.RenameMessageClass(this.reg);
            default:
                throw new Error("Renaming of " + type + " not yet supported");
        }
    }
    apply(edits) {
        const renames = [];
        const result = {
            addedFiles: new Set(),
            deletedFiles: new Set(),
            updatedFiles: new Set(),
        };
        // assumption: only renames or text changes, no deletes or creates
        for (const dc of edits.documentChanges || []) {
            if (vscode_languageserver_types_1.TextDocumentEdit.is(dc)) {
                this.applyEdit(dc);
                result.updatedFiles.add(dc.textDocument.uri);
            }
            else if (vscode_languageserver_types_1.RenameFile.is(dc)) {
                renames.push(dc);
            }
            else {
                throw new Error("unexpected documentChange type");
            }
        }
        for (const rename of renames) {
            result.updatedFiles.delete(rename.oldUri);
            result.deletedFiles.add(rename.oldUri);
            result.addedFiles.add(rename.newUri);
        }
        this.applyRenames(renames);
        return result;
    }
    applyEdit(dc) {
        const file = this.reg.getFileByName(dc.textDocument.uri);
        if (file === undefined) {
            throw new Error("file " + dc.textDocument.uri + " not found");
        }
        const rows = file.getRawRows();
        for (const e of dc.edits) {
            if (e.range.start.line !== e.range.end.line) {
                throw new Error("applyEdit, start and end line differ");
            }
            const before = rows[e.range.start.line];
            rows[e.range.start.line] = before.substring(0, e.range.start.character) +
                e.newText +
                before.substring(e.range.end.character);
        }
        const newFile = new memory_file_1.MemoryFile(dc.textDocument.uri, rows.join("\n"));
        this.reg.updateFile(newFile);
    }
    applyRenames(renames) {
        for (const r of renames) {
            const old = this.reg.getFileByName(r.oldUri);
            if (old === undefined) {
                throw new Error("applyRenames, old not found");
            }
            const newFile = new memory_file_1.MemoryFile(r.newUri, old.getRaw());
            this.reg.removeFile(old);
            this.reg.addFile(newFile);
        }
    }
}
exports.Renamer = Renamer;
//# sourceMappingURL=renamer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rename/renamer_helper.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RenamerHelper = void 0;
const vscode_languageserver_types_1 = __webpack_require__(/*! vscode-languageserver-types */ "./node_modules/vscode-languageserver-types/lib/umd/main.js");
const __1 = __webpack_require__(/*! ../.. */ "./node_modules/@abaplint/core/build/src/index.js");
const syntax_1 = __webpack_require__(/*! ../../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _scope_type_1 = __webpack_require__(/*! ../../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const virtual_position_1 = __webpack_require__(/*! ../../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const _abap_object_1 = __webpack_require__(/*! ../_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class RenamerHelper {
    constructor(reg) {
        this.reg = reg;
    }
    renameReferences(id, oldName, newName) {
        if (id === undefined) {
            throw new Error("renameReferences, no main identifier found");
        }
        let refs = [];
        for (const o of this.reg.getObjects()) {
            if (o instanceof _abap_object_1.ABAPObject) {
                if (this.reg.isDependency(o)) {
                    continue; // do not search in dependencies
                }
                refs = refs.concat(this.findReferences(new syntax_1.SyntaxLogic(this.reg, o).run().spaghetti.getTop(), id));
            }
        }
        // start with the last reference in the file first, if there are multiple refs per line
        return this.replaceRefs(refs, oldName, newName).reverse();
    }
    renameDDICCodeReferences(obj, oldName, newName) {
        const changes = [];
        const used = this.reg.getDDICReferences().listWhereUsed(obj);
        for (const u of used) {
            if (u.token === undefined || u.filename === undefined) {
                continue;
            }
            const range = vscode_languageserver_types_1.Range.create(u.token.getStart().getRow() - 1, u.token.getStart().getCol() - 1, u.token.getStart().getRow() - 1, u.token.getStart().getCol() - 1 + oldName.length);
            changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: u.filename, version: 1 }, [vscode_languageserver_types_1.TextEdit.replace(range, newName.toLowerCase())]));
        }
        return changes;
    }
    renameDDICTABLReferences(obj, oldName, newName) {
        const changes = [];
        const used = this.reg.getDDICReferences().listWhereUsed(obj);
        const handled = {};
        for (const u of used) {
            if (u.type !== "TABL" || handled[u.name.toUpperCase()] === true) {
                // a TABL might reference the object multiple times, but they are all fixes in one call to buildXMLFileEdits
                continue;
            }
            const tabl = this.reg.getObject(u.type, u.name);
            if (tabl === undefined) {
                continue;
            }
            changes.push(...this.buildXMLFileEdits(tabl, "ROLLNAME", oldName, newName));
            handled[u.name.toUpperCase()] = true;
        }
        return changes;
    }
    renameDDICDTELReferences(obj, oldName, newName) {
        const changes = [];
        const used = this.reg.getDDICReferences().listWhereUsed(obj);
        for (const u of used) {
            if (u.type !== "DTEL") {
                continue;
            }
            const tabl = this.reg.getObject(u.type, u.name);
            if (tabl === undefined) {
                continue;
            }
            changes.push(...this.buildXMLFileEdits(tabl, "DOMNAME", oldName, newName));
        }
        return changes;
    }
    renameDDICTTYPReferences(obj, oldName, newName) {
        const changes = [];
        const used = this.reg.getDDICReferences().listWhereUsed(obj);
        for (const u of used) {
            if (u.type !== "TTYP") {
                continue;
            }
            const tabl = this.reg.getObject(u.type, u.name);
            if (tabl === undefined) {
                continue;
            }
            changes.push(...this.buildXMLFileEdits(tabl, "ROWTYPE", oldName, newName));
        }
        return changes;
    }
    renameDDICAUTHReferences(obj, oldName, newName) {
        const changes = [];
        const used = this.reg.getDDICReferences().listWhereUsed(obj);
        for (const u of used) {
            if (u.type !== "AUTH") {
                continue;
            }
            const tabl = this.reg.getObject(u.type, u.name);
            if (tabl === undefined) {
                continue;
            }
            changes.push(...this.buildXMLFileEdits(tabl, "ROLLNAME", oldName, newName));
        }
        return changes;
    }
    buildXMLFileEdits(object, xmlTag, oldName, newName) {
        const changes = [];
        const xml = object.getXMLFile();
        if (xml === undefined) {
            return [];
        }
        const tag = xmlTag.toUpperCase();
        const search = "<" + tag + ">" + oldName.toUpperCase() + "</" + tag + ">";
        const length = tag.length + 2;
        const rows = xml.getRawRows();
        for (let i = 0; i < rows.length; i++) {
            const index = rows[i].indexOf(search);
            if (index >= 0) {
                const range = vscode_languageserver_types_1.Range.create(i, index + length, i, index + oldName.length + length);
                changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: xml.getFilename(), version: 1 }, [vscode_languageserver_types_1.TextEdit.replace(range, newName.toUpperCase())]));
            }
        }
        return changes;
    }
    renameFiles(obj, oldName, name) {
        const list = [];
        const newName = name.toLowerCase().replace(/\//g, "#");
        oldName = oldName.toLowerCase().replace(/\//g, "#");
        for (const f of obj.getFiles()) {
            // todo, this is not completely correct, ie. if the URI contains the same directory name as the object name
            const newFilename = f.getFilename().replace(oldName, newName);
            list.push(vscode_languageserver_types_1.RenameFile.create(f.getFilename(), newFilename));
        }
        return list;
    }
    ////////////////////////
    replaceRefs(refs, oldName, newName) {
        const changes = [];
        // "zif_abapgit_auth~is_allowed" is a single token so only replace the first part of a token
        for (const r of refs) {
            const range = vscode_languageserver_types_1.Range.create(r.getStart().getRow() - 1, r.getStart().getCol() - 1, r.getStart().getRow() - 1, r.getStart().getCol() - 1 + oldName.length);
            changes.push(vscode_languageserver_types_1.TextDocumentEdit.create({ uri: r.getFilename(), version: 1 }, [vscode_languageserver_types_1.TextEdit.replace(range, newName.toLowerCase())]));
        }
        return changes;
    }
    findReferences(node, identifier) {
        var _a;
        let ret = [];
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.BuiltIn) {
            for (const r of node.getData().references) {
                if (((_a = r.resolved) === null || _a === void 0 ? void 0 : _a.equals(identifier))
                    && r.referenceType !== __1.ReferenceType.InferredType
                    && !(r.position.getStart() instanceof virtual_position_1.VirtualPosition)) {
                    ret.push(r.position);
                }
            }
        }
        for (const c of node.getChildren()) {
            ret = ret.concat(this.findReferences(c, identifier));
        }
        return ret;
    }
}
exports.RenamerHelper = RenamerHelper;
//# sourceMappingURL=renamer_helper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/restriction_field.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/restriction_field.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestrictionField = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class RestrictionField extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA5";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.RestrictionField = RestrictionField;
//# sourceMappingURL=restriction_field.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/restriction_type.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/restriction_type.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RestrictionType = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class RestrictionType extends _abstract_object_1.AbstractObject {
    getType() {
        return "SIA2";
    }
    getAllowedNaming() {
        return {
            maxLength: 200,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.RestrictionType = RestrictionType;
//# sourceMappingURL=restriction_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/rfc_service.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/rfc_service.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RFCService = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class RFCService extends _abstract_object_1.AbstractObject {
    getType() {
        return "SRFC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.RFCService = RFCService;
//# sourceMappingURL=rfc_service.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/sapscript.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/sapscript.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SAPScript = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SAPScript extends _abstract_object_1.AbstractObject {
    getType() {
        return "FORM";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SAPScript = SAPScript;
//# sourceMappingURL=sapscript.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/sapscript_style.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/sapscript_style.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SAPScriptStyle = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SAPScriptStyle extends _abstract_object_1.AbstractObject {
    getType() {
        return "STYL";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SAPScriptStyle = SAPScriptStyle;
//# sourceMappingURL=sapscript_style.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/screen_variant.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/screen_variant.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ScreenVariant = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ScreenVariant extends _abstract_object_1.AbstractObject {
    getType() {
        return "SCVI";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ScreenVariant = ScreenVariant;
//# sourceMappingURL=screen_variant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/search_help.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/search_help.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SearchHelp = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SearchHelp extends _abstract_object_1.AbstractObject {
    getType() {
        return "SHLP";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SearchHelp = SearchHelp;
//# sourceMappingURL=search_help.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/service_binding.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/service_binding.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceBinding = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ServiceBinding extends _abstract_object_1.AbstractObject {
    getType() {
        return "SRVB";
    }
    getAllowedNaming() {
        return {
            maxLength: 26,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ServiceBinding = ServiceBinding;
//# sourceMappingURL=service_binding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/service_definition.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/service_definition.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ServiceDefinition = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ServiceDefinition extends _abstract_object_1.AbstractObject {
    getType() {
        return "SRVD";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ServiceDefinition = ServiceDefinition;
//# sourceMappingURL=service_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/shared_memory.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/shared_memory.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SharedMemory = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SharedMemory extends _abstract_object_1.AbstractObject {
    getType() {
        return "SHMA";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SharedMemory = SharedMemory;
//# sourceMappingURL=shared_memory.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/smart_form.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/smart_form.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmartForm = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SmartForm extends _abstract_object_1.AbstractObject {
    getType() {
        return "SSFO";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SmartForm = SmartForm;
//# sourceMappingURL=smart_form.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/smart_style.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/smart_style.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SmartStyle = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SmartStyle extends _abstract_object_1.AbstractObject {
    getType() {
        return "SSST";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SmartStyle = SmartStyle;
//# sourceMappingURL=smart_style.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/standard_task.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/standard_task.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StandardTask = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class StandardTask extends _abstract_object_1.AbstractObject {
    getType() {
        return "PDTS";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.StandardTask = StandardTask;
//# sourceMappingURL=standard_task.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/switch_assignment_hierarchy.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/switch_assignment_hierarchy.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwitchAssignmentHierarchy = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SwitchAssignmentHierarchy extends _abstract_object_1.AbstractObject {
    getType() {
        return "SHI8";
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SwitchAssignmentHierarchy = SwitchAssignmentHierarchy;
//# sourceMappingURL=switch_assignment_hierarchy.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/switch_assignments.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/switch_assignments.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SwitchAssignments = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class SwitchAssignments extends _abstract_object_1.AbstractObject {
    getType() {
        return "SFSW";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.SwitchAssignments = SwitchAssignments;
//# sourceMappingURL=switch_assignments.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/table.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/table.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Table = exports.TableCategory = exports.EnhancementCategory = void 0;
const Types = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
var EnhancementCategory;
(function (EnhancementCategory) {
    EnhancementCategory["NotClassified"] = "0";
    EnhancementCategory["CannotBeEhanced"] = "1";
    EnhancementCategory["Character"] = "2";
    EnhancementCategory["CharacterOrNumeric"] = "3";
    EnhancementCategory["Deep"] = "4";
})(EnhancementCategory || (exports.EnhancementCategory = EnhancementCategory = {}));
var TableCategory;
(function (TableCategory) {
    TableCategory["Transparent"] = "TRANSP";
    TableCategory["Structure"] = "INTTAB";
    TableCategory["Cluster"] = "CLUSTER";
    TableCategory["Pooled"] = "POOL";
    TableCategory["View"] = "VIEW";
    TableCategory["Append"] = "APPEND";
})(TableCategory || (exports.TableCategory = TableCategory = {}));
class Table extends _abstract_object_1.AbstractObject {
    getType() {
        return "TABL";
    }
    getDescription() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.description;
    }
    getAllowedNaming() {
        let length = 30;
        const regex = /^((\/[A-Z_\d]{3,8}\/)|[a-zA-Z0-9]{3})\w+$/;
        if (this.getTableCategory() === TableCategory.Transparent) {
            length = 16;
        }
        return {
            maxLength: length,
            allowNamespace: true,
            customRegex: regex,
        };
    }
    setDirty() {
        this.parsedData = undefined;
        super.setDirty();
    }
    listKeys(reg) {
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        if (this.parsedData === undefined) {
            return [];
        }
        const ret = [];
        for (const p of this.parsedData.fields) {
            if (p.KEYFLAG === "X" && p.FIELDNAME === ".INCLUDE") {
                const lookup = new ddic_1.DDIC(reg).lookupTableOrView(p.PRECFIELD).type;
                if (lookup instanceof Types.StructureType) {
                    for (const c of lookup.getComponents()) {
                        ret.push(c.name);
                    }
                }
            }
            else if (p.KEYFLAG === "X") {
                ret.push(p.FIELDNAME);
            }
        }
        return ret;
    }
    parseType(reg) {
        var _a, _b;
        if (this.parsedData === undefined) {
            this.parseXML();
            if (this.parsedData === undefined) {
                return new Types.UnknownType("Table, parser error");
            }
        }
        if (reg.getConfig().getVersion() === version_1.Version.Cloud
            && this.parsedData.dataClass === "USER3") {
            return new Types.UnknownType("Data class = USER3 not allowed in cloud");
        }
        const references = [];
        const components = [];
        const ddic = new ddic_1.DDIC(reg);
        for (const field of this.parsedData.fields) {
            const comptype = field.COMPTYPE ? field.COMPTYPE : "";
            if (comptype === "E") { // data element
                const lookup = ddic.lookupDataElement(field.ROLLNAME);
                components.push({ name: field.FIELDNAME, type: lookup.type });
                if (lookup.object) {
                    references.push({ object: lookup.object });
                }
            }
            else if (field.FIELDNAME === ".INCLUDE" || field.FIELDNAME === ".INCLU--AP") { // incude or append structure
                if (field.PRECFIELD === undefined) {
                    return new Types.UnknownType("Table, parser error, PRECFIELD undefined");
                }
                const lookup = ddic.lookupTableOrView(field.PRECFIELD);
                let found = lookup.type;
                if (lookup.object) {
                    references.push({ object: lookup.object });
                }
                if (found instanceof _typed_identifier_1.TypedIdentifier) {
                    found = found.getType();
                }
                if (found instanceof Types.StructureType) {
                    if (field.GROUPNAME !== undefined) {
                        components.push({ name: field.GROUPNAME, type: found });
                    }
                    for (const c of found.getComponents()) {
                        components.push({ name: c.name, type: c.type });
                    }
                }
                else if ((((_a = field.PRECFIELD) === null || _a === void 0 ? void 0 : _a.startsWith("CI_")) || ((_b = field.PRECFIELD) === null || _b === void 0 ? void 0 : _b.startsWith("SI_")))
                    && found instanceof Types.UnknownType) {
                    continue;
                }
                else if (found instanceof Types.UnknownType) {
                    return found;
                }
                else if (found instanceof Types.VoidType) {
                    // set the full structure to void
                    return found;
                }
                else {
                    components.push({ name: field.FIELDNAME, type: found });
                }
            }
            else if (comptype === "S" && field.FIELDNAME.startsWith(".INCLU-")) {
                const lookup = ddic.lookupTableOrView(field.PRECFIELD);
                if (lookup.object) {
                    references.push({ object: lookup.object });
                }
                const found = lookup.type;
                if (found instanceof Types.VoidType) {
                    // set the full structure to void
                    return found;
                }
                else if (found instanceof Types.StructureType) {
                    const suffix = field.FIELDNAME.split("-")[1];
                    for (const c of found.getComponents()) {
                        components.push({ name: c.name + suffix, type: c.type });
                    }
                }
                else if (found instanceof Types.UnknownType) {
                    return found;
                }
            }
            else if (comptype === "S") {
                const lookup = ddic.lookupTableOrView(field.ROLLNAME);
                components.push({ name: field.FIELDNAME, type: lookup.type });
                if (lookup.object) {
                    references.push({ object: lookup.object });
                }
            }
            else if (comptype === "R") {
                if (field.ROLLNAME === undefined) {
                    throw new Error("Expected ROLLNAME");
                }
                if (field.ROLLNAME === "DATA") {
                    components.push({
                        name: field.FIELDNAME,
                        type: new basic_1.DataReference(new basic_1.AnyType())
                    });
                }
                else if (field.ROLLNAME === "OBJECT") {
                    components.push({
                        name: field.FIELDNAME,
                        type: new basic_1.GenericObjectReferenceType()
                    });
                }
                else if (field.REFTYPE === "S") {
                    const lookup = ddic.lookupTableOrView(field.ROLLNAME);
                    components.push({ name: field.FIELDNAME, type: new basic_1.DataReference(lookup.type) });
                    if (lookup.object) {
                        references.push({ object: lookup.object });
                    }
                }
                else if (field.REFTYPE === "L") {
                    const lookup = ddic.lookupTableType(field.ROLLNAME);
                    components.push({ name: field.FIELDNAME, type: new basic_1.DataReference(lookup.type) });
                    if (lookup.object) {
                        references.push({ object: lookup.object });
                    }
                }
                else if (field.REFTYPE === "E") {
                    const lookup = ddic.lookupDataElement(field.ROLLNAME);
                    components.push({ name: field.FIELDNAME, type: new basic_1.DataReference(lookup.type) });
                    if (lookup.object) {
                        references.push({ object: lookup.object });
                    }
                }
                else {
                    const lookup = ddic.lookupObject(field.ROLLNAME);
                    components.push({ name: field.FIELDNAME, type: lookup.type });
                    if (lookup.object) {
                        references.push({ object: lookup.object });
                    }
                }
            }
            else if (comptype === "L") {
                const lookup = ddic.lookupTableType(field.ROLLNAME);
                components.push({ name: field.FIELDNAME, type: lookup.type });
                if (lookup.object) {
                    references.push({ object: lookup.object });
                }
            }
            else if (comptype === "") { // built in
                const datatype = field.DATATYPE;
                if (datatype === undefined) {
                    throw new Error("Expected DATATYPE, while parsing TABL " + this.getName());
                }
                const length = field.LENG ? field.LENG : field.INTLEN;
                components.push({
                    name: field.FIELDNAME,
                    type: ddic.textToType({
                        text: datatype,
                        length: length,
                        decimals: field.DECIMALS,
                        infoText: this.getName() + "-" + field.FIELDNAME,
                        description: field.DDTEXT,
                    })
                });
            }
            else {
                components.push({
                    name: field.FIELDNAME,
                    type: new Types.UnknownType("Table " + this.getName() + ", unknown component type \"" + comptype + "\"")
                });
            }
            if (field.CHECKTABLE) {
                const lookup = ddic.lookupTableOrView2(field.CHECKTABLE);
                if (lookup) {
                    references.push({ object: lookup });
                }
            }
        }
        if (components.length === 0) {
            return new Types.UnknownType("Table/Structure " + this.getName() + " does not contain any components");
        }
        reg.getDDICReferences().setUsing(this, references);
        return new Types.StructureType(components, this.getName(), this.getName(), this.getDescription());
    }
    getTableCategory() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.tableCategory;
    }
    getEnhancementCategory() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        if (((_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.enhancementCategory) === undefined) {
            return EnhancementCategory.NotClassified;
        }
        return this.parsedData.enhancementCategory;
    }
    ///////////////
    parseXML() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        const parsed = super.parseRaw2();
        if (parsed === undefined) {
            return;
        }
        this.parsedData = { fields: [] };
        if (parsed.abapGit === undefined) {
            return;
        }
        // enhancement category
        if (((_b = (_a = parsed.abapGit["asx:abap"]["asx:values"]) === null || _a === void 0 ? void 0 : _a.DD02V) === null || _b === void 0 ? void 0 : _b.EXCLASS) === undefined) {
            this.parsedData.enhancementCategory = EnhancementCategory.NotClassified;
        }
        else {
            this.parsedData.enhancementCategory = (_d = (_c = parsed.abapGit["asx:abap"]["asx:values"]) === null || _c === void 0 ? void 0 : _c.DD02V) === null || _d === void 0 ? void 0 : _d.EXCLASS;
        }
        // table category
        this.parsedData.tableCategory = (_f = (_e = parsed.abapGit["asx:abap"]["asx:values"]) === null || _e === void 0 ? void 0 : _e.DD02V) === null || _f === void 0 ? void 0 : _f.TABCLASS;
        this.parsedData.description = (_h = (_g = parsed.abapGit["asx:abap"]["asx:values"]) === null || _g === void 0 ? void 0 : _g.DD02V) === null || _h === void 0 ? void 0 : _h.DDTEXT;
        this.parsedData.dataClass = (_k = (_j = parsed.abapGit["asx:abap"]["asx:values"]) === null || _j === void 0 ? void 0 : _j.DD09L) === null || _k === void 0 ? void 0 : _k.TABART;
        // fields
        const fields = (_l = parsed.abapGit["asx:abap"]["asx:values"]) === null || _l === void 0 ? void 0 : _l.DD03P_TABLE;
        for (const field of (0, xml_utils_1.xmlToArray)(fields === null || fields === void 0 ? void 0 : fields.DD03P)) {
            this.parsedData.fields.push({
                FIELDNAME: field.FIELDNAME,
                ROLLNAME: field.ROLLNAME,
                COMPTYPE: field.COMPTYPE,
                PRECFIELD: field.PRECFIELD,
                LENG: field.LENG,
                INTLEN: field.INTLEN,
                DATATYPE: field.DATATYPE,
                DECIMALS: field.DECIMALS,
                KEYFLAG: field.KEYFLAG,
                GROUPNAME: field.GROUPNAME,
                CHECKTABLE: field.CHECKTABLE,
                REFTYPE: field.REFTYPE,
                DDTEXT: field.DDTEXT,
            });
        }
    }
}
exports.Table = Table;
//# sourceMappingURL=table.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/table_type.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/table_type.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TableType = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const Types = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class TableType extends _abstract_object_1.AbstractObject {
    constructor() {
        super(...arguments);
        this.parsedXML = undefined;
    }
    getType() {
        return "TTYP";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        var _a;
        this.parseXML();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.ddtext;
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    buildPrimaryKey() {
        var _a, _b, _c, _d, _e;
        const primaryKey = {
            isUnique: ((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.keykind) === "U",
            type: basic_1.TableAccessType.standard,
            keyFields: [],
            name: "primary_key",
        };
        if (((_b = this.parsedXML) === null || _b === void 0 ? void 0 : _b.accessmode) === "S") {
            primaryKey.type = basic_1.TableAccessType.sorted;
        }
        else if (((_c = this.parsedXML) === null || _c === void 0 ? void 0 : _c.accessmode) === "H") {
            primaryKey.type = basic_1.TableAccessType.hashed;
        }
        for (const f of ((_d = this.parsedXML) === null || _d === void 0 ? void 0 : _d.dd42v) || []) {
            if (f.keyname === "") {
                primaryKey.keyFields.push(f.keyfield);
            }
        }
        if (((_e = this.parsedXML) === null || _e === void 0 ? void 0 : _e.keydef) === "T" && primaryKey.keyFields.length === 0) {
            primaryKey.keyFields.push("table_line");
        }
        return primaryKey;
    }
    buildTableOptions() {
        var _a, _b, _c, _d;
        let keyType = Types.TableKeyType.user;
        if (((_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.keydef) === "D") {
            keyType = Types.TableKeyType.default;
        }
        const tableOptions = {
            withHeader: false,
            keyType: keyType,
            primaryKey: this.buildPrimaryKey(),
            secondary: [],
        };
        for (const k of ((_b = this.parsedXML) === null || _b === void 0 ? void 0 : _b.dd43v) || []) {
            const fields = [];
            for (const f of ((_c = this.parsedXML) === null || _c === void 0 ? void 0 : _c.dd42v) || []) {
                if (f.keyname === k.keyname) {
                    fields.push(f.keyfield);
                }
            }
            let accessType = basic_1.TableAccessType.standard;
            switch (k.accessmode) {
                case "S":
                    accessType = basic_1.TableAccessType.sorted;
                    break;
                case "H":
                    accessType = basic_1.TableAccessType.hashed;
                    break;
                default:
                    break;
            }
            (_d = tableOptions.secondary) === null || _d === void 0 ? void 0 : _d.push({
                name: k.keyname,
                type: accessType,
                keyFields: fields,
                isUnique: k.unique,
            });
        }
        return tableOptions;
    }
    parseType(reg) {
        this.parseXML();
        const ddic = new ddic_1.DDIC(reg);
        const references = [];
        let type;
        const tableOptions = this.buildTableOptions();
        if (this.parsedXML === undefined) {
            type = new Types.UnknownType("Table Type, parser error", this.getName());
        }
        else if (this.parsedXML.rowkind === "S") {
            const lookup = ddic.lookupTableOrView(this.parsedXML.rowtype);
            type = new Types.TableType(lookup.type, tableOptions, this.getName(), this.getDescription());
            if (lookup.object) {
                references.push({ object: lookup.object });
            }
        }
        else if (this.parsedXML.rowkind === "E") {
            const lookup = ddic.lookupDataElement(this.parsedXML.rowtype);
            type = new Types.TableType(lookup.type, tableOptions, this.getName(), this.getDescription());
            if (lookup.object) {
                references.push({ object: lookup.object });
            }
        }
        else if (this.parsedXML.rowkind === "L") {
            const lookup = ddic.lookupTableType(this.parsedXML.rowtype);
            type = new Types.TableType(lookup.type, tableOptions, this.getName(), this.getDescription());
            if (lookup.object) {
                references.push({ object: lookup.object });
            }
        }
        else if (this.parsedXML.rowkind === "R" && this.parsedXML.rowtype === "OBJECT") {
            type = new Types.TableType(new basic_1.GenericObjectReferenceType(), tableOptions, this.getName(), this.getDescription());
        }
        else if (this.parsedXML.rowkind === "R" && this.parsedXML.rowtype === "DATA") {
            type = new Types.TableType(new basic_1.DataReference(new Types.DataType()), tableOptions, this.getName(), this.getDescription());
        }
        else if (this.parsedXML.rowkind === "R" && this.parsedXML.rowtype !== undefined) {
            const lookup = ddic.lookupObject(this.parsedXML.rowtype);
            type = new Types.TableType(lookup.type, tableOptions, this.getName(), this.getDescription());
            if (lookup.object) {
                references.push({ object: lookup.object });
            }
        }
        else if (this.parsedXML.rowkind === "") {
            if (this.parsedXML.datatype === undefined) {
                type = new Types.UnknownType("Table Type, empty DATATYPE" + this.getName(), this.getName());
            }
            else {
                const row = ddic.textToType({
                    text: this.parsedXML.datatype,
                    length: this.parsedXML.leng,
                    decimals: this.parsedXML.decimals,
                    infoText: this.getName(),
                });
                type = new Types.TableType(row, tableOptions, this.getName(), this.getDescription());
            }
        }
        else {
            type = new Types.UnknownType("Table Type, unknown kind \"" + this.parsedXML.rowkind + "\"" + this.getName(), this.getName());
        }
        reg.getDDICReferences().setUsing(this, references);
        return type;
    }
    ////////////////////
    parseXML() {
        var _a, _b;
        if (this.parsedXML !== undefined) {
            return;
        }
        this.parsedXML = {
            dd42v: [],
            dd43v: [],
        };
        const parsed = super.parseRaw2();
        if (parsed === undefined || parsed.abapGit === undefined) {
            return;
        }
        const values = parsed.abapGit["asx:abap"]["asx:values"];
        const dd40v = values.DD40V;
        this.parsedXML.rowtype = dd40v.ROWTYPE ? dd40v.ROWTYPE : "";
        this.parsedXML.rowkind = dd40v.ROWKIND ? dd40v.ROWKIND : "";
        this.parsedXML.datatype = dd40v.DATATYPE;
        this.parsedXML.leng = dd40v.LENG;
        this.parsedXML.decimals = dd40v.DECIMALS;
        this.parsedXML.accessmode = dd40v.ACCESSMODE;
        this.parsedXML.keykind = dd40v.KEYKIND;
        this.parsedXML.ddtext = dd40v.DDTEXT;
        this.parsedXML.keydef = dd40v.KEYDEF;
        for (const x of (0, xml_utils_1.xmlToArray)((_a = values.DD42V) === null || _a === void 0 ? void 0 : _a.DD42V)) {
            this.parsedXML.dd42v.push({
                keyname: x.SECKEYNAME || "",
                keyfield: x.KEYFIELD || "",
            });
        }
        for (const x of (0, xml_utils_1.xmlToArray)((_b = values.DD43V) === null || _b === void 0 ? void 0 : _b.DD43V)) {
            this.parsedXML.dd43v.push({
                keyname: x.SECKEYNAME || "",
                accessmode: x.ACCESSMODE || "",
                kind: x.KIND || "",
                unique: x.SECKEYUNIQUE === "X",
            });
        }
    }
}
exports.TableType = TableType;
//# sourceMappingURL=table_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/technical_job_definition.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/technical_job_definition.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TechnicalJobDefinition = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class TechnicalJobDefinition extends _abstract_object_1.AbstractObject {
    getType() {
        return "JOBD";
    }
    getAllowedNaming() {
        return {
            maxLength: 32,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.TechnicalJobDefinition = TechnicalJobDefinition;
//# sourceMappingURL=technical_job_definition.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/transaction.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/transaction.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transaction = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Transaction extends _abstract_object_1.AbstractObject {
    getType() {
        return "TRAN";
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getAllowedNaming() {
        return {
            maxLength: 20,
            allowNamespace: true,
        };
    }
    getProgramName() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.programName;
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    parse() {
        var _a, _b;
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.description = (_a = parsed.abapGit["asx:abap"]["asx:values"].TSTCT) === null || _a === void 0 ? void 0 : _a.TTEXT;
        this.parsedXML.programName = (_b = parsed.abapGit["asx:abap"]["asx:values"].TSTC) === null || _b === void 0 ? void 0 : _b.PGMNA;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.Transaction = Transaction;
//# sourceMappingURL=transaction.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/transaction_variant.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/transaction_variant.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TransactionVariant = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class TransactionVariant extends _abstract_object_1.AbstractObject {
    getType() {
        return "STVI";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.TransactionVariant = TransactionVariant;
//# sourceMappingURL=transaction_variant.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/transformation.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/transformation.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Transformation = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class Transformation extends _abstract_object_1.AbstractObject {
    getType() {
        return "XSLT";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.Transformation = Transformation;
//# sourceMappingURL=transformation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/type_pool.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/type_pool.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypePool = void 0;
const _abap_object_1 = __webpack_require__(/*! ./_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class TypePool extends _abap_object_1.ABAPObject {
    getType() {
        return "TYPE";
    }
    getSequencedFiles() {
        const main = this.getMainABAPFile();
        if (main === undefined) {
            return [];
        }
        return [main];
    }
    getAllowedNaming() {
        return {
            maxLength: 5,
            allowNamespace: false,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.TypePool = TypePool;
//# sourceMappingURL=type_pool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/view.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/view.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.View = void 0;
const Types = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
var ViewClass;
(function (ViewClass) {
    ViewClass["ExternalView"] = "X";
})(ViewClass || (ViewClass = {}));
class View extends _abstract_object_1.AbstractObject {
    getType() {
        return "VIEW";
    }
    getAllowedNaming() {
        return {
            maxLength: 16,
            allowNamespace: true,
        };
    }
    getFields() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.fields;
    }
    getJoin() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.join;
    }
    setDirty() {
        this.parsedData = undefined;
        super.setDirty();
    }
    parseType(reg) {
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        if (this.parsedData === undefined) {
            return new Types.UnknownType("View, parser error", this.getName());
        }
        const components = [];
        const references = [];
        const ddic = new ddic_1.DDIC(reg);
        for (const field of this.parsedData.fields) {
            if (field.VIEWFIELD === "*" || field.VIEWFIELD === "-") {
                // ignore, this is a special case of old style .INCLUDE
                continue;
            }
            else if (this.parsedData.header.VIEWCLASS === ViewClass.ExternalView) {
                components.push({
                    name: field.VIEWFIELD,
                    type: new Types.VoidType("ExternalView")
                });
                continue;
            }
            else if (field.TABNAME === this.getName()) {
                throw new Error("Unexpected self reference in view " + this.getName() + ", " + field.FIELDNAME + " " + field.FIELDNAME);
            }
            const lookup = ddic.lookupTableOrView(field.TABNAME);
            let found = lookup.type;
            if (lookup.object) {
                references.push({ object: lookup.object });
            }
            if (field.VIEWFIELD === ".APPEND") {
                // it is already expanded in the abapGit xml
                continue;
            }
            if (found instanceof Types.StructureType) {
                const s = found.getComponentByName(field.FIELDNAME);
                if (s === undefined) {
                    found = new Types.UnknownType(field.FIELDNAME + " not found in " + field.TABNAME + ", VIEW parse type");
                }
                else {
                    found = s;
                }
            }
            components.push({
                name: field.VIEWFIELD,
                type: found
            });
        }
        reg.getDDICReferences().setUsing(this, references);
        if (components.length === 0) {
            return new Types.UnknownType("View " + this.getName() + " does not contain any components");
        }
        return new Types.StructureType(components, this.getName());
    }
    listKeys() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        const ret = [];
        for (const p of ((_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.fields) || []) {
            if (p.KEYFLAG === "X") {
                ret.push(p.FIELDNAME);
            }
        }
        return ret;
    }
    getDescription() {
        var _a;
        if (this.parsedData === undefined) {
            this.parseXML();
        }
        return (_a = this.parsedData) === null || _a === void 0 ? void 0 : _a.header.DDTEXT;
    }
    ///////////////
    parseXML() {
        var _a, _b, _c;
        this.parsedData = {
            header: {
                VIEWCLASS: "",
                DDTEXT: "",
            },
            fields: [],
            join: [],
        };
        const parsed = super.parseRaw2();
        if (parsed === undefined || parsed.abapGit === undefined) {
            return;
        }
        const header = (_a = parsed.abapGit["asx:abap"]["asx:values"]) === null || _a === void 0 ? void 0 : _a.DD25V;
        this.parsedData.header = {
            VIEWCLASS: (header === null || header === void 0 ? void 0 : header.VIEWCLASS) || "",
            DDTEXT: (header === null || header === void 0 ? void 0 : header.DDTEXT) || "",
        };
        const fields = (_b = parsed.abapGit["asx:abap"]["asx:values"]) === null || _b === void 0 ? void 0 : _b.DD27P_TABLE;
        for (const field of (0, xml_utils_1.xmlToArray)(fields === null || fields === void 0 ? void 0 : fields.DD27P)) {
            this.parsedData.fields.push({
                VIEWFIELD: field.VIEWFIELD,
                TABNAME: field.TABNAME,
                FIELDNAME: field.FIELDNAME,
                KEYFLAG: field.KEYFLAG,
            });
        }
        const join = (_c = parsed.abapGit["asx:abap"]["asx:values"]) === null || _c === void 0 ? void 0 : _c.DD28J_TABLE;
        for (const j of (0, xml_utils_1.xmlToArray)(join === null || join === void 0 ? void 0 : join.DD28J)) {
            this.parsedData.join.push({
                LTAB: j.LTAB,
                LFIELD: j.LFIELD,
                OPERATOR: j.OPERATOR,
                RTAB: j.RTAB,
                RFIELD: j.RFIELD,
            });
        }
    }
}
exports.View = View;
//# sourceMappingURL=view.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/view_cluster.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/view_cluster.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ViewCluster = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class ViewCluster extends _abstract_object_1.AbstractObject {
    getType() {
        return "VCLS";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.ViewCluster = ViewCluster;
//# sourceMappingURL=view_cluster.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/virtual_end_point.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/virtual_end_point.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VirtualEndPoint = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class VirtualEndPoint extends _abstract_object_1.AbstractObject {
    getType() {
        return "WEBI";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.VirtualEndPoint = VirtualEndPoint;
//# sourceMappingURL=virtual_end_point.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_application.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/web_dynpro_application.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDynproApplication = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class WebDynproApplication extends _abstract_object_1.AbstractObject {
    getType() {
        return "WDYA";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.WebDynproApplication = WebDynproApplication;
//# sourceMappingURL=web_dynpro_application.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_application_configuration.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/web_dynpro_application_configuration.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDynproApplicationConfiguration = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class WebDynproApplicationConfiguration extends _abstract_object_1.AbstractObject {
    getType() {
        return "WDCA";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.WebDynproApplicationConfiguration = WebDynproApplicationConfiguration;
//# sourceMappingURL=web_dynpro_application_configuration.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_component.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/web_dynpro_component.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDynproComponent = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class WebDynproComponent extends _abstract_object_1.AbstractObject {
    getType() {
        return "WDYN";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.WebDynproComponent = WebDynproComponent;
//# sourceMappingURL=web_dynpro_component.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/web_dynpro_component_configuration.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/web_dynpro_component_configuration.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebDynproComponentConfiguration = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class WebDynproComponentConfiguration extends _abstract_object_1.AbstractObject {
    getType() {
        return "WDCC";
    }
    getAllowedNaming() {
        return {
            maxLength: 30,
            allowNamespace: true,
        };
    }
    getDescription() {
        // todo
        return undefined;
    }
}
exports.WebDynproComponentConfiguration = WebDynproComponentConfiguration;
//# sourceMappingURL=web_dynpro_component_configuration.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/objects/web_mime.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/objects/web_mime.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WebMIME = void 0;
const _abstract_object_1 = __webpack_require__(/*! ./_abstract_object */ "./node_modules/@abaplint/core/build/src/objects/_abstract_object.js");
class WebMIME extends _abstract_object_1.AbstractObject {
    getType() {
        return "W3MI";
    }
    getAllowedNaming() {
        return {
            maxLength: 40,
            allowNamespace: true,
            customRegex: new RegExp(/^[A-Z_-\d/<> ]+$/i),
        };
    }
    getDescription() {
        var _a;
        this.parse();
        return (_a = this.parsedXML) === null || _a === void 0 ? void 0 : _a.description;
    }
    setDirty() {
        this.parsedXML = undefined;
        super.setDirty();
    }
    getDataFile() {
        for (const f of this.getFiles()) {
            if (f.getFilename().includes(".data.")) {
                return f;
            }
        }
        return undefined;
    }
    parse() {
        if (this.parsedXML) {
            return { updated: false, runtime: 0 };
        }
        const start = Date.now();
        this.parsedXML = {};
        const parsed = super.parseRaw2();
        if (parsed === undefined
            || parsed.abapGit === undefined
            || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return { updated: false, runtime: 0 };
        }
        this.parsedXML.description = parsed.abapGit["asx:abap"]["asx:values"].TEXT;
        const end = Date.now();
        return { updated: true, runtime: end - start };
    }
}
exports.WebMIME = WebMIME;
//# sourceMappingURL=web_mime.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/position.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/position.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Position = void 0;
// first position is (1,1)
class Position {
    constructor(row, col) {
        this.row = row;
        this.col = col;
    }
    getCol() {
        return this.col;
    }
    getRow() {
        return this.row;
    }
    isAfter(p) {
        return this.row > p.row || (this.row === p.row && this.col >= p.col);
    }
    equals(p) {
        return this.row === p.getRow() && this.col === p.getCol();
    }
    isBefore(p) {
        return this.row < p.row || (this.row === p.row && this.col < p.col);
    }
    isBetween(p1, p2) {
        return this.isAfter(p1) && this.isBefore(p2);
    }
}
exports.Position = Position;
//# sourceMappingURL=position.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/pretty_printer/fix_keyword_case.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/pretty_printer/fix_keyword_case.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FixCase = void 0;
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const keyword_case_1 = __webpack_require__(/*! ../rules/keyword_case */ "./node_modules/@abaplint/core/build/src/rules/keyword_case.js");
const Tokens = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class FixCase {
    constructor(fileContents, config) {
        this.keywordCase = new keyword_case_1.KeywordCase();
        this.keywordCase.setConfig(config.readByRule(this.keywordCase.getMetadata().key));
        this.fileContents = fileContents;
        this.config = config;
    }
    execute(statement) {
        for (const child of statement.getChildren()) {
            if (child instanceof nodes_1.TokenNodeRegex) {
                const token = child.get();
                if (token instanceof Tokens.StringToken) {
                    continue;
                }
                this.replaceString(token.getStart(), this.formatNonKeyword(token.getStr()));
                continue;
            }
            else if (child instanceof nodes_1.TokenNode) {
                const token = child.get();
                const str = token.getStr();
                if (this.keywordCase.violatesRule(str) && token instanceof tokens_1.Identifier) {
                    this.replaceString(token.getStart(), this.formatKeyword(str));
                }
            }
            else if (child instanceof nodes_1.ExpressionNode) {
                this.execute(child);
            }
            else {
                throw new Error("pretty printer, traverse, unexpected node type");
            }
        }
        return this.fileContents;
    }
    formatNonKeyword(str) {
        return str.toLowerCase();
    }
    formatKeyword(keyword) {
        const ruleKey = this.keywordCase.getMetadata().key;
        const rule = this.config.readByRule(ruleKey);
        const style = rule ? rule["style"] : keyword_case_1.KeywordCaseStyle.Upper;
        return style === keyword_case_1.KeywordCaseStyle.Lower ? keyword.toLowerCase() : keyword.toUpperCase();
    }
    replaceString(pos, str) {
        const lines = this.fileContents.split("\n");
        const line = lines[pos.getRow() - 1];
        lines[pos.getRow() - 1] = line.substr(0, pos.getCol() - 1) + str + line.substr(pos.getCol() + str.length - 1);
        this.fileContents = lines.join("\n");
    }
}
exports.FixCase = FixCase;
//# sourceMappingURL=fix_keyword_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/pretty_printer/indent.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/pretty_printer/indent.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Indent = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
// todo, will break if there is multiple statements per line?
class Indent {
    constructor(options) {
        this.globalClasses = new Set();
        this.options = options || {};
    }
    execute(original, modified) {
        const statements = original.getStatements();
        const expected = this.getExpectedIndents(original);
        const lines = modified.split("\n");
        for (const statement of statements) {
            if (statement.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
                continue; // macro contents
            }
            const exp = expected.shift();
            if (exp === undefined || exp < 0) {
                continue;
            }
            const row = statement.getFirstToken().getStart().getRow() - 1;
            lines[row] = lines[row].trim();
            for (let i = 1; i < exp; i++) {
                lines[row] = " " + lines[row];
            }
        }
        return lines.join("\n");
    }
    // returns list of expected indentation for each line/statement?
    getExpectedIndents(file) {
        const ret = [];
        const init = 1;
        const stack = new Stack();
        let indent = init;
        let parentIsEvent = false;
        let previousStatement = undefined;
        for (const statement of file.getStatements()) {
            if (statement.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
                continue; // skip macro contents
            }
            const type = statement.get();
            if (type instanceof Statements.EndIf
                || type instanceof Statements.EndWhile
                || type instanceof Statements.EndModule
                || type instanceof Statements.EndSelect
                || type instanceof Statements.EndMethod
                || type instanceof Statements.EndAt
                || type instanceof Statements.Else
                || type instanceof Statements.EndExec
                || type instanceof Statements.EndOfDefinition
                || type instanceof Statements.EndLoop
                || type instanceof Statements.EndTestInjection
                || type instanceof Statements.EndTestSeam
                || type instanceof Statements.EndForm
                || type instanceof Statements.EndCatch
                || (this.options.selectionScreenBlockIndentation === true
                    && type instanceof Statements.SelectionScreen
                    && (statement.concatTokens().toUpperCase().includes("END OF SCREEN") ||
                        statement.concatTokens().toUpperCase().includes("END OF BLOCK") ||
                        statement.concatTokens().toUpperCase().includes("END OF LINE")))
                || type instanceof Statements.ElseIf
                || type instanceof Statements.EndFunction
                || type instanceof Statements.EndInterface
                || type instanceof Statements.EndDo) {
                indent = indent - 2;
            }
            else if (type instanceof Statements.StartOfSelection
                || type instanceof Statements.AtSelectionScreen
                || type instanceof Statements.AtLineSelection
                || type instanceof Statements.Initialization
                || type instanceof Statements.AtUserCommand
                || type instanceof Statements.TopOfPage
                || type instanceof Statements.Get
                || type instanceof Statements.EndOfSelection
                || type instanceof Statements.LoadOfProgram) {
                indent = init;
                parentIsEvent = true;
            }
            else if (type instanceof Statements.Form
                || (type instanceof Statements.Include && parentIsEvent)
                || type instanceof Statements.Module
                || type instanceof Statements.ClassImplementation
                || type instanceof Statements.ClassDefinition) {
                indent = init;
                parentIsEvent = false;
            }
            else if (type instanceof Statements.Cleanup
                || type instanceof Statements.Catch) {
                indent = stack.peek() - 2;
            }
            else if (type instanceof Statements.Public
                || type instanceof Statements.Protected
                || type instanceof Statements.Private
                || type instanceof Statements.WhenType
                || type instanceof Statements.WhenOthers
                || type instanceof Statements.When) {
                indent = stack.peek();
            }
            else if (type instanceof Statements.EndTry) {
                indent = stack.pop() - (this.options.alignTryCatch ? 2 : 4);
            }
            else if (type instanceof Statements.EndClass
                || type instanceof Statements.EndCase) {
                indent = stack.pop() - 2;
                indent = Math.max(indent, init); // maybe move this out of switch before ret.push(indent)
            }
            else if (type instanceof _statement_1.Comment
                || type instanceof Statements.IncludeType
                || type instanceof _statement_1.Empty
                || type instanceof _statement_1.MacroContent) {
                ret.push(-1);
                previousStatement = statement;
                continue;
            }
            if (previousStatement
                && !(previousStatement.get() instanceof _statement_1.Comment)
                && previousStatement.getLastToken().getEnd().getRow() === statement.getFirstToken().getStart().getRow()) {
                // any indentation allowed if there are multiple statements on the same line
                ret.push(-1);
                previousStatement = statement;
                continue;
            }
            ret.push(indent);
            if (type instanceof Statements.If
                || type instanceof Statements.While
                || type instanceof Statements.Module
                || type instanceof Statements.SelectLoop
                || type instanceof Statements.FunctionModule
                || type instanceof Statements.Interface
                || type instanceof Statements.Do
                || type instanceof Statements.At
                || type instanceof Statements.AtFirst
                || type instanceof Statements.AtLast
                || type instanceof Statements.ExecSQL
                || type instanceof Statements.Catch
                || type instanceof Statements.Define
                || type instanceof Statements.When
                || type instanceof Statements.WhenType
                || type instanceof Statements.WhenOthers
                || type instanceof Statements.Cleanup
                || type instanceof Statements.Loop
                || type instanceof Statements.LoopAtScreen
                || type instanceof Statements.CatchSystemExceptions
                || type instanceof Statements.Form
                || type instanceof Statements.Else
                || type instanceof Statements.ElseIf
                || type instanceof Statements.MethodImplementation
                || type instanceof Statements.TestInjection
                || type instanceof Statements.TestSeam
                || (this.options.selectionScreenBlockIndentation === true
                    && type instanceof Statements.SelectionScreen
                    && (statement.concatTokens().toUpperCase().includes("BEGIN OF SCREEN") ||
                        statement.concatTokens().toUpperCase().includes("BEGIN OF TABBED BLOCK") ||
                        statement.concatTokens().toUpperCase().includes("BEGIN OF BLOCK") ||
                        statement.concatTokens().toUpperCase().includes("BEGIN OF LINE")))
                || type instanceof Statements.StartOfSelection
                || type instanceof Statements.Get
                || type instanceof Statements.AtSelectionScreen
                || type instanceof Statements.AtLineSelection
                || type instanceof Statements.LoadOfProgram
                || type instanceof Statements.Initialization
                || type instanceof Statements.AtUserCommand
                || type instanceof Statements.TopOfPage
                || type instanceof Statements.EndOfSelection
                || type instanceof Statements.Public
                || type instanceof Statements.Protected
                || type instanceof Statements.Private) {
                indent = indent + 2;
            }
            else if (type instanceof Statements.Try) {
                indent = indent + (this.options.alignTryCatch ? 2 : 4);
                stack.push(indent);
            }
            else if (type instanceof Statements.ClassDefinition
                || type instanceof Statements.Case
                || type instanceof Statements.CaseType
                || type instanceof Statements.ClassImplementation) {
                indent = indent + (this.skipIndentForGlobalClass(statement) ? 0 : 2);
                stack.push(indent);
            }
            previousStatement = statement;
        }
        return ret;
    }
    skipIndentForGlobalClass(statement) {
        if (!this.options.globalClassSkipFirst) {
            return false;
        }
        const type = statement.get();
        if (type instanceof Statements.ClassDefinition && statement.findFirstExpression(Expressions.ClassGlobal)) {
            const className = statement.findFirstExpression(Expressions.ClassName);
            if (className) {
                this.globalClasses.add(className.getFirstToken().getStr().toUpperCase());
            }
            return true;
        }
        else if (type instanceof Statements.ClassImplementation) {
            const className = statement.findFirstExpression(Expressions.ClassName);
            if (className && this.globalClasses.has(className.getFirstToken().getStr().toUpperCase())) {
                return true;
            }
        }
        return false;
    }
}
exports.Indent = Indent;
class Stack {
    constructor() {
        this.items = [];
    }
    push(item) {
        this.items.push(item);
    }
    peek() {
        return this.items[this.items.length - 1];
    }
    pop() {
        const peek = this.peek();
        this.items = this.items.slice(0, this.items.length - 1);
        return peek;
    }
}
//# sourceMappingURL=indent.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/pretty_printer/pretty_printer.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/pretty_printer/pretty_printer.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrettyPrinter = void 0;
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const fix_keyword_case_1 = __webpack_require__(/*! ./fix_keyword_case */ "./node_modules/@abaplint/core/build/src/pretty_printer/fix_keyword_case.js");
const indent_1 = __webpack_require__(/*! ./indent */ "./node_modules/@abaplint/core/build/src/pretty_printer/indent.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const indentation_1 = __webpack_require__(/*! ../rules/indentation */ "./node_modules/@abaplint/core/build/src/rules/indentation.js");
class PrettyPrinter {
    constructor(file, config) {
        this.result = file.getRaw();
        this.file = file;
        this.config = config;
        const indentationConf = config.readByRule(new indentation_1.Indentation().getMetadata().key);
        this.options = {
            alignTryCatch: indentationConf === null || indentationConf === void 0 ? void 0 : indentationConf.alignTryCatch,
            globalClassSkipFirst: indentationConf === null || indentationConf === void 0 ? void 0 : indentationConf.globalClassSkipFirst,
        };
    }
    run() {
        const statements = this.file.getStatements();
        for (const statement of statements) {
            if (statement.get() instanceof _statement_1.Unknown
                || statement.get() instanceof _statement_1.MacroContent
                || statement.get() instanceof _statement_1.MacroCall
                || statement.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition
                || statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            // note that no positions are changed when case is changed
            const fixCase = new fix_keyword_case_1.FixCase(this.result, this.config);
            this.result = fixCase.execute(statement);
        }
        const indentation = new indent_1.Indent(this.options);
        this.result = indentation.execute(this.file, this.result);
        return this.result;
    }
}
exports.PrettyPrinter = PrettyPrinter;
//# sourceMappingURL=pretty_printer.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/registry.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/registry.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Registry = void 0;
const config_1 = __webpack_require__(/*! ./config */ "./node_modules/@abaplint/core/build/src/config.js");
const artifacts_objects_1 = __webpack_require__(/*! ./artifacts_objects */ "./node_modules/@abaplint/core/build/src/artifacts_objects.js");
const find_global_definitions_1 = __webpack_require__(/*! ./abap/5_syntax/global_definitions/find_global_definitions */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/global_definitions/find_global_definitions.js");
const excludeHelper_1 = __webpack_require__(/*! ./utils/excludeHelper */ "./node_modules/@abaplint/core/build/src/utils/excludeHelper.js");
const ddic_references_1 = __webpack_require__(/*! ./ddic_references */ "./node_modules/@abaplint/core/build/src/ddic_references.js");
const rules_runner_1 = __webpack_require__(/*! ./rules_runner */ "./node_modules/@abaplint/core/build/src/rules_runner.js");
const msag_references_1 = __webpack_require__(/*! ./msag_references */ "./node_modules/@abaplint/core/build/src/msag_references.js");
const macro_references_1 = __webpack_require__(/*! ./macro_references */ "./node_modules/@abaplint/core/build/src/macro_references.js");
// todo, this should really be an instance in case there are multiple Registry'ies
class ParsingPerformance {
    static clear() {
        this.results = [];
        this.lexing = 0;
        this.statements = 0;
        this.structure = 0;
    }
    static push(obj, result) {
        if (result.runtimeExtra) {
            this.lexing += result.runtimeExtra.lexing;
            this.statements += result.runtimeExtra.statements;
            this.structure += result.runtimeExtra.structure;
        }
        if (result.runtime < 100) {
            return;
        }
        if (this.results === undefined) {
            this.results = [];
        }
        let extra = "";
        if (result.runtimeExtra) {
            extra = `\t(lexing: ${result.runtimeExtra.lexing}ms, statements: ${result.runtimeExtra.statements}ms, structure: ${result.runtimeExtra.structure}ms)`;
        }
        this.results.push({
            runtime: result.runtime,
            extra,
            name: obj.getType() + " " + obj.getName(),
        });
    }
    static output() {
        const MAX = 10;
        this.results.sort((a, b) => { return b.runtime - a.runtime; });
        for (let i = 0; i < MAX; i++) {
            const row = this.results[i];
            if (row === undefined) {
                break;
            }
            process.stderr.write(`\t${row.runtime}ms\t${row.name} ${row.extra}\n`);
        }
        process.stderr.write(`\tTotal lexing:     ${this.lexing}ms\n`);
        process.stderr.write(`\tTotal statements: ${this.statements}ms\n`);
        process.stderr.write(`\tTotal structure:  ${this.structure}ms\n`);
    }
}
///////////////////////////////////////////////////////////////////////////////////////////////
class Registry {
    constructor(conf) {
        this.objects = {};
        this.objectsByType = {};
        this.dependencies = {};
        this.conf = conf ? conf : config_1.Config.getDefault();
        this.ddicReferences = new ddic_references_1.DDICReferences();
        this.msagReferences = new msag_references_1.MSAGReferences();
        this.macroReferences = new macro_references_1.MacroReferences();
    }
    static abaplintVersion() {
        // magic, see build script "version.sh"
        return "2.113.34";
    }
    getDDICReferences() {
        return this.ddicReferences;
    }
    getMSAGReferences() {
        return this.msagReferences;
    }
    getMacroReferences() {
        return this.macroReferences;
    }
    *getObjects() {
        for (const name in this.objects) {
            for (const type in this.objects[name]) {
                yield this.objects[name][type];
            }
        }
    }
    *getObjectsByType(type) {
        for (const name in this.objectsByType[type] || []) {
            yield this.objectsByType[type][name];
        }
    }
    *getFiles() {
        for (const obj of this.getObjects()) {
            for (const file of obj.getFiles()) {
                yield file;
            }
        }
    }
    getFirstObject() {
        for (const name in this.objects) {
            for (const type in this.objects[name]) {
                return this.objects[name][type];
            }
        }
        return undefined;
    }
    getObjectCount(skipDependencies = true) {
        let res = 0;
        for (const o of this.getObjects()) {
            if (skipDependencies === true && this.isDependency(o)) {
                continue;
            }
            res = res + 1;
        }
        return res;
    }
    getFileByName(filename) {
        const upper = filename.toUpperCase();
        for (const o of this.getObjects()) {
            for (const f of o.getFiles()) {
                if (f.getFilename().toUpperCase() === upper) {
                    return f;
                }
            }
        }
        return undefined;
    }
    getObject(type, name) {
        if (type === undefined || name === undefined) {
            return undefined;
        }
        const searchName = name.toUpperCase();
        if (this.objects[searchName]) {
            return this.objects[searchName][type];
        }
        return undefined;
    }
    getConfig() {
        return this.conf;
    }
    // assumption: Config is immutable, and can only be changed via this method
    setConfig(conf) {
        for (const obj of this.getObjects()) {
            obj.setDirty();
        }
        this.conf = conf;
        return this;
    }
    inErrorNamespace(name) {
        // todo: performance? cache regexp?
        const reg = new RegExp(this.getConfig().getSyntaxSetttings().errorNamespace, "i");
        return reg.test(name);
    }
    addFile(file) {
        return this.addFiles([file]);
    }
    updateFile(file) {
        const obj = this.find(file.getObjectName(), file.getObjectType());
        obj.updateFile(file);
        return this;
    }
    removeFile(file) {
        const obj = this.find(file.getObjectName(), file.getObjectType());
        obj.removeFile(file);
        if (obj.getFiles().length === 0) {
            this.ddicReferences.clear(obj);
            this.msagReferences.clear(obj);
            this.removeObject(obj);
        }
        return this;
    }
    _addFiles(files, dependency) {
        var _a;
        const globalExclude = ((_a = this.conf.getGlobal().exclude) !== null && _a !== void 0 ? _a : [])
            .map(pattern => new RegExp(pattern, "i"));
        for (const f of files) {
            const filename = f.getFilename();
            const isNotAbapgitFile = filename.split(".").length <= 2;
            if (isNotAbapgitFile || excludeHelper_1.ExcludeHelper.isExcluded(filename, globalExclude)) {
                continue;
            }
            let found = this.findOrCreate(f.getObjectName(), f.getObjectType());
            if (dependency === false && found && this.isDependency(found)) {
                this.removeDependency(found);
                found = this.findOrCreate(f.getObjectName(), f.getObjectType());
            }
            found.addFile(f);
        }
        return this;
    }
    addFiles(files) {
        this._addFiles(files, false);
        return this;
    }
    addDependencies(files) {
        for (const f of files) {
            this.addDependency(f);
        }
        return this;
    }
    addDependency(file) {
        var _a;
        const type = (_a = file.getObjectType()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        if (type === undefined) {
            return this;
        }
        const name = file.getObjectName().toUpperCase();
        if (this.dependencies[type] === undefined) {
            this.dependencies[type] = {};
        }
        this.dependencies[type][name] = true;
        this._addFiles([file], true);
        return this;
    }
    removeDependency(obj) {
        var _a;
        (_a = this.dependencies[obj.getType()]) === null || _a === void 0 ? true : delete _a[obj.getName()];
        this.removeObject(obj);
    }
    isDependency(obj) {
        var _a;
        return ((_a = this.dependencies[obj.getType()]) === null || _a === void 0 ? void 0 : _a[obj.getName()]) === true;
    }
    isFileDependency(filename) {
        var _a, _b;
        const f = this.getFileByName(filename);
        if (f === undefined) {
            return false;
        }
        const type = (_a = f.getObjectType()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        if (type === undefined) {
            return false;
        }
        const name = f.getObjectName().toUpperCase();
        return ((_b = this.dependencies[type]) === null || _b === void 0 ? void 0 : _b[name]) === true;
    }
    // assumption: the file is already in the registry
    findObjectForFile(file) {
        const filename = file.getFilename();
        for (const obj of this.getObjects()) {
            for (const ofile of obj.getFiles()) {
                if (ofile.getFilename() === filename) {
                    return obj;
                }
            }
        }
        return undefined;
    }
    // todo, this will be changed to async sometime
    findIssues(input) {
        if (this.isDirty() === true) {
            this.parse();
        }
        return new rules_runner_1.RulesRunner(this).runRules(this.getObjects(), input);
    }
    // todo, this will be changed to async sometime
    findIssuesObject(iobj) {
        if (this.isDirty() === true) {
            this.parse();
        }
        return new rules_runner_1.RulesRunner(this).runRules([iobj]);
    }
    // todo, this will be changed to async sometime
    parse() {
        if (this.isDirty() === false) {
            return this;
        }
        ParsingPerformance.clear();
        for (const o of this.getObjects()) {
            this.parsePrivate(o);
        }
        new find_global_definitions_1.FindGlobalDefinitions(this).run();
        return this;
    }
    async parseAsync(input) {
        var _a, _b;
        if (this.isDirty() === false) {
            return this;
        }
        ParsingPerformance.clear();
        (_a = input === null || input === void 0 ? void 0 : input.progress) === null || _a === void 0 ? void 0 : _a.set(this.getObjectCount(false), "Lexing and parsing");
        for (const o of this.getObjects()) {
            await ((_b = input === null || input === void 0 ? void 0 : input.progress) === null || _b === void 0 ? void 0 : _b.tick("Lexing and parsing(" + this.conf.getVersion() + ") - " + o.getType() + " " + o.getName()));
            this.parsePrivate(o);
        }
        if ((input === null || input === void 0 ? void 0 : input.outputPerformance) === true) {
            ParsingPerformance.output();
        }
        new find_global_definitions_1.FindGlobalDefinitions(this).run(input === null || input === void 0 ? void 0 : input.progress);
        return this;
    }
    //////////////////////////////////////////
    // todo, refactor, this is a mess, see where-used, a lot of the code should be in this method instead
    parsePrivate(input) {
        const config = this.getConfig();
        const result = input.parse(config.getVersion(), config.getSyntaxSetttings().globalMacros, this);
        ParsingPerformance.push(input, result);
    }
    isDirty() {
        for (const o of this.getObjects()) {
            const dirty = o.isDirty();
            if (dirty === true) {
                return true;
            }
        }
        return false;
    }
    findOrCreate(name, type) {
        try {
            return this.find(name, type);
        }
        catch (_a) {
            const newName = name.toUpperCase();
            const newType = type ? type : "UNKNOWN";
            const add = artifacts_objects_1.ArtifactsObjects.newObject(newName, newType);
            if (this.objects[newName] === undefined) {
                this.objects[newName] = {};
            }
            this.objects[newName][newType] = add;
            if (this.objectsByType[newType] === undefined) {
                this.objectsByType[newType] = {};
            }
            this.objectsByType[newType][newName] = add;
            return add;
        }
    }
    removeObject(remove) {
        if (remove === undefined) {
            return;
        }
        if (this.objects[remove.getName()][remove.getType()] === undefined) {
            throw new Error("removeObject: object not found");
        }
        if (Object.keys(this.objects[remove.getName()]).length === 1) {
            delete this.objects[remove.getName()];
        }
        else {
            delete this.objects[remove.getName()][remove.getType()];
        }
        if (Object.keys(this.objectsByType[remove.getType()]).length === 1) {
            delete this.objectsByType[remove.getType()];
        }
        else {
            delete this.objectsByType[remove.getType()][remove.getName()];
        }
    }
    find(name, type) {
        const searchType = type ? type : "UNKNOWN";
        const searchName = name.toUpperCase();
        if (this.objects[searchName] !== undefined
            && this.objects[searchName][searchType]) {
            return this.objects[searchName][searchType];
        }
        throw new Error("find: object not found, " + type + " " + name);
    }
}
exports.Registry = Registry;
//# sourceMappingURL=registry.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/7bit_ascii.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/7bit_ascii.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SevenBitAscii = exports.SevenBitAsciiConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class SevenBitAsciiConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SevenBitAsciiConf = SevenBitAsciiConf;
class SevenBitAscii {
    constructor() {
        this.conf = new SevenBitAsciiConf();
    }
    getMetadata() {
        return {
            key: "7bit_ascii",
            title: "Check for 7bit ascii",
            shortDescription: `Only allow characters from the 7bit ASCII set.`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/05/

https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abencharacter_set_guidl.htm

Checkes files with extensions ".abap" and ".asddls"`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `WRITE '뽑'.`,
            goodExample: `WRITE cl_abap_conv_in_ce=>uccp( 'BF51' ).`,
        };
    }
    initialize(_reg) {
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const output = [];
        for (const file of obj.getFiles()) {
            const filename = file.getFilename();
            if (filename.endsWith(".abap") || filename.endsWith(".asddls")) {
                const rows = file.getRawRows();
                for (let i = 0; i < rows.length; i++) {
                    const found = /[\u007f-\uffff]/.exec(rows[i]);
                    if (found !== null) {
                        const column = found.index + 1;
                        const start = new position_1.Position(i + 1, column);
                        const end = new position_1.Position(i + 1, column + 1);
                        const message = "Contains non 7 bit ascii character";
                        const issue = issue_1.Issue.atRange(file, start, end, message, this.getMetadata().key, this.conf.severity);
                        output.push(issue);
                    }
                    // method getRawRows() splits by newline, so the carraige return
                    // should always be last character if present
                    const carriage = /\r.+$/.exec(rows[i]);
                    if (carriage !== null) {
                        const column = carriage.index + 1;
                        const start = new position_1.Position(i + 1, column);
                        const end = new position_1.Position(i + 1, column + 1);
                        const message = "Dangling carriage return";
                        const issue = issue_1.Issue.atRange(file, start, end, message, this.getMetadata().key, this.conf.severity);
                        output.push(issue);
                    }
                }
            }
        }
        return output;
    }
}
exports.SevenBitAscii = SevenBitAscii;
//# sourceMappingURL=7bit_ascii.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/_abap_rule.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ABAPRule = void 0;
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class ABAPRule {
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const abap = obj;
        const output = [];
        for (const file of abap.getABAPFiles()) {
            output.push(...this.runParsed(file, obj));
        }
        return output;
    }
}
exports.ABAPRule = ABAPRule;
//# sourceMappingURL=_abap_rule.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BasicRuleConfig = void 0;
const severity_1 = __webpack_require__(/*! ../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
class BasicRuleConfig {
    constructor() {
        /** List of file regex filename patterns to exclude, case insensitive */
        this.exclude = [];
        /** Problem severity */
        this.severity = severity_1.Severity.Error;
    }
}
exports.BasicRuleConfig = BasicRuleConfig;
//# sourceMappingURL=_basic_rule_config.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/_irule.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/_irule.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RuleTag = void 0;
var RuleTag;
(function (RuleTag) {
    RuleTag["Experimental"] = "Experimental";
    RuleTag["DeprecationCandidate"] = "DeprecationCandidate";
    RuleTag["Upport"] = "Upport";
    RuleTag["Downport"] = "Downport";
    RuleTag["Whitespace"] = "Whitespace";
    RuleTag["Naming"] = "Naming";
    RuleTag["Quickfix"] = "Quickfix";
    RuleTag["Performance"] = "Performance";
    RuleTag["Syntax"] = "Syntax";
    RuleTag["Security"] = "Security";
    /** Relevant wrt the official SAP ABAP style guide*/
    RuleTag["Styleguide"] = "Styleguide";
    /** Single file compatible, the rule gives correct results when having only information about the single file */
    RuleTag["SingleFile"] = "SingleFile";
})(RuleTag || (exports.RuleTag = RuleTag = {}));
//# sourceMappingURL=_irule.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamingRuleConfig = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
class NamingRuleConfig extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Specifies whether the pattern is forbidden (violation if name matches) or required (violation if name does not match). */
        this.patternKind = "required";
        /** A list of names to be ignored */
        this.ignoreNames = [];
        /** A list of patterns to be ignored. For example, you can use it to ignore ambiguous prefixes */
        this.ignorePatterns = [];
    }
}
exports.NamingRuleConfig = NamingRuleConfig;
//# sourceMappingURL=_naming_rule_config.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/abapdoc.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/abapdoc.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Abapdoc = exports.AbapdocConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const visibility_1 = __webpack_require__(/*! ../abap/4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class AbapdocConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Check local classes and interfaces for abapdoc. */
        this.checkLocal = false;
        this.classDefinition = false;
        this.interfaceDefinition = false;
        /** Ignores classes flagged as FOR TESTING */
        this.ignoreTestClasses = true;
    }
}
exports.AbapdocConf = AbapdocConf;
class Abapdoc extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AbapdocConf();
    }
    getMetadata() {
        return {
            key: "abapdoc",
            title: "Check abapdoc",
            shortDescription: `Various checks regarding abapdoc.`,
            extendedInformation: `Base rule checks for existence of abapdoc for public class methods and all interface methods.

Plus class and interface definitions.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#abap-doc-only-for-public-apis`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b;
        const issues = [];
        const rows = file.getRawRows();
        const regexEmptyTags = '^\\"! .*<[^/>]*><\\/';
        const regexEmptyAbapdoc = '^\\"!.+$';
        const regexEmptyParameterName = '^\\"! @parameter .+\\|';
        let methods = [];
        for (const classDef of file.getInfo().listClassDefinitions()) {
            if (this.conf.checkLocal === false && classDef.isLocal === true) {
                continue;
            }
            if (this.conf.ignoreTestClasses === true && classDef.isForTesting === true) {
                continue;
            }
            methods = methods.concat(classDef.methods.filter(m => m.visibility === visibility_1.Visibility.Public));
            if (this.conf.classDefinition === true) {
                const previousRow = classDef.identifier.getStart().getRow() - 2;
                if (((_a = rows[previousRow]) === null || _a === void 0 ? void 0 : _a.trim().substring(0, 2)) !== "\"!") {
                    const message = "Missing ABAP Doc for class " + classDef.identifier.getToken().getStr();
                    const issue = issue_1.Issue.atIdentifier(classDef.identifier, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        for (const interfaceDef of file.getInfo().listInterfaceDefinitions()) {
            if (this.conf.checkLocal === false && interfaceDef.isLocal === true) {
                continue;
            }
            methods = methods.concat(interfaceDef.methods);
            if (this.conf.interfaceDefinition === true) {
                const previousRow = interfaceDef.identifier.getStart().getRow() - 2;
                if (((_b = rows[previousRow]) === null || _b === void 0 ? void 0 : _b.trim().substring(0, 2)) !== "\"!") {
                    const message = "Missing ABAP Doc for interface " + interfaceDef.identifier.getToken().getStr();
                    const issue = issue_1.Issue.atIdentifier(interfaceDef.identifier, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        for (const method of methods) {
            if (method.isRedefinition === true) {
                continue;
            }
            const previousRowsTexts = this.getAbapdoc(rows, method.identifier.getStart());
            if (previousRowsTexts === undefined) {
                continue;
            }
            for (const rowText of previousRowsTexts) {
                if (rowText.trim().match(regexEmptyTags) !== null) {
                    const message = "Empty tag(s) in ABAP Doc for method " + method.identifier.getToken().getStr() + " (" + rowText + ")";
                    const issue = issue_1.Issue.atIdentifier(method.identifier, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                if (rowText.trim().match(regexEmptyAbapdoc) === null && previousRowsTexts.indexOf(rowText) === previousRowsTexts.length - 1) {
                    const message = "Missing ABAP Doc for method " + method.identifier.getToken().getStr() + " (" + rowText + ")";
                    const issue = issue_1.Issue.atIdentifier(method.identifier, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                if (rowText.trim().match(regexEmptyParameterName) !== null) {
                    const message = "Missing ABAP Doc parameter name for method " + method.identifier.getToken().getStr() + " (" + rowText + ")";
                    const issue = issue_1.Issue.atIdentifier(method.identifier, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
    getAbapdoc(rows, pos) {
        let previousRow = pos.getRow() - 2;
        let rowText = rows[previousRow].trim().toUpperCase();
        const text = [];
        if (rowText === "METHODS" || rowText === "CLASS-METHODS") {
            previousRow--;
            rowText = rows[previousRow].trim().toUpperCase();
        }
        text.push(rowText);
        //we need to push the first row despite if it is actually an abapdoc or not
        //if the first row above a method is abapdoc then try to get the rest of the abapdoc block above
        if (rowText.trim().substring(0, 2) === "\"!") {
            while (previousRow >= 0) {
                previousRow--;
                rowText = rows[previousRow].trim().toUpperCase();
                if (rowText.trim().substring(0, 2) !== "\"!") {
                    break;
                }
                text.push(rowText);
            }
        }
        return text;
    }
}
exports.Abapdoc = Abapdoc;
//# sourceMappingURL=abapdoc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/add_test_attributes.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/add_test_attributes.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AddTestAttributes = exports.AddTestAttributesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class AddTestAttributesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.AddTestAttributesConf = AddTestAttributesConf;
class AddTestAttributes extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AddTestAttributesConf();
    }
    getMetadata() {
        return {
            key: "add_test_attributes",
            title: "Add test attributes for tests classes with test methods",
            shortDescription: `Add test attributes DURATION and RISK LEVEL for tests classes with test methods`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `CLASS ltcl_test1 DEFINITION FINAL FOR TESTING.
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS test FOR TESTING RAISING cx_static_check.
ENDCLASS.

CLASS ltcl_test1 IMPLEMENTATION.
  METHOD test.
  ENDMETHOD.
ENDCLASS.`,
            goodExample: `CLASS ltcl_test2 DEFINITION FINAL FOR TESTING DURATION SHORT RISK LEVEL HARMLESS.
  PUBLIC SECTION.
  PROTECTED SECTION.
  PRIVATE SECTION.
    METHODS test FOR TESTING RAISING cx_static_check.
ENDCLASS.

CLASS ltcl_test2 IMPLEMENTATION.
  METHOD test.
  ENDMETHOD.
ENDCLASS.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const classStructure of stru.findAllStructures(Structures.ClassDefinition)) {
            const cdef = classStructure.findFirstStatement(Statements.ClassDefinition);
            if (cdef === undefined) {
                continue;
            }
            const cdefConcat = cdef === null || cdef === void 0 ? void 0 : cdef.concatTokens().toUpperCase();
            if ((cdefConcat === null || cdefConcat === void 0 ? void 0 : cdefConcat.includes(" FOR TESTING")) === false) {
                continue;
            }
            const hasDuration = cdefConcat === null || cdefConcat === void 0 ? void 0 : cdefConcat.includes(" DURATION ");
            const hasRiskLevel = cdefConcat === null || cdefConcat === void 0 ? void 0 : cdefConcat.includes(" RISK LEVEL ");
            if (hasDuration === true && hasRiskLevel === true) {
                continue;
            }
            let hasTestMethod = false;
            for (const mdef of classStructure.findAllStatements(Statements.MethodDef)) {
                const concat = mdef.concatTokens().toUpperCase();
                if (concat.includes(" FOR TESTING")) {
                    hasTestMethod = true;
                }
            }
            if (hasTestMethod === false) {
                continue;
            }
            if (hasDuration === false) {
                issues.push(issue_1.Issue.atStatement(file, cdef, "Add DURATION", this.getMetadata().key, this.getConfig().severity));
            }
            if (hasRiskLevel === false) {
                issues.push(issue_1.Issue.atStatement(file, cdef, "Add RISK LEVEL", this.getMetadata().key, this.getConfig().severity));
            }
        }
        return issues;
    }
}
exports.AddTestAttributes = AddTestAttributes;
//# sourceMappingURL=add_test_attributes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/align_parameters.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/align_parameters.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlignParameters = exports.AlignParametersConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class AlignParametersConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.AlignParametersConf = AlignParametersConf;
class AlignParameters extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AlignParametersConf();
    }
    getMetadata() {
        return {
            key: "align_parameters",
            title: "Align Parameters",
            shortDescription: `Checks for vertially aligned parameters`,
            extendedInformation: `Checks:
* function module calls
* method calls
* VALUE constructors
* NEW constructors
* RAISE EXCEPTION statements
* CREATE OBJECT statements
* RAISE EVENT statements

https://github.com/SAP/styleguides/blob/master/clean-abap/CleanABAP.md#align-parameters

Does not take effect on non functional method calls, use https://rules.abaplint.org/functional_writing/

If parameters are on the same row, no issues are reported, see
https://rules.abaplint.org/max_one_method_parameter_per_line/ for splitting parameters to lines`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix],
            badExample: `CALL FUNCTION 'FOOBAR'
  EXPORTING
    foo = 2
    parameter = 3.

foobar( moo = 1
  param = 1 ).

foo = VALUE #(
    foo = bar
        moo = 2 ).`,
            goodExample: `CALL FUNCTION 'FOOBAR'
  EXPORTING
    foo       = 2
    parameter = 3.

foobar( moo   = 1
        param = 1 ).

foo = VALUE #(
    foo = bar
    moo = 2 ).

DATA(sdf) = VALUE type(
  common_val     = 2
  another_common = 5
  ( row_value = 4
    value_foo = 5 ) ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues; // parser error
        }
        const candidates = [];
        candidates.push(...this.functionParameterCandidates(stru));
        candidates.push(...this.methodCallParamCandidates(stru));
        candidates.push(...this.valueBodyCandidates(stru));
        candidates.push(...this.raiseAndCreateCandidates(stru));
        candidates.push(...this.newCandidates(stru));
        for (const c of candidates) {
            const i = this.checkCandidate(c, file);
            if (i) {
                issues.push(i);
            }
        }
        return issues;
    }
    checkCandidate(candidate, file) {
        if (candidate.parameters.length === 0) {
            return undefined;
        }
        let expectedEqualsColumn = 0;
        let row = 0;
        for (const p of candidate.parameters) {
            const currentCol = p.left.getLastToken().getCol() + p.left.getLastToken().getStr().length + 1;
            if (p.eq.getRow() === row) {
                return undefined;
            }
            row = p.eq.getRow();
            if (currentCol > expectedEqualsColumn) {
                expectedEqualsColumn = currentCol;
            }
        }
        for (const p of candidate.parameters) {
            if (p.eq.getCol() !== expectedEqualsColumn) {
                let fix;
                if (p.eq.getCol() < expectedEqualsColumn) {
                    fix = edit_helper_1.EditHelper.insertAt(file, p.eq, " ".repeat(expectedEqualsColumn - p.eq.getCol()));
                }
                else {
                    fix = edit_helper_1.EditHelper.deleteRange(file, new position_1.Position(p.eq.getRow(), expectedEqualsColumn), p.eq);
                }
                const message = "Align parameters to column " + expectedEqualsColumn;
                return issue_1.Issue.atPosition(file, p.eq, message, this.getMetadata().key, this.getConfig().severity, fix);
            }
        }
        return undefined;
    }
    newCandidates(stru) {
        const candidates = [];
        for (const vb of stru.findAllExpressionsRecursive(Expressions.NewObject)) {
            const parameters = [];
            const fieldAssignments = vb.findDirectExpressions(Expressions.FieldAssignment);
            if (fieldAssignments.length >= 2) {
                for (const fs of fieldAssignments) {
                    const children = fs.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
                if (parameters.length > 0) {
                    candidates.push({ parameters });
                    continue;
                }
            }
            const list = vb.findDirectExpression(Expressions.ParameterListS);
            if (list) {
                for (const c of list.getChildren()) {
                    const children = c.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
                if (parameters.length > 0) {
                    candidates.push({ parameters });
                }
            }
        }
        return candidates;
    }
    valueBodyCandidates(stru) {
        const candidates = [];
        for (const vb of stru.findAllExpressionsRecursive(Expressions.ValueBody)) {
            const parameters = [];
            const fieldAssignments = vb.findDirectExpressions(Expressions.FieldAssignment);
            if (fieldAssignments.length <= 1) {
                continue;
            }
            for (const fs of fieldAssignments) {
                const children = fs.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            if (parameters.length > 0) {
                candidates.push({ parameters });
            }
        }
        for (const vb of stru.findAllExpressionsRecursive(Expressions.ValueBodyLine)) {
            const parameters = [];
            const fieldAssignments = vb.findDirectExpressions(Expressions.FieldAssignment);
            if (fieldAssignments.length <= 1) {
                continue;
            }
            for (const fs of fieldAssignments) {
                const children = fs.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            if (parameters.length > 0) {
                candidates.push({ parameters });
            }
        }
        return candidates;
    }
    raiseAndCreateCandidates(stru) {
        const candidates = [];
        const statements = stru.findAllStatements(__1.Statements.Raise);
        statements.push(...stru.findAllStatements(__1.Statements.CreateObject));
        statements.push(...stru.findAllStatements(__1.Statements.RaiseEvent));
        for (const raise of statements) {
            const parameters = [];
            const param = raise.findDirectExpression(Expressions.ParameterListS);
            for (const p of (param === null || param === void 0 ? void 0 : param.getChildren()) || []) {
                const children = p.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            const ex = raise.findDirectExpression(Expressions.ParameterListExceptions);
            for (const e of (ex === null || ex === void 0 ? void 0 : ex.getChildren()) || []) {
                const children = e.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            if (parameters.length > 0) {
                candidates.push({ parameters });
            }
        }
        return candidates;
    }
    methodCallParamCandidates(stru) {
        var _a, _b, _c;
        const candidates = [];
        for (const mcp of stru.findAllExpressionsRecursive(Expressions.MethodCallParam)) {
            const parameters = [];
            for (const param of ((_a = mcp.findDirectExpression(Expressions.ParameterListS)) === null || _a === void 0 ? void 0 : _a.getChildren()) || []) {
                const children = param.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            const mp = mcp.findDirectExpression(Expressions.MethodParameters);
            if (mp) {
                for (const p of ((_b = mp.findDirectExpression(Expressions.ParameterListS)) === null || _b === void 0 ? void 0 : _b.getChildren()) || []) {
                    const children = p.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
                for (const l of mp.findDirectExpressions(Expressions.ParameterListT)) {
                    for (const p of l.findDirectExpressions(Expressions.ParameterT) || []) {
                        const children = p.getChildren();
                        if (children.length < 3) {
                            continue; // unexpected
                        }
                        parameters.push({
                            left: children[0],
                            eq: children[1].getFirstToken().getStart(),
                            right: children[2],
                        });
                    }
                }
                const rec = mp.findDirectExpression(Expressions.ParameterT);
                if (rec) {
                    const children = rec.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
                for (const ex of ((_c = mp.findDirectExpression(Expressions.ParameterListExceptions)) === null || _c === void 0 ? void 0 : _c.getChildren()) || []) {
                    const children = ex.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
            }
            if (parameters.length > 0) {
                candidates.push({ parameters });
            }
        }
        return candidates;
    }
    functionParameterCandidates(stru) {
        const candidates = [];
        for (const fp of stru.findAllExpressionsRecursive(Expressions.FunctionParameters)) {
            const parameters = [];
            for (const p of fp.findAllExpressions(Expressions.FunctionExportingParameter)) {
                const children = p.getChildren();
                if (children.length < 3) {
                    continue; // unexpected
                }
                parameters.push({
                    left: children[0],
                    eq: children[1].getFirstToken().getStart(),
                    right: children[2],
                });
            }
            for (const list of fp.findDirectExpressions(Expressions.ParameterListT)) {
                for (const pt of list.findDirectExpressions(Expressions.ParameterT)) {
                    const children = pt.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
            }
            const list = fp.findDirectExpression(Expressions.ParameterListExceptions);
            if (list) {
                for (const pt of list.findDirectExpressions(Expressions.ParameterException)) {
                    const children = pt.getChildren();
                    if (children.length < 3) {
                        continue; // unexpected
                    }
                    parameters.push({
                        left: children[0],
                        eq: children[1].getFirstToken().getStart(),
                        right: children[2],
                    });
                }
            }
            if (parameters.length > 0) {
                candidates.push({ parameters });
            }
        }
        return candidates;
    }
}
exports.AlignParameters = AlignParameters;
//# sourceMappingURL=align_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/align_pseudo_comments.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/align_pseudo_comments.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlignPseudoComments = exports.AlignPseudoCommentsConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class AlignPseudoCommentsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.AlignPseudoCommentsConf = AlignPseudoCommentsConf;
class AlignPseudoComments extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AlignPseudoCommentsConf();
    }
    getMetadata() {
        return {
            key: "align_pseudo_comments",
            title: "Align pseudo comments",
            shortDescription: `Align code inspector pseudo comments in statements`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix],
            badExample: `WRITE 'sdf'. "#EC sdf`,
            goodExample: `WRITE 'sdf'.                                                "#EC sdf`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let previousEnd = undefined;
        for (const statement of file.getStatements()) {
            if (!(statement.get() instanceof _statement_1.Comment)) {
                previousEnd = statement.getLastToken().getEnd();
                continue;
            }
            const commentLength = statement.concatTokens().length;
            const firstCommentToken = statement.getFirstToken();
            if (firstCommentToken.getStr().startsWith(`"#`) === false) {
                continue;
            }
            else if (previousEnd === undefined) {
                continue;
            }
            let expectedColumn = 61;
            if (commentLength > 10) {
                expectedColumn = 72 - commentLength;
            }
            const col = firstCommentToken.getStart().getCol();
            if (previousEnd.getCol() < expectedColumn && col !== expectedColumn) {
                let fix = undefined;
                if (col < expectedColumn) {
                    fix = edit_helper_1.EditHelper.insertAt(file, firstCommentToken.getStart(), " ".repeat(expectedColumn - col));
                }
                else {
                    const from = new position_1.Position(firstCommentToken.getStart().getRow(), expectedColumn);
                    fix = edit_helper_1.EditHelper.deleteRange(file, from, firstCommentToken.getStart());
                }
                const message = "Align pseudo comment to column " + expectedColumn;
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, fix));
            }
        }
        return issues;
    }
}
exports.AlignPseudoComments = AlignPseudoComments;
//# sourceMappingURL=align_pseudo_comments.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/align_type_expressions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/align_type_expressions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AlignTypeExpressions = exports.AlignTypeExpressionsConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class AlignTypeExpressionsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore global exception classes */
        this.ignoreExceptions = true;
    }
}
exports.AlignTypeExpressionsConf = AlignTypeExpressionsConf;
class AlignTypeExpressions extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AlignTypeExpressionsConf();
    }
    getMetadata() {
        return {
            key: "align_type_expressions",
            title: "Align TYPE expressions",
            shortDescription: `Align TYPE expressions in statements`,
            extendedInformation: `
Currently works for METHODS + BEGIN OF

If BEGIN OF has an INCLUDE TYPE its ignored

Also note that clean ABAP does not recommend aligning TYPE clauses:
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#dont-align-type-clauses`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix],
            badExample: `
TYPES: BEGIN OF foo,
         bar TYPE i,
         foobar TYPE i,
       END OF foo.

INTERFACE lif.
  METHODS bar
    IMPORTING
      foo TYPE i
      foobar TYPE i.
ENDINTERFACE.`,
            goodExample: `
TYPES: BEGIN OF foo,
         bar    TYPE i,
         foobar TYPE i,
       END OF foo.

INTERFACE lif.
  METHODS bar
    IMPORTING
      foo    TYPE i
      foobar TYPE i.
ENDINTERFACE.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues; // parser error
        }
        const ddic = new ddic_1.DDIC(this.reg);
        if (obj instanceof objects_1.Class) {
            const definition = obj.getClassDefinition();
            if (definition === undefined) {
                return [];
            }
            else if (this.conf.ignoreExceptions && ddic.isException(definition, obj)) {
                return [];
            }
        }
        issues.push(...this.checkTypes(stru, file));
        issues.push(...this.checkMethods(stru, file));
        return issues;
    }
    check(fields, column, file) {
        const issues = [];
        const rows = new Set();
        for (const f of fields) {
            const row = f.after.getRow();
            if (rows.has(row)) {
                return [];
            }
            rows.add(row);
        }
        for (const f of fields) {
            if (f.after.getCol() === column) {
                continue;
            }
            let fix = undefined;
            if (f.after.getCol() < column) {
                fix = edit_helper_1.EditHelper.insertAt(file, f.after, " ".repeat(column - f.after.getCol()));
            }
            else {
                fix = edit_helper_1.EditHelper.deleteRange(file, new position_1.Position(f.after.getRow(), column), f.after);
            }
            const message = `Align TYPE expressions to column ${column}`;
            const issue = issue_1.Issue.atPosition(file, f.after, message, this.getMetadata().key, this.conf.severity, fix);
            issues.push(issue);
        }
        return issues;
    }
    checkMethods(stru, file) {
        const issues = [];
        const methods = stru.findAllStatements(Statements.MethodDef);
        for (const m of methods) {
            const fields = [];
            const params = m.findAllExpressions(Expressions.MethodParam);
            let column = 0;
            for (const p of params) {
                const children = p.getChildren();
                const name = children[children.length - 2];
                fields.push({
                    nameEnd: name.getLastToken().getEnd(),
                    after: p.findFirstExpression(Expressions.TypeParam).getFirstToken().getStart()
                });
                column = Math.max(column, name.getFirstToken().getEnd().getCol() + 1);
            }
            const ret = m.findFirstExpression(Expressions.MethodDefReturning);
            if (ret) {
                const children = ret.getChildren();
                const name = children[children.length - 2];
                fields.push({
                    nameEnd: name.getLastToken().getEnd(),
                    after: ret.findFirstExpression(Expressions.TypeParam).getFirstToken().getStart()
                });
                column = Math.max(column, name.getLastToken().getEnd().getCol() + 1);
            }
            issues.push(...this.check(fields, column, file));
        }
        return issues;
    }
    checkTypes(stru, file) {
        const issues = [];
        const types = stru.findAllStructuresRecursive(Structures.Types);
        for (const t of types) {
            if (t.findDirectStatement(Statements.IncludeType)) {
                continue;
            }
            const fields = [];
            let column = 0;
            const st = t.findDirectStatements(Statements.Type);
            for (const s of st) {
                const name = s.getChildren()[1];
                fields.push({
                    nameEnd: name.getLastToken().getEnd(),
                    after: s.getChildren()[2].getFirstToken().getStart()
                });
                column = Math.max(column, name.getFirstToken().getEnd().getCol() + 1);
            }
            issues.push(...this.check(fields, column, file));
        }
        return issues;
    }
}
exports.AlignTypeExpressions = AlignTypeExpressions;
//# sourceMappingURL=align_type_expressions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/allowed_object_naming.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/allowed_object_naming.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllowedObjectNaming = exports.AllowedObjectNamingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const NAME_REGEX = /^(\/[A-Z_\d]{3,8}\/)?[A-Z_\d<> ]+$/i;
class AllowedObjectNamingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.AllowedObjectNamingConf = AllowedObjectNamingConf;
class AllowedObjectNaming {
    constructor() {
        this.conf = new AllowedObjectNamingConf();
    }
    getMetadata() {
        return {
            key: "allowed_object_naming",
            title: "Allowed object naming",
            shortDescription: `Enforces basic name length and namespace restrictions, see note SAP 104010`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
        };
    }
    initialize(_reg) {
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const allowed = obj.getAllowedNaming();
        const name = obj.getName();
        let message = "";
        if (name.length > allowed.maxLength) {
            message = "Name exceeds max length";
        }
        else if (allowed.allowNamespace === false && name.indexOf("/") >= 0) {
            message = "Namespace not allowed for object type";
        }
        else if (allowed.customRegex !== undefined) {
            if (name.match(allowed.customRegex) === null) {
                message = "Name not allowed";
            }
        }
        else if (name.match(NAME_REGEX) === null) {
            message = "Name not allowed";
        }
        if (message.length > 0) {
            return [issue_1.Issue.atRow(obj.getFiles()[0], 1, message, this.getMetadata().key, this.conf.severity)];
        }
        return [];
    }
}
exports.AllowedObjectNaming = AllowedObjectNaming;
//# sourceMappingURL=allowed_object_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/allowed_object_types.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/allowed_object_types.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AllowedObjectTypes = exports.AllowedObjectTypesConf = void 0;
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class AllowedObjectTypesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** List of allowed object types, example: ["CLAS", "INTF"]
         * @uniqueItems true
        */
        this.allowed = [];
    }
}
exports.AllowedObjectTypesConf = AllowedObjectTypesConf;
class AllowedObjectTypes {
    constructor() {
        this.conf = new AllowedObjectTypesConf();
    }
    getMetadata() {
        return {
            key: "allowed_object_types",
            title: "Check allowed object types",
            shortDescription: `Restricts the set of allowed object types.`,
            extendedInformation: `"allowed" is a list of 4 character R3TR object types, example: ["CLAS", "INTF"]`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    initialize(_reg) {
        return this;
    }
    getDescription(objectType) {
        return "Object type " + objectType + " not allowed";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const allowed = this.getConfig().allowed;
        if (allowed === undefined || allowed.length === 0) {
            return [];
        }
        const objectType = obj.getType();
        if (allowed.indexOf(objectType) < 0) {
            const position = new position_1.Position(1, 1);
            const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, this.getDescription(objectType), this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
}
exports.AllowedObjectTypes = AllowedObjectTypes;
//# sourceMappingURL=allowed_object_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/ambiguous_statement.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/ambiguous_statement.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AmbiguousStatement = exports.AmbiguousStatementConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const combi_1 = __webpack_require__(/*! ../abap/2_statements/combi */ "./node_modules/@abaplint/core/build/src/abap/2_statements/combi.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class AmbiguousStatementConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.AmbiguousStatementConf = AmbiguousStatementConf;
class AmbiguousStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AmbiguousStatementConf();
    }
    getMetadata() {
        return {
            key: "ambiguous_statement",
            title: "Check for ambigious statements",
            shortDescription: `Checks for ambiguity between deleting or modifying from internal and database table
Add "TABLE" keyword or "@" for escaping SQL variables

Only works if the target version is 740sp05 or above`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `DELETE foo FROM bar.
MODIFY foo FROM bar.`,
            goodExample: `DELETE foo FROM @bar.
DELETE TABLE itab FROM 2.
MODIFY zfoo FROM @wa.
MODIFY TABLE foo FROM bar.`,
        };
    }
    getMessage() {
        return "Ambiguous statement. Use explicit syntax.";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp05) {
            return [];
        }
        for (const statement of file.getStatements()) {
            let match = false;
            if (statement.get() instanceof Statements.DeleteDatabase) {
                match = this.tryMatch(statement, this.reg, Statements.DeleteInternal);
            }
            else if (statement.get() instanceof Statements.DeleteInternal) {
                match = this.tryMatch(statement, this.reg, Statements.DeleteDatabase);
            }
            else if (statement.get() instanceof Statements.ModifyInternal) {
                match = this.tryMatch(statement, this.reg, Statements.ModifyDatabase);
            }
            else if (statement.get() instanceof Statements.ModifyDatabase) {
                match = this.tryMatch(statement, this.reg, Statements.ModifyInternal);
            }
            if (match) {
                const issue = issue_1.Issue.atStatement(file, statement, this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
    tryMatch(st, reg, type1) {
        const ver = reg.getConfig().getVersion();
        const tokens = st.getTokens().slice(0);
        tokens.pop();
        const match = combi_1.Combi.run(new type1().getMatcher(), tokens, ver);
        return match !== undefined;
    }
}
exports.AmbiguousStatement = AmbiguousStatement;
//# sourceMappingURL=ambiguous_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/avoid_use.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/avoid_use.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.AvoidUse = exports.AvoidUseConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class AvoidUseConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Do not emit quick fix suggestion */
        this.skipQuickFix = false;
        /** Detects DEFINE (macro definitions) */
        this.define = true;
        /** Detects statics */
        this.statics = true;
        /** Detects DEFAULT KEY definitions, from version v740sp02 and up. Use pseudo comment DEFAULT_KEY to ignore */
        this.defaultKey = true;
        /** Detects BREAK and BREAK-POINTS */
        this.break = true;
        /** Detects TEST SEAMS. Use pseudo comment TEST_SEAM_USAGE to ignore */
        this.testSeams = true;
        /** Detects DESCRIBE TABLE LINES, use lines() instead */
        this.describeLines = true;
        /** Detects EXPORT TO MEMORY */
        this.exportToMemory = true;
        /** Detects EXPORT TO DATABASE */
        this.exportToDatabase = true;
    }
}
exports.AvoidUseConf = AvoidUseConf;
class AvoidUse extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new AvoidUseConf();
    }
    getMetadata() {
        return {
            key: "avoid_use",
            title: "Avoid use of certain statements",
            shortDescription: `Detects usage of certain statements.`,
            extendedInformation: `DEFAULT KEY: https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-default-key

Macros: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abenmacros_guidl.htm

STATICS: use CLASS-DATA instead

DESCRIBE TABLE LINES: use lines() instead (quickfix exists)

TEST-SEAMS: https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-test-seams-as-temporary-workaround

BREAK points`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(statement) {
        return "Avoid use of " + statement;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        let isStaticsBlock = false;
        const statements = file.getStatements();
        for (let i = 0; i < statements.length; i++) {
            const statementNode = statements[i];
            const statement = statementNode.get();
            let message = undefined;
            let fix = undefined;
            if (this.conf.define && statement instanceof Statements.Define) {
                message = "DEFINE";
            }
            else if (this.conf.describeLines && statement instanceof Statements.Describe) {
                const children = statementNode.getChildren();
                if (children.length === 6 && children[3].getFirstToken().getStr().toUpperCase() === "LINES") {
                    message = "DESCRIBE LINES, use lines() instead";
                    fix = this.conf.skipQuickFix === true ? undefined : this.getDescribeLinesFix(file, statementNode);
                }
            }
            else if (this.conf.statics && statement instanceof Statements.StaticBegin) {
                isStaticsBlock = true;
                message = "STATICS";
            }
            else if (this.conf.statics && statement instanceof Statements.StaticEnd) {
                isStaticsBlock = false;
            }
            else if (this.conf.exportToMemory && statement instanceof Statements.Export && statementNode.concatTokens().includes("TO MEMORY ")) {
                message = "EXPORT TO MEMORY";
            }
            else if (this.conf.exportToDatabase && statement instanceof Statements.Export && statementNode.concatTokens().includes("TO DATABASE ")) {
                message = "EXPORT TO DATABASE";
            }
            else if (this.conf.testSeams && statement instanceof Statements.TestSeam) {
                const next = statements[i + 1];
                if ((next === null || next === void 0 ? void 0 : next.get()) instanceof _statement_1.Comment && next.concatTokens().includes("EC TEST_SEAM_USAGE")) {
                    continue;
                }
                message = "TEST-SEAM";
            }
            else if (this.conf.statics && statement instanceof Statements.Static && isStaticsBlock === false) {
                message = "STATICS";
            }
            else if (this.conf.break && statement instanceof Statements.Break) {
                message = "BREAK/BREAK-POINT";
                fix = this.conf.skipQuickFix === true ? undefined : edit_helper_1.EditHelper.deleteStatement(file, statementNode);
            }
            if (message) {
                issues.push(issue_1.Issue.atStatement(file, statementNode, this.getDescription(message), this.getMetadata().key, this.conf.severity, fix));
            }
            if (this.conf.defaultKey
                && (this.reg.getConfig().getVersion() >= version_1.Version.v740sp02
                    || this.reg.getConfig().getVersion() === version_1.Version.Cloud)
                && (statement instanceof Statements.Data || statement instanceof Statements.Type)) {
                const tt = (_a = statementNode.findFirstExpression(expressions_1.TypeTable)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(expressions_1.TypeTableKey);
                const token = tt === null || tt === void 0 ? void 0 : tt.findDirectTokenByText("DEFAULT");
                if (tt && token) {
                    const next = statements[i + 1];
                    if ((next === null || next === void 0 ? void 0 : next.get()) instanceof _statement_1.Comment && next.concatTokens().includes("EC DEFAULT_KEY")) {
                        continue;
                    }
                    message = "DEFAULT KEY";
                    issues.push(issue_1.Issue.atToken(file, token, this.getDescription(message), this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
    getDescribeLinesFix(file, statementNode) {
        const children = statementNode.getChildren();
        const target = children[4].concatTokens();
        const source = children[2].concatTokens();
        const startPosition = children[0].getFirstToken().getStart();
        const insertText = target + " = lines( " + source + " ).";
        const deleteFix = edit_helper_1.EditHelper.deleteStatement(file, statementNode);
        const insertFix = edit_helper_1.EditHelper.insertAt(file, startPosition, insertText);
        const finalFix = edit_helper_1.EditHelper.merge(deleteFix, insertFix);
        return finalFix;
    }
}
exports.AvoidUse = AvoidUse;
//# sourceMappingURL=avoid_use.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/begin_end_names.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/begin_end_names.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeginEndNames = exports.BeginEndNamesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class BeginEndNamesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.BeginEndNamesConf = BeginEndNamesConf;
class BeginEndNames extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new BeginEndNamesConf();
    }
    getMetadata() {
        return {
            key: "begin_end_names",
            title: "Check BEGIN END names",
            shortDescription: `Check BEGIN OF and END OF names match, plus there must be statements between BEGIN and END`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `DATA: BEGIN OF stru,
        field TYPE i,
      END OF structure_not_the_same.`,
            goodExample: `DATA: BEGIN OF stru,
        field TYPE i,
      END OF stru.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const output = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        const containsUnknown = file.getStatements().some(s => s.get() instanceof _statement_1.Unknown);
        if (containsUnknown === true) {
            return [];
        }
        output.push(...this.test(struc, Structures.Data, Statements.DataBegin, Statements.DataEnd, file));
        output.push(...this.test(struc, Structures.ClassData, Statements.ClassDataBegin, Statements.ClassDataEnd, file));
        output.push(...this.test(struc, Structures.Constants, Statements.ConstantBegin, Statements.ConstantEnd, file));
        output.push(...this.test(struc, Structures.Statics, Statements.StaticBegin, Statements.StaticEnd, file));
        output.push(...this.test(struc, Structures.TypeEnum, Statements.TypeEnumBegin, Statements.TypeEnumEnd, file));
        output.push(...this.test(struc, Structures.Types, Statements.TypeBegin, Statements.TypeEnd, file));
        return output;
    }
    test(stru, type, b, e, file) {
        const output = [];
        for (const sub of stru.findAllStructuresRecursive(type)) {
            let begin = sub.findDirectStatements(b)[0].findFirstExpression(Expressions.NamespaceSimpleName);
            if (begin === undefined) {
                begin = sub.findDirectStatements(b)[0].findFirstExpression(Expressions.DefinitionName);
            }
            if (begin === undefined) {
                continue;
            }
            const first = begin.getFirstToken();
            let end = sub.findDirectStatements(e)[0].findFirstExpression(Expressions.NamespaceSimpleName);
            if (end === undefined) {
                end = sub.findDirectStatements(e)[0].findFirstExpression(Expressions.DefinitionName);
            }
            if (end === undefined) {
                continue;
            }
            const last = end.getFirstToken();
            if (first.getStr().toUpperCase() !== last.getStr().toUpperCase()) {
                const fix = edit_helper_1.EditHelper.replaceRange(file, last.getStart(), last.getEnd(), first.getStr());
                const message = "BEGIN END names must match";
                const issue = issue_1.Issue.atToken(file, first, message, this.getMetadata().key, this.conf.severity, fix);
                output.push(issue);
            }
            if (sub.getChildren().length === 2) {
                const message = "There must be statements between BEGIN and END";
                const issue = issue_1.Issue.atToken(file, first, message, this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        return output;
    }
}
exports.BeginEndNames = BeginEndNames;
//# sourceMappingURL=begin_end_names.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/begin_single_include.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/begin_single_include.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.BeginSingleInclude = exports.BeginSingleIncludeConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class BeginSingleIncludeConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.BeginSingleIncludeConf = BeginSingleIncludeConf;
class BeginSingleInclude extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new BeginSingleIncludeConf();
    }
    getMetadata() {
        return {
            key: "begin_single_include",
            title: "BEGIN contains single INCLUDE",
            shortDescription: `Finds TYPE BEGIN with just one INCLUDE TYPE, and DATA with single INCLUDE STRUCTURE`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `TYPES: BEGIN OF dummy1.
  INCLUDE TYPE dselc.
TYPES: END OF dummy1.

DATA BEGIN OF foo.
INCLUDE STRUCTURE syst.
DATA END OF foo.

STATICS BEGIN OF bar.
INCLUDE STRUCTURE syst.
STATICS END OF bar.`,
            goodExample: `DATA BEGIN OF foo.
  DATA field TYPE i.
  INCLUDE STRUCTURE dselc.
DATA END OF foo.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const t of stru.findAllStructures(Structures.Types)) {
            if (t.getChildren().length !== 3) {
                continue;
            }
            if (t.findFirstStatement(Statements.IncludeType)) {
                const token = t.getFirstToken();
                const message = "TYPE BEGIN with single INCLUDE";
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        for (const t of stru.findAllStructures(Structures.Data)) {
            if (t.getChildren().length !== 3) {
                continue;
            }
            if (t.findFirstStatement(Statements.IncludeType)) {
                const token = t.getFirstToken();
                const message = "DATA BEGIN with single INCLUDE";
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        for (const t of stru.findAllStructures(Structures.Statics)) {
            if (t.getChildren().length !== 3) {
                continue;
            }
            if (t.findFirstStatement(Statements.IncludeType)) {
                const token = t.getFirstToken();
                const message = "STATICS BEGIN with single INCLUDE";
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.BeginSingleInclude = BeginSingleInclude;
//# sourceMappingURL=begin_single_include.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/call_transaction_authority_check.js":
/*!*****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/call_transaction_authority_check.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CallTransactionAuthorityCheck = exports.CallTransactionAuthorityCheckConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class CallTransactionAuthorityCheckConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CallTransactionAuthorityCheckConf = CallTransactionAuthorityCheckConf;
class CallTransactionAuthorityCheck extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CallTransactionAuthorityCheckConf();
        this.MINIMUM_VERSION = version_1.Version.v740sp02;
    }
    getMetadata() {
        return {
            key: "call_transaction_authority_check",
            title: "Call Transaction Authority-Check",
            shortDescription: `Checks that usages of CALL TRANSACTION contain an authority-check.`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/54/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Security],
            badExample: `CALL TRANSACTION 'FOO'.`,
            goodExample: `TRY.
    CALL TRANSACTION 'FOO' WITH AUTHORITY-CHECK.
  CATCH cx_sy_authorization_error.
ENDTRY.`,
        };
    }
    getMessage() {
        return "Add an authority check to CALL TRANSACTION";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const currentVersion = this.reg.getConfig().getVersion();
        // Cloud version does not support CALL TRANSACTION
        if (currentVersion < this.MINIMUM_VERSION || currentVersion === version_1.Version.Cloud) {
            return [];
        }
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        for (const statNode of file.getStatements()) {
            const statement = statNode.get();
            if (statement instanceof Statements.CallTransaction && !statNode.concatTokensWithoutStringsAndComments().toUpperCase().includes("WITH AUTHORITY-CHECK")) {
                issues.push(issue_1.Issue.atStatement(file, statNode, this.getMessage(), this.getMetadata().key));
            }
        }
        return issues;
    }
}
exports.CallTransactionAuthorityCheck = CallTransactionAuthorityCheck;
//# sourceMappingURL=call_transaction_authority_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cds_comment_style.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cds_comment_style.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSCommentStyle = exports.CDSCommentStyleConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const cds_lexer_1 = __webpack_require__(/*! ../cds/cds_lexer */ "./node_modules/@abaplint/core/build/src/cds/cds_lexer.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
class CDSCommentStyleConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CDSCommentStyleConf = CDSCommentStyleConf;
class CDSCommentStyle {
    constructor() {
        this.conf = new CDSCommentStyleConf();
    }
    getMetadata() {
        return {
            key: "cds_comment_style",
            title: "CDS Comment Style",
            shortDescription: `Check for obsolete comment style`,
            extendedInformation: `Check for obsolete comment style

Comments starting with "--" are considered obsolete

https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abencds_general_syntax_rules.htm`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: "-- this is a comment",
            goodExample: "// this is a comment",
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(object) {
        const issues = [];
        if ((object.getType() === "DDLS" && object instanceof objects_1.DataDefinition) ||
            (object.getType() === "DDLX" && object instanceof objects_1.CDSMetadataExtension)) {
            const file = object.findSourceFile();
            if (file === undefined) {
                return issues;
            }
            const tokens = cds_lexer_1.CDSLexer.run(file);
            for (const t of tokens) {
                if (t instanceof tokens_1.Comment && t.getStr().startsWith("--")) {
                    issues.push(issue_1.Issue.atToken(file, t, `Use "//" for comments instead of "--"`, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return issues;
    }
}
exports.CDSCommentStyle = CDSCommentStyle;
//# sourceMappingURL=cds_comment_style.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cds_legacy_view.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cds_legacy_view.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSLegacyView = exports.CDSLegacyViewConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class CDSLegacyViewConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CDSLegacyViewConf = CDSLegacyViewConf;
class CDSLegacyView {
    constructor() {
        this.conf = new CDSLegacyViewConf();
    }
    getMetadata() {
        return {
            key: "cds_legacy_view",
            title: "CDS Legacy View",
            shortDescription: `Identify CDS Legacy Views`,
            extendedInformation: `Use DEFINE VIEW ENTITY instead of DEFINE VIEW

https://blogs.sap.com/2021/10/16/a-new-generation-of-cds-views-how-to-migrate-your-cds-views-to-cds-view-entities/

v755 and up`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Upport],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(o) {
        const issues = [];
        if (this.reg.getConfig().getVersion() < version_1.Version.v755
            && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        if (o.getType() !== "DDLS") {
            return [];
        }
        if (o instanceof objects_1.DataDefinition) {
            const tree = o.getTree();
            if (tree === undefined) {
                return []; // parser error
            }
            if (tree.findDirectTokenByText("ENTITY") === undefined) {
                const file = o.findSourceFile();
                if (file) {
                    issues.push(issue_1.Issue.atRow(file, 1, "CDS Legacy View", this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return issues;
    }
}
exports.CDSLegacyView = CDSLegacyView;
//# sourceMappingURL=cds_legacy_view.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cds_parser_error.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cds_parser_error.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CDSParserError = exports.CDSParserErrorConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class CDSParserErrorConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CDSParserErrorConf = CDSParserErrorConf;
class CDSParserError {
    constructor() {
        this.conf = new CDSParserErrorConf();
    }
    getMetadata() {
        return {
            key: "cds_parser_error",
            title: "CDS Parser Error",
            shortDescription: `CDS parsing`,
            extendedInformation: `Parses CDS and issues parser errors`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(object) {
        const issues = [];
        if ((object.getType() === "DDLS" && object instanceof objects_1.DataDefinition) ||
            (object.getType() === "DDLX" && object instanceof objects_1.CDSMetadataExtension)) {
            const hasError = object.hasParserError();
            const file = object.findSourceFile();
            if (hasError === true && file) {
                issues.push(issue_1.Issue.atRow(file, 1, "CDS Parser error", this.getMetadata().key, this.getConfig().severity));
            }
        }
        return issues;
    }
}
exports.CDSParserError = CDSParserError;
//# sourceMappingURL=cds_parser_error.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/chain_mainly_declarations.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/chain_mainly_declarations.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChainMainlyDeclarations = exports.ChainMainlyDeclarationsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class ChainMainlyDeclarationsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow definition statements to be chained */
        this.definitions = true;
        /** Allow WRITE statements to be chained */
        this.write = true;
        /** Allow MOVE statements to be chained */
        this.move = true;
        /** Allow REFRESH statements to be chained */
        this.refresh = true;
        /** Allow UNASSIGN statements to be chained */
        this.unassign = true;
        /** Allow CLEAR statements to be chained */
        this.clear = true;
        /** Allow HIDE statements to be chained */
        this.hide = true;
        /** Allow FREE statements to be chained */
        this.free = true;
        /** Allow INCLUDE statements to be chained */
        this.include = true;
        /** Allow CHECK statements to be chained */
        this.check = true;
        /** Allow SORT statements to be chained */
        this.sort = true;
    }
}
exports.ChainMainlyDeclarationsConf = ChainMainlyDeclarationsConf;
class ChainMainlyDeclarations extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ChainMainlyDeclarationsConf();
    }
    getMetadata() {
        return {
            key: "chain_mainly_declarations",
            title: "Chain mainly declarations",
            shortDescription: `Chain mainly declarations, allows chaining for the configured statements, reports errors for other statements.`,
            extendedInformation: `
https://docs.abapopenchecks.org/checks/23/

https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abenchained_statements_guidl.htm
`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `CALL METHOD: bar.`,
            goodExample: `CALL METHOD bar.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        let previousRow;
        for (const statementNode of structure.findAllStatementNodes()) {
            const colon = statementNode.getColon();
            if (colon === undefined) {
                continue;
            }
            const statement = statementNode.get();
            if (this.conf.definitions === true
                && (statement instanceof Statements.ClassData
                    || statement instanceof Statements.ClassDataBegin
                    || statement instanceof Statements.ClassDataEnd
                    || statement instanceof Statements.Static
                    || statement instanceof Statements.StaticBegin
                    || statement instanceof Statements.StaticEnd
                    || statement instanceof Statements.Local
                    || statement instanceof Statements.Constant
                    || statement instanceof Statements.ConstantBegin
                    || statement instanceof Statements.ConstantEnd
                    || statement instanceof Statements.Controls
                    || statement instanceof Statements.Parameter
                    || statement instanceof Statements.SelectOption
                    || statement instanceof Statements.SelectionScreen
                    || statement instanceof Statements.Aliases
                    || statement instanceof Statements.Tables
                    || statement instanceof Statements.MethodDef
                    || statement instanceof Statements.InterfaceDef
                    || statement instanceof Statements.Type
                    || statement instanceof Statements.TypeBegin
                    || statement instanceof Statements.TypeEnd
                    || statement instanceof Statements.TypeEnumBegin
                    || statement instanceof Statements.TypeEnumEnd
                    || statement instanceof Statements.TypeEnum
                    || statement instanceof Statements.Events
                    || statement instanceof Statements.Ranges
                    || statement instanceof Statements.TypePools
                    || statement instanceof Statements.FieldSymbol
                    || statement instanceof Statements.Data
                    || statement instanceof Statements.DataBegin
                    || statement instanceof Statements.DataEnd)) {
                continue;
            }
            else if (this.conf.write === true && statement instanceof Statements.Write) {
                continue;
            }
            else if (this.conf.move === true && statement instanceof Statements.Move) {
                continue;
            }
            else if (this.conf.refresh === true && statement instanceof Statements.Refresh) {
                continue;
            }
            else if (this.conf.unassign === true && statement instanceof Statements.Unassign) {
                continue;
            }
            else if (this.conf.clear === true && statement instanceof Statements.Clear) {
                continue;
            }
            else if (this.conf.hide === true && statement instanceof Statements.Hide) {
                continue;
            }
            else if (this.conf.free === true && statement instanceof Statements.Free) {
                continue;
            }
            else if (this.conf.include === true && statement instanceof Statements.Include) {
                continue;
            }
            else if (this.conf.check === true && statement instanceof Statements.Check) {
                continue;
            }
            else if (this.conf.sort === true && statement instanceof Statements.Sort) {
                continue;
            }
            let prevFix;
            if (previousRow === colon.getStart().getRow()) {
                prevFix = (_a = issues.pop()) === null || _a === void 0 ? void 0 : _a.getDefaultFix();
            }
            const fix = this.getFix(file, statement, statementNode, prevFix);
            const message = "Chain mainly declarations";
            issues.push(issue_1.Issue.atToken(file, statementNode.getFirstToken(), message, this.getMetadata().key, this.conf.severity, fix));
            previousRow = statementNode.getColon().getStart().getRow();
        }
        return issues;
    }
    getFix(file, statement, statementNode, prevFix) {
        if (statement instanceof Statements.ClassDataBegin ||
            statement instanceof Statements.ClassDataEnd ||
            statement instanceof Statements.StaticBegin ||
            statement instanceof Statements.StaticEnd ||
            statement instanceof Statements.ConstantBegin ||
            statement instanceof Statements.ConstantEnd ||
            statement instanceof Statements.TypeBegin ||
            statement instanceof Statements.TypeEnd ||
            statement instanceof Statements.TypeEnumBegin ||
            statement instanceof Statements.TypeEnumEnd ||
            statement instanceof Statements.DataBegin ||
            statement instanceof Statements.DataEnd) {
            return undefined;
        }
        let replacement = statementNode.concatTokens();
        replacement = replacement.replace(",", ".");
        let start;
        if (prevFix === undefined) {
            start = statementNode.getStart();
        }
        else {
            start = statementNode.getTokens()[1].getStart();
        }
        let fix = edit_helper_1.EditHelper.replaceRange(file, start, statementNode.getEnd(), replacement);
        if (prevFix !== undefined) {
            fix = edit_helper_1.EditHelper.merge(fix, prevFix);
        }
        return fix;
    }
}
exports.ChainMainlyDeclarations = ChainMainlyDeclarations;
//# sourceMappingURL=chain_mainly_declarations.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/change_if_to_case.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/change_if_to_case.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ChangeIfToCase = exports.ChangeIfToCaseConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ChangeIfToCaseConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** skip specific names, case insensitive regular expression
         * @uniqueItems true
         */
        this.skipNames = [];
    }
}
exports.ChangeIfToCaseConf = ChangeIfToCaseConf;
class ChangeIfToCase extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ChangeIfToCaseConf();
    }
    getMetadata() {
        return {
            key: "change_if_to_case",
            title: "Change IF to CASE",
            shortDescription: `Finds IF constructs that can be changed to CASE`,
            // eslint-disable-next-line max-len
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-case-to-else-if-for-multiple-alternative-conditions

If the first comparison is a boolean compare, no issue is reported.`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `IF l_fcat-fieldname EQ 'FOO'.
ELSEIF l_fcat-fieldname = 'BAR'
    OR l_fcat-fieldname = 'MOO'.
ENDIF.`,
            goodExample: `CASE l_fcat-fieldname.
  WHEN 'FOO'.
  WHEN 'BAR' OR 'MOO'.
ENDCASE.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues;
        }
        for (const i of stru.findAllStructuresRecursive(Structures.If)) {
            const conds = [];
            const ifStatement = i.findDirectStatement(Statements.If);
            if (ifStatement === undefined) {
                continue;
            }
            if (ifStatement.concatTokens().match(/ (abap_true|abap_false)\s*\./i)) {
                continue;
            }
            conds.push(ifStatement === null || ifStatement === void 0 ? void 0 : ifStatement.findDirectExpression(Expressions.Cond));
            for (const ei of i.findDirectStructures(Structures.ElseIf)) {
                conds.push((_a = ei.findDirectStatement(Statements.ElseIf)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Cond));
            }
            if (conds.length === 1) {
                continue;
            }
            const issue = this.analyze(conds);
            if (issue === true) {
                const message = "Change IF to CASE";
                issues.push(issue_1.Issue.atStatement(file, ifStatement, message, this.getMetadata().key, this.getConfig().severity));
            }
        }
        return issues;
    }
    analyze(conds) {
        var _a, _b, _c, _d, _e;
        const tuples = [];
        for (const c of conds) {
            if (c === undefined) {
                continue;
            }
            if (c.findFirstExpression(Expressions.CondSub)) {
                return false;
            }
            else if (c.findDirectTokenByText("AND") || c.findDirectTokenByText("EQUIV")) {
                return false;
            }
            for (const compare of c.findAllExpressions(Expressions.Compare)) {
                const op = (_a = compare.findDirectExpression(Expressions.CompareOperator)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
                if (compare.getChildren().length !== 3) {
                    return false;
                }
                else if (op !== "=" && op !== "EQ") {
                    return false;
                }
                const left = (_c = (_b = compare.getChildren()[0]) === null || _b === void 0 ? void 0 : _b.concatTokens()) === null || _c === void 0 ? void 0 : _c.toUpperCase();
                const right = (_e = (_d = compare.getChildren()[2]) === null || _d === void 0 ? void 0 : _d.concatTokens()) === null || _e === void 0 ? void 0 : _e.toUpperCase();
                tuples.push({ left, right });
            }
        }
        if (tuples.length === 1) {
            return false;
        }
        let chain = "";
        if (tuples[0].left === tuples[1].left) {
            chain = tuples[0].left;
        }
        else if (tuples[0].left === tuples[1].right) {
            chain = tuples[0].left;
        }
        else if (tuples[0].right === tuples[1].right) {
            chain = tuples[0].right;
        }
        else if (tuples[0].right === tuples[1].left) {
            chain = tuples[0].right;
        }
        else {
            return false;
        }
        for (const skip of this.getConfig().skipNames || []) {
            const reg = new RegExp(skip, "i");
            if (chain.match(reg)) {
                return false;
            }
        }
        for (const t of tuples) {
            if (t.left !== chain && t.right !== chain) {
                return false;
            }
        }
        return true;
    }
}
exports.ChangeIfToCase = ChangeIfToCase;
//# sourceMappingURL=change_if_to_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_abstract.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_abstract.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckAbstract = exports.CheckAbstractConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class CheckAbstractConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckAbstractConf = CheckAbstractConf;
var IssueType;
(function (IssueType) {
    /** Abstract method defined in non-abstract class */
    IssueType[IssueType["NotAbstractClass"] = 0] = "NotAbstractClass";
    IssueType[IssueType["AbstractAndFinal"] = 1] = "AbstractAndFinal";
})(IssueType || (IssueType = {}));
class CheckAbstract extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CheckAbstractConf();
    }
    getMetadata() {
        return {
            key: "check_abstract",
            title: "Check abstract methods and classes",
            shortDescription: `Checks abstract methods and classes:
- class defined as abstract and final,
- non-abstract class contains abstract methods`,
            extendedInformation: `If a class defines only constants, use an interface instead`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(issueType, name) {
        switch (issueType) {
            case IssueType.AbstractAndFinal:
                return "Classes should not be ABSTRACT and FINAL: " + name;
            case IssueType.NotAbstractClass:
                return "Abstract methods require abstract classes: " + name;
            default:
                return "";
        }
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const classDef of file.getInfo().listClassDefinitions()) {
            if (classDef.isAbstract === true) {
                if (classDef.isFinal === true && classDef.isForTesting === false) {
                    issues.push(issue_1.Issue.atIdentifier(classDef.identifier, this.getDescription(IssueType.AbstractAndFinal, classDef.name), this.getMetadata().key, this.conf.severity));
                }
                continue;
            }
            for (const methodDef of classDef.methods) {
                if (methodDef.isAbstract === true) {
                    issues.push(issue_1.Issue.atIdentifier(methodDef.identifier, this.getDescription(IssueType.NotAbstractClass, methodDef.name), this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
}
exports.CheckAbstract = CheckAbstract;
//# sourceMappingURL=check_abstract.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_comments.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_comments.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckComments = exports.CheckCommentsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class CheckCommentsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allows the use of end-of-line comments. */
        this.allowEndOfLine = false;
    }
}
exports.CheckCommentsConf = CheckCommentsConf;
var IssueType;
(function (IssueType) {
    IssueType[IssueType["EndOfLine"] = 0] = "EndOfLine";
})(IssueType || (IssueType = {}));
class CheckComments extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CheckCommentsConf();
    }
    getMetadata() {
        return {
            key: "check_comments",
            title: "Check Comments",
            shortDescription: `
Various checks for comment usage.`,
            extendedInformation: `
Detects end of line comments. Comments starting with "#EC" or "##" are ignored

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#put-comments-before-the-statement-they-relate-to`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE 2. " descriptive comment`,
            goodExample: `" descriptive comment\nWRITE 2.`,
        };
    }
    getDescription(issueType) {
        switch (issueType) {
            case IssueType.EndOfLine: return `Do not use end of line comments - move comment to previous row instead`;
            default: return "";
        }
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const rows = file.getRawRows();
        if (this.conf.allowEndOfLine === true) {
            return [];
        }
        const commentRows = [];
        for (let i = 0; i < rows.length; i++) {
            const row = rows[i];
            if (row.trim().startsWith("*") || row.trim().startsWith(`"`)) {
                commentRows.push(i);
            }
        }
        const statements = file.getStatements();
        for (let i = statements.length - 1; i >= 0; i--) {
            const statement = statements[i];
            if (statement.get() instanceof _statement_1.Comment && !commentRows.includes(statement.getStart().getRow() - 1)) {
                if (statement.getFirstToken().getStr().startsWith(`"#EC`)
                    || statement.getFirstToken().getStr().startsWith(`"##`)) {
                    continue;
                }
                issues.push(issue_1.Issue.atStatement(file, statement, this.getDescription(IssueType.EndOfLine), this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.CheckComments = CheckComments;
//# sourceMappingURL=check_comments.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_ddic.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_ddic.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckDDIC = exports.CheckDDICConf = void 0;
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
class CheckDDICConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckDDICConf = CheckDDICConf;
class CheckDDIC {
    constructor() {
        this.conf = new CheckDDICConf();
    }
    getMetadata() {
        return {
            key: "check_ddic",
            title: "Check DDIC",
            // eslint-disable-next-line max-len
            shortDescription: `Checks the types of DDIC objects can be resolved, the namespace of the development/errors can be configured in "errorNamespace" `,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        let found = undefined;
        if (obj instanceof Objects.DataElement
            || obj instanceof Objects.Domain
            || obj instanceof Objects.Table
            || obj instanceof Objects.View
            || obj instanceof Objects.AuthorizationCheckField
            || obj instanceof Objects.LockObject
            || obj instanceof Objects.MaintenanceAndTransportObject
            || obj instanceof Objects.TableType) {
            found = obj.parseType(this.reg);
        }
        else {
            return [];
        }
        return this.check(found, obj);
    }
    check(found, obj) {
        const ret = [];
        if (found instanceof basic_1.UnknownType) {
            const position = new position_1.Position(1, 1);
            const message = "Unknown/un-resolveable type in " + obj.getName() + ": " + found.getError();
            ret.push(issue_1.Issue.atPosition(obj.getFiles()[0], position, message, this.getMetadata().key, this.conf.severity));
        }
        else if (found instanceof basic_1.StructureType) {
            // assumption: no circular types
            for (const c of found.getComponents()) {
                ret.push(...this.check(c.type instanceof _typed_identifier_1.TypedIdentifier ? c.type.getType() : c.type, obj));
            }
        }
        else if (found instanceof basic_1.TableType) {
            ret.push(...this.check(found.getRowType(), obj));
        }
        // todo, reference types?
        return ret;
    }
}
exports.CheckDDIC = CheckDDIC;
//# sourceMappingURL=check_ddic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_include.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_include.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckInclude = exports.CheckIncludeConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const include_graph_1 = __webpack_require__(/*! ../utils/include_graph */ "./node_modules/@abaplint/core/build/src/utils/include_graph.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class CheckIncludeConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckIncludeConf = CheckIncludeConf;
class CheckInclude {
    constructor() {
        this.conf = new CheckIncludeConf();
    }
    getMetadata() {
        return {
            key: "check_include",
            title: "Check INCLUDEs",
            shortDescription: `Checks INCLUDE statements`,
            extendedInformation: `
* Reports unused includes
* Errors if the includes are not found
* Error if including a main program`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        this.graph = new include_graph_1.IncludeGraph(this.reg);
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        let ret = [];
        for (const file of obj.getABAPFiles()) {
            ret = ret.concat(this.graph.getIssuesFile(file));
        }
        return ret;
    }
}
exports.CheckInclude = CheckInclude;
//# sourceMappingURL=check_include.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_subrc.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_subrc.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckSubrc = exports.CheckSubrcConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class CheckSubrcConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.openDataset = true;
        this.authorityCheck = true;
        this.selectSingle = true;
        this.selectTable = true;
        this.updateDatabase = true;
        this.insertDatabase = true;
        this.modifyDatabase = true;
        this.readTable = true;
        this.assign = true;
        this.find = true;
    }
}
exports.CheckSubrcConf = CheckSubrcConf;
class CheckSubrc extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CheckSubrcConf();
    }
    getMetadata() {
        return {
            key: "check_subrc",
            title: "Check sy-subrc",
            shortDescription: `Check sy-subrc`,
            extendedInformation: `Pseudo comment "#EC CI_SUBRC can be added to suppress findings

If sy-dbcnt is checked after database statements, it is considered okay.

"SELECT SINGLE @abap_true FROM " is considered as an existence check, also "SELECT COUNT( * )" is considered okay

If IS ASSIGNED is checked after assigning, it is considered okay.

FIND statement with MATCH COUNT is considered okay if subrc is not checked`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            pseudoComment: "EC CI_SUBRC",
            pragma: "##SUBRC_OK",
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    buildFix(file, statement) {
        return {
            description: "Add ##SUBRC_OK",
            edit: edit_helper_1.EditHelper.insertAt(file, statement.getLastToken().getStart(), " ##SUBRC_OK"),
        };
    }
    runParsed(file) {
        const issues = [];
        const statements = file.getStatements();
        const message = "Check sy-subrc";
        const config = this.getConfig();
        for (let i = 0; i < statements.length; i++) {
            const statement = statements[i];
            // todo: CALL FUNCTION
            if (statement.getPragmas().some(t => t.getStr() === this.getMetadata().pragma)) {
                continue;
            }
            if (config.openDataset === true
                && statement.get() instanceof Statements.OpenDataset
                && this.isChecked(i, statements) === false) {
                // it doesnt make sense to ignore the subrc for open dataset, so no quick fix
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity));
            }
            else if (config.authorityCheck === true
                && statement.get() instanceof Statements.AuthorityCheck
                && this.isChecked(i, statements) === false) {
                // it doesnt make sense to ignore the subrc for authority checks, so no quick fix
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity));
            }
            else if (config.selectSingle === true
                && statement.get() instanceof Statements.Select
                && statement.concatTokens().toUpperCase().startsWith("SELECT SINGLE ")
                && this.isChecked(i, statements) === false
                && this.checksDbcnt(i, statements) === false) {
                const concat = statement.concatTokens().toUpperCase();
                if (concat.startsWith("SELECT SINGLE @ABAP_TRUE FROM ")) {
                    continue;
                }
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.selectTable === true
                && statement.get() instanceof Statements.Select
                && statement.concatTokens().toUpperCase().startsWith("SELECT SINGLE ") === false
                && statement.concatTokens().toUpperCase().startsWith("SELECT COUNT( * ) ") === false
                && statement.concatTokens().toUpperCase().startsWith("SELECT COUNT(*) ") === false
                && this.isChecked(i, statements) === false
                && this.checksDbcnt(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.updateDatabase === true
                && statement.get() instanceof Statements.UpdateDatabase
                && this.isChecked(i, statements) === false
                && this.checksDbcnt(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.insertDatabase === true
                && statement.get() instanceof Statements.InsertDatabase
                && this.isChecked(i, statements) === false
                && this.checksDbcnt(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.modifyDatabase === true
                && statement.get() instanceof Statements.ModifyDatabase
                && this.isChecked(i, statements) === false
                && this.checksDbcnt(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.readTable === true
                && statement.get() instanceof Statements.ReadTable
                && this.isChecked(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.assign === true
                && statement.get() instanceof Statements.Assign
                && this.isSimpleAssign(statement) === false
                && this.isChecked(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
            else if (config.find === true
                && statement.get() instanceof Statements.Find
                && this.isExemptedFind(statement) === false
                && this.isChecked(i, statements) === false) {
                const fix = this.buildFix(file, statement);
                issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, undefined, [fix]));
            }
        }
        return issues;
    }
    ////////////////
    isSimpleAssign(statement) {
        if (statement.getChildren().length === 5) {
            const source = statement.findDirectExpression(Expressions.AssignSource);
            if ((source === null || source === void 0 ? void 0 : source.getChildren().length) === 1
                && source.findDirectExpression(Expressions.Source) !== undefined) {
                return true;
            }
        }
        return false;
    }
    isExemptedFind(s) {
        // see https://github.com/abaplint/abaplint/issues/2130
        return s.concatTokens().toUpperCase().includes(" MATCH COUNT ") === true;
    }
    checksDbcnt(index, statements) {
        for (let i = index + 1; i < statements.length; i++) {
            const statement = statements[i];
            const concat = statement.concatTokens().toUpperCase();
            if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            else if (statement.get() instanceof Statements.EndIf
                || statement.get() instanceof Statements.EndTestSeam) {
                continue;
            }
            else {
                return concat.includes("SY-DBCNT");
            }
        }
        return false;
    }
    isChecked(index, statements) {
        var _a, _b;
        let assigned = undefined;
        let assignedn = undefined;
        if (statements[index].get() instanceof Statements.Assign
            || statements[index].get() instanceof Statements.ReadTable) {
            const fs = (_b = (_a = statements[index].findFirstExpression(Expressions.FSTarget)) === null || _a === void 0 ? void 0 : _a.findFirstExpression(Expressions.FieldSymbol)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr();
            assigned = (fs === null || fs === void 0 ? void 0 : fs.toUpperCase()) + " IS ASSIGNED";
            assignedn = (fs === null || fs === void 0 ? void 0 : fs.toUpperCase()) + " IS NOT ASSIGNED";
        }
        for (let i = index + 1; i < statements.length; i++) {
            const statement = statements[i];
            const concat = statement.concatTokens().toUpperCase();
            if (statement.get() instanceof _statement_1.Comment) {
                if (concat.includes("" + this.getMetadata().pseudoComment)) {
                    return true;
                }
            }
            else if (statement.get() instanceof Statements.EndIf
                || statement.get() instanceof Statements.EndTestSeam) {
                continue;
            }
            else {
                if (assigned && concat.includes(assigned)) {
                    return true;
                }
                if (assignedn && concat.includes(assignedn)) {
                    return true;
                }
                return concat.includes(" SY-SUBRC")
                    || concat.includes("CL_ABAP_UNIT_ASSERT=>ASSERT_SUBRC");
            }
        }
        return false;
    }
}
exports.CheckSubrc = CheckSubrc;
//# sourceMappingURL=check_subrc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_syntax.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_syntax.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckSyntax = exports.CheckSyntaxConf = void 0;
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const severity_1 = __webpack_require__(/*! ../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
const _syntax_input_1 = __webpack_require__(/*! ../abap/5_syntax/_syntax_input */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_syntax_input.js");
class CheckSyntaxConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckSyntaxConf = CheckSyntaxConf;
class CheckSyntax {
    constructor() {
        this.conf = new CheckSyntaxConf();
    }
    getMetadata() {
        return {
            key: _syntax_input_1.CheckSyntaxKey,
            title: "Check syntax",
            shortDescription: `Enables syntax check and variable resolution`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const issues = new syntax_1.SyntaxLogic(this.reg, obj).run().issues;
        // the syntax logic does not know the rule severity when its run
        if (this.conf.severity
            && this.conf.severity !== severity_1.Severity.Error) {
            issues.forEach((value, index) => {
                const data = value.getData();
                data.severity = this.conf.severity;
                issues[index] = new issue_1.Issue(data);
            });
        }
        return issues;
    }
}
exports.CheckSyntax = CheckSyntax;
//# sourceMappingURL=check_syntax.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_text_elements.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_text_elements.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckTextElements = exports.CheckTextElementsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const include_graph_1 = __webpack_require__(/*! ../utils/include_graph */ "./node_modules/@abaplint/core/build/src/utils/include_graph.js");
class CheckTextElementsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckTextElementsConf = CheckTextElementsConf;
class CheckTextElements {
    constructor() {
        this.conf = new CheckTextElementsConf();
    }
    getMetadata() {
        return {
            key: "check_text_elements",
            title: "Check text elements",
            shortDescription: `Check text elements exists or matches code`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        this.graph = new include_graph_1.IncludeGraph(this.reg);
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const output = [];
        for (const file of obj.getABAPFiles()) {
            const stru = file.getStructure();
            if (stru === undefined) {
                continue;
            }
            let texts;
            let mainName = undefined;
            const expressions = stru.findAllExpressionsMulti([Expressions.TextElement, Expressions.TextElementString]);
            // optimize: no need to find main and texts if there are no expressions to check
            if (expressions.length > 0) {
                const mains = this.graph.listMainForInclude(file.getFilename());
                if (mains.length === 1) {
                    // todo, this only checks the first main
                    mainName = mains[0];
                    const main1 = this.reg.findObjectForFile(this.reg.getFileByName(mains[0]));
                    texts = main1.getTexts();
                }
                else {
                    texts = obj.getTexts();
                }
            }
            for (const e of expressions) {
                if (e.get() instanceof Expressions.TextElement) {
                    const token = e.findFirstExpression(Expressions.TextElementKey).getFirstToken();
                    const key = token.getStr().toUpperCase();
                    if (texts[key] === undefined) {
                        const message = `Text element "${key}" not found` + (mainName ? ", " + mainName : "");
                        output.push(issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity));
                    }
                }
                else {
                    // its a Expressions.TextElementString
                    const token = e.findFirstExpression(Expressions.TextElementKey).getFirstToken();
                    const code = e.getFirstToken().getStr();
                    const key = token.getStr().toUpperCase();
                    let found = texts[key];
                    if (found && code.startsWith("'")) {
                        found = found.replace(/'/g, "''");
                    }
                    if (found === undefined) {
                        const message = `Text element "${key}" not found` + (mainName ? ", " + mainName : "");
                        output.push(issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity));
                    }
                    else if (code !== "'" + found + "'"
                        && code !== "`" + found + "`") {
                        output.push(issue_1.Issue.atToken(file, token, "Text does not match text element", this.getMetadata().key, this.conf.severity));
                    }
                }
            }
        }
        return output;
    }
}
exports.CheckTextElements = CheckTextElements;
//# sourceMappingURL=check_text_elements.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/check_transformation_exists.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/check_transformation_exists.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CheckTransformationExists = exports.CheckTransformationExistsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class CheckTransformationExistsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CheckTransformationExistsConf = CheckTransformationExistsConf;
class CheckTransformationExists extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CheckTransformationExistsConf();
    }
    getMetadata() {
        return {
            key: "check_transformation_exists",
            title: "Check transformation exists",
            shortDescription: `Checks that used XSLT transformations exist.`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getDescription(name) {
        return "Transformation \"" + name + "\" not found";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const output = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        for (const s of file.getStatements()) {
            if (s.get() instanceof statements_1.CallTransformation) {
                const nameExpression = s.findFirstExpression(expressions_1.NamespaceSimpleName);
                if (nameExpression === undefined) {
                    continue;
                }
                const tok = nameExpression.getFirstToken();
                const name = tok.getStr();
                if (this.reg.inErrorNamespace(name) === true
                    && this.reg.getObject("XSLT", name) === undefined) {
                    const issue = issue_1.Issue.atToken(file, tok, this.getDescription(name), this.getMetadata().key);
                    output.push(issue);
                }
            }
        }
        return output;
    }
}
exports.CheckTransformationExists = CheckTransformationExists;
//# sourceMappingURL=check_transformation_exists.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/class_attribute_names.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/class_attribute_names.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassAttributeNames = exports.ClassAttributeNamesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _abap_file_information_1 = __webpack_require__(/*! ../abap/4_file_information/_abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class ClassAttributeNamesConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore global exception classes */
        this.ignoreExceptions = true;
        /** Ignore local classes */
        this.ignoreLocal = true;
        /** Ignore interfaces */
        this.ignoreInterfaces = false;
        /** The pattern for static variable names */
        this.statics = "^G._.+$";
        /** The pattern for instance variable names */
        this.instance = "^M._.+$";
        /** The pattern for constant variable names */
        this.constants = "";
    }
}
exports.ClassAttributeNamesConf = ClassAttributeNamesConf;
class ClassAttributeNames extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ClassAttributeNamesConf();
    }
    getMetadata() {
        return {
            key: "class_attribute_names",
            title: "Class attributes naming",
            shortDescription: `Allows you to enforce a pattern, such as a prefix, for class variable names.`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(actual, expected) {
        return this.conf.patternKind === "required" ?
            "Class attribute name \"" + actual + "\" does not match pattern " + expected :
            "Class attribute name \"" + actual + "\" must not match pattern " + expected;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        let issues = [];
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        let attributes = [];
        const ddic = new ddic_1.DDIC(this.reg);
        for (const classDef of file.getInfo().listClassDefinitions()) {
            if ((classDef.isLocal && this.conf.ignoreLocal)
                || (ddic.isException(classDef, obj) && this.conf.ignoreExceptions)) {
                continue;
            }
            attributes = attributes.concat(classDef.attributes);
        }
        if (this.conf.ignoreInterfaces === false) {
            for (const intfDef of file.getInfo().listInterfaceDefinitions()) {
                if (intfDef.isLocal && this.conf.ignoreLocal) {
                    continue;
                }
                attributes = attributes.concat(intfDef.attributes);
            }
        }
        issues = this.checkAttributes(attributes);
        return issues;
    }
    checkAttributes(attr) {
        if (attr === undefined) {
            return [];
        }
        let ret = [];
        for (const a of attr) {
            switch (a.level) {
                case _abap_file_information_1.AttributeLevel.Instance:
                    ret = ret.concat(this.checkName(a.identifier, this.conf.instance));
                    break;
                case _abap_file_information_1.AttributeLevel.Static:
                    ret = ret.concat(this.checkName(a.identifier, this.conf.statics));
                    break;
                case _abap_file_information_1.AttributeLevel.Constant:
                    ret = ret.concat(this.checkName(a.identifier, this.conf.constants));
                    break;
                default:
                    break;
            }
        }
        return ret;
    }
    checkName(attr, expected) {
        const ret = [];
        const regex = new RegExp(expected, "i");
        const name = attr.getName();
        if (name_validator_1.NameValidator.violatesRule(name, regex, this.conf)) {
            const issue = issue_1.Issue.atIdentifier(attr, this.getDescription(name, expected), this.getMetadata().key, this.conf.severity);
            ret.push(issue);
        }
        return ret;
    }
}
exports.ClassAttributeNames = ClassAttributeNames;
//# sourceMappingURL=class_attribute_names.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/classic_exceptions_overlap.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/classic_exceptions_overlap.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ClassicExceptionsOverlap = exports.ClassicExceptionsOverlapConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ClassicExceptionsOverlapConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ClassicExceptionsOverlapConf = ClassicExceptionsOverlapConf;
class ClassicExceptionsOverlap extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ClassicExceptionsOverlapConf();
    }
    getMetadata() {
        return {
            key: "classic_exceptions_overlap",
            title: "Classic exceptions overlap when catching",
            shortDescription: `Find overlapping classic exceptions`,
            extendedInformation: `When debugging its typically good to know exactly which exception is caught`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `CALL FUNCTION 'SOMETHING'
  EXCEPTIONS
    system_failure        = 1 MESSAGE lv_message
    communication_failure = 1 MESSAGE lv_message
    resource_failure      = 1
    OTHERS                = 1.`,
            goodExample: `CALL FUNCTION 'SOMETHING'
  EXCEPTIONS
    system_failure        = 1 MESSAGE lv_message
    communication_failure = 2 MESSAGE lv_message
    resource_failure      = 3
    OTHERS                = 4.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const output = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return []; // syntax error
        }
        for (const p of struc.findAllExpressions(Expressions.ParameterListExceptions)) {
            const set = new Set();
            for (const e of p.findAllExpressions(Expressions.ParameterException)) {
                const text = (_a = e.findDirectExpression(Expressions.Integer)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
                if (text === undefined) {
                    continue;
                }
                if (set.has(text)) {
                    const message = "Exception overlap, " + text;
                    const issue = issue_1.Issue.atToken(file, e.getFirstToken(), message, this.getMetadata().key, this.getConfig().severity);
                    output.push(issue);
                    break;
                }
                set.add(text);
            }
        }
        return output;
    }
}
exports.ClassicExceptionsOverlap = ClassicExceptionsOverlap;
//# sourceMappingURL=classic_exceptions_overlap.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cloud_types.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cloud_types.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CloudTypes = exports.CloudTypesConf = void 0;
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class CloudTypesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.CloudTypesConf = CloudTypesConf;
class CloudTypes {
    constructor() {
        this.conf = new CloudTypesConf();
    }
    getMetadata() {
        return {
            key: "cloud_types",
            title: "Check cloud types",
            shortDescription: `Checks that the package does not contain any object types unsupported in cloud ABAP.`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Syntax],
        };
    }
    getDescription(objectType) {
        return "Object type " + objectType + " not supported in cloud";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    static isCloud(obj) {
        return obj instanceof Objects.ApplicationJobCatalogEntry
            || obj instanceof Objects.ApplicationJobTemplate
            || obj instanceof Objects.AssignmentServiceToAuthorizationGroup
            || obj instanceof Objects.ATCCheckCategory
            || obj instanceof Objects.ATCCheckObject
            || obj instanceof Objects.ATCCheckVariant
            || obj instanceof Objects.AuthorizationCheckField
            || obj instanceof Objects.AuthorizationObject
            || obj instanceof Objects.AuthorizationObjectExtension
            || obj instanceof Objects.BehaviorDefinition
            || obj instanceof Objects.BusinessCatalog
            || obj instanceof Objects.BusinessCatalogAppAssignment
            || obj instanceof Objects.CDSMetadataExtension
            || obj instanceof Objects.Class
            || obj instanceof Objects.ApplicationLogObject
            || obj instanceof Objects.CommunicationScenario
            || obj instanceof Objects.DataControl
            || obj instanceof Objects.DataDefinition
            || obj instanceof Objects.DataElement
            || obj instanceof Objects.Domain
            || obj instanceof Objects.EventBinding
            || obj instanceof Objects.EventConsumer
            || obj instanceof Objects.FunctionGroup
            || obj instanceof Objects.HttpService
            || obj instanceof Objects.IAMApp
            || obj instanceof Objects.InboundService
            || obj instanceof Objects.Interface
            || obj instanceof Objects.LockObject
            || obj instanceof Objects.MessageClass
            || obj instanceof Objects.NumberRange
            || obj instanceof Objects.OutboundService
            || obj instanceof Objects.Package
            || obj instanceof Objects.RestrictionField
            || obj instanceof Objects.RestrictionType
            || obj instanceof Objects.ServiceBinding
            || obj instanceof Objects.ServiceDefinition
            || obj instanceof Objects.Table
            || obj instanceof Objects.TableType
            || obj instanceof Objects.Transformation;
    }
    run(obj) {
        if (this.reg.getConfig().getVersion() !== version_1.Version.Cloud || CloudTypes.isCloud(obj)) {
            return [];
        }
        const position = new position_1.Position(1, 1);
        const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, this.getDescription(obj.getType()), this.getMetadata().key, this.conf.severity);
        return [issue];
    }
}
exports.CloudTypes = CloudTypes;
//# sourceMappingURL=cloud_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/colon_missing_space.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/colon_missing_space.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ColonMissingSpace = exports.ColonMissingSpaceConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ColonMissingSpaceConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ColonMissingSpaceConf = ColonMissingSpaceConf;
class ColonMissingSpace extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ColonMissingSpaceConf();
    }
    getMetadata() {
        return {
            key: "colon_missing_space",
            title: "Colon missing space",
            shortDescription: `Checks for missing spaces after colons in chained statements.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE:hello, world.`,
            goodExample: `WRITE: hello, world.`,
        };
    }
    getMessage() {
        return "Missing space after the colon";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const tokens = file.getTokens();
        for (let i = 0; i < tokens.length; i++) {
            const token = tokens[i];
            if (token.getStr() === ":"
                && tokens[i + 1] !== undefined
                && tokens[i + 1].getRow() === token.getRow()
                && tokens[i + 1].getCol() === token.getCol() + 1) {
                const start = token.getStart();
                const end = new position_1.Position(start.getRow(), start.getCol() + 1);
                const fix = edit_helper_1.EditHelper.insertAt(file, end, " ");
                const issue = issue_1.Issue.atRange(file, start, end, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.ColonMissingSpace = ColonMissingSpace;
//# sourceMappingURL=colon_missing_space.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/commented_code.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/commented_code.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommentedCode = exports.CommentedCodeConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const abap_parser_1 = __webpack_require__(/*! ../abap/abap_parser */ "./node_modules/@abaplint/core/build/src/abap/abap_parser.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const memory_file_1 = __webpack_require__(/*! ../files/memory_file */ "./node_modules/@abaplint/core/build/src/files/memory_file.js");
class CommentedCodeConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow INCLUDEs in function groups */
        this.allowIncludeInFugr = true;
    }
}
exports.CommentedCodeConf = CommentedCodeConf;
class CommentedCode extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new CommentedCodeConf();
    }
    getMetadata() {
        return {
            key: "commented_code",
            title: "Find commented code",
            shortDescription: `Detects usage of commented out code.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#delete-code-instead-of-commenting-it
https://docs.abapopenchecks.org/checks/14/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `* WRITE 'hello world'.`,
        };
    }
    getMessage() {
        return "Commented code";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        let issues = [];
        const rows = file.getRawRows();
        let code = "";
        let posEnd = undefined;
        let posStart = undefined;
        for (let i = 0; i < rows.length; i++) {
            if (this.isCommentLine(rows[i])) {
                if (code === "") {
                    posStart = new position_1.Position(i + 1, 1);
                }
                code = code + rows[i].trim().substr(1) + "\n";
                posEnd = new position_1.Position(i + 1, rows[i].length + 1);
            }
            else if (code !== "" && posStart && posEnd) {
                issues = issues.concat(this.check(code.trim(), file, posStart, posEnd, obj));
                code = "";
            }
        }
        if (posStart && posEnd) {
            issues = issues.concat(this.check(code.trim(), file, posStart, posEnd, obj));
        }
        return issues;
    }
    check(code, file, posStart, posEnd, obj) {
        // assumption: code must end with "." in order to be valid ABAP
        if (code === "" || code.charAt(code.length - 1) !== ".") {
            return [];
        }
        const commented = new memory_file_1.MemoryFile("_foobar.prog.abap", code);
        const abapFile = new abap_parser_1.ABAPParser().parse([commented]).output[0];
        const statementNodes = abapFile.getStatements();
        if (statementNodes.length === 0) {
            return [];
        }
        let containsStatement = false;
        for (const statementNode of statementNodes) {
            const statement = statementNode.get();
            if (this.getConfig().allowIncludeInFugr === true
                && obj instanceof objects_1.FunctionGroup
                && statement instanceof statements_1.Include) {
                continue;
            }
            if (!(statement instanceof _statement_1.Unknown
                || statement instanceof _statement_1.Empty
                || statement instanceof _statement_1.Comment)) {
                containsStatement = true;
                break;
            }
        }
        if (!containsStatement) {
            return [];
        }
        const fix = edit_helper_1.EditHelper.deleteRange(file, posStart, posEnd);
        const issue = issue_1.Issue.atRange(file, posStart, posEnd, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
        return [issue];
    }
    isCommentLine(text) {
        return (text.substr(0, 1) === "*")
            || (text.trim().substr(0, 1) === "\"" && text.trim().substr(1, 1) !== "!");
    }
}
exports.CommentedCode = CommentedCode;
//# sourceMappingURL=commented_code.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/constant_classes.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/constant_classes.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstantClasses = exports.ConstantClassesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
/** Checks that constants classes are in sync with domain fixed values */
class ConstantClassesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Specify a list of domain-class pairs which will be validated */
        this.mapping = [];
    }
}
exports.ConstantClassesConf = ConstantClassesConf;
class ConstantClasses {
    constructor() {
        this.conf = new ConstantClassesConf();
    }
    getMetadata() {
        return {
            key: "constant_classes",
            title: "Validate constant classes",
            shortDescription: `Checks that a class contains exactly the constants corresponding to a domain's fixed values.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-enumeration-classes-to-constants-interfaces`,
            tags: [_irule_1.RuleTag.Styleguide],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (this.conf
            && this.conf.mapping
            && obj instanceof __1.Objects.Domain) {
            const configEntry = this.conf.mapping.find(x => x.domain.toUpperCase() === obj.getName().toUpperCase());
            if (!configEntry) {
                return [];
            }
            const classWithConstants = this.reg.getObject("CLAS", configEntry === null || configEntry === void 0 ? void 0 : configEntry.class.toUpperCase());
            if (!classWithConstants) {
                return [issue_1.Issue.atIdentifier(obj.getIdentifier(), `Constant class pattern implementation ${configEntry.class} missing for domain ${configEntry.domain}`, this.getMetadata().key, this.conf.severity)];
                // quickfix will implement the whole class
            }
            const classContents = classWithConstants.getMainABAPFile();
            if (classContents === undefined) {
                return [];
            }
            const def = classWithConstants.getClassDefinition();
            if (!def) {
                // this issue is checked by rule implement_methods.
                // we will not issue errors that all constants are missing until there is a class implementation
                return [];
            }
            const domainValueInfo = obj.getFixedValues();
            const domainValues = domainValueInfo.map(x => x.low);
            const issues = [];
            if (obj.getFixedValues().length === 0) {
                // possibly this is not even a domain with fixed values
                issues.push(issue_1.Issue.atStatement(classContents, classContents.getStatements()[0], `Domain ${configEntry.domain} does not contain any fixed values. Either add some values or disable this check`, this.getMetadata().key, this.conf.severity));
            }
            // later we will raise an issue if we did not find it
            let domainNameConstantFound = false;
            for (const constant of def.constants) {
                if (configEntry.constantForDomainName
                    && constant.name === configEntry.constantForDomainName) {
                    // we require the constant value to be uppercase just in case
                    // in the config it does not matter
                    if (constant.value !== configEntry.domain.toLocaleUpperCase()) {
                        issues.push(this.issueAtConstant(constant, `Constant value ${constant.value} must match domain name ${configEntry.domain} `));
                    }
                    domainNameConstantFound = true;
                    continue;
                }
                if (configEntry.useExactType && constant.typeName.toLowerCase() !== configEntry.domain.toLowerCase()) {
                    issues.push(this.issueAtConstant(constant, `Use exact type ${configEntry.domain} instead of ${constant.typeName}`));
                    // quickfix will change the type
                }
                if (constant.visibility !== __1.Visibility.Public) {
                    issues.push(this.issueAtConstant(constant, `Constant ${constant.name} should be public`));
                    // quickfix will move constant
                }
                if (!domainValues.includes(constant.value)) {
                    issues.push(this.issueAtConstant(constant, `Extra constant ${constant.name} found which is not present in domain ${configEntry.domain}`));
                    // quickfix will remove constant
                }
            }
            for (const d of domainValueInfo) {
                if (!def.constants.find(c => c.value === d.low)) {
                    issues.push(issue_1.Issue.atStatement(classContents, classContents.getStatements()[0], `Missing constant for ${d.low} (domain ${configEntry.domain})`, this.getMetadata().key, this.conf.severity));
                    // quickfix will add constant
                }
            }
            if (configEntry.constantForDomainName && !domainNameConstantFound) {
                issues.push(issue_1.Issue.atStatement(classContents, classContents.getStatements()[0], `Missing constant ${configEntry.constantForDomainName} for name of domain ${configEntry.domain}`, this.getMetadata().key, this.conf.severity));
            }
            return issues;
        }
        return [];
    }
    issueAtConstant(constant, message) {
        return issue_1.Issue.atIdentifier(constant.identifier, message, this.getMetadata().key, this.conf.severity);
    }
}
exports.ConstantClasses = ConstantClasses;
//# sourceMappingURL=constant_classes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/constructor_visibility_public.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/constructor_visibility_public.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ConstructorVisibilityPublic = exports.ConstructorVisibilityPublicConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const visibility_1 = __webpack_require__(/*! ../abap/4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
class ConstructorVisibilityPublicConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ConstructorVisibilityPublicConf = ConstructorVisibilityPublicConf;
class ConstructorVisibilityPublic {
    constructor() {
        this.conf = new ConstructorVisibilityPublicConf();
    }
    getMetadata() {
        return {
            key: "constructor_visibility_public",
            title: "Check constructor visibility is public",
            shortDescription: `Constructor must be placed in the public section, even if the class is not CREATE PUBLIC.`,
            extendedInformation: `
This only applies to global classes.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#if-your-global-class-is-create-private-leave-the-constructor-public
https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abeninstance_constructor_guidl.htm`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "Constructor visibility should be public";
    }
    getConfig() {
        return this.conf;
    }
    initialize(_reg) {
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const issues = [];
        if (!(obj instanceof objects_1.Class)) {
            return [];
        }
        const def = obj.getClassDefinition();
        if (def === undefined) {
            return [];
        }
        for (const method of def.methods) {
            if (method.name.toUpperCase() === "CONSTRUCTOR"
                && method.visibility !== visibility_1.Visibility.Public) {
                const issue = issue_1.Issue.atIdentifier(method.identifier, this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.ConstructorVisibilityPublic = ConstructorVisibilityPublic;
//# sourceMappingURL=constructor_visibility_public.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/contains_tab.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/contains_tab.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ContainsTab = exports.ContainsTabConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class ContainsTabConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** quick fix replace with number of spaces */
        this.spaces = 1;
    }
}
exports.ContainsTabConf = ContainsTabConf;
class ContainsTab extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ContainsTabConf();
    }
    getMetadata() {
        return {
            key: "contains_tab",
            title: "Code contains tab",
            shortDescription: `Checks for usage of tabs (enable to enforce spaces)`,
            extendedInformation: `
https://docs.abapopenchecks.org/checks/09/
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#indent-and-snap-to-tab`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `\tWRITE 'hello world'.`,
            goodExample: `  WRITE 'hello world'.`,
        };
    }
    getMessage() {
        return "Code should not contain tabs";
    }
    getConfig() {
        if (this.conf.spaces === undefined) {
            this.conf.spaces = 1;
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const lines = file.getRaw().split("\n");
        lines.forEach((_, i) => {
            const tabCol = lines[i].indexOf("\t");
            if (tabCol >= 0) {
                let tabAmount = 1;
                while (lines[i].indexOf("\t", tabCol + tabAmount - 1) >= 0) {
                    tabAmount++;
                }
                issues.push(this.createIssue(i, tabCol, tabAmount, file));
            }
        });
        return issues;
    }
    createIssue(line, tabCol, tabAmount, file) {
        const tabStartPos = new position_1.Position(line + 1, tabCol + 1);
        const tabEndPos = new position_1.Position(line + 1, tabCol + tabAmount);
        const fix = edit_helper_1.EditHelper.replaceRange(file, tabStartPos, tabEndPos, " ".repeat(this.getConfig().spaces));
        return issue_1.Issue.atRange(file, tabStartPos, tabEndPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
    }
}
exports.ContainsTab = ContainsTab;
//# sourceMappingURL=contains_tab.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cyclic_oo.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cyclic_oo.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CyclicOO = exports.CyclicOOConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _builtin_1 = __webpack_require__(/*! ../abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class CyclicOOConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** List of object names to skip, must be full upper case name
         * @uniqueItems true
        */
        this.skip = [];
        /** Skips shared memory enabled classes */
        this.skipSharedMemory = true;
        /** Skip testclass inclues */
        this.skipTestclasses = true;
    }
}
exports.CyclicOOConf = CyclicOOConf;
class CyclicOO {
    constructor() {
        this.conf = new CyclicOOConf();
        this.edges = {};
    }
    getMetadata() {
        return {
            key: "cyclic_oo",
            title: "Cyclic OO",
            shortDescription: `Finds cyclic/circular OO references`,
            extendedInformation: `Runs for global INTF + CLAS objects

Objects must be without syntax errors for this rule to take effect

References in testclass includes are ignored`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skip === undefined) {
            this.conf.skip = [];
        }
    }
    initialize(reg) {
        var _a;
        this.reg = reg;
        this.edges = {};
        for (const obj of this.reg.getObjectsByType("CLAS")) {
            if (this.reg.isDependency(obj)) {
                continue;
            }
            const name = obj.getName().toUpperCase();
            if (!(obj instanceof objects_1.Class)) {
                continue;
            }
            else if (this.conf.skip.indexOf(name) >= 0) {
                continue;
            }
            else if (this.conf.skipSharedMemory === true && ((_a = obj.getClassDefinition()) === null || _a === void 0 ? void 0 : _a.isSharedMemory) === true) {
                continue;
            }
            const run = new syntax_1.SyntaxLogic(this.reg, obj).run();
            if (run.issues.length > 0) {
                continue;
            }
            this.buildEdges(name, run.spaghetti.getTop());
        }
        for (const obj of this.reg.getObjectsByType("INTF")) {
            if (this.reg.isDependency(obj)) {
                continue;
            }
            const name = obj.getName().toUpperCase();
            if (!(obj instanceof _abap_object_1.ABAPObject)) {
                continue;
            }
            else if (this.conf.skip.indexOf(name) >= 0) {
                continue;
            }
            const run = new syntax_1.SyntaxLogic(this.reg, obj).run();
            if (run.issues.length > 0) {
                continue;
            }
            this.buildEdges(name, run.spaghetti.getTop());
        }
        return this;
    }
    run(obj) {
        if (!(obj instanceof objects_1.Interface) && !(obj instanceof objects_1.Class)) {
            return [];
        }
        const id = obj.getIdentifier();
        if (id === undefined) {
            return [];
        }
        const previous = {};
        previous[obj.getName()] = true;
        const path = this.findCycle(obj.getName(), obj.getName(), previous);
        if (path) {
            const message = "Cyclic definition/usage: " + obj.getName() + " -> " + path;
            return [issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.conf.severity)];
        }
        return [];
    }
    /////////////////////////////
    findCycle(source, current, previous) {
        if (this.edges[current] === undefined) {
            return undefined;
        }
        for (const e of this.edges[current]) {
            if (e === source) {
                return e;
            }
            if (previous[e] === undefined) { // dont revisit vertices
                previous[e] = true;
                const found = this.findCycle(source, e, previous);
                if (found) {
                    return e + " -> " + found;
                }
            }
        }
        return undefined;
    }
    buildEdges(from, node) {
        var _a;
        for (const r of node.getData().references) {
            if (r.resolved === undefined
                || node.getIdentifier().filename === r.resolved.getFilename()
                || r.resolved.getFilename() === _builtin_1.BuiltIn.filename) {
                continue;
            }
            if (this.conf.skipTestclasses === true
                && (r.position.getFilename().includes(".testclasses.")
                    || r.resolved.getFilename().includes(".testclasses."))) {
                continue;
            }
            if (r.referenceType === _reference_1.ReferenceType.ObjectOrientedReference
                && ((_a = r.extra) === null || _a === void 0 ? void 0 : _a.ooName)) {
                if (this.edges[from] === undefined) {
                    this.edges[from] = [];
                }
                const name = r.extra.ooName.toUpperCase();
                if (name !== from && this.edges[from].indexOf(name) < 0) {
                    const obj = this.reg.getObject("INTF", name) || this.reg.getObject("CLAS", name);
                    if (obj && this.reg.isDependency(obj)) {
                        continue;
                    }
                    this.edges[from].push(name);
                }
            }
        }
        for (const c of node.getChildren()) {
            this.buildEdges(from, c);
        }
    }
}
exports.CyclicOO = CyclicOO;
//# sourceMappingURL=cyclic_oo.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/cyclomatic_complexity.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/cyclomatic_complexity.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CyclomaticComplexity = exports.CyclomaticComplexityConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const cyclomatic_complexity_stats_1 = __webpack_require__(/*! ../utils/cyclomatic_complexity_stats */ "./node_modules/@abaplint/core/build/src/utils/cyclomatic_complexity_stats.js");
class CyclomaticComplexityConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.max = 20;
    }
}
exports.CyclomaticComplexityConf = CyclomaticComplexityConf;
class CyclomaticComplexity {
    constructor() {
        this.conf = new CyclomaticComplexityConf();
    }
    getMetadata() {
        return {
            key: "cyclomatic_complexity",
            title: "Cyclomatic Complexity",
            shortDescription: `Cyclomatic complexity, only reported for methods`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.max === undefined) {
            this.conf.max = new CyclomaticComplexityConf().max;
        }
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        const issues = [];
        const stats = cyclomatic_complexity_stats_1.CyclomaticComplexityStats.run(obj);
        for (const s of stats) {
            if (s.count > this.conf.max) {
                const message = "Max cyclomatic complexity reached, " + s.count + ", " + s.name;
                const issue = issue_1.Issue.atPosition(s.file, s.pos, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.CyclomaticComplexity = CyclomaticComplexity;
//# sourceMappingURL=cyclomatic_complexity.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/dangerous_statement.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/dangerous_statement.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DangerousStatement = exports.DangerousStatementConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class DangerousStatementConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Detects execSQL (dynamic SQL) */
        this.execSQL = true;
        /** Detects kernel calls */
        this.kernelCall = true;
        /** Detects SYSTEM-CALL */
        this.systemCall = true;
        /** Detects INSERT REPORT */
        this.insertReport = true;
        this.generateDynpro = true;
        this.generateReport = true;
        this.generateSubroutine = true;
        this.deleteReport = true;
        this.deleteTextpool = true;
        this.insertTextpool = true;
        this.deleteDynpro = true;
        this.exportDynpro = true;
        /** Finds instances of dynamic SQL: SELECT, UPDATE, DELETE, INSERT, MODIFY */
        this.dynamicSQL = true;
    }
}
exports.DangerousStatementConf = DangerousStatementConf;
class DangerousStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new DangerousStatementConf();
    }
    getMetadata() {
        return {
            key: "dangerous_statement",
            title: "Dangerous statement",
            shortDescription: `Detects potentially dangerous statements`,
            extendedInformation: `Dynamic SQL: Typically ABAP logic does not need dynamic SQL,
dynamic SQL can potentially create SQL injection problems`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Security],
        };
    }
    getDescription(statement) {
        return "Potential dangerous statement " + statement;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const statementNode of file.getStatements()) {
            const statement = statementNode.get();
            let message = undefined;
            if (this.conf.execSQL && statement instanceof Statements.ExecSQL) {
                message = "EXEC SQL";
            }
            else if (this.conf.kernelCall && statement instanceof Statements.CallKernel) {
                message = "KERNEL CALL";
            }
            else if (this.conf.systemCall && statement instanceof Statements.SystemCall) {
                message = "SYSTEM-CALL";
            }
            else if (this.conf.insertReport && statement instanceof Statements.InsertReport) {
                message = "INSERT REPORT";
            }
            else if (this.conf.generateDynpro && statement instanceof Statements.GenerateDynpro) {
                message = "GENERATE DYNPRO";
            }
            else if (this.conf.generateReport && statement instanceof Statements.GenerateReport) {
                message = "GENERATE REPORT";
            }
            else if (this.conf.generateSubroutine && statement instanceof Statements.GenerateSubroutine) {
                message = "GENERATE SUBROUTINE";
            }
            else if (this.conf.deleteReport && statement instanceof Statements.DeleteReport) {
                message = "DELETE REPORT";
            }
            else if (this.conf.deleteTextpool && statement instanceof Statements.DeleteTextpool) {
                message = "DELETE TEXTPOOL";
            }
            else if (this.conf.insertTextpool && statement instanceof Statements.InsertTextpool) {
                message = "INSERT TEXTPOOL";
            }
            else if (this.conf.deleteDynpro && statement instanceof Statements.DeleteDynpro) {
                message = "DELETE DYNPRO";
            }
            else if (this.conf.exportDynpro && statement instanceof Statements.ExportDynpro) {
                message = "EXPORT DYNPRO";
            }
            if (message) {
                issues.push(issue_1.Issue.atStatement(file, statementNode, this.getDescription(message), this.getMetadata().key, this.conf.severity));
            }
            if (this.conf.dynamicSQL) {
                message = this.findDynamicSQL(statementNode);
                if (message) {
                    issues.push(issue_1.Issue.atStatement(file, statementNode, this.getDescription(message), this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
    findDynamicSQL(statementNode) {
        const statement = statementNode.get();
        if (statement instanceof Statements.UpdateDatabase
            || statement instanceof Statements.Select
            || statement instanceof Statements.SelectLoop
            || statement instanceof Statements.InsertDatabase
            || statement instanceof Statements.ModifyDatabase
            || statement instanceof Statements.DeleteDatabase) {
            const dyn = statementNode.findFirstExpression(Expressions.Dynamic);
            if (dyn && dyn.findDirectExpression(Expressions.Constant) === undefined) {
                return "Dynamic SQL";
            }
        }
        return undefined;
    }
}
exports.DangerousStatement = DangerousStatement;
//# sourceMappingURL=dangerous_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/db_operation_in_loop.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/db_operation_in_loop.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DbOperationInLoop = exports.DbOperationInLoopConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class DbOperationInLoopConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.DbOperationInLoopConf = DbOperationInLoopConf;
class DbOperationInLoop extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new DbOperationInLoopConf();
    }
    getMetadata() {
        return {
            key: "db_operation_in_loop",
            title: "Database operation in loop",
            shortDescription: `Database operation in LOOP/DO/WHILE`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Performance],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues;
        }
        const loops = stru.findAllStructures(Structures.Loop);
        loops.push(...stru.findAllStructures(Structures.Do));
        loops.push(...stru.findAllStructures(Structures.While));
        for (const l of loops) {
            let found = undefined;
            if (found === undefined) {
                found = l.findFirstStatement(Statements.Select);
            }
            if (found === undefined) {
                found = l.findFirstStatement(Statements.SelectLoop);
            }
            if (found === undefined) {
                found = l.findFirstStatement(Statements.InsertDatabase);
            }
            if (found === undefined) {
                found = l.findFirstStatement(Statements.DeleteDatabase);
            }
            if (found === undefined) {
                found = l.findFirstStatement(Statements.UpdateDatabase);
            }
            if (found === undefined) {
                found = l.findFirstStatement(Statements.ModifyDatabase);
            }
            if (found) {
                const message = "Database operation in loop";
                issues.push(issue_1.Issue.atStatement(file, found, message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.DbOperationInLoop = DbOperationInLoop;
//# sourceMappingURL=db_operation_in_loop.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/definitions_top.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/definitions_top.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DefinitionsTop = exports.DefinitionsTopConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
class DefinitionsTopConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.DefinitionsTopConf = DefinitionsTopConf;
// todo, use enum instead?
// const ANY = 1;
const DEFINITION = 2;
const AFTER = 3;
const IGNORE = 4;
class DefinitionsTop extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new DefinitionsTopConf();
    }
    getMetadata() {
        return {
            key: "definitions_top",
            title: "Place definitions in top of routine",
            shortDescription: `Checks that definitions are placed at the beginning of METHODs, FORMs and FUNCTIONs.`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/17/`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `FROM foo.
  WRITE 'hello'.
  DATA int TYPE i.
ENDFORM.`,
            goodExample: `FROM foo.
  DATA int TYPE i.
  WRITE 'hello'.
ENDFORM.`,
        };
    }
    getMessage() {
        return "Reorder definitions to top of routine";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        const containsUnknown = file.getStatements().some(s => s.get() instanceof _statement_1.Unknown);
        if (containsUnknown === true) {
            return [];
        }
        const routines = structure.findAllStructuresMulti([Structures.Form, Structures.Method, Structures.FunctionModule]);
        for (const r of routines) {
            // one fix per routine
            this.fixed = false;
            this.mode = DEFINITION;
            this.moveTo = (_a = r.getFirstStatement()) === null || _a === void 0 ? void 0 : _a.getLastToken().getEnd();
            const found = this.walk(r, file);
            if (found) {
                issues.push(found);
            }
        }
        return issues;
    }
    //////////////////
    walk(r, file) {
        var _a, _b, _c, _d, _e, _f;
        let previous = undefined;
        for (const c of r.getChildren()) {
            const get = c.get();
            if (c instanceof nodes_1.StatementNode) {
                if (get instanceof _statement_1.Comment) {
                    continue;
                }
                else if (get instanceof Statements.FunctionModule) {
                    continue;
                }
                else if (get instanceof Statements.Form) {
                    continue;
                }
                else if (get instanceof Statements.MethodImplementation) {
                    continue;
                }
            }
            if (c instanceof nodes_1.StructureNode
                && (get instanceof Structures.Data
                    || get instanceof Structures.Types
                    || get instanceof Structures.Constants
                    || get instanceof Structures.Statics)) {
                if (this.mode === AFTER) {
                    // These are chained structured statements
                    let fix = undefined;
                    if (((_b = (_a = c.getLastChild()) === null || _a === void 0 ? void 0 : _a.getLastChild()) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr()) === "."
                        && !(previous instanceof nodes_1.StructureNode)
                        && this.moveTo) {
                        // this is not perfect, but will work for now
                        const start = (_d = (_c = c.getFirstChild()) === null || _c === void 0 ? void 0 : _c.getFirstChild()) === null || _d === void 0 ? void 0 : _d.getFirstToken().getStart();
                        const end = (_f = (_e = c.getLastChild()) === null || _e === void 0 ? void 0 : _e.getLastChild()) === null || _f === void 0 ? void 0 : _f.getLastToken().getEnd();
                        if (start && end) {
                            let concat = c.concatTokens();
                            concat = concat.replace(/,/g, ".\n");
                            const fix1 = edit_helper_1.EditHelper.deleteRange(file, start, end);
                            const fix2 = edit_helper_1.EditHelper.insertAt(file, this.moveTo, "\n" + concat);
                            fix = edit_helper_1.EditHelper.merge(fix1, fix2);
                        }
                    }
                    // no quick fixes for these, its difficult?
                    return issue_1.Issue.atStatement(file, c.getFirstStatement(), this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                }
                else {
                    this.moveTo = c.getLastToken().getEnd();
                }
            }
            else if (c instanceof nodes_1.StatementNode
                && (get instanceof Statements.Data
                    || get instanceof Statements.Type
                    || get instanceof Statements.Constant
                    || (get instanceof Statements.Move && c.concatTokens().toUpperCase().startsWith("DATA("))
                    || get instanceof Statements.Static
                    || get instanceof Statements.FieldSymbol)) {
                if (this.mode === AFTER) {
                    // only one fix per routine, as it reorders a lot
                    if (!(get instanceof Statements.Move && c.concatTokens().toUpperCase().startsWith("DATA("))) {
                        let fix = undefined;
                        if (this.fixed === false && this.moveTo) {
                            fix = this.buildFix(file, c, this.moveTo);
                            this.fixed = true;
                        }
                        return issue_1.Issue.atStatement(file, c, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                    }
                }
                else {
                    this.moveTo = c.getLastToken().getEnd();
                }
            }
            else if (c instanceof nodes_1.StructureNode && get instanceof Structures.Define) {
                this.mode = IGNORE;
                return undefined;
            }
            else if (c instanceof nodes_1.StatementNode && get instanceof _statement_1.Unknown) {
                this.mode = IGNORE;
                return undefined;
            }
            else if (c instanceof nodes_1.StatementNode && this.mode === DEFINITION) {
                this.mode = AFTER;
            }
            else if (c instanceof nodes_1.StructureNode) {
                const found = this.walk(c, file);
                if (found) {
                    return found;
                }
            }
            previous = c;
        }
        return undefined;
    }
    buildFix(file, statement, at) {
        let concat = statement.concatTokens();
        concat = concat.replace(/,$/, ".");
        const fix1 = edit_helper_1.EditHelper.deleteStatement(file, statement);
        const indentation = " ".repeat(statement.getFirstToken().getCol() - 1);
        const fix2 = edit_helper_1.EditHelper.insertAt(file, at, "\n" + indentation + concat);
        return edit_helper_1.EditHelper.merge(fix1, fix2);
    }
}
exports.DefinitionsTop = DefinitionsTop;
//# sourceMappingURL=definitions_top.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/description_empty.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/description_empty.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DescriptionEmpty = exports.DescriptionEmptyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
// standard class CL_OO_CLASS assumes classes have descriptions
class DescriptionEmptyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.DescriptionEmptyConf = DescriptionEmptyConf;
class DescriptionEmpty {
    constructor() {
        this.conf = new DescriptionEmptyConf();
    }
    getMetadata() {
        return {
            key: "description_empty",
            title: "Description in class must exist",
            shortDescription: `Ensures descriptions in class metadata exist.`,
        };
    }
    getDescription(name) {
        return "Description empty in " + name;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        const issues = [];
        if (obj instanceof objects_1.Class || obj instanceof objects_1.Interface) {
            const description = obj.getDescription();
            let message = undefined;
            if (description === "") {
                message = this.getDescription(obj.getName());
            }
            else if (description === undefined) {
                message = this.getDescription(obj.getName() + ", class XML file not found");
            }
            if (message) {
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.DescriptionEmpty = DescriptionEmpty;
//# sourceMappingURL=description_empty.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/double_space.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/double_space.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DoubleSpace = exports.DoubleSpaceConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class DoubleSpaceConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Check for double space after keywords */
        this.keywords = true;
        /** list of keywords to skip, case insensitive */
        this.skipKeywords = ["CHANGING", "EXPORTING", "OTHERS"];
        /** Check for double space after start parenthesis */
        this.startParen = true;
        /** Check for double space before end parenthesis */
        this.endParen = true;
        /** Check for double space after colon/chaining operator */
        this.afterColon = true;
    }
}
exports.DoubleSpaceConf = DoubleSpaceConf;
class DoubleSpace extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new DoubleSpaceConf();
    }
    getMetadata() {
        return {
            key: "double_space",
            title: "Double space",
            shortDescription: `Checks that only a single space follows certain common statements.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `DATA  foo TYPE i.`,
            goodExample: `DATA foo TYPE i.`,
        };
    }
    getMessage() {
        return "Remove double space";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skipKeywords === undefined) {
            this.conf.skipKeywords = new DoubleSpaceConf().skipKeywords;
        }
    }
    runParsed(file) {
        let issues = [];
        for (const s of file.getStatements()) {
            if (this.conf.keywords === true
                && !(s.get() instanceof _statement_1.Unknown)
                && !(s.get() instanceof statements_1.MethodDef)
                && !(s.get() instanceof _statement_1.MacroCall)
                && !(s.get() instanceof statements_1.Events)
                && !(s.get() instanceof _statement_1.MacroContent)) {
                issues = issues.concat(this.checkKeywords(s, file));
            }
            issues = issues.concat(this.checkParen(s, file));
        }
        issues = issues.concat(this.checkAfterColon(file));
        return issues;
    }
    checkAfterColon(file) {
        const issues = [];
        let cPosition = undefined;
        if (this.conf.afterColon !== true) {
            return [];
        }
        for (const s of file.getStatements()) {
            const colon = s.getColon();
            if (colon === undefined) {
                continue;
            }
            else if (cPosition !== undefined && cPosition.getCol() === colon.getCol()) {
                continue;
            }
            cPosition = colon.getStart();
            for (const t of s.getTokens()) {
                if (t.getRow() !== cPosition.getRow()) {
                    return [];
                }
                else if (t.getCol() < cPosition.getCol()) {
                    continue;
                }
                if (t.getCol() > cPosition.getCol() + 2) {
                    const issueStartPos = new position_1.Position(cPosition.getRow(), cPosition.getCol() + 2);
                    const issueEndPos = new position_1.Position(t.getRow(), t.getCol());
                    const fix = edit_helper_1.EditHelper.deleteRange(file, issueStartPos, issueEndPos);
                    issues.push(issue_1.Issue.atRange(file, issueStartPos, issueEndPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix));
                }
                break;
            }
        }
        return issues;
    }
    checkParen(s, file) {
        const issues = [];
        let prev = undefined;
        for (const t of s.getTokens()) {
            if (prev === undefined) {
                prev = t;
                continue;
            }
            if (this.getConfig().startParen === true
                && prev.getRow() === t.getRow()
                && prev instanceof tokens_1.ParenLeftW
                && !(t instanceof tokens_1.Comment)
                && prev.getEnd().getCol() + 1 < t.getCol()) {
                const issueStartPos = new position_1.Position(prev.getRow(), prev.getCol() + 2);
                const issueEndPos = new position_1.Position(t.getRow(), t.getCol());
                const fix = edit_helper_1.EditHelper.deleteRange(file, issueStartPos, issueEndPos);
                if (this.pragmaInRange(s.getPragmas(), issueStartPos, issueEndPos) === false) {
                    issues.push(issue_1.Issue.atRange(file, issueStartPos, issueEndPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix));
                }
            }
            if (this.getConfig().endParen === true
                && prev.getRow() === t.getRow()
                && !(prev instanceof tokens_1.ParenLeftW)
                && (t instanceof tokens_1.WParenRightW || t instanceof tokens_1.WParenRight)
                && prev.getEnd().getCol() + 1 < t.getCol()) {
                const issueStartPos = new position_1.Position(prev.getEnd().getRow(), prev.getEnd().getCol() + 1);
                const issueEndPos = new position_1.Position(t.getRow(), t.getCol());
                const fix = edit_helper_1.EditHelper.deleteRange(file, issueStartPos, issueEndPos);
                if (this.pragmaInRange(s.getPragmas(), issueStartPos, issueEndPos) === false) {
                    issues.push(issue_1.Issue.atRange(file, issueStartPos, issueEndPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix));
                }
            }
            prev = t;
        }
        return issues;
    }
    pragmaInRange(pragmas, start, end) {
        let ret = false;
        for (const p of pragmas) {
            if (p.getStart().isBetween(start, end)) {
                ret = true;
            }
        }
        return ret;
    }
    checkKeywords(s, file) {
        const issues = [];
        let prev = undefined;
        if (s.getColon() !== undefined || s.getPragmas().length > 0) {
            // for chained statments just give up
            return [];
        }
        for (const n of s.getTokenNodes()) {
            if (prev === undefined) {
                prev = n;
                continue;
            }
            const upper = prev.get().getStr().toUpperCase();
            if (prev instanceof nodes_1.TokenNodeRegex
                || upper === "("
                || upper === ")"
                || this.getConfig().skipKeywords.some(e => e.toUpperCase() === upper)) {
                // not a keyword, continue
                prev = n;
                continue;
            }
            if (prev.get().getStart().getRow() === n.get().getStart().getRow()
                && prev.get().getEnd().getCol() + 1 < n.get().getStart().getCol()) {
                const issueStartPos = new position_1.Position(prev.get().getEnd().getRow(), prev.get().getEnd().getCol() + 1);
                const issueEndPos = new position_1.Position(n.get().getRow(), n.get().getCol());
                const fix = edit_helper_1.EditHelper.deleteRange(file, issueStartPos, issueEndPos);
                issues.push(issue_1.Issue.atRange(file, issueStartPos, issueEndPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix));
                return issues;
            }
            prev = n;
        }
        return [];
    }
}
exports.DoubleSpace = DoubleSpace;
//# sourceMappingURL=double_space.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/downport.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/downport.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Downport = exports.DownportConf = void 0;
/* eslint-disable max-len */
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const registry_1 = __webpack_require__(/*! ../registry */ "./node_modules/@abaplint/core/build/src/registry.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const config_1 = __webpack_require__(/*! ../config */ "./node_modules/@abaplint/core/build/src/config.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const include_graph_1 = __webpack_require__(/*! ../utils/include_graph */ "./node_modules/@abaplint/core/build/src/utils/include_graph.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _builtin_1 = __webpack_require__(/*! ../abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const crypto = __webpack_require__(/*! crypto */ "crypto");
// todo: refactor each sub-rule to new classes?
// todo: add configuration
class DownportConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.DownportConf = DownportConf;
class SkipToNextFile extends Error {
    constructor(issue) {
        super();
        this.issue = issue;
    }
}
class SpagHelper {
    constructor(spag) {
        this.spag = spag;
    }
    renameVariable(oldName, pos, lowFile, newName) {
        let fix = undefined;
        const references = this.findReferences(oldName, pos);
        references.sort((a, b) => {
            if (a.start.equals(b.start)) {
                return 0;
            }
            return a.start.isAfter(b.start) ? 1 : -1;
        });
        for (const r of references) {
            const replace = edit_helper_1.EditHelper.replaceRange(lowFile, r.start, r.end, newName);
            if (fix === undefined) {
                fix = replace;
            }
            else {
                fix = edit_helper_1.EditHelper.merge(replace, fix);
            }
        }
        return fix;
    }
    findReferences(name, pos) {
        var _a, _b;
        const positions = [];
        function has(element) {
            return positions.some(a => a.start.equals(element.start));
        }
        for (const r of this.spag.getData().references) {
            if (((_a = r.resolved) === null || _a === void 0 ? void 0 : _a.getName()) === name && ((_b = r.resolved) === null || _b === void 0 ? void 0 : _b.getStart().equals(pos))) {
                const sub = {
                    start: r.position.getStart(),
                    end: r.position.getEnd(),
                };
                if (has(sub) === false) {
                    positions.push(sub);
                }
            }
        }
        for (const child of this.spag.getChildren()) {
            const subPositions = new SpagHelper(child).findReferences(name, pos);
            for (const sub of subPositions) {
                if (has(sub) === false) {
                    positions.push(sub);
                }
            }
        }
        return positions;
    }
    findRecursiveDuplicate(name, skip) {
        var _a;
        const found = this.spag.findVariable(name);
        if ((found === null || found === void 0 ? void 0 : found.getStart().equals(skip)) === false) {
            return found;
        }
        for (const child of ((_a = this.spag) === null || _a === void 0 ? void 0 : _a.getChildren()) || []) {
            const sub = new SpagHelper(child).findRecursiveDuplicate(name, skip);
            if (sub) {
                return sub;
            }
        }
        return undefined;
    }
    isDuplicateName(name, pos) {
        let parent = this.spag.getParent();
        while ((parent === null || parent === void 0 ? void 0 : parent.getIdentifier().stype) === _scope_type_1.ScopeType.Let
            || (parent === null || parent === void 0 ? void 0 : parent.getIdentifier().stype) === _scope_type_1.ScopeType.For) {
            parent = parent.getParent();
        }
        if (parent === undefined) {
            return undefined;
        }
        return new SpagHelper(parent).findRecursiveDuplicate(name, pos) !== undefined;
    }
}
class Downport {
    constructor() {
        this.conf = new DownportConf();
    }
    getMetadata() {
        return {
            key: "downport",
            title: "Downport statement",
            shortDescription: `Downport functionality`,
            extendedInformation: `Much like the 'commented_code' rule this rule loops through unknown statements and tries parsing with
a higher level language version. If successful, various rules are applied to downport the statement.
Target downport version is always v702, thus rule is only enabled if target version is v702.

Current rules:
* NEW transformed to CREATE OBJECT, opposite of https://rules.abaplint.org/use_new/
* DATA() definitions are outlined, opposite of https://rules.abaplint.org/prefer_inline/
* FIELD-SYMBOL() definitions are outlined
* CONV is outlined
* COND is outlined
* REDUCE is outlined
* SWITCH is outlined
* FILTER is outlined
* APPEND expression is outlined
* INSERT expression is outlined
* EMPTY KEY is changed to DEFAULT KEY, opposite of DEFAULT KEY in https://rules.abaplint.org/avoid_use/
* CAST changed to ?=
* LOOP AT method_call( ) is outlined
* VALUE # with structure fields
* VALUE # with internal table lines
* Table Expressions are outlined
* SELECT INTO @DATA definitions are outlined
* Some occurrences of string template formatting option ALPHA changed to function module call
* SELECT/INSERT/MODIFY/DELETE/UPDATE "," in field list removed, "@" in source/targets removed
* PARTIALLY IMPLEMENTED removed, it can be quick fixed via rule implement_methods
* RAISE EXCEPTION ... MESSAGE
* Moving with +=, -=, /=, *=, &&= is expanded
* line_exists and line_index is downported to READ TABLE
* ENUMs, but does not nessesarily give the correct type and value
* MESSAGE with non simple source

Only one transformation is applied to a statement at a time, so multiple steps might be required to do the full downport.

Make sure to test the downported code, it might not always be completely correct.`,
            tags: [_irule_1.RuleTag.Downport, _irule_1.RuleTag.Quickfix],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.lowReg = reg;
        const version = this.lowReg.getConfig().getVersion();
        if (version === version_1.Version.v702 || version === version_1.Version.OpenABAP) {
            this.initHighReg();
        }
        return this;
    }
    listMainForInclude(filename) {
        if (filename === undefined) {
            return [];
        }
        // only initialize this.graph if needed
        if (this.graph === undefined) {
            this.graph = new include_graph_1.IncludeGraph(this.lowReg);
        }
        return this.graph.listMainForInclude(filename);
    }
    containsError(highObj) {
        for (const file of highObj.getABAPFiles()) {
            for (const statement of file.getStatements()) {
                if (statement.get() instanceof _statement_1.Unknown) {
                    return true; // contains parser errors
                }
            }
            if (file.getStructure() === undefined) {
                return true;
            }
        }
        return false;
    }
    run(lowObj) {
        var _a;
        const ret = [];
        this.counter = 1;
        const version = this.lowReg.getConfig().getVersion();
        if (version !== version_1.Version.v702 && version !== version_1.Version.OpenABAP) {
            return ret;
        }
        else if (!(lowObj instanceof _abap_object_1.ABAPObject)) {
            return ret;
        }
        const highObj = this.highReg.getObject(lowObj.getType(), lowObj.getName());
        if (highObj === undefined || !(highObj instanceof _abap_object_1.ABAPObject)) {
            return ret;
        }
        let highSyntaxObj = highObj;
        if (this.containsError(highObj)) {
            return ret;
        }
        // for includes do the syntax check via a main program
        if (lowObj instanceof objects_1.Program && lowObj.isInclude()) {
            const mains = this.listMainForInclude((_a = lowObj.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getFilename());
            if (mains.length <= 0) {
                return [];
            }
            const f = this.highReg.getFileByName(mains[0]);
            if (f === undefined) {
                return [];
            }
            highSyntaxObj = this.highReg.findObjectForFile(f);
        }
        for (const lowFile of lowObj.getABAPFiles()) {
            let highSyntax = undefined;
            const highFile = highObj.getABAPFileByName(lowFile.getFilename());
            if (highFile === undefined) {
                continue;
            }
            const lowStatements = lowFile.getStatements();
            const highStatements = highFile.getStatements();
            if (lowStatements.length !== highStatements.length) {
                // after applying a fix, there might be more statements in lowFile
                // should highReg be initialized again?
                /*
                const message = "Internal Error: Statement lengths does not match";
                ret.push(Issue.atStatement(lowFile, lowStatements[0], message, this.getMetadata().key));
                */
                // hmm, add some way to disable lazyUnknown() in statement_parser.ts
                // alternatively explicit enable it in vscode, its only relevant when a user is
                // actively editing the files
                continue;
            }
            if (highSyntax === undefined) {
                highSyntax = new syntax_1.SyntaxLogic(this.highReg, highSyntaxObj).run();
            }
            let containsUnknown = false;
            for (let i = 0; i < lowStatements.length; i++) {
                const low = lowStatements[i];
                const high = highStatements[i];
                if ((low.get() instanceof _statement_1.Unknown && !(high.get() instanceof _statement_1.Unknown))
                    || high.findFirstExpression(Expressions.InlineData)) {
                    containsUnknown = true;
                    try {
                        const issue = this.checkStatement(low, high, lowFile, highSyntax, highFile);
                        if (issue) {
                            ret.push(issue);
                        }
                    }
                    catch (e) {
                        if (e instanceof SkipToNextFile) {
                            ret.push(e.issue);
                            break;
                        }
                        else {
                            throw e;
                        }
                    }
                }
            }
            if (ret.length === 0 && containsUnknown) {
                // this is a hack in order not to change too many unit tests
                for (let i = 0; i < lowStatements.length; i++) {
                    const high = highStatements[i];
                    if (high.get() instanceof Statements.Data) {
                        const issue = this.anonymousTableType(high, lowFile, highSyntax);
                        if (issue) {
                            ret.push(issue);
                        }
                    }
                }
            }
            if (ret.length === 0 && lowFile.getRaw().includes(" xsdbool(")) {
                for (let i = 0; i < lowStatements.length; i++) {
                    const high = highStatements[i];
                    const issue = this.replaceXsdBool(high, lowFile, highSyntax);
                    if (issue) {
                        ret.push(issue);
                    }
                }
            }
        }
        return ret;
    }
    ////////////////////
    /** clones the orginal repository into highReg, and parses it with higher language version */
    initHighReg() {
        // use default configuration, ie. default target version
        const highConfig = config_1.Config.getDefault().get();
        const lowConfig = this.lowReg.getConfig().get();
        highConfig.syntax.errorNamespace = lowConfig.syntax.errorNamespace;
        highConfig.syntax.globalConstants = lowConfig.syntax.globalConstants;
        highConfig.syntax.globalMacros = lowConfig.syntax.globalMacros;
        this.highReg = new registry_1.Registry();
        for (const o of this.lowReg.getObjects()) {
            for (const f of o.getFiles()) {
                if (this.lowReg.isDependency(o) === true) {
                    this.highReg.addDependency(f);
                }
                else {
                    this.highReg.addFile(f);
                }
            }
        }
        this.highReg.parse();
    }
    /** applies one rule at a time, multiple iterations are required to transform complex statements */
    checkStatement(low, high, lowFile, highSyntax, highFile) {
        if (low.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
            return undefined;
        }
        // downport XSDBOOL() early, as it is valid 702 syntax
        /*
        let found = this.replaceXsdBool(high, lowFile, highSyntax);
        if (found) {
          return found;
        }
        */
        let found = this.downportEnum(low, high, lowFile, highSyntax, highFile);
        if (found) {
            return found;
        }
        found = this.partiallyImplemented(high, lowFile);
        if (found) {
            return found;
        }
        found = this.raiseException(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.emptyKey(low, high, lowFile);
        if (found) {
            return found;
        }
        found = this.stringTemplateAlpha(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.moveWithOperator(low, high, lowFile);
        if (found) {
            return found;
        }
        found = this.moveWithSimpleValue(low, high, lowFile);
        if (found) {
            return found;
        }
        found = this.assignWithTable(low, high, lowFile);
        if (found) {
            return found;
        }
        found = this.assignComponent(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportRefSimple(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportCorrespondingSimple(high, lowFile);
        if (found) {
            return found;
        }
        found = this.downportRef(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportLoopGroup(high, lowFile, highSyntax, highFile);
        if (found) {
            return found;
        }
        found = this.callFunctionParameterSimple(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.moveWithTableTarget(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportSelectInline(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportSelectExistence(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportSQLExtras(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineLoopInput(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineLoopTarget(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        let skipValue = false;
        let skipReduce = false;
        const valueBody = high.findFirstExpression(Expressions.ValueBody);
        const reduceBody = high.findFirstExpression(Expressions.ReduceBody);
        if (valueBody && reduceBody) {
            const valueToken = valueBody.getFirstToken();
            const reduceToken = reduceBody.getFirstToken();
            if (valueToken.getStart().isBefore(reduceToken.getStart())) {
                skipReduce = true;
            }
            else {
                skipValue = true;
            }
        }
        if (skipValue !== true) {
            found = this.outlineValue(low, high, lowFile, highSyntax);
            if (found) {
                return found;
            }
        }
        if (skipReduce !== true) {
            found = this.outlineReduce(low, high, lowFile, highSyntax);
            if (found) {
                return found;
            }
        }
        found = this.outlineCorresponding(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportSelectFields(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineSwitch(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineFilter(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineCast(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineConv(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineCond(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineCatchSimple(high, lowFile);
        if (found) {
            return found;
        }
        found = this.outlineGetReferenceSimple(high, lowFile);
        if (found) {
            return found;
        }
        found = this.outlineDataSimple(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineData(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.outlineFS(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.newToCreateObject(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceLineFunctions(high, lowFile, highSyntax, highFile);
        if (found) {
            return found;
        }
        found = this.getReference(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceContains(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceMethodConditional(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceTableExpression(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceAppendExpression(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.replaceInsertExpression(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportMessageSource(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportMessage(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportReadTable(high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        return undefined;
    }
    //////////////////////////////////////////
    /** removes @'s */
    downportSQLExtras(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        if (!(high.get() instanceof Statements.Select)
            && !(high.get() instanceof Statements.SelectLoop)
            && !(high.get() instanceof Statements.UpdateDatabase)
            && !(high.get() instanceof Statements.ModifyDatabase)
            && !(high.get() instanceof Statements.DeleteDatabase)
            && !(high.get() instanceof Statements.InsertDatabase)) {
            return undefined;
        }
        let fix = undefined;
        const addFix = (token) => {
            const add = edit_helper_1.EditHelper.deleteToken(lowFile, token);
            if (fix === undefined) {
                fix = add;
            }
            else {
                fix = edit_helper_1.EditHelper.merge(fix, add);
            }
        };
        const candidates = [high.findAllExpressionsRecursive(Expressions.SQLTarget),
            high.findAllExpressionsRecursive(Expressions.SQLSource),
            high.findAllExpressionsRecursive(Expressions.SQLSourceNoSpace),
            high.findAllExpressionsRecursive(Expressions.SQLSourceSimple)].flat();
        for (const c of candidates.reverse()) {
            if (c.getFirstToken() instanceof tokens_1.WAt
                || c.getFirstToken() instanceof tokens_1.At) {
                const tokens = c.getAllTokens();
                if (tokens[1] instanceof tokens_1.ParenLeftW && tokens[tokens.length - 1] instanceof tokens_1.WParenRightW) {
                    const source = c.findDirectExpression(Expressions.Source);
                    const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
                    const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getStart(), `DATA(${uniqueName}) = ${source === null || source === void 0 ? void 0 : source.concatTokens()}.\n`);
                    const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, c.getFirstToken().getStart(), c.getLastToken().getEnd(), "@" + uniqueName);
                    const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
                    return issue_1.Issue.atToken(lowFile, low.getFirstToken(), "SQL, outline complex @", this.getMetadata().key, this.conf.severity, fix);
                }
                else {
                    addFix(c.getFirstToken());
                }
            }
        }
        for (const fieldList of high.findAllExpressionsMulti([Expressions.SQLFieldList, Expressions.SQLFieldListLoop], true)) {
            for (const token of fieldList.getDirectTokens()) {
                if (token.getStr() === ",") {
                    addFix(token);
                }
            }
        }
        if (fix !== undefined) {
            return issue_1.Issue.atToken(lowFile, low.getFirstToken(), "SQL, remove @ and ,", this.getMetadata().key, this.conf.severity, fix);
        }
        for (const c of high.findAllExpressionsRecursive(Expressions.SQLIn)) {
            const children = c.getChildren();
            const first = children[1];
            if (!(first.get() instanceof tokens_1.WParenLeftW)) {
                continue;
            }
            const last = children[children.length - 1];
            if (last.get() instanceof tokens_1.WParenRightW || last.get() instanceof tokens_1.WParenRight) {
                const firstEnd = first.getFirstToken().getEnd();
                const endDelete = new position_1.Position(firstEnd.getRow(), firstEnd.getCol() + 1);
                const fix1 = edit_helper_1.EditHelper.deleteRange(lowFile, firstEnd, endDelete);
                const lastStart = last.getFirstToken().getStart();
                const startDelete = new position_1.Position(lastStart.getRow(), lastStart.getCol() - 1);
                const fix2 = edit_helper_1.EditHelper.deleteRange(lowFile, startDelete, lastStart);
                fix = edit_helper_1.EditHelper.merge(fix2, fix1);
                return issue_1.Issue.atToken(lowFile, low.getFirstToken(), "SQL, remove spaces", this.getMetadata().key, this.conf.severity, fix);
            }
        }
        return undefined;
    }
    downportSelectExistence(low, high, lowFile, highSyntax) {
        var _a, _b, _c, _d;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        else if (!(high.get() instanceof Statements.Select)) {
            return undefined;
        }
        const fieldList = high.findFirstExpression(Expressions.SQLFieldList);
        if ((fieldList === null || fieldList === void 0 ? void 0 : fieldList.concatTokens().toUpperCase()) !== "@ABAP_TRUE") {
            return undefined;
        }
        const fieldName = (_b = (_a = high.findFirstExpression(Expressions.SQLCond)) === null || _a === void 0 ? void 0 : _a.findFirstExpression(Expressions.SQLFieldName)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (fieldName === undefined) {
            return undefined;
        }
        const into = high.findFirstExpression(Expressions.SQLIntoStructure);
        if (into === undefined) {
            return undefined;
        }
        const intoName = (_d = (_c = into.findFirstExpression(Expressions.SQLTarget)) === null || _c === void 0 ? void 0 : _c.findFirstExpression(Expressions.Target)) === null || _d === void 0 ? void 0 : _d.concatTokens();
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const fix1 = edit_helper_1.EditHelper.replaceRange(lowFile, fieldList.getFirstToken().getStart(), fieldList.getLastToken().getEnd(), fieldName);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, into === null || into === void 0 ? void 0 : into.getFirstToken().getStart(), into === null || into === void 0 ? void 0 : into.getLastToken().getEnd(), `INTO @DATA(${uniqueName})`);
        let fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        const fix3 = edit_helper_1.EditHelper.insertAt(lowFile, high.getLastToken().getEnd(), `\nCLEAR ${intoName}.\nIF sy-subrc = 0.\n  ${intoName} = abap_true.\nENDIF.`);
        fix = edit_helper_1.EditHelper.merge(fix, fix3);
        return issue_1.Issue.atToken(lowFile, low.getFirstToken(), "SQL, refactor existence check", this.getMetadata().key, this.conf.severity, fix);
    }
    downportSelectInline(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        else if (!(high.get() instanceof Statements.Select) && !(high.get() instanceof Statements.SelectLoop)) {
            return undefined;
        }
        // as first step outline the @DATA, note that void types are okay, as long the field names are specified
        let found = this.downportSelectSingleInline(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        found = this.downportSelectTableInline(low, high, lowFile, highSyntax);
        if (found) {
            return found;
        }
        return undefined;
    }
    downportSelectFields(low, high, lowFile, _highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        else if (!(high.get() instanceof Statements.Select)) {
            return undefined;
        }
        const fields = high.findFirstExpression(Expressions.SQLFields);
        if (fields === undefined) {
            return undefined;
        }
        const code = (_a = fields.getLastChild()) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (code === undefined) {
            return undefined;
        }
        const fix1 = edit_helper_1.EditHelper.deleteRange(lowFile, fields.getFirstToken().getStart(), fields.getLastToken().getEnd());
        const fix2 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getEnd(), " " + code);
        const fix = edit_helper_1.EditHelper.merge(fix1, fix2);
        return issue_1.Issue.atToken(lowFile, fields.getFirstToken(), "Replace FIELDS", this.getMetadata().key, this.conf.severity, fix);
    }
    downportSelectSingleInline(low, high, lowFile, _highSyntax) {
        var _a, _b, _c, _d;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        const targets = ((_a = high.findFirstExpression(Expressions.SQLIntoStructure)) === null || _a === void 0 ? void 0 : _a.findDirectExpressions(Expressions.SQLTarget)) || [];
        if (targets.length !== 1) {
            return undefined;
        }
        const inlineData = targets[0].findFirstExpression(Expressions.InlineData);
        if (inlineData === undefined) {
            return undefined;
        }
        const sqlFrom = high.findAllExpressions(Expressions.SQLFromSource);
        if (sqlFrom.length !== 1) {
            return undefined;
        }
        const tableName = (_b = sqlFrom[0].findDirectExpression(Expressions.DatabaseTable)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (tableName === undefined) {
            return undefined;
        }
        const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
        let fieldList = high.findFirstExpression(Expressions.SQLFieldList);
        if (fieldList === undefined) {
            fieldList = high.findFirstExpression(Expressions.SQLFieldListLoop);
        }
        if (fieldList === undefined) {
            return undefined;
        }
        let fieldDefinition = "";
        const fields = fieldList.findAllExpressions(Expressions.SQLFieldName);
        const name = ((_c = inlineData.findFirstExpression(Expressions.TargetField)) === null || _c === void 0 ? void 0 : _c.concatTokens()) || "error";
        if (fields.length === 1) {
            fieldDefinition = `DATA ${name} TYPE ${tableName}-${fields[0].concatTokens()}.`;
        }
        else if (fieldList.concatTokens() === "*") {
            fieldDefinition = `DATA ${name} TYPE ${tableName}.`;
        }
        else if (fieldList.concatTokens().toUpperCase() === "COUNT( * )") {
            fieldDefinition = `DATA ${name} TYPE i.`;
        }
        else if (fieldList.concatTokens().toUpperCase() === "@ABAP_TRUE"
            || fieldList.concatTokens().toUpperCase() === "@ABAP_FALSE") {
            fieldDefinition = `DATA ${name} TYPE abap_bool.`;
        }
        else if (fieldList.getChildren().length === 1 && fieldList.getChildren()[0].get() instanceof Expressions.SQLAggregation) {
            const c = fieldList.getChildren()[0];
            if (c instanceof nodes_1.ExpressionNode) {
                const concat = (_d = c.findFirstExpression(Expressions.SQLArithmetics)) === null || _d === void 0 ? void 0 : _d.concatTokens();
                fieldDefinition = `DATA ${name} TYPE ${tableName}-${concat}.`;
            }
        }
        else {
            for (const f of fields) {
                const fieldName = f.concatTokens();
                fieldDefinition += indentation + "        " + fieldName + " TYPE " + tableName + "-" + fieldName + ",\n";
            }
            fieldDefinition = `DATA: BEGIN OF ${name},
${fieldDefinition}${indentation}      END OF ${name}.`;
        }
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getStart(), `${fieldDefinition}
${indentation}`);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, inlineData.getFirstToken().getStart(), inlineData.getLastToken().getEnd(), name);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, inlineData.getFirstToken(), "Outline SELECT @DATA", this.getMetadata().key, this.conf.severity, fix);
    }
    downportSelectTableInline(low, high, lowFile, highSyntax) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        const targets = ((_a = high.findFirstExpression(Expressions.SQLIntoTable)) === null || _a === void 0 ? void 0 : _a.findDirectExpressions(Expressions.SQLTarget)) || [];
        if (targets.length !== 1) {
            return undefined;
        }
        const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
        const inlineData = targets[0].findFirstExpression(Expressions.InlineData);
        if (inlineData === undefined) {
            return undefined;
        }
        const sqlFrom = high.findAllExpressions(Expressions.SQLFromSource);
        if (sqlFrom.length === 0) {
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Error outlining, sqlFrom not found", this.getMetadata().key, this.conf.severity);
        }
        let tableName = (_b = sqlFrom[0].findDirectExpression(Expressions.DatabaseTable)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        if (tableName === undefined) {
            return undefined;
        }
        const tableMap = {};
        for (const from of sqlFrom) {
            const dbName = (_c = from.findDirectExpression(Expressions.DatabaseTable)) === null || _c === void 0 ? void 0 : _c.concatTokens().toUpperCase();
            if (dbName === undefined) {
                continue;
            }
            const asName = ((_d = from.findDirectExpression(Expressions.SQLAsName)) === null || _d === void 0 ? void 0 : _d.concatTokens().toUpperCase()) || dbName;
            tableMap[asName] = dbName;
        }
        const fieldList = high.findFirstExpression(Expressions.SQLFieldList);
        if (fieldList === undefined) {
            return undefined;
        }
        let fieldDefinitions = "";
        for (const f of fieldList.findAllExpressions(Expressions.SQLField)) {
            let fieldName = (_e = f.findFirstExpression(Expressions.SQLFieldName)) === null || _e === void 0 ? void 0 : _e.concatTokens();
            if (fieldName === undefined) {
                continue;
            }
            if (fieldName.includes("~")) {
                const split = fieldName.split("~");
                tableName = split[0];
                fieldName = split[1];
            }
            const translated = tableMap[tableName.toUpperCase()];
            const typeName = translated + "-" + fieldName;
            fieldName = ((_f = f.findFirstExpression(Expressions.SQLAsName)) === null || _f === void 0 ? void 0 : _f.concatTokens()) || fieldName;
            fieldDefinitions += indentation + "        " + fieldName + " TYPE " + typeName.toLowerCase() + ",\n";
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const name = ((_g = inlineData.findFirstExpression(Expressions.TargetField)) === null || _g === void 0 ? void 0 : _g.concatTokens()) || "error";
        let fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getStart(), `TYPES: BEGIN OF ${uniqueName},
${fieldDefinitions}${indentation}      END OF ${uniqueName}.
${indentation}DATA ${name} TYPE STANDARD TABLE OF ${uniqueName} WITH DEFAULT KEY.
${indentation}`);
        if (fieldDefinitions === "") {
            fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getStart(), `DATA ${name} TYPE STANDARD TABLE OF ${tableName} WITH DEFAULT KEY.
${indentation}`);
        }
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, inlineData.getFirstToken().getStart(), inlineData.getLastToken().getEnd(), name);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, inlineData.getFirstToken(), "Outline SELECT @DATA", this.getMetadata().key, this.conf.severity, fix);
    }
    // the anonymous type minght be used in inferred type statements, define it so it can be referred
    anonymousTableType(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.Data)) {
            return undefined;
        }
        const tt = high.findFirstExpression(Expressions.TypeTable);
        if (tt === undefined) {
            return undefined;
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const code = `TYPES ${uniqueName} ${tt.concatTokens()}.\n`;
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, tt.getFirstToken().getStart(), tt.getLastToken().getEnd(), "TYPE " + uniqueName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Add type for table definition", this.getMetadata().key, this.conf.severity, fix);
    }
    downportMessage(high, lowFile, highSyntax) {
        var _a, _b;
        if (!(high.get() instanceof Statements.Message)) {
            return undefined;
        }
        const foundWith = high.findExpressionAfterToken("WITH");
        if (foundWith === undefined) {
            return undefined;
        }
        const likeSource = high.findExpressionAfterToken("LIKE");
        for (const s of high.findAllExpressions(Expressions.Source)) {
            if (s === likeSource) {
                continue;
            }
            else if (s.getChildren().length === 1 && ((_a = s.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.Constant) {
                continue;
            }
            else if (s.getChildren().length === 1 && ((_b = s.getFirstChild()) === null || _b === void 0 ? void 0 : _b.get()) instanceof Expressions.FieldChain) {
                continue;
            }
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            const code = `DATA(${uniqueName}) = ${s.concatTokens()}.\n${indentation}`;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, s.getFirstToken().getStart(), s.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Refactor MESSAGE WITH source", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    replaceAppendExpression(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.Append)) {
            return undefined;
        }
        const children = high.getChildren();
        if (children[1].get() instanceof Expressions.Source) {
            const source = children[1];
            const target = high.findDirectExpression(Expressions.Target);
            if (target === undefined) {
                return undefined;
            }
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA ${uniqueName} LIKE LINE OF ${target === null || target === void 0 ? void 0 : target.concatTokens()}.
${indentation}${uniqueName} = ${source.concatTokens()}.\n${indentation}`);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, source.getFirstToken().getStart(), source.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline APPEND source expression", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    downportReadTable(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.ReadTable)) {
            return undefined;
        }
        const source = high.findExpressionAfterToken("TABLE");
        if ((source === null || source === void 0 ? void 0 : source.get()) instanceof Expressions.Source) {
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA(${uniqueName}) = ${source.concatTokens()}.\n` + indentation);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, source.getFirstToken().getStart(), source.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline table source", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    downportMessageSource(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.Message)) {
            return undefined;
        }
        const source = high.findExpressionAfterToken("MESSAGE");
        if ((source === null || source === void 0 ? void 0 : source.get()) instanceof Expressions.Source) {
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA(${uniqueName}) = ${source.concatTokens()}.\n` + indentation);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, source.getFirstToken().getStart(), source.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline message source", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    replaceInsertExpression(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.InsertInternal)) {
            return undefined;
        }
        const children = high.getChildren();
        if (children[1].get() instanceof Expressions.Source) {
            const source = children[1];
            const target = high.findDirectExpression(Expressions.Target);
            if (target === undefined) {
                return undefined;
            }
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA ${uniqueName} LIKE LINE OF ${target === null || target === void 0 ? void 0 : target.concatTokens()}.
${indentation}${uniqueName} = ${source.concatTokens()}.\n${indentation}`);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, source.getFirstToken().getStart(), source.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline INSERT source expression", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    replaceTableExpression(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const fieldChain of high.findAllExpressionsRecursive(Expressions.FieldChain)) {
            const tableExpression = fieldChain.findDirectExpression(Expressions.TableExpression);
            if (tableExpression === undefined) {
                continue;
            }
            const concat = high.concatTokens().toUpperCase();
            if (concat.includes(" LINE_EXISTS( ") || concat.includes(" LINE_INDEX( ")) {
                // note: line_exists() must be replaced before handling table expressions
                continue;
            }
            let pre = "";
            let startToken = undefined;
            for (const child of fieldChain.getChildren()) {
                if (startToken === undefined) {
                    startToken = child.getFirstToken();
                }
                else if (child === tableExpression) {
                    break;
                }
                pre += child.concatTokens();
            }
            if (startToken === undefined) {
                continue;
            }
            const condition = this.tableCondition(tableExpression);
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const tabixBackup = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const firstToken = high.getFirstToken();
            // note that the tabix restore should be done before throwing the exception
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA ${uniqueName} LIKE LINE OF ${pre}.
${indentation}DATA ${tabixBackup} LIKE sy-tabix.
${indentation}${tabixBackup} = sy-tabix.
${indentation}READ TABLE ${pre} ${condition}INTO ${uniqueName}.
${indentation}sy-tabix = ${tabixBackup}.
${indentation}IF sy-subrc <> 0.
${indentation}  RAISE EXCEPTION TYPE cx_sy_itab_line_not_found.
${indentation}ENDIF.
${indentation}`);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, startToken.getStart(), tableExpression.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            if (high.get() instanceof Statements.ElseIf) {
                throw "downport, unable to downport table expression in ELSEIF";
            }
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline table expression", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    tableCondition(tableExpression) {
        let condition = "";
        let keyName = "";
        for (const c of tableExpression.getChildren() || []) {
            if (c.getFirstToken().getStr() === "[" || c.getFirstToken().getStr() === "]") {
                continue;
            }
            else if (c.get() instanceof Expressions.ComponentChainSimple && condition === "") {
                if (keyName === "") {
                    condition = "WITH KEY ";
                }
                else {
                    condition = "WITH TABLE KEY " + keyName + " COMPONENTS ";
                }
            }
            else if (c.get() instanceof Expressions.Source && condition === "") {
                condition = "INDEX ";
            }
            else if (c instanceof nodes_1.TokenNode && c.getFirstToken().getStr().toUpperCase() === "KEY") {
                continue;
            }
            else if (c.get() instanceof Expressions.SimpleName) {
                keyName = c.concatTokens();
                continue;
            }
            condition += c.concatTokens() + " ";
        }
        return condition;
    }
    outlineCatchSimple(node, lowFile) {
        // outlines "CATCH cx_bcs INTO DATA(lx_bcs_excep).", note that this does not need to look at types
        var _a, _b;
        if (!(node.get() instanceof Statements.Catch)) {
            return undefined;
        }
        const target = node.findFirstExpression(Expressions.Target);
        if (!(((_a = target === null || target === void 0 ? void 0 : target.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.InlineData)) {
            return undefined;
        }
        const classNames = node.findDirectExpressions(Expressions.ClassName);
        if (classNames.length !== 1) {
            return undefined;
        }
        const className = classNames[0].concatTokens();
        const targetName = (_b = target.findFirstExpression(Expressions.TargetField)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
        const code = `  DATA ${targetName} TYPE REF TO ${className}.
${indentation}CATCH ${className} INTO ${targetName}.`;
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, node.getStart(), node.getEnd(), code);
        return issue_1.Issue.atToken(lowFile, node.getFirstToken(), "Outline DATA", this.getMetadata().key, this.conf.severity, fix);
    }
    outlineGetReferenceSimple(node, lowFile) {
        var _a, _b, _c;
        if (!(node.get() instanceof Statements.GetReference)) {
            return undefined;
        }
        const target = node.findFirstExpression(Expressions.Target);
        if (!(((_a = target === null || target === void 0 ? void 0 : target.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.InlineData)) {
            return undefined;
        }
        const source = node.findFirstExpression(Expressions.Source);
        if (!(((_b = source === null || source === void 0 ? void 0 : source.getFirstChild()) === null || _b === void 0 ? void 0 : _b.get()) instanceof Expressions.FieldChain)) {
            return undefined;
        }
        const targetName = ((_c = target.findFirstExpression(Expressions.TargetField)) === null || _c === void 0 ? void 0 : _c.concatTokens()) || "errorError";
        const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
        const firstToken = target.getFirstToken();
        const lastToken = target.getLastToken();
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, node.getStart(), `DATA ${targetName} LIKE REF TO ${source.concatTokens()}.\n${indentation}`);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), lastToken.getEnd(), targetName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, node.getFirstToken(), "Outline DATA", this.getMetadata().key, this.conf.severity, fix);
    }
    outlineDataSimple(node, lowFile, highSyntax) {
        var _a, _b, _c;
        if (!(node.get() instanceof Statements.Move)) {
            return undefined;
        }
        const target = node.findFirstExpression(Expressions.Target);
        if (!(((_a = target === null || target === void 0 ? void 0 : target.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.InlineData)) {
            return undefined;
        }
        let type = "";
        const source = node.findFirstExpression(Expressions.Source);
        if (source === undefined) {
            return undefined;
        }
        else if (source.getChildren().length !== 1) {
            return undefined;
        }
        else if (!(((_b = source.getFirstChild()) === null || _b === void 0 ? void 0 : _b.get()) instanceof Expressions.FieldChain)) {
            return undefined;
        }
        else if (source.findFirstExpression(Expressions.FieldOffset)) {
            return undefined;
        }
        else if (source.findFirstExpression(Expressions.FieldLength)) {
            return undefined;
        }
        else if (source.findFirstExpression(Expressions.TableExpression)) {
            const chain = source.findDirectExpression(Expressions.FieldChain);
            if (chain !== undefined
                && chain.getChildren().length === 2
                && chain.getChildren()[0].get() instanceof Expressions.SourceField
                && chain.getChildren()[1].get() instanceof Expressions.TableExpression) {
                type = "LINE OF " + chain.getChildren()[0].concatTokens();
            }
            else {
                return undefined;
            }
        }
        else {
            const spag = highSyntax.spaghetti.lookupPosition(source.getFirstToken().getStart(), lowFile.getFilename());
            if (spag) {
                const found = spag.findVariable(source.concatTokens());
                if (found && found.getType().isGeneric() === true) {
                    return undefined;
                }
            }
            type = source.concatTokens();
        }
        const targetName = (_c = target.findFirstExpression(Expressions.TargetField)) === null || _c === void 0 ? void 0 : _c.concatTokens();
        const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
        const firstToken = node.getFirstToken();
        const lastToken = node.getLastToken();
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, firstToken.getStart(), `DATA ${targetName} LIKE ${type}.\n${indentation}`);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), lastToken.getEnd(), `${targetName} = ${source.concatTokens()}.`);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, node.getFirstToken(), "Outline DATA", this.getMetadata().key, this.conf.severity, fix);
    }
    partiallyImplemented(node, lowFile) {
        if (node.get() instanceof Statements.InterfaceDef) {
            const partially = node.findDirectTokenByText("PARTIALLY");
            if (partially === undefined) {
                return undefined;
            }
            const implemented = node.findDirectTokenByText("IMPLEMENTED");
            if (implemented === undefined) {
                return undefined;
            }
            const fix = edit_helper_1.EditHelper.deleteRange(lowFile, partially.getStart(), implemented.getEnd());
            return issue_1.Issue.atToken(lowFile, partially, "Downport PARTIALLY IMPLEMENTED", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    raiseException(node, lowFile, highSyntax) {
        /*
        Note: IF_T100_DYN_MSG does not exist in 702, so this rule is mostly relevant for the transpiler
    
        DATA foo LIKE if_t100_message=>t100key.
        foo-msgid = 'ZHVAM'.
        foo-msgno = '001'.
        foo-attr1 = 'IF_T100_DYN_MSG~MSGV1'.
        foo-attr2 = 'IF_T100_DYN_MSG~MSGV2'.
        foo-attr3 = 'IF_T100_DYN_MSG~MSGV3'.
        foo-attr4 = 'IF_T100_DYN_MSG~MSGV4'.
        DATA bar TYPE REF TO zcl_hvam_exception.
        CREATE OBJECT bar EXPORTING textid = foo.
        bar->if_t100_dyn_msg~msgty = 'E'.
        bar->if_t100_dyn_msg~msgv1 = 'abc'.
        bar->if_t100_dyn_msg~msgv2 = 'abc'.
        bar->if_t100_dyn_msg~msgv3 = 'abc'.
        bar->if_t100_dyn_msg~msgv4 = 'abc'.
        RAISE EXCEPTION bar.
        */
        var _a, _b, _c, _d, _e, _f, _g;
        if (!(node.get() instanceof Statements.Raise)) {
            return undefined;
        }
        let id = undefined;
        let number = undefined;
        let startToken = node.findDirectTokenByText("ID");
        if (startToken) {
            const sources = node.findDirectExpressions(Expressions.Source);
            id = sources[0].concatTokens();
            const numberExpression = node.findExpressionAfterToken("NUMBER");
            if (numberExpression === undefined) {
                throw "downport raiseException, could not find number";
            }
            number = numberExpression.concatTokens();
            if (numberExpression.get() instanceof Expressions.MessageNumber) {
                number = "'" + number + "'";
            }
        }
        else {
            const s = node.findDirectExpression(Expressions.MessageSource);
            if (s === undefined) {
                return undefined;
            }
            if (s.findDirectExpression(Expressions.MessageClass)) {
                id = "'" + ((_b = (_a = s.findDirectExpression(Expressions.MessageClass)) === null || _a === void 0 ? void 0 : _a.concatTokens()) === null || _b === void 0 ? void 0 : _b.toUpperCase()) + "'";
            }
            else {
                id = (_c = s.findExpressionAfterToken("ID")) === null || _c === void 0 ? void 0 : _c.concatTokens();
            }
            if (s.findDirectExpression(Expressions.MessageTypeAndNumber)) {
                number = "'" + ((_d = s.findDirectExpression(Expressions.MessageTypeAndNumber)) === null || _d === void 0 ? void 0 : _d.concatTokens().substring(1)) + "'";
            }
            else {
                number = (_e = s.findExpressionAfterToken("NUMBER")) === null || _e === void 0 ? void 0 : _e.concatTokens();
            }
            startToken = node.getFirstToken();
        }
        const withs = ((_f = node.findDirectExpression(Expressions.RaiseWith)) === null || _f === void 0 ? void 0 : _f.findDirectExpressions(Expressions.SimpleSource1)) || [];
        const className = ((_g = node.findDirectExpression(Expressions.ClassName)) === null || _g === void 0 ? void 0 : _g.concatTokens()) || "ERROR";
        const uniqueName1 = this.uniqueName(node.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const uniqueName2 = this.uniqueName(node.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
        let abap = `DATA ${uniqueName1} LIKE if_t100_message=>t100key.
${indentation}${uniqueName1}-msgid = ${id}.
${indentation}${uniqueName1}-msgno = ${number}.\n`;
        if (withs.length > 0) {
            abap += `${indentation}${uniqueName1}-attr1 = 'IF_T100_DYN_MSG~MSGV1'.
${indentation}${uniqueName1}-attr2 = 'IF_T100_DYN_MSG~MSGV2'.
${indentation}${uniqueName1}-attr3 = 'IF_T100_DYN_MSG~MSGV3'.
${indentation}${uniqueName1}-attr4 = 'IF_T100_DYN_MSG~MSGV4'.\n`;
        }
        abap += `${indentation}DATA ${uniqueName2} TYPE REF TO ${className}.
${indentation}CREATE OBJECT ${uniqueName2} EXPORTING textid = ${uniqueName1}.\n`;
        if (withs.length > 0) {
            abap += `${indentation}${uniqueName2}->if_t100_dyn_msg~msgty = 'E'.\n`;
        }
        let count = 1;
        for (const w of withs) {
            abap += `${indentation}${uniqueName2}->if_t100_dyn_msg~msgv${count} = ${w.concatTokens()}.\n`;
            count++;
        }
        abap += `${indentation}RAISE EXCEPTION ${uniqueName2}.`;
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, node.getStart(), node.getEnd(), abap);
        return issue_1.Issue.atToken(lowFile, startToken, "Downport RAISE MESSAGE", this.getMetadata().key, this.conf.severity, fix);
    }
    emptyKey(low, node, lowFile) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (let i of node.findAllExpressions(Expressions.TypeTable)) {
            const key = i.findDirectExpression(Expressions.TypeTableKey);
            if (key === undefined) {
                continue;
            }
            i = key;
            const concat = i.concatTokens();
            if (concat.toUpperCase().includes("WITH EMPTY KEY") === false) {
                continue;
            }
            const token = i.findDirectTokenByText("EMPTY");
            if (token === undefined) {
                continue;
            }
            const fix = edit_helper_1.EditHelper.replaceToken(lowFile, token, "DEFAULT");
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Downport EMPTY KEY", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    callFunctionParameterSimple(high, lowFile, highSyntax) {
        if (!(high.get() instanceof Statements.CallFunction)) {
            return undefined;
        }
        let found = undefined;
        for (const p of high.findAllExpressions(Expressions.FunctionExportingParameter)) {
            found = p.findDirectExpression(Expressions.Source);
            if (found && (found.findDirectExpression(Expressions.FieldChain)
                || found.findDirectExpression(Expressions.Constant)
                || found.findDirectExpression(Expressions.TextElement))) {
                // its actually simple, ok
                found = undefined;
            }
            else if (found !== undefined) {
                break;
            }
        }
        if (found === undefined) {
            return undefined;
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const code = `DATA(${uniqueName}) = ${found.concatTokens()}.\n`;
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, found.getFirstToken().getStart(), found.getLastToken().getEnd(), uniqueName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, call function parameter", this.getMetadata().key, this.conf.severity, fix);
    }
    downportCorrespondingSimple(high, lowFile) {
        var _a, _b;
        if (!(high.get() instanceof Statements.Move)
            || high.getChildren().length !== 4
            || high.getChildren()[2].getFirstToken().getStr().toUpperCase() !== "CORRESPONDING") {
            return undefined;
        }
        const target = high.findDirectExpression(Expressions.Target);
        if (target === undefined) {
            return undefined;
        }
        const sourceRef = (_a = high.findFirstExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.findFirstExpression(Expressions.CorrespondingBody);
        if ((sourceRef === null || sourceRef === void 0 ? void 0 : sourceRef.getChildren().length) === 1 && target.concatTokens().toUpperCase().startsWith("DATA(") === false) {
            const code = `MOVE-CORRESPONDING ${sourceRef.concatTokens()} TO ${target.concatTokens()}`;
            const start = high.getFirstToken().getStart();
            const end = high.getLastToken().getStart();
            const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, simple CORRESPONDING move", this.getMetadata().key, this.conf.severity, fix);
        }
        else if ((sourceRef === null || sourceRef === void 0 ? void 0 : sourceRef.getChildren().length) === 5 && ((_b = sourceRef.getFirstChild()) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase()) === "BASE") {
            let code = `${target.concatTokens()} = ${sourceRef.getChildren()[2].concatTokens()}.\n`;
            code += `MOVE-CORRESPONDING ${sourceRef.getChildren()[4].concatTokens()} TO ${target.concatTokens()}`;
            const start = high.getFirstToken().getStart();
            const end = high.getLastToken().getStart();
            const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, CORRESPONDING BASE move", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    downportRefSimple(high, lowFile, highSyntax) {
        var _a, _b;
        if (!(high.get() instanceof Statements.Move)
            || high.getChildren().length !== 4
            || high.getChildren()[2].getFirstToken().getStr().toUpperCase() !== "REF") {
            return undefined;
        }
        const target = high.findDirectExpression(Expressions.Target);
        if (target === undefined) {
            return undefined;
        }
        const sourceRef = (_a = high.findFirstExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Source);
        if (sourceRef === undefined
            || sourceRef.getChildren().length !== 1) {
            return undefined;
        }
        let code = "";
        if (sourceRef.findFirstExpression(Expressions.TableExpression)) {
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            code = `ASSIGN ${sourceRef.concatTokens()} TO FIELD-SYMBOL(<${uniqueName}>).
IF sy-subrc <> 0.
  RAISE EXCEPTION TYPE cx_sy_itab_line_not_found.
ENDIF.
GET REFERENCE OF <${uniqueName}> INTO ${target.concatTokens()}`;
        }
        else {
            const concat = target.concatTokens();
            code = `GET REFERENCE OF ${sourceRef.concatTokens()} INTO ${concat}`;
            // workaround for handling generic ANY type,
            if (concat.toUpperCase().startsWith("DATA(")) {
                const spag = highSyntax.spaghetti.lookupPosition(high.getFirstToken().getStart(), lowFile.getFilename());
                if (spag !== undefined) {
                    const found = spag.findVariable(sourceRef.concatTokens());
                    const tt = found === null || found === void 0 ? void 0 : found.getType();
                    if (tt instanceof basic_1.AnyType) {
                        const tname = (_b = target.findFirstExpression(Expressions.TargetField)) === null || _b === void 0 ? void 0 : _b.concatTokens();
                        code = `DATA ${tname} TYPE REF TO data.\nGET REFERENCE OF ${sourceRef.concatTokens()} INTO ${tname}`;
                    }
                }
            }
        }
        const start = high.getFirstToken().getStart();
        const end = high.getLastToken().getStart();
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, simple REF move", this.getMetadata().key, this.conf.severity, fix);
    }
    downportLoopGroup(high, lowFile, highSyntax, highFile) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
        if (!(high.get() instanceof Statements.Loop)) {
            return undefined;
        }
        const group = high.findDirectExpression(Expressions.LoopGroupBy);
        if (group === undefined) {
            return undefined;
        }
        const groupTargetName = ((_a = group.findFirstExpression(Expressions.TargetField)) === null || _a === void 0 ? void 0 : _a.concatTokens())
            || ((_b = group.findFirstExpression(Expressions.TargetFieldSymbol)) === null || _b === void 0 ? void 0 : _b.concatTokens().replace("<", "_").replace(">", "_"))
            || "nameNotFound";
        const loopSourceName = ((_c = high.findFirstExpression(Expressions.SimpleSource2)) === null || _c === void 0 ? void 0 : _c.concatTokens()) || "nameNotFound";
        const loopTargetName = ((_d = high.findFirstExpression(Expressions.TargetField)) === null || _d === void 0 ? void 0 : _d.concatTokens())
            || ((_e = high.findFirstExpression(Expressions.TargetFieldSymbol)) === null || _e === void 0 ? void 0 : _e.concatTokens())
            || "nameNotFound";
        const groupTarget = ((_f = group.findDirectExpression(Expressions.LoopGroupByTarget)) === null || _f === void 0 ? void 0 : _f.concatTokens()) || "";
        const isReference = (_g = high.findFirstExpression(Expressions.LoopTarget)) === null || _g === void 0 ? void 0 : _g.concatTokens().toUpperCase().startsWith("REFERENCE INTO ");
        let loopSourceRowType = "typeNotFound";
        const spag = highSyntax.spaghetti.lookupPosition(high.getFirstToken().getStart(), lowFile.getFilename());
        if (spag !== undefined) {
            const found = spag.findVariable(loopSourceName);
            const tt = found === null || found === void 0 ? void 0 : found.getType();
            if (tt instanceof basic_1.TableType) {
                loopSourceRowType = tt.getRowType().getQualifiedName() || "typeNotFound";
            }
        }
        let code = `TYPES: BEGIN OF ${groupTargetName}type,\n`;
        let condition = "";
        let groupCountName = undefined;
        let groupIndexName = undefined;
        for (const c of group.findAllExpressions(Expressions.LoopGroupByComponent)) {
            const name = c.findFirstExpression(Expressions.ComponentName);
            let type = ((_h = c.findFirstExpression(Expressions.Source)) === null || _h === void 0 ? void 0 : _h.concatTokens()) || "todo";
            if ((_j = c.concatTokens()) === null || _j === void 0 ? void 0 : _j.toUpperCase().endsWith(" = GROUP SIZE")) {
                type = "i";
                groupCountName = name === null || name === void 0 ? void 0 : name.concatTokens();
            }
            else if ((_k = c.concatTokens()) === null || _k === void 0 ? void 0 : _k.toUpperCase().endsWith(" = GROUP INDEX")) {
                type = "i";
                groupIndexName = name === null || name === void 0 ? void 0 : name.concatTokens();
            }
            else {
                if (condition !== "") {
                    condition += " ";
                }
                condition += c.concatTokens();
                type = type.replace(loopTargetName, loopSourceRowType);
                type = type.replace("->", "-");
            }
            code += `         ${name === null || name === void 0 ? void 0 : name.concatTokens()} TYPE ${type},\n`;
        }
        const s = group.findDirectExpression(Expressions.Source);
        let singleName = "";
        if (s) {
            let type = s.concatTokens();
            type = type.replace(loopTargetName, loopSourceRowType);
            type = type.replace("->", "-");
            singleName = s.concatTokens().split("-")[1];
            code += `         ${singleName} TYPE ${type},\n`;
            condition = singleName + " = " + s.concatTokens();
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const uniqueFS = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const uniqueNameIndex = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        code += `         items LIKE ${loopSourceName},
       END OF ${groupTargetName}type.
DATA ${groupTargetName}tab TYPE STANDARD TABLE OF ${groupTargetName}type WITH DEFAULT KEY.
DATA ${uniqueName} LIKE LINE OF ${groupTargetName}tab.
LOOP AT ${loopSourceName} ${(_l = high.findFirstExpression(Expressions.LoopTarget)) === null || _l === void 0 ? void 0 : _l.concatTokens()}.\n`;
        if (groupIndexName !== undefined) {
            code += `DATA(${uniqueNameIndex}) = sy-tabix.\n`;
        }
        code += `READ TABLE ${groupTargetName}tab ASSIGNING FIELD-SYMBOL(<${uniqueFS}>) WITH KEY ${condition}.
IF sy-subrc = 0.\n`;
        if (groupCountName !== undefined) {
            code += `  <${uniqueFS}>-${groupCountName} = <${uniqueFS}>-${groupCountName} + 1.\n`;
        }
        code += `  INSERT ${loopTargetName}${isReference ? "->*" : ""} INTO TABLE <${uniqueFS}>-items.
ELSE.\n`;
        code += `  CLEAR ${uniqueName}.\n`;
        for (const c of group.findAllExpressions(Expressions.LoopGroupByComponent)) {
            const concat = c.concatTokens();
            //      console.dir(concat);
            if (concat.endsWith(" GROUP INDEX")) {
                code += `  ${uniqueName}-${groupIndexName} = ${uniqueNameIndex}.\n`;
            }
            else if (concat.endsWith(" GROUP SIZE")) {
                code += `  ${uniqueName}-${groupCountName} = 1.\n`;
            }
            else {
                code += `  ${uniqueName}-${concat}.\n`;
            }
        }
        if (singleName !== "") {
            code += `  ${uniqueName}-${singleName} = ${loopTargetName}-${singleName}.\n`;
        }
        code += `  INSERT ${loopTargetName}${isReference ? "->*" : ""} INTO TABLE ${uniqueName}-items.\n`;
        code += `  INSERT ${uniqueName} INTO TABLE ${groupTargetName}tab.\n`;
        code += `ENDIF.
ENDLOOP.
LOOP AT ${groupTargetName}tab ${groupTarget}.`;
        let fix = edit_helper_1.EditHelper.replaceRange(lowFile, high.getFirstToken().getStart(), high.getLastToken().getEnd(), code);
        for (const l of ((_m = highFile.getStructure()) === null || _m === void 0 ? void 0 : _m.findAllStructures(Structures.Loop)) || []) {
            // make sure to find the correct/current loop statement
            if (l.findDirectStatement(Statements.Loop) !== high) {
                continue;
            }
            for (const loop of l.findAllStatements(Statements.Loop)) {
                if ((_o = loop.concatTokens()) === null || _o === void 0 ? void 0 : _o.toUpperCase().startsWith("LOOP AT GROUP ")) {
                    const subLoopSource = loop.findFirstExpression(Expressions.SimpleSource2);
                    if (subLoopSource === undefined) {
                        continue;
                    }
                    const subLoopSourceName = (subLoopSource === null || subLoopSource === void 0 ? void 0 : subLoopSource.concatTokens()) || "nameNotFound";
                    const subCode = `LOOP AT ${subLoopSourceName}${isReference ? "->" : "-"}items`;
                    const subFix = edit_helper_1.EditHelper.replaceRange(lowFile, loop.getFirstToken().getStart(), subLoopSource.getLastToken().getEnd(), subCode);
                    fix = edit_helper_1.EditHelper.merge(subFix, fix);
                }
            }
        }
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, LOOP GROUP", this.getMetadata().key, this.conf.severity, fix);
    }
    downportRef(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        let found = undefined;
        for (const s of high.findAllExpressionsRecursive(Expressions.Source)) {
            if (s.getFirstToken().getStr().toUpperCase() === "REF"
                && s.findDirectExpression(Expressions.TypeNameOrInfer)) {
                found = s;
            }
        }
        if (found === undefined) {
            return undefined;
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const code = `DATA(${uniqueName}) = ${found.concatTokens()}.\n`;
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, found.getFirstToken().getStart(), found.getLastToken().getEnd(), uniqueName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, REF", this.getMetadata().key, this.conf.severity, fix);
    }
    assignWithTable(low, high, lowFile) {
        var _a, _b;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        if (!(high.get() instanceof Statements.Assign)) {
            return undefined;
        }
        else if (high.getChildren().length !== 5) {
            return undefined;
        }
        const fieldChain = (_b = (_a = high.findDirectExpression(Expressions.AssignSource)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.findDirectExpression(Expressions.FieldChain);
        const tableExpression = fieldChain === null || fieldChain === void 0 ? void 0 : fieldChain.getLastChild();
        if (tableExpression === undefined
            || !(tableExpression.get() instanceof Expressions.TableExpression)
            || !(tableExpression instanceof nodes_1.ExpressionNode)) {
            return undefined;
        }
        let condition = "";
        if (tableExpression.getChildren().length === 3) {
            const index = tableExpression.findDirectExpression(Expressions.Source);
            if (index === undefined) {
                return undefined;
            }
            condition = `INDEX ${index.concatTokens()}`;
        }
        else {
            let concat = tableExpression.concatTokens();
            concat = concat.substring(2);
            concat = concat.substring(0, concat.length - 2);
            condition = `WITH KEY ${concat}`;
        }
        let pre = "";
        for (const c of fieldChain.getChildren()) {
            if (c === tableExpression) {
                break;
            }
            pre += c.concatTokens();
        }
        const fsTarget = high.findDirectExpression(Expressions.FSTarget);
        const code = `READ TABLE ${pre} ${condition} ASSIGNING ${fsTarget === null || fsTarget === void 0 ? void 0 : fsTarget.concatTokens()}.`;
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, high.getFirstToken().getStart(), high.getLastToken().getEnd(), code);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, ASSIGN table expr", this.getMetadata().key, this.conf.severity, fix);
    }
    assignComponent(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        if (!(high.get() instanceof Statements.Assign)) {
            return undefined;
        }
        const assignSource = high.findDirectExpression(Expressions.AssignSource);
        if (assignSource === undefined || assignSource.getFirstToken().getStr().toUpperCase() !== "COMPONENT") {
            return undefined;
        }
        const componentSource = assignSource.findExpressionAfterToken("COMPONENT");
        if (componentSource === undefined || componentSource.get() instanceof Expressions.SimpleSource3) {
            return undefined;
        }
        const uniqueName = this.uniqueName(assignSource.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const code = `DATA(${uniqueName}) = ${componentSource.concatTokens()}.\n`;
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, componentSource.getFirstToken().getStart(), componentSource.getLastToken().getEnd(), uniqueName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, ASSIGN COMPONENT source", this.getMetadata().key, this.conf.severity, fix);
    }
    moveWithSimpleValue(low, high, lowFile) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        if (!(high.get() instanceof Statements.Move)
            || high.getChildren().length !== 4) {
            return undefined;
        }
        const target = high.findDirectExpression(Expressions.Target);
        if (target === undefined) {
            return undefined;
        }
        const source = high.findDirectExpression(Expressions.Source);
        if (source === undefined) {
            return undefined;
        }
        const field = target.findDirectExpression(Expressions.TargetField);
        if (field === undefined) {
            return;
        }
        const valueBody = source.findDirectExpression(Expressions.ValueBody);
        if (valueBody === undefined) {
            return;
        }
        const type = source.findDirectExpression(Expressions.TypeNameOrInfer);
        if (type === undefined || (type === null || type === void 0 ? void 0 : type.concatTokens()) !== "#") {
            return;
        }
        const fieldAssignments = valueBody.findDirectExpressions(Expressions.FieldAssignment);
        if (fieldAssignments.length === 0) {
            return;
        }
        else if (fieldAssignments.length !== valueBody.getChildren().length) {
            return;
        }
        const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
        let code = `CLEAR ${target.concatTokens()}.\n`;
        for (const fieldAssignment of fieldAssignments) {
            code += indentation + target.concatTokens() + "-" + fieldAssignment.concatTokensWithLinebreaks() + `.\n`;
        }
        code = code.trimEnd();
        const start = high.getFirstToken().getStart();
        const end = high.getLastToken().getEnd();
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, simple move", this.getMetadata().key, this.conf.severity, fix);
    }
    // note, downporting ENUM does not give the correct types, but it will work in most cases?
    downportEnum(_low, high, lowFile, _highSyntax, highFile) {
        var _a, _b, _c, _d, _e;
        if (!(high.get() instanceof Statements.TypeEnumBegin)) {
            return undefined;
        }
        const enumStructure = (_a = highFile.getStructure()) === null || _a === void 0 ? void 0 : _a.findFirstStructure(Structures.TypeEnum);
        if (enumStructure === undefined) {
            return undefined;
        }
        if (enumStructure.getFirstStatement() !== high) {
            return undefined;
        }
        const enumName = (_b = high.findExpressionAfterToken("ENUM")) === null || _b === void 0 ? void 0 : _b.concatTokens();
        const structureName = (_c = high.findExpressionAfterToken("STRUCTURE")) === null || _c === void 0 ? void 0 : _c.concatTokens();
        // all ENUMS are char like?
        let code = `TYPES ${enumName} TYPE string.
CONSTANTS: BEGIN OF ${structureName},\n`;
        let count = 1;
        for (const e of enumStructure.findDirectStatements(Statements.TypeEnum).concat(enumStructure.findDirectStatements(Statements.Type))) {
            const name = (_d = e.findFirstExpression(Expressions.NamespaceSimpleName)) === null || _d === void 0 ? void 0 : _d.concatTokens();
            let value = (_e = e.findFirstExpression(Expressions.Value)) === null || _e === void 0 ? void 0 : _e.concatTokens();
            if (value === undefined) {
                value = "VALUE '" + count++ + "'";
            }
            code += `             ${name} TYPE ${enumName} ${value},\n`;
        }
        code += `           END OF ${structureName}.`;
        const start = enumStructure.getFirstToken().getStart();
        const end = enumStructure.getLastToken().getEnd();
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport ENUM", this.getMetadata().key, this.conf.severity, fix);
    }
    moveWithTableTarget(low, high, lowFile, highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        if (!(high.get() instanceof Statements.Move)) {
            return undefined;
        }
        const target = high.findDirectExpression(Expressions.Target);
        if (target === undefined) {
            return undefined;
        }
        const tableExpression = target.findDirectExpression(Expressions.TableExpression);
        if (tableExpression === undefined) {
            return undefined;
        }
        const index = tableExpression.findDirectExpression(Expressions.Source);
        if (index === undefined) {
            return undefined;
        }
        let uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        uniqueName = `<${uniqueName}>`;
        const tName = target.concatTokens().split("[")[0];
        const condition = this.tableCondition(tableExpression);
        const tabixBackup = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
        // restore tabix before exeption
        const code = `FIELD-SYMBOLS ${uniqueName} LIKE LINE OF ${tName}.
${indentation}DATA ${tabixBackup} LIKE sy-tabix.
${indentation}${tabixBackup} = sy-tabix.
${indentation}READ TABLE ${tName} ${condition}ASSIGNING ${uniqueName}.
${indentation}sy-tabix = ${tabixBackup}.
${indentation}IF sy-subrc <> 0.
${indentation}  RAISE EXCEPTION TYPE cx_sy_itab_line_not_found.
${indentation}ENDIF.
${indentation}${uniqueName}`;
        const start = target.getFirstToken().getStart();
        const end = (_a = tableExpression.findDirectTokenByText("]")) === null || _a === void 0 ? void 0 : _a.getEnd();
        if (end === undefined) {
            return undefined;
        }
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport, move with table target", this.getMetadata().key, this.conf.severity, fix);
    }
    moveWithOperator(low, high, lowFile) {
        var _a, _b, _c;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        else if (!(high.get() instanceof Statements.Move)) {
            return undefined;
        }
        const children = high.getChildren();
        const secondChild = children[1];
        if (secondChild === undefined) {
            return undefined;
        }
        const op = secondChild.getFirstToken();
        let operator = "";
        switch (op.getStr()) {
            case "+":
                operator = " + ";
                break;
            case "-":
                operator = " - ";
                break;
            case "/=":
                operator = " / ";
                break;
            case "*=":
                operator = " * ";
                break;
            case "&&=":
                operator = " && ";
                break;
            default:
                return undefined;
        }
        const target = (_a = high.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (target === undefined) {
            return;
        }
        const sourceStart = (_c = (_b = high.findDirectExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.getFirstChild()) === null || _c === void 0 ? void 0 : _c.getFirstToken().getStart();
        if (sourceStart === undefined) {
            return;
        }
        const fix = edit_helper_1.EditHelper.replaceRange(lowFile, op.getStart(), sourceStart, "= " + target + operator);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Expand operator", this.getMetadata().key, this.conf.severity, fix);
    }
    stringTemplateAlpha(low, high, lowFile, highSyntax) {
        var _a, _b;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const child of high.findAllExpressionsRecursive(Expressions.StringTemplateSource)) {
            const formatting = (_a = child.findDirectExpression(Expressions.StringTemplateFormatting)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
            if (formatting === undefined
                || (formatting === null || formatting === void 0 ? void 0 : formatting.startsWith("ALPHA = ")) === false) {
                continue;
            }
            let functionName = "";
            switch (formatting) {
                case "ALPHA = IN":
                    functionName = "CONVERSION_EXIT_ALPHA_INPUT";
                    break;
                case "ALPHA = OUT":
                    functionName = "CONVERSION_EXIT_ALPHA_OUTPUT";
                    break;
                default:
                    return undefined;
            }
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const source = (_b = child.findDirectExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.concatTokens();
            const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const code = `DATA ${uniqueName} TYPE string.
${indentation}CALL FUNCTION '${functionName}'
${indentation}  EXPORTING
${indentation}    input  = ${source}
${indentation}  IMPORTING
${indentation}    output = ${uniqueName}.\n`;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, child.getFirstToken().getStart(), child.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Downport ALPHA", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineLoopInput(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        else if (!(high.get() instanceof Statements.Loop)) {
            return undefined;
        }
        else if (high.findDirectExpression(Expressions.SimpleSource2)) {
            return undefined;
        }
        // the first Source must be outlined
        const s = high.findDirectExpression(Expressions.Source);
        if (s === undefined) {
            return undefined;
        }
        const uniqueName = this.uniqueName(high.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
        const code = `DATA(${uniqueName}) = ${s.concatTokens()}.\n` +
            " ".repeat(high.getFirstToken().getStart().getCol() - 1);
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, s.getFirstToken().getStart(), s.getLastToken().getEnd(), uniqueName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Outline LOOP input", this.getMetadata().key, this.conf.severity, fix);
    }
    outlineLoopTarget(node, lowFile, highSyntax) {
        var _a, _b, _c, _d, _e, _f, _g;
        // also allows outlining of voided types
        if (!(node.get() instanceof Statements.Loop)) {
            return undefined;
        }
        const sourceName = (_a = node.findDirectExpression(Expressions.SimpleSource2)) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (sourceName === undefined) {
            return undefined;
        }
        const concat = node.concatTokens().toUpperCase();
        if (concat.includes(" GROUP BY ") || concat.startsWith("LOOP AT GROUP ")) {
            return undefined;
        }
        const isReference = concat.includes(" REFERENCE INTO ");
        const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
        const dataTarget = (_c = (_b = node.findDirectExpression(Expressions.LoopTarget)) === null || _b === void 0 ? void 0 : _b.findDirectExpression(Expressions.Target)) === null || _c === void 0 ? void 0 : _c.findDirectExpression(Expressions.InlineData);
        if (dataTarget) {
            const targetName = ((_d = dataTarget.findDirectExpression(Expressions.TargetField)) === null || _d === void 0 ? void 0 : _d.concatTokens()) || "DOWNPORT_ERROR";
            let code = `DATA ${targetName} LIKE LINE OF ${sourceName}.\n${indentation}`;
            if (isReference) {
                const likeName = this.uniqueName(node.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
                code = `DATA ${likeName} LIKE LINE OF ${sourceName}.\n${indentation}DATA ${targetName} LIKE REF TO ${likeName}.\n${indentation}`;
            }
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, node.getFirstToken().getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, dataTarget.getFirstToken().getStart(), dataTarget.getLastToken().getEnd(), targetName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, node.getFirstToken(), "Outline LOOP data target", this.getMetadata().key, this.conf.severity, fix);
        }
        const fsTarget = (_f = (_e = node.findDirectExpression(Expressions.LoopTarget)) === null || _e === void 0 ? void 0 : _e.findDirectExpression(Expressions.FSTarget)) === null || _f === void 0 ? void 0 : _f.findDirectExpression(Expressions.InlineFS);
        if (fsTarget) {
            const targetName = ((_g = fsTarget.findDirectExpression(Expressions.TargetFieldSymbol)) === null || _g === void 0 ? void 0 : _g.concatTokens()) || "DOWNPORT_ERROR";
            const code = `FIELD-SYMBOLS ${targetName} LIKE LINE OF ${sourceName}.\n${indentation}`;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, node.getFirstToken().getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, fsTarget.getFirstToken().getStart(), fsTarget.getLastToken().getEnd(), targetName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, node.getFirstToken(), "Outline LOOP fs target", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineFor(forLoop, indentation, lowFile, highSyntax) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        let body = "";
        let end = "";
        const loopSource = (_a = forLoop.findFirstExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.concatTokens();
        let loopTargetFieldExpression = forLoop.findFirstExpression(Expressions.TargetField);
        let loopTargetFieldName = loopTargetFieldExpression === null || loopTargetFieldExpression === void 0 ? void 0 : loopTargetFieldExpression.concatTokens();
        const of = forLoop.findExpressionAfterToken("OF");
        if (of !== undefined) {
            loopTargetFieldExpression = of;
            loopTargetFieldName = of === null || of === void 0 ? void 0 : of.concatTokens();
        }
        if (((_c = (_b = forLoop.findDirectExpression(Expressions.InlineLoopDefinition)) === null || _b === void 0 ? void 0 : _b.getFirstChild()) === null || _c === void 0 ? void 0 : _c.get()) instanceof Expressions.TargetFieldSymbol) {
            loopTargetFieldExpression = undefined;
            loopTargetFieldName = undefined;
        }
        if (loopTargetFieldExpression) {
            const start = loopTargetFieldExpression.getFirstToken().getStart();
            const spag = highSyntax.spaghetti.lookupPosition(start, lowFile.getFilename());
            if (loopTargetFieldName && spag) {
                if (new SpagHelper(spag).isDuplicateName(loopTargetFieldName, start)) {
                    this.renameVariable(spag, loopTargetFieldName, start, lowFile, highSyntax);
                }
            }
        }
        let cond = ((_d = forLoop.findDirectExpression(Expressions.ComponentCond)) === null || _d === void 0 ? void 0 : _d.concatTokens()) || "";
        if (cond !== "") {
            cond = " WHERE " + cond;
        }
        const loop = forLoop.findDirectExpression(Expressions.InlineLoopDefinition);
        const indexInto = (_e = loop === null || loop === void 0 ? void 0 : loop.findExpressionAfterToken("INTO")) === null || _e === void 0 ? void 0 : _e.concatTokens();
        if (forLoop.findDirectTokenByText("UNTIL")
            || forLoop.findDirectTokenByText("WHILE")) {
            const fieldDef = forLoop.findDirectExpression(Expressions.InlineFieldDefinition);
            const field = (_f = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.findFirstExpression(Expressions.Field)) === null || _f === void 0 ? void 0 : _f.concatTokens();
            const indexBackup = this.uniqueName(forLoop.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            body += indentation + "DATA " + field + " TYPE i.\n";
            const second = fieldDef === null || fieldDef === void 0 ? void 0 : fieldDef.getChildren()[2];
            if ((second === null || second === void 0 ? void 0 : second.get()) instanceof Expressions.Source) {
                body += indentation + field + " = " + second.concatTokens() + ".\n";
            }
            const not = forLoop.findDirectTokenByText("UNTIL") ? " NOT" : "";
            const cond = forLoop.findFirstExpression(Expressions.Cond);
            body += indentation + `DATA ${indexBackup} LIKE sy-index.\n`;
            body += indentation + `${indexBackup} = sy-index.\n`;
            body += indentation + `WHILE${not} ${cond === null || cond === void 0 ? void 0 : cond.concatTokens()}.\n`;
            body += indentation + `  sy-index = ${indexBackup}.\n`;
            const then = forLoop.findExpressionAfterToken("THEN");
            if (then) {
                end += `  ${field} = ${then.concatTokens()}.\n`;
            }
            else {
                end += `  ${field} = ${field} + 1.\n`;
            }
            end += indentation + "ENDWHILE";
        }
        else if (loopTargetFieldName !== undefined) {
            let from = (_g = forLoop.findExpressionAfterToken("FROM")) === null || _g === void 0 ? void 0 : _g.concatTokens();
            from = from ? " FROM " + from : "";
            let to = (_h = forLoop.findExpressionAfterToken("TO")) === null || _h === void 0 ? void 0 : _h.concatTokens();
            to = to ? " TO " + to : "";
            let gby = "";
            for (const lg of forLoop.findDirectExpressions(Expressions.LoopGroupByComponent)) {
                if (gby !== "") {
                    gby += " ";
                }
                gby += lg.concatTokens();
            }
            if (gby !== "") {
                gby = " GROUP BY ( " + gby + " )";
            }
            const fc = forLoop.findDirectExpression(Expressions.FieldChain);
            if (fc) {
                gby = " GROUP BY " + fc.concatTokens();
            }
            if (forLoop.findDirectTokenByText("ASCENDING")) {
                gby += " ASCENDING";
            }
            if (forLoop.findDirectTokenByText("DESCENDING")) {
                gby += " DESCENDING";
            }
            const groups = forLoop.findExpressionAfterToken("GROUPS");
            if (groups) {
                const concat = groups.concatTokens();
                if (concat.startsWith("<")) {
                    gby += " ASSIGNING FIELD-SYMBOL(" + concat + ")";
                }
                else {
                    gby += " INTO DATA(" + concat + ")";
                }
            }
            let inGroup = "";
            if (forLoop.concatTokens().toUpperCase().includes(" IN GROUP ")) {
                inGroup = "-items";
            }
            let into = "INTO DATA";
            if (loopTargetFieldName.startsWith("<")) {
                into = "ASSIGNING FIELD-SYMBOL";
            }
            // todo, also backup sy-index / sy-tabix here?
            body += indentation + `LOOP AT ${loopSource}${inGroup} ${into}(${loopTargetFieldName})${from}${to}${cond}${gby}.\n`;
            if (indexInto) {
                body += indentation + "  DATA(" + indexInto + ") = sy-tabix.\n";
            }
            end = "ENDLOOP";
        }
        else if (loopTargetFieldName === undefined) {
            // todo, also backup sy-index / sy-tabix here?
            const loopTargetFieldSymbol = (_j = forLoop.findFirstExpression(Expressions.TargetFieldSymbol)) === null || _j === void 0 ? void 0 : _j.concatTokens();
            body += indentation + `LOOP AT ${loopSource} ASSIGNING FIELD-SYMBOL(${loopTargetFieldSymbol})${cond}.\n`;
            if (indexInto) {
                body += indentation + "  DATA(" + indexInto + ") = sy-tabix.\n";
            }
            end = "ENDLOOP";
        }
        const l = forLoop.findDirectExpression(Expressions.Let);
        if (l) {
            body += this.outlineLet(l, indentation, highSyntax, lowFile);
        }
        return { body, end };
    }
    outlineFilter(low, high, lowFile, highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Source)) {
            const firstToken = i.getFirstToken();
            if (firstToken.getStr().toUpperCase() !== "FILTER") {
                continue;
            }
            const filterBody = i.findDirectExpression(Expressions.FilterBody);
            if (filterBody === undefined) {
                continue;
            }
            const sourceName = (_a = filterBody.findDirectExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.concatTokens();
            if (sourceName === undefined) {
                continue;
            }
            let type = this.findType(i, lowFile, highSyntax);
            if (type === undefined) {
                type = "LIKE " + sourceName;
            }
            else {
                type = "TYPE " + type;
            }
            const uniqueName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            const loopName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            let body = "";
            body += `DATA ${uniqueName} ${type}.\n`;
            body += `${indentation}LOOP AT ${sourceName} INTO DATA(${loopName}) ${filterBody.concatTokens().substring(sourceName.length + 1)}.\n`;
            body += `${indentation}  INSERT ${loopName} INTO TABLE ${uniqueName}.\n`;
            body += `${indentation}ENDLOOP.\n${indentation}`;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), body);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), i.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, firstToken, "Downport FILTER", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineSwitch(low, high, lowFile, highSyntax) {
        var _a, _b, _c, _d;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Source)) {
            const firstToken = i.getFirstToken();
            if (firstToken.getStr().toUpperCase() !== "SWITCH") {
                continue;
            }
            let type = this.findType(i, lowFile, highSyntax);
            if (type === undefined) {
                if (high.get() instanceof Statements.Move
                    && high.findDirectExpression(Expressions.Source) === i
                    && ((_a = high.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.TargetField)) !== undefined) {
                    type = "LIKE " + ((_b = high.findDirectExpression(Expressions.Target)) === null || _b === void 0 ? void 0 : _b.concatTokens());
                }
                if (type === undefined) {
                    continue;
                }
            }
            else {
                type = "TYPE " + type;
            }
            const uniqueName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            let body = "";
            let name = "";
            const switchBody = i.findDirectExpression(Expressions.SwitchBody);
            if (switchBody === undefined) {
                continue;
            }
            for (const l of ((_c = switchBody === null || switchBody === void 0 ? void 0 : switchBody.findDirectExpression(Expressions.Let)) === null || _c === void 0 ? void 0 : _c.findDirectExpressions(Expressions.InlineFieldDefinition)) || []) {
                name = l.getFirstToken().getStr();
                body += indentation + `DATA(${name}) = ${(_d = switchBody.findFirstExpression(Expressions.Source)) === null || _d === void 0 ? void 0 : _d.concatTokens()}.\n`;
            }
            body += `DATA ${uniqueName} ${type}.\n`;
            let firstSource = false;
            let inWhen = false;
            for (const c of switchBody.getChildren()) {
                if (c.get() instanceof Expressions.Source && firstSource === false) {
                    body += indentation + `CASE ${c.concatTokens()}.`;
                    firstSource = true;
                }
                else if (c instanceof nodes_1.TokenNode && c.concatTokens().toUpperCase() === "THEN") {
                    inWhen = true;
                    body += ".\n";
                }
                else if (c instanceof nodes_1.TokenNode && c.concatTokens().toUpperCase() === "WHEN") {
                    inWhen = false;
                    body += `\n${indentation}  WHEN `;
                }
                else if (c instanceof nodes_1.TokenNode && c.concatTokens().toUpperCase() === "OR") {
                    body += ` OR `;
                }
                else if (c instanceof nodes_1.TokenNode && c.concatTokens().toUpperCase() === "ELSE") {
                    inWhen = true;
                    body += `\n${indentation}  WHEN OTHERS.\n`;
                }
                else if (inWhen === false) {
                    body += c.concatTokens();
                }
                else {
                    body += indentation + "    " + uniqueName + " = " + c.concatTokens() + ".";
                }
            }
            body += "\n" + indentation + "ENDCASE.\n" + indentation;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), body);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), i.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, firstToken, "Downport SWITCH", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineReduce(low, high, lowFile, highSyntax) {
        var _a, _b;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Source)) {
            const firstToken = i.getFirstToken();
            if (firstToken.getStr().toUpperCase() !== "REDUCE") {
                continue;
            }
            const type = this.findType(i, lowFile, highSyntax);
            if (type === undefined) {
                continue;
            }
            const uniqueName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            let body = "";
            let name = "";
            const reduceBody = i.findDirectExpression(Expressions.ReduceBody);
            if (reduceBody === undefined) {
                continue;
            }
            const letNode = reduceBody.findDirectExpression(Expressions.Let);
            if (letNode) {
                body += this.outlineLet(letNode, indentation, highSyntax, lowFile);
            }
            let firstName = "";
            for (const init of reduceBody.findDirectExpressions(Expressions.InlineFieldDefinition)) {
                name = init.getFirstToken().getStr();
                if (firstName === "") {
                    firstName = name;
                }
                const spag = highSyntax.spaghetti.lookupPosition(init.getFirstToken().getStart(), lowFile.getFilename());
                if (spag && new SpagHelper(spag).isDuplicateName(name, init.getFirstToken().getStart())) {
                    this.renameVariable(spag, name, init.getFirstToken().getStart(), lowFile, highSyntax);
                }
                const s = (_a = init.findFirstExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.concatTokens();
                const t = (_b = init.findFirstExpression(Expressions.TypeName)) === null || _b === void 0 ? void 0 : _b.concatTokens();
                if (s) {
                    if (s.toUpperCase().startsWith("VALUE #")) {
                        body += indentation + `DATA(${name}) = ${s.replace("#", type)}.\n`;
                    }
                    else {
                        body += indentation + `DATA(${name}) = ${s}.\n`;
                    }
                }
                else {
                    body += indentation + `DATA ${name} TYPE ${t}.\n`;
                }
            }
            let end = "";
            for (const forLoop of (reduceBody === null || reduceBody === void 0 ? void 0 : reduceBody.findDirectExpressions(Expressions.For)) || []) {
                const outlineFor = this.outlineFor(forLoop, indentation, lowFile, highSyntax);
                body += outlineFor.body;
                end = outlineFor.end + `.\n` + end;
            }
            const next = reduceBody.findDirectExpression(Expressions.ReduceNext);
            if (next === undefined) {
                continue;
            }
            for (const n of next.getChildren()) {
                const concat = n.concatTokens();
                if (concat.toUpperCase() === "NEXT") {
                    continue;
                }
                else if (n.get() instanceof Expressions.SimpleTarget) {
                    body += indentation + "  " + concat + " ";
                }
                else if (n.get() instanceof Expressions.Source) {
                    body += " " + concat + ".\n";
                }
                else {
                    body += concat;
                }
            }
            body += indentation + end;
            body += indentation + `${uniqueName} = ${firstName}.\n`;
            const abap = `DATA ${uniqueName} TYPE ${type}.\n` +
                body +
                indentation;
            const reduceEnd = i.findDirectTokenByText(")");
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), reduceEnd.getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, firstToken, "Downport REDUCE", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineCorresponding(low, high, lowFile, highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        const allSources = high.findAllExpressionsRecursive(Expressions.Source);
        for (const s of allSources) {
            const firstToken = s.getFirstToken();
            if (firstToken.getStr().toUpperCase() !== "CORRESPONDING") {
                continue;
            }
            const correspondingBody = s.findDirectExpression(Expressions.CorrespondingBody);
            if ((correspondingBody === null || correspondingBody === void 0 ? void 0 : correspondingBody.getFirstToken().getStr().toUpperCase()) === "BASE") {
                continue;
            }
            const uniqueName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            let type = this.findType(s, lowFile, highSyntax);
            if (type === undefined) {
                if (high.get() instanceof Statements.Move && high.findDirectExpression(Expressions.Source) === s) {
                    type = "LIKE " + ((_a = high.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.concatTokens());
                }
                if (type === undefined) {
                    continue;
                }
            }
            else {
                type = "TYPE " + type;
            }
            const abap = `DATA ${uniqueName} ${type}.\n` +
                indentation + `CLEAR ${uniqueName}.\n` + // might be called inside a loop
                indentation + `MOVE-CORRESPONDING ${correspondingBody === null || correspondingBody === void 0 ? void 0 : correspondingBody.concatTokens()} TO ${uniqueName}.\n` +
                indentation;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), s.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, firstToken, "Downport CORRESPONDING", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineValue(low, high, lowFile, highSyntax) {
        var _a, _b, _c;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        const allSources = high.findAllExpressionsRecursive(Expressions.Source);
        for (const s of allSources) {
            const firstToken = s.getFirstToken();
            if (firstToken.getStr().toUpperCase() !== "VALUE") {
                continue;
            }
            const valueBody = s.findDirectExpression(Expressions.ValueBody);
            let type = this.findType(s, lowFile, highSyntax);
            if (type === undefined) {
                if (high.get() instanceof Statements.Move && high.findDirectExpression(Expressions.Source) === s) {
                    type = "LIKE " + ((_a = high.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.concatTokens());
                }
                if (type === undefined) {
                    continue;
                }
            }
            else {
                type = "TYPE " + type;
            }
            const uniqueName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
            let indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            let body = "";
            const base = valueBody === null || valueBody === void 0 ? void 0 : valueBody.findExpressionAfterToken("BASE");
            if (base) {
                body += indentation + uniqueName + " = " + base.concatTokens() + ".\n";
            }
            let end = "";
            let structureName = uniqueName;
            let added = false;
            let data = "";
            let previous = undefined;
            if ((valueBody === null || valueBody === void 0 ? void 0 : valueBody.findDirectExpression(Expressions.ValueBodyLine)) !== undefined) {
                structureName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
                const extra = (valueBody === null || valueBody === void 0 ? void 0 : valueBody.findDirectExpression(Expressions.For)) ? "  " : "";
                data = indentation + extra + `DATA ${structureName} LIKE LINE OF ${uniqueName}.\n`;
            }
            for (const a of (valueBody === null || valueBody === void 0 ? void 0 : valueBody.getChildren()) || []) {
                if (a.get() instanceof Expressions.FieldAssignment) {
                    if (added === false) {
                        body += data;
                        added = true;
                    }
                    body += indentation + structureName + "-" + a.concatTokens() + ".\n";
                }
                else if (a instanceof nodes_1.ExpressionNode && a.get() instanceof Expressions.For) {
                    const outlineFor = this.outlineFor(a, indentation, lowFile, highSyntax);
                    body += outlineFor.body;
                    end = outlineFor.end + `.\n` + end;
                    indentation += "  ";
                }
                else if (a instanceof nodes_1.ExpressionNode && a.get() instanceof Expressions.Source) {
                    // special handling for superflous value expression
                    if ((valueBody === null || valueBody === void 0 ? void 0 : valueBody.getChildren().length) === 1) {
                        body += indentation + uniqueName + " = " + a.concatTokens() + `.\n`;
                    }
                }
                else if (a instanceof nodes_1.ExpressionNode && a.get() instanceof Expressions.Let) {
                    body += this.outlineLet(a, indentation, highSyntax, lowFile);
                }
                if (a instanceof nodes_1.ExpressionNode && a.get() instanceof Expressions.ValueBodyLine) {
                    let skip = false;
                    for (const b of (a === null || a === void 0 ? void 0 : a.getChildren()) || []) {
                        if (b.get() instanceof Expressions.FieldAssignment) {
                            if (added === false) {
                                body += data;
                                added = true;
                            }
                            body += indentation + structureName + "-" + b.concatTokensWithLinebreaks() + ".\n";
                        }
                        else if (b.get() instanceof Expressions.Source) {
                            // note: it wont work with APPEND for Hashed/Sorted Tables, so use INSERT,
                            body += indentation + "INSERT " + b.concatTokens() + ` INTO TABLE ${uniqueName}.\n`;
                            skip = true;
                        }
                        else if (b.get() instanceof Expressions.ValueBodyLines) {
                            body += indentation + "INSERT " + b.concatTokens() + ` INTO TABLE ${uniqueName}.\n`;
                            skip = true;
                        }
                        else if (b.concatTokens() === ")") {
                            if (added === false && (previous === null || previous === void 0 ? void 0 : previous.concatTokens()) === "(") {
                                body += data;
                                added = true;
                            }
                            if (skip === false) {
                                body += indentation + `INSERT ${structureName} INTO TABLE ${uniqueName}.\n`;
                            }
                        }
                        previous = b;
                    }
                }
            }
            if (body === "" && ((_b = valueBody === null || valueBody === void 0 ? void 0 : valueBody.getLastChild()) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr().toUpperCase()) === "OPTIONAL") {
                const fieldChain = valueBody.findFirstExpression(Expressions.FieldChain);
                const rowName = this.uniqueName(firstToken.getStart(), lowFile.getFilename(), highSyntax);
                let tableExpression = undefined;
                let tabName = "";
                let after = "";
                for (const c of (fieldChain === null || fieldChain === void 0 ? void 0 : fieldChain.getChildren()) || []) {
                    if (c.get() instanceof Expressions.TableExpression && c instanceof nodes_1.ExpressionNode) {
                        tableExpression = c;
                    }
                    else if (tableExpression === undefined) {
                        tabName += c.concatTokens();
                    }
                    else {
                        after += c.concatTokens();
                    }
                }
                let condition = "";
                if ((tableExpression === null || tableExpression === void 0 ? void 0 : tableExpression.getChildren().length) === 3) {
                    condition = "INDEX " + ((_c = tableExpression === null || tableExpression === void 0 ? void 0 : tableExpression.findDirectExpression(Expressions.Source)) === null || _c === void 0 ? void 0 : _c.concatTokens());
                }
                else {
                    condition = "WITH KEY " + (tableExpression === null || tableExpression === void 0 ? void 0 : tableExpression.concatTokens().replace("[ ", "").replace(" ]", ""));
                }
                body +=
                    indentation + `READ TABLE ${tabName} INTO DATA(${rowName}) ${condition}.\n` +
                        indentation + `IF sy-subrc = 0.\n` +
                        indentation + `  ${uniqueName} = ${rowName}${after}.\n` +
                        indentation + `ENDIF.\n`;
                if (type.includes("LIKE DATA(")) {
                    type = `LIKE LINE OF ${tabName}`;
                }
            }
            if (end !== "") {
                indentation = indentation.substring(2);
                body += indentation + end;
            }
            const abap = `DATA ${uniqueName} ${type}.\n` +
                indentation + `CLEAR ${uniqueName}.\n` + // might be called inside a loop
                body +
                indentation;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, firstToken.getStart(), s.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, firstToken, "Downport VALUE", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineLet(node, indentation, highSyntax, lowFile) {
        var _a;
        let ret = "";
        for (const f of node.findDirectExpressions(Expressions.InlineFieldDefinition)) {
            const c = f.getFirstChild();
            if (c === undefined) {
                continue;
            }
            const name = c.concatTokens().toLowerCase();
            const spag = highSyntax.spaghetti.lookupPosition(c.getFirstToken().getStart(), lowFile.getFilename());
            if (spag === undefined) {
                continue;
            }
            if (new SpagHelper(spag).isDuplicateName(name, c.getFirstToken().getStart())) {
                this.renameVariable(spag, name, c.getFirstToken().getStart(), lowFile, highSyntax);
            }
            const found = spag.findVariable(name);
            if (found === undefined) {
                const source = f.findFirstExpression(Expressions.Source);
                if (source) {
                    ret += indentation + "DATA(" + name + `) = ${source.concatTokens()}.\n`;
                }
                continue;
            }
            const type = found.getType().getQualifiedName() ? (_a = found.getType().getQualifiedName()) === null || _a === void 0 ? void 0 : _a.toLowerCase() : found.getType().toABAP();
            ret += indentation + "DATA " + name + ` TYPE ${type}.\n`;
            const source = f.findFirstExpression(Expressions.Source);
            if (source) {
                ret += indentation + name + ` = ${source.concatTokens()}.\n`;
            }
        }
        return ret;
    }
    renameVariable(spag, name, pos, lowFile, highSyntax) {
        const newName = this.uniqueName(pos, lowFile.getFilename(), highSyntax);
        const fix = new SpagHelper(spag).renameVariable(name, pos, lowFile, newName);
        const issue = issue_1.Issue.atPosition(lowFile, pos, "Rename before outline", this.getMetadata().key, this.conf.severity, fix);
        throw new SkipToNextFile(issue);
    }
    findType(i, lowFile, highSyntax, ref = false) {
        var _a;
        const expr = i.findDirectExpression(Expressions.TypeNameOrInfer);
        if (expr === undefined) {
            return undefined;
        }
        const firstToken = expr.getFirstToken();
        const concat = expr.concatTokens().toLowerCase();
        if (concat !== "#") {
            return ref ? "REF TO " + concat : concat;
        }
        const spag = highSyntax.spaghetti.lookupPosition(firstToken.getStart(), lowFile.getFilename());
        if (spag === undefined) {
            return undefined;
        }
        let inferred = undefined;
        for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
            if (r.referenceType === _reference_1.ReferenceType.InferredType
                && r.resolved
                && r.position.getStart().equals(firstToken.getStart())
                && r.resolved instanceof _typed_identifier_1.TypedIdentifier) {
                inferred = r.resolved;
                break;
            }
        }
        if (inferred === undefined) {
            return undefined;
        }
        if (inferred.getType() instanceof basic_1.ObjectReferenceType) {
            return inferred.getType().toABAP();
        }
        else {
            return (_a = inferred.getType().getQualifiedName()) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        }
    }
    outlineFS(low, high, lowFile, highSyntax) {
        var _a, _b;
        if (!(low.get() instanceof _statement_1.Unknown)
            || (high.get() instanceof Statements.Loop)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.InlineFS)) {
            const nameToken = (_a = i.findDirectExpression(Expressions.TargetFieldSymbol)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            if (nameToken === undefined) {
                continue;
            }
            const name = nameToken.getStr();
            let type = "";
            if (high.concatTokens().toUpperCase().startsWith("APPEND INITIAL LINE TO ")) {
                type = "LIKE LINE OF " + ((_b = high.findFirstExpression(Expressions.Target)) === null || _b === void 0 ? void 0 : _b.concatTokens());
            }
            else {
                const spag = highSyntax.spaghetti.lookupPosition(nameToken.getStart(), lowFile.getFilename());
                if (spag === undefined) {
                    continue;
                }
                const found = spag.findVariable(name);
                if (found === undefined) {
                    continue;
                }
                else if (found.getType() instanceof basic_1.VoidType) {
                    return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Error outlining voided type", this.getMetadata().key, this.conf.severity);
                }
                type = "TYPE ";
                type += found.getType().getQualifiedName() ? found.getType().getQualifiedName().toLowerCase() : found.getType().toABAP();
            }
            const code = `FIELD-SYMBOLS ${name} ${type}.\n` +
                " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, i.getFirstToken().getStart(), i.getLastToken().getEnd(), name);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Outline FIELD-SYMBOL", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineData(node, lowFile, highSyntax) {
        // hmm, no guard here, as DATA(SDF) is valid in 702
        var _a, _b;
        for (const i of node.findAllExpressionsRecursive(Expressions.InlineData)) {
            const nameToken = (_a = i.findDirectExpression(Expressions.TargetField)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
            if (nameToken === undefined) {
                continue;
            }
            const name = nameToken.getStr();
            const spag = highSyntax.spaghetti.lookupPosition(nameToken.getStart(), lowFile.getFilename());
            if (spag === undefined) {
                continue;
            }
            const found = spag.findVariable(name);
            if (found === undefined) {
                continue;
            }
            else if (found.getType() instanceof basic_1.VoidType && found.getType().getQualifiedName() === undefined) {
                continue;
            }
            else if (found.getType() instanceof basic_1.StructureType && found.getType().getQualifiedName() === undefined) {
                continue;
            }
            let type = found.getType().getQualifiedName()
                ? (_b = found.getType().getQualifiedName()) === null || _b === void 0 ? void 0 : _b.toLowerCase()
                : found.getType().toABAP();
            if (found.getType() instanceof basic_1.ObjectReferenceType) {
                type = found.getType().toABAP();
            }
            if (type === "") {
                continue;
            }
            const code = `DATA ${name} TYPE ${type}.\n` +
                " ".repeat(node.getFirstToken().getStart().getCol() - 1);
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, node.getFirstToken().getStart(), code);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, i.getFirstToken().getStart(), i.getLastToken().getEnd(), name);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Outline DATA", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    outlineCond(low, high, lowFile, highSyntax) {
        var _a, _b;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Source)) {
            if (i.getFirstToken().getStr().toUpperCase() !== "COND") {
                continue;
            }
            const body = i.findDirectExpression(Expressions.CondBody);
            if (body === undefined) {
                continue;
            }
            const uniqueName = this.uniqueName(i.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            let type = this.findType(i, lowFile, highSyntax);
            if (type === undefined) {
                if (high.get() instanceof Statements.Move
                    && high.findDirectExpression(Expressions.Source) === i
                    && ((_a = high.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.TargetField)) !== undefined) {
                    type = "LIKE " + ((_b = high.findDirectExpression(Expressions.Target)) === null || _b === void 0 ? void 0 : _b.concatTokens());
                }
                if (type === undefined) {
                    continue;
                }
            }
            else {
                type = "TYPE " + type;
            }
            const indent = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const bodyCode = this.buildCondBody(body, uniqueName, indent, lowFile, highSyntax);
            const last = i.findDirectTokenByText(")");
            const abap = `DATA ${uniqueName} ${type}.\n` + bodyCode;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, i.getFirstToken().getStart(), last.getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Downport COND", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    buildCondBody(body, uniqueName, indent, lowFile, highSyntax) {
        let code = "";
        let first = true;
        let addElse = true;
        for (const c of body.getChildren()) {
            if (c instanceof nodes_1.TokenNode) {
                switch (c.getFirstToken().getStr().toUpperCase()) {
                    case "WHEN":
                        if (first === true) {
                            code += indent + "IF ";
                            first = false;
                        }
                        else {
                            code += indent + "ELSEIF ";
                        }
                        break;
                    case "THEN":
                        code += ".\n";
                        break;
                    case "ELSE":
                        code += indent + "ELSE.\n";
                        addElse = false;
                        break;
                    default:
                        throw "buildCondBody, unexpected token";
                }
            }
            else if (c.get() instanceof Expressions.Cond) {
                code += c.concatTokens();
            }
            else if (c.get() instanceof Expressions.Let) {
                code += this.outlineLet(c, indent, highSyntax, lowFile);
            }
            else if (c.get() instanceof Expressions.Source) {
                code += indent + "  " + uniqueName + " = " + c.concatTokens() + ".\n";
            }
            else if (c.get() instanceof Expressions.Throw) {
                code += indent + "  " + c.concatTokens().replace(/THROW /i, "RAISE EXCEPTION NEW ") + ".\n";
            }
            else {
                throw "buildCondBody, unexpected expression, " + c.get().constructor.name;
            }
        }
        if (addElse) {
            // COND might be called inside a loop
            code += indent + "ELSE.\n";
            code += indent + `  CLEAR ${uniqueName}.\n`;
        }
        code += indent + "ENDIF.\n";
        code += indent;
        return code;
    }
    outlineConv(low, high, lowFile, highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Source)) {
            if (i.getFirstToken().getStr().toUpperCase() !== "CONV") {
                continue;
            }
            const end = i.findDirectTokenByText(")");
            if (end === undefined) {
                continue;
            }
            const body = (_a = i.findDirectExpression(Expressions.ConvBody)) === null || _a === void 0 ? void 0 : _a.concatTokens();
            if (body === undefined) {
                continue;
            }
            const uniqueName = this.uniqueName(i.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const type = this.findType(i, lowFile, highSyntax);
            const indent = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const abap = `DATA ${uniqueName} TYPE ${type}.\n` +
                indent + `${uniqueName} = ${body}.\n` +
                indent;
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, i.getFirstToken().getStart(), end.getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Downport CONV", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    // "CAST" to "?="
    outlineCast(low, high, lowFile, highSyntax) {
        var _a;
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const i of high.findAllExpressionsRecursive(Expressions.Cast)) {
            const uniqueName = this.uniqueName(i.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const type = this.findType(i, lowFile, highSyntax, true);
            const body = (_a = i.findDirectExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.concatTokens();
            const abap = `DATA ${uniqueName} TYPE ${type}.\n` +
                " ".repeat(high.getFirstToken().getStart().getCol() - 1) +
                `${uniqueName} ?= ${body}.\n` +
                " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), abap);
            const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, i.getFirstToken().getStart(), i.getLastToken().getEnd(), uniqueName);
            const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            return issue_1.Issue.atToken(lowFile, i.getFirstToken(), "Downport CAST", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    uniqueName(position, filename, highSyntax) {
        const spag = highSyntax.spaghetti.lookupPosition(position, filename);
        if (spag === undefined) {
            const name = "temprr" + this.counter;
            this.counter++;
            return name;
        }
        let postfix = "";
        if (spag.getIdentifier().stype === _scope_type_1.ScopeType.ClassDefinition) {
            // try making sure this name is not used in subclasses
            const hash = crypto.createHash("sha1").update(spag.getIdentifier().sname).digest("hex");
            postfix = "_" + hash.substring(0, 10);
        }
        while (true) {
            const name = "temp" + this.counter + postfix;
            const exists = this.existsRecursive(spag, name);
            this.counter++;
            if (exists === false) {
                return name;
            }
        }
    }
    // todo, optimize, the findVariable() and findType() does a lot of redundant checks
    existsRecursive(spag, name) {
        const existsDirect = spag.findVariable(name) || spag.findType(name);
        if (existsDirect) {
            return true;
        }
        for (const child of spag.getChildren()) {
            if (child.findVariable(name) || child.findType(name) || this.existsRecursive(child, name)) {
                return true;
            }
        }
        return false;
    }
    replaceXsdBool(node, lowFile, highSyntax) {
        const spag = highSyntax.spaghetti.lookupPosition(node.getFirstToken().getStart(), lowFile.getFilename());
        for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
            if (r.referenceType === _reference_1.ReferenceType.BuiltinMethodReference
                && r.position.getName().toUpperCase() === "XSDBOOL") {
                const token = r.position.getToken();
                let source = undefined;
                for (const s of node.findAllExpressionsRecursive(Expressions.Source)) {
                    if (s.getFirstToken().getStart().equals(token.getStart())) {
                        source = s;
                        break;
                    }
                }
                const children = source === null || source === void 0 ? void 0 : source.getChildren();
                if (source === undefined || (children === null || children === void 0 ? void 0 : children.length) !== 4) {
                    continue;
                }
                // make sure to convert to the correct type, RTTI might be used on the result of XSDBOOL
                const code = "CONV xsdboolean( boolc( " + children[2].concatTokens() + " ) )";
                const fix = edit_helper_1.EditHelper.replaceRange(lowFile, source.getFirstToken().getStart(), source.getLastToken().getEnd(), code);
                return issue_1.Issue.atToken(lowFile, token, "Use BOOLC", this.getMetadata().key, this.conf.severity, fix);
            }
        }
        return undefined;
    }
    findMethodCallExpression(node, token) {
        var _a;
        for (const m of node.findAllExpressions(Expressions.MethodCall)) {
            if ((_a = m.findDirectExpression(Expressions.MethodName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStart().equals(token.getStart())) {
                return m;
            }
        }
        return undefined;
    }
    replaceMethodConditional(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        for (const c of high.findAllExpressionsRecursive(Expressions.Compare)) {
            const chain = c.findDirectExpression(Expressions.MethodCallChain);
            if (chain === undefined) {
                continue;
            }
            const concat = chain.concatTokens().toUpperCase();
            if (concat.startsWith("LINE_EXISTS( ") || concat.startsWith("LINE_INDEX( ")) {
                // these are handled separately
                continue;
            }
            let predicate = false;
            const spag = highSyntax.spaghetti.lookupPosition(high.getFirstToken().getStart(), lowFile.getFilename());
            for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
                if (r.referenceType === _reference_1.ReferenceType.BuiltinMethodReference &&
                    new _builtin_1.BuiltIn().isPredicate(chain.getFirstToken().getStr().toUpperCase())) {
                    predicate = true;
                    break;
                }
            }
            const end = chain.getLastToken().getEnd();
            let fix = edit_helper_1.EditHelper.insertAt(lowFile, end, " IS NOT INITIAL");
            if (predicate === true) {
                fix = edit_helper_1.EditHelper.insertAt(lowFile, end, " ) = abap_true");
                const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, chain.getFirstToken().getStart(), "boolc( ");
                fix = edit_helper_1.EditHelper.merge(fix, fix1);
            }
            return issue_1.Issue.atToken(lowFile, chain.getFirstToken(), "Downport method conditional", this.getMetadata().key, this.conf.severity, fix);
        }
        return undefined;
    }
    getReference(node, lowFile, _highSyntax) {
        var _a, _b, _c;
        if (!(node.get() instanceof Statements.GetReference)) {
            return undefined;
        }
        const inline = (_a = node.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.InlineData);
        if (inline === undefined) {
            return undefined;
        }
        const targetName = (_b = inline.findDirectExpression(Expressions.TargetField)) === null || _b === void 0 ? void 0 : _b.concatTokens();
        const sourceName = (_c = node.findDirectExpression(Expressions.Source)) === null || _c === void 0 ? void 0 : _c.concatTokens();
        if (targetName === undefined || sourceName === undefined) {
            return undefined;
        }
        const code = `DATA ${targetName} LIKE REF TO ${sourceName}.\n`;
        const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, node.getFirstToken().getStart(), code);
        const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, inline.getFirstToken().getStart(), inline.getLastToken().getEnd(), targetName);
        const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
        return issue_1.Issue.atToken(lowFile, inline.getFirstToken(), "Downport, outline DATA ref", this.getMetadata().key, this.conf.severity, fix);
    }
    replaceContains(node, lowFile, highSyntax) {
        const spag = highSyntax.spaghetti.lookupPosition(node.getFirstToken().getStart(), lowFile.getFilename());
        // only downport if its an single method call condition
        let found = false;
        for (const c of node.findAllExpressionsRecursive(Expressions.Compare)) {
            found = c.findDirectExpression(Expressions.MethodCallChain) !== undefined;
            if (found === true) {
                break;
            }
        }
        if (found === false) {
            return undefined;
        }
        for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
            if (r.referenceType !== _reference_1.ReferenceType.BuiltinMethodReference) {
                continue;
            }
            const func = r.position.getName().toUpperCase();
            if (func === "CONTAINS") {
                const token = r.position.getToken();
                const expression = this.findMethodCallExpression(node, token);
                if (expression === undefined) {
                    continue;
                }
                const sList = expression.findAllExpressions(Expressions.Source).map(e => e.concatTokens());
                if (sList.length !== 2) {
                    continue;
                }
                const code = sList[0] + " CS " + sList[1];
                const start = expression.getFirstToken().getStart();
                const end = expression.getLastToken().getEnd();
                const fix = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, code);
                return issue_1.Issue.atToken(lowFile, token, "Downport contains()", this.getMetadata().key, this.conf.severity, fix);
            }
        }
        return undefined;
    }
    replaceLineFunctions(node, lowFile, highSyntax, highFile) {
        var _a, _b;
        const spag = highSyntax.spaghetti.lookupPosition(node.getFirstToken().getStart(), lowFile.getFilename());
        for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
            if (r.referenceType !== _reference_1.ReferenceType.BuiltinMethodReference) {
                continue;
            }
            const func = r.position.getName().toUpperCase();
            if (func === "LINE_EXISTS" || func === "LINE_INDEX") {
                const token = r.position.getToken();
                const expression = this.findMethodCallExpression(node, token);
                if (expression === undefined) {
                    continue;
                }
                let condition = "";
                for (const c of ((_a = expression === null || expression === void 0 ? void 0 : expression.findFirstExpression(Expressions.TableExpression)) === null || _a === void 0 ? void 0 : _a.getChildren()) || []) {
                    if (c.getFirstToken().getStr() === "[" || c.getFirstToken().getStr() === "]") {
                        continue;
                    }
                    else if (c.get() instanceof Expressions.ComponentChainSimple && condition === "") {
                        condition = "WITH KEY ";
                    }
                    else if (c.get() instanceof Expressions.Source && condition === "") {
                        condition = "INDEX ";
                    }
                    condition += c.concatTokens() + " ";
                }
                const tableName = (_b = expression.findFirstExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.concatTokens().split("[")[0];
                const uniqueName = this.uniqueName(node.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
                const indentation = " ".repeat(node.getFirstToken().getStart().getCol() - 1);
                const sy = func === "LINE_EXISTS" ? "sy-subrc" : "sy-tabix";
                const code = `DATA ${uniqueName} LIKE sy-subrc.\n` +
                    indentation + `READ TABLE ${tableName} ${condition}TRANSPORTING NO FIELDS.\n` +
                    indentation + uniqueName + ` = ${sy}.\n` +
                    indentation;
                let insertAt = node.getFirstToken().getStart();
                if (node.get() instanceof statements_1.ElseIf) {
                    // assumption: no side effects in IF conditions
                    insertAt = this.findStartOfIf(node, highFile);
                    if (insertAt === undefined) {
                        continue;
                    }
                }
                const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, insertAt, code);
                const start = expression.getFirstToken().getStart();
                const end = expression.getLastToken().getEnd();
                const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, start, end, uniqueName + (func === "LINE_EXISTS" ? " = 0" : ""));
                const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
                return issue_1.Issue.atToken(lowFile, token, "Replace line function", this.getMetadata().key, this.conf.severity, fix);
            }
        }
        return undefined;
    }
    findStartOfIf(node, highFile) {
        const structure = highFile.getStructure();
        for (const c of (structure === null || structure === void 0 ? void 0 : structure.findAllStructuresRecursive(Structures.If)) || []) {
            for (const ei of c.findDirectStructures(Structures.ElseIf)) {
                if (ei.getFirstStatement() === node) {
                    return c.getFirstToken().getStart();
                }
            }
        }
        return undefined;
    }
    newToCreateObject(low, high, lowFile, highSyntax) {
        if (!(low.get() instanceof _statement_1.Unknown)) {
            return undefined;
        }
        const source = high.findDirectExpression(Expressions.Source);
        let fix = undefined;
        if (high.get() instanceof Statements.Move
            && source
            && source.getFirstToken().getStr().toUpperCase() === "NEW") {
            const target = high.findDirectExpression(Expressions.Target);
            const found = source === null || source === void 0 ? void 0 : source.findFirstExpression(Expressions.NewObject);
            // must be at top level of the source for quickfix to work(todo: handle more scenarios)
            if (target
                && found
                && source.concatTokens() === found.concatTokens()
                && target.findDirectExpression(Expressions.InlineData) === undefined) {
                const abap = this.newParameters(found, target.concatTokens(), highSyntax, lowFile);
                if (abap !== undefined) {
                    fix = edit_helper_1.EditHelper.replaceRange(lowFile, high.getFirstToken().getStart(), high.getLastToken().getEnd(), abap);
                }
            }
        }
        if (fix === undefined && high.findAllExpressions(Expressions.NewObject)) {
            const found = high.findFirstExpression(Expressions.NewObject);
            if (found === undefined) {
                return undefined;
            }
            const name = this.uniqueName(found.getFirstToken().getStart(), lowFile.getFilename(), highSyntax);
            const abap = this.newParameters(found, name, highSyntax, lowFile);
            if (abap === undefined) {
                return undefined;
            }
            const type = this.findType(found, lowFile, highSyntax);
            const indentation = " ".repeat(high.getFirstToken().getStart().getCol() - 1);
            const data = `DATA ${name} TYPE REF TO ${type}.\n` +
                indentation + abap + "\n" +
                indentation;
            if (found.getFirstToken().getStart().equals(high.getFirstToken().getStart())
                && found.getLastToken().getEnd().equals(high.getLastToken().getStart())) {
                // full statement = standalone NEW expression
                fix = edit_helper_1.EditHelper.replaceRange(lowFile, high.getFirstToken().getStart(), high.getLastToken().getEnd(), abap);
            }
            else {
                const fix1 = edit_helper_1.EditHelper.insertAt(lowFile, high.getFirstToken().getStart(), data);
                const fix2 = edit_helper_1.EditHelper.replaceRange(lowFile, found.getFirstToken().getStart(), found.getLastToken().getEnd(), name);
                fix = edit_helper_1.EditHelper.merge(fix2, fix1);
            }
        }
        if (fix) {
            return issue_1.Issue.atToken(lowFile, high.getFirstToken(), "Use CREATE OBJECT instead of NEW", this.getMetadata().key, this.conf.severity, fix);
        }
        else {
            return undefined;
        }
    }
    newParameters(found, name, highSyntax, lowFile) {
        var _a, _b, _c;
        const typeToken = (_a = found.findDirectExpression(Expressions.TypeNameOrInfer)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
        let extra = (typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStr()) === "#" ? "" : " TYPE " + (typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStr());
        const parameters = found.findFirstExpression(Expressions.ParameterListS);
        if (parameters) {
            extra = parameters ? extra + " EXPORTING " + parameters.concatTokens() : extra;
        }
        else if (typeToken) {
            const source = (_b = found.findDirectExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.concatTokens();
            if (source) {
                // find the default parameter name for the constructor
                const spag = highSyntax.spaghetti.lookupPosition(typeToken === null || typeToken === void 0 ? void 0 : typeToken.getStart(), lowFile.getFilename());
                let cdef = undefined;
                for (const r of (spag === null || spag === void 0 ? void 0 : spag.getData().references) || []) {
                    if ((r.referenceType === _reference_1.ReferenceType.InferredType
                        || r.referenceType === _reference_1.ReferenceType.ObjectOrientedReference)
                        && r.resolved && r.position.getStart().equals(typeToken.getStart())) {
                        cdef = r.resolved;
                    }
                }
                if (cdef && cdef.getMethodDefinitions === undefined) {
                    return undefined; // something wrong
                }
                const importing = (_c = this.findConstructor(cdef, spag)) === null || _c === void 0 ? void 0 : _c.getParameters().getDefaultImporting();
                if (importing) {
                    extra += " EXPORTING " + importing + " = " + source;
                }
                else if (spag === undefined) {
                    extra += " SpagUndefined ERROR";
                }
                else if (cdef === undefined) {
                    extra += " ClassDefinitionNotFound ERROR";
                }
                else {
                    extra += " SomeError ERROR";
                }
            }
        }
        const abap = `CREATE OBJECT ${name}${extra}.`;
        return abap;
    }
    findConstructor(cdef, spag) {
        let def = cdef;
        while (def !== undefined) {
            const method = def === null || def === void 0 ? void 0 : def.getMethodDefinitions().getByName("CONSTRUCTOR");
            if (method) {
                return method;
            }
            const name = def.getSuperClass();
            if (name) {
                def = spag === null || spag === void 0 ? void 0 : spag.findClassDefinition(name);
            }
            else {
                return undefined;
            }
        }
    }
}
exports.Downport = Downport;
//# sourceMappingURL=downport.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/dynpro_checks.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/dynpro_checks.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.DynproChecks = exports.DynproChecksConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class DynproChecksConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.DynproChecksConf = DynproChecksConf;
class DynproChecks {
    constructor() {
        this.conf = new DynproChecksConf();
    }
    getMetadata() {
        return {
            key: "dynpro_checks",
            title: "Dynpro Checks",
            shortDescription: `Various Dynpro checks`,
            extendedInformation: `* Check length of PUSH elements less than 132`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    initialize(_reg) {
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const ret = [];
        if (!(obj instanceof objects_1.Program)) {
            return [];
        }
        const file = obj.getXMLFile();
        if (file === undefined) {
            return [];
        }
        for (const dynpro of obj.getDynpros()) {
            for (const field of dynpro.fields) {
                if (field.type === "PUSH" && field.length > 132) {
                    const message = `Screen ${dynpro.number}, field ${field.name} LENGTH longer than 132`;
                    ret.push(issue_1.Issue.atPosition(file, new position_1.Position(1, 1), message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return ret;
    }
}
exports.DynproChecks = DynproChecks;
//# sourceMappingURL=dynpro_checks.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/easy_to_find_messages.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/easy_to_find_messages.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EasyToFindMessages = exports.EasyToFindMessagesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class EasyToFindMessagesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.EasyToFindMessagesConf = EasyToFindMessagesConf;
class EasyToFindMessages {
    constructor() {
        this.conf = new EasyToFindMessagesConf();
    }
    getMetadata() {
        return {
            key: "easy_to_find_messages",
            title: "Easy to find messages",
            shortDescription: `Make messages easy to find`,
            extendedInformation: `All messages must be statically referenced exactly once

Only MESSAGE and RAISE statments are counted as static references

Also see rule "message_exists"

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#make-messages-easy-to-find`,
            tags: [_irule_1.RuleTag.Styleguide],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.msagReferences = reg.getMSAGReferences();
        // the SyntaxLogic builds the references
        for (const obj of reg.getObjects()) {
            if (obj instanceof _abap_object_1.ABAPObject) {
                new syntax_1.SyntaxLogic(reg, obj).run();
            }
        }
        return this;
    }
    run(object) {
        const issues = [];
        if (object.getType() === "MSAG") {
            const msag = object;
            for (const message of msag.getMessages()) {
                const where = this.msagReferences.listByMessage(msag.getName().toUpperCase(), message.getNumber());
                if (where.length === 0) {
                    const text = `Message ${message.getNumber()} not statically referenced`;
                    const position = new position_1.Position(1, 1);
                    const issue = issue_1.Issue.atPosition(object.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                else if (where.length >= 2) {
                    const text = `Message ${message.getNumber()} referenced more than once`;
                    const position = new position_1.Position(1, 1);
                    const issue = issue_1.Issue.atPosition(object.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.EasyToFindMessages = EasyToFindMessages;
//# sourceMappingURL=easy_to_find_messages.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/empty_event.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/empty_event.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmptyEvent = exports.EmptyEventConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const selection_events_1 = __webpack_require__(/*! ../abap/flow/selection_events */ "./node_modules/@abaplint/core/build/src/abap/flow/selection_events.js");
class EmptyEventConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.EmptyEventConf = EmptyEventConf;
class EmptyEvent extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new EmptyEventConf();
    }
    getMetadata() {
        return {
            key: "empty_event",
            title: "Empty selection screen or list processing event block",
            shortDescription: `Empty selection screen or list processing event block`,
            extendedInformation: ``,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `
INITIALIZATION.
  WRITE 'hello'.
END-OF-SELECTION.`,
            goodExample: `
START-OF-SELECTION.
  PERFORM sdf.
  COMMIT WORK.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (!(obj instanceof objects_1.Program) || obj.isInclude()) {
            return issues;
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        let currentEvent = undefined;
        let children = [];
        for (const s of stru.getChildren() || []) {
            if (selection_events_1.SELECTION_EVENTS.some(f => s.get() instanceof f)) {
                if (currentEvent !== undefined && children.length === 0) {
                    issues.push(issue_1.Issue.atStatement(file, currentEvent, "Empty event", this.getMetadata().key, this.getConfig().severity));
                }
                children = [];
                currentEvent = s;
            }
            else if (s.get() instanceof Structures.Normal) {
                const stru = s;
                // ignore declaration stuff
                if (selection_events_1.DECLARATION_STUFF.some(d => { var _a; return ((_a = stru.getFirstStatement()) === null || _a === void 0 ? void 0 : _a.get()) instanceof d; })) {
                    continue;
                }
                children.push(s);
            }
            else {
                if (currentEvent !== undefined && children.length === 0) {
                    issues.push(issue_1.Issue.atStatement(file, currentEvent, "Empty event", this.getMetadata().key, this.getConfig().severity));
                }
                children = [];
                currentEvent = undefined;
            }
        }
        if (currentEvent !== undefined && children.length === 0) {
            issues.push(issue_1.Issue.atStatement(file, currentEvent, "Empty event", this.getMetadata().key, this.getConfig().severity));
        }
        return issues;
    }
}
exports.EmptyEvent = EmptyEvent;
//# sourceMappingURL=empty_event.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/empty_line_in_statement.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/empty_line_in_statement.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmptyLineinStatement = exports.EmptyLineinStatementConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class EmptyLineinStatementConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow changed empty lines in chanined statements */
        this.allowChained = false;
    }
}
exports.EmptyLineinStatementConf = EmptyLineinStatementConf;
class EmptyLineinStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new EmptyLineinStatementConf();
    }
    getMetadata() {
        return {
            key: "empty_line_in_statement",
            title: "Find empty lines in statements",
            shortDescription: `Checks that statements do not contain empty lines.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#dont-obsess-with-separating-blank-lines

https://docs.abapopenchecks.org/checks/41/`,
            tags: [_irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Whitespace, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `WRITE\n\nhello.`,
            goodExample: `WRITE hello.`,
        };
    }
    getMessage() {
        return "Remove empty line in statement";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const s of file.getStatements()) {
            if (s.get() instanceof _statement_1.Unknown
                || s.get() instanceof _statement_1.NativeSQL) {
                return []; // skip the file if there are parser errors or native/sqlscript
            }
        }
        let prevLine = undefined;
        for (const t of file.getTokens()) {
            if (prevLine === undefined && t instanceof tokens_1.Comment) {
                continue;
            }
            else if (prevLine === undefined) {
                prevLine = t.getRow();
            }
            if (prevLine && t.getRow() - prevLine >= 2) {
                const fix = edit_helper_1.EditHelper.deleteRange(file, new position_1.Position(prevLine + 1, 1), t.getStart());
                const issue = issue_1.Issue.atToken(file, t, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            if (t instanceof tokens_1.Punctuation && t.getStr() === ".") {
                prevLine = undefined;
            }
            else if (this.conf.allowChained === true && t instanceof tokens_1.Punctuation && t.getStr() === ",") {
                prevLine = undefined;
            }
            else {
                prevLine = t.getRow();
            }
        }
        return issues;
    }
}
exports.EmptyLineinStatement = EmptyLineinStatement;
//# sourceMappingURL=empty_line_in_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/empty_statement.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/empty_statement.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmptyStatement = exports.EmptyStatementConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class EmptyStatementConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.EmptyStatementConf = EmptyStatementConf;
class EmptyStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new EmptyStatementConf();
    }
    getMetadata() {
        return {
            key: "empty_statement",
            title: "Remove empty statement",
            shortDescription: `Checks for empty statements (an empty statement is a single dot)`,
            tags: [_irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE 'hello world'..`,
            goodExample: `WRITE 'hello world'.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const statements = file.getStatements();
        let previousEnd = new position_1.Position(1, 1);
        for (const sta of statements) {
            if (sta.get() instanceof _statement_1.Empty) {
                const token = sta.getFirstToken();
                const fix = edit_helper_1.EditHelper.deleteRange(file, previousEnd, token.getEnd());
                const issue = issue_1.Issue.atStatement(file, sta, "Remove empty statement", this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            previousEnd = sta.getLastToken().getEnd();
        }
        return issues;
    }
}
exports.EmptyStatement = EmptyStatement;
//# sourceMappingURL=empty_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/empty_structure.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/empty_structure.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EmptyStructure = exports.EmptyStructureConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class EmptyStructureConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Checks for empty LOOP blocks */
        this.loop = true;
        /** Allow empty LOOP if subrc is checked after the loop */
        this.loopAllowIfSubrc = true;
        /** Checks for empty IF blocks */
        this.if = true;
        /** Checks for empty WHILE blocks */
        this.while = true;
        /** Checks for empty CASE blocks */
        this.case = true;
        /** Checks for empty SELECT blockss */
        this.select = true;
        /** Checks for empty DO blocks */
        this.do = true;
        /** Checks for empty AT blocks */
        this.at = true;
        /** Checks for empty TRY blocks */
        this.try = true;
        /** Checks for empty WHEN blocks */
        this.when = true;
        // todo, other category containing ELSE
    }
}
exports.EmptyStructureConf = EmptyStructureConf;
class EmptyStructure extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new EmptyStructureConf();
    }
    getMetadata() {
        return {
            key: "empty_structure",
            title: "Find empty blocks",
            shortDescription: `Checks that the code does not contain empty blocks.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#no-empty-if-branches`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `IF foo = bar.
ENDIF.

DO 2 TIMES.
ENDDO.`,
            goodExample: `LOOP AT itab WHERE qty = 0 OR date > sy-datum.
ENDLOOP.
result = xsdbool( sy-subrc = 0 ).`,
        };
    }
    getDescription(name) {
        return "Empty block, add code: " + name;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        const statements = file.getStatements();
        for (const statement of statements) {
            if (statement.get() instanceof _statement_1.Unknown) {
                return []; // contains parser errors
            }
        }
        const candidates = [];
        if (this.getConfig().while === true) {
            candidates.push(...stru.findAllStructuresRecursive(Structures.While));
        }
        if (this.getConfig().case === true) {
            candidates.push(...stru.findAllStructuresRecursive(Structures.Case));
        }
        if (this.getConfig().select === true) {
            candidates.push(...stru.findAllStructuresRecursive(Structures.Select));
        }
        if (this.getConfig().do === true) {
            candidates.push(...stru.findAllStructuresRecursive(Structures.Do));
        }
        if (this.getConfig().at === true) {
            candidates.push(...stru.findAllStructuresRecursive(Structures.At));
            candidates.push(...stru.findAllStructuresRecursive(Structures.AtFirst));
            candidates.push(...stru.findAllStructuresRecursive(Structures.AtLast));
        }
        for (const l of candidates) {
            if (l.getChildren().length === 2) {
                const token = l.getFirstToken();
                const issue = issue_1.Issue.atToken(file, token, this.getDescription(l.get().constructor.name), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        if (this.getConfig().try === true) {
            const tries = stru.findAllStructuresRecursive(Structures.Try);
            for (const t of tries) {
                const normal = t.findDirectStructure(Structures.Body);
                if (normal === undefined) {
                    const token = t.getFirstToken();
                    const issue = issue_1.Issue.atToken(file, token, this.getDescription(t.get().constructor.name), this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        if (this.getConfig().loop === true) {
            const loops = stru.findAllStructuresRecursive(Structures.Loop);
            for (const loop of loops) {
                if (loop.getChildren().length === 2) {
                    const endloopStatement = loop.getLastChild();
                    const endloopIndex = statements.findIndex((s) => s === endloopStatement);
                    const afterEndloop = statements[endloopIndex + 1];
                    if (afterEndloop !== undefined && afterEndloop.concatTokens().toUpperCase().includes("SY-SUBRC")) {
                        continue;
                    }
                    const token = loop.getFirstToken();
                    const issue = issue_1.Issue.atToken(file, token, this.getDescription(loop.get().constructor.name), this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        if (this.getConfig().if === true) {
            const tries = stru.findAllStructuresRecursive(Structures.If)
                .concat(stru.findAllStructuresRecursive(Structures.Else))
                .concat(stru.findAllStructuresRecursive(Structures.ElseIf));
            for (const t of tries) {
                const normal = t.findDirectStructure(Structures.Body);
                if (normal === undefined) {
                    const token = t.getFirstToken();
                    const issue = issue_1.Issue.atToken(file, token, this.getDescription(t.get().constructor.name), this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        if (this.getConfig().when === true) {
            const tries = stru.findAllStructuresRecursive(Structures.When);
            for (const t of tries) {
                if (t.getChildren().length === 1) {
                    const token = t.getFirstToken();
                    const message = this.getDescription(t.get().constructor.name);
                    const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.EmptyStructure = EmptyStructure;
//# sourceMappingURL=empty_structure.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/exit_or_check.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/exit_or_check.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExitOrCheck = exports.ExitOrCheckConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class ExitOrCheckConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.allowExit = false;
        this.allowCheck = false;
    }
}
exports.ExitOrCheckConf = ExitOrCheckConf;
class ExitOrCheck extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ExitOrCheckConf();
    }
    getMetadata() {
        return {
            key: "exit_or_check",
            title: "Find EXIT or CHECK outside loops",
            shortDescription: `Detects usages of EXIT or CHECK statements outside of loops.
Use RETURN to leave procesing blocks instead.`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abenleave_processing_blocks.htm
https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abapcheck_processing_blocks.htm
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#check-vs-return`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stack = [];
        for (const statement of file.getStatements()) {
            const get = statement.get();
            if (get instanceof Statements.Loop
                || get instanceof Statements.While
                || get instanceof Statements.LoopAtScreen
                || get instanceof Statements.SelectLoop
                || get instanceof Statements.Do) {
                stack.push(statement);
            }
            else if (get instanceof Statements.EndLoop
                || get instanceof Statements.EndWhile
                || get instanceof Statements.EndSelect
                || get instanceof Statements.EndDo) {
                stack.pop();
            }
            else if (this.conf.allowCheck === false && get instanceof Statements.Check && stack.length === 0) {
                const message = "CHECK is not allowed outside of loops";
                let tokensString = statement.concatTokens();
                tokensString = tokensString.slice(statement.getFirstToken().getEnd().getCol());
                const replacement = "IF NOT " + tokensString + "\n  RETURN.\nENDIF.";
                const fix = edit_helper_1.EditHelper.replaceRange(file, statement.getFirstToken().getStart(), statement.getLastToken().getEnd(), replacement);
                const issue = issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            else if (this.conf.allowExit === false && get instanceof Statements.Exit && stack.length === 0) {
                const message = "EXIT is not allowed outside of loops";
                const fix = edit_helper_1.EditHelper.replaceToken(file, statement.getFirstToken(), "RETURN");
                const issue = issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.ExitOrCheck = ExitOrCheck;
//# sourceMappingURL=exit_or_check.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/expand_macros.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/expand_macros.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExpandMacros = exports.ExpandMacrosConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
class ExpandMacrosConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ExpandMacrosConf = ExpandMacrosConf;
class ExpandMacros extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ExpandMacrosConf();
    }
    getMetadata() {
        return {
            key: "expand_macros",
            title: "Expand Macros",
            shortDescription: `Allows expanding macro calls with quick fixes`,
            extendedInformation: `Macros: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abenmacros_guidl.htm

Note that macros/DEFINE cannot be used in the ABAP Cloud programming model`,
            badExample: `DEFINE _hello.
  WRITE 'hello'.
END-OF-DEFINITION.
_hello.`,
            goodExample: `WRITE 'hello'.`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Upport],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const message = "Expand macro call";
        const statements = file.getStatements();
        for (let i = 0; i < statements.length; i++) {
            const statementNode = statements[i];
            const statement = statementNode.get();
            if (!(statement instanceof _statement_1.MacroCall)) {
                continue;
            }
            let replace = "";
            for (let j = i + 1; j < statements.length; j++) {
                const sub = statements[j];
                if (sub.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
                    if (sub.get() instanceof _statement_1.MacroCall) {
                        continue;
                    }
                    if (replace !== "") {
                        replace += "\n";
                    }
                    replace += sub.concatTokensVirtual();
                }
                else {
                    break;
                }
            }
            if (statementNode.getColon()) {
                replace += "\n";
            }
            const fix1 = edit_helper_1.EditHelper.deleteStatement(file, statementNode);
            const fix2 = edit_helper_1.EditHelper.insertAt(file, statementNode.getStart(), replace);
            const fix = edit_helper_1.EditHelper.merge(fix1, fix2);
            issues.push(issue_1.Issue.atStatement(file, statementNode, message, this.getMetadata().key, this.conf.severity, fix));
            // only one fix at a time per file
            break;
        }
        return issues;
    }
}
exports.ExpandMacros = ExpandMacros;
//# sourceMappingURL=expand_macros.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/exporting.js":
/*!******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/exporting.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Exporting = exports.ExportingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class ExportingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ExportingConf = ExportingConf;
class Exporting extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ExportingConf();
    }
    getMetadata() {
        return {
            key: "exporting",
            title: "EXPORTING can be omitted",
            shortDescription: `Detects EXPORTING statements which can be omitted.`,
            badExample: `call_method( EXPORTING foo = bar ).`,
            goodExample: `call_method( foo = bar ).`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#omit-the-optional-keyword-exporting
https://docs.abapopenchecks.org/checks/30/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "The EXPORTING keyword can be omitted";
    }
    runParsed(file, obj) {
        let issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        for (const statement of file.getStatements()) {
            const expressions = statement.findAllExpressionsMulti([expressions_1.MethodCallBody, expressions_1.MethodCall]);
            for (const b of expressions) {
                if (b.get() instanceof expressions_1.MethodCallBody) {
                    if (b.getFirstToken().getStr() !== "(") {
                        continue;
                    }
                    issues = issues.concat(this.check(b, file));
                }
                else if (b.get() instanceof expressions_1.MethodCall) {
                    issues = issues.concat(this.check(b, file));
                }
            }
        }
        return issues;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    check(node, file) {
        const e = node.findFirstExpression(expressions_1.MethodParameters);
        if (e === undefined) {
            return [];
        }
        if (e.getFirstToken().getStr().toUpperCase() !== "EXPORTING") {
            return [];
        }
        const tokens = e.getDirectTokens();
        const strings = tokens.map(t => t.getStr().toUpperCase());
        if (strings[0] === "EXPORTING"
            && strings.includes("IMPORTING") === false
            && strings.includes("RECEIVING") === false
            && strings.includes("EXCEPTIONS") === false
            && strings.includes("CHANGING") === false) {
            const next = e.getAllTokens()[1];
            const fix = edit_helper_1.EditHelper.deleteRange(file, tokens[0].getStart(), next.getStart());
            const issue = issue_1.Issue.atToken(file, tokens[0], this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
            return [issue];
        }
        return [];
    }
}
exports.Exporting = Exporting;
//# sourceMappingURL=exporting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/forbidden_identifier.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/forbidden_identifier.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForbiddenIdentifier = exports.ForbiddenIdentifierConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ForbiddenIdentifierConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** List of forbideen identifiers, array of string regex
         * @uniqueItems true
        */
        this.check = [];
    }
}
exports.ForbiddenIdentifierConf = ForbiddenIdentifierConf;
class ForbiddenIdentifier extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ForbiddenIdentifierConf();
    }
    getMetadata() {
        return {
            key: "forbidden_identifier",
            title: "Forbidden Identifier",
            shortDescription: `Forbid use of specified identifiers, list of regex.`,
            extendedInformation: `Used in the transpiler to find javascript keywords in ABAP identifiers,
https://github.com/abaplint/transpiler/blob/bda94b8b56e2b7f2f87be2168f12361aa530220e/packages/transpiler/src/validation.ts#L44`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.check === undefined) {
            this.conf.check = [];
        }
    }
    runParsed(file) {
        if (this.conf.check.length === 0) {
            return [];
        }
        let ret = [];
        for (const s of file.getStatements()) {
            ret = ret.concat(this.traverse(s, file));
        }
        return ret;
    }
    traverse(node, file) {
        let ret = [];
        for (const c of node.getChildren()) {
            if (c instanceof nodes_1.TokenNodeRegex) {
                ret = ret.concat(this.check(c.get(), file));
            }
            else if (c instanceof nodes_1.TokenNode) {
                continue;
            }
            else {
                ret = ret.concat(this.traverse(c, file));
            }
        }
        return ret;
    }
    check(token, file) {
        const str = token.getStr();
        const ret = [];
        for (const c of this.conf.check) {
            const reg = new RegExp(c, "i");
            if (reg.exec(str)) {
                const message = "Identifer \"" + str + "\" not allowed";
                ret.push(issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity));
            }
        }
        return ret;
    }
}
exports.ForbiddenIdentifier = ForbiddenIdentifier;
//# sourceMappingURL=forbidden_identifier.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/forbidden_pseudo_and_pragma.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/forbidden_pseudo_and_pragma.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForbiddenPseudoAndPragma = exports.ForbiddenPseudoAndPragmaConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class ForbiddenPseudoAndPragmaConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** @uniqueItems true */
        this.pseudo = [`"#EC *`];
        /** @uniqueItems true */
        this.pragmas = [];
        this.ignoreGlobalClassDefinition = false;
        this.ignoreGlobalInterface = false;
    }
}
exports.ForbiddenPseudoAndPragmaConf = ForbiddenPseudoAndPragmaConf;
class ForbiddenPseudoAndPragma extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ForbiddenPseudoAndPragmaConf();
    }
    getMetadata() {
        return {
            key: "forbidden_pseudo_and_pragma",
            title: "Forbidden pseudo comments and pragma",
            shortDescription: `Checks for unwanted pseudo comments and pragma`,
            tags: [_irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `DATA i TYPE i. "#EC *`,
            goodExample: `DATA i TYPE i.`,
        };
    }
    getConfig() {
        // @ts-ignore
        if (this.conf === true) {
            this.conf = new ForbiddenPseudoAndPragmaConf();
        }
        if (this.conf.pseudo === undefined) {
            this.conf.pseudo = [];
        }
        if (this.conf.pragmas === undefined) {
            this.conf.pragmas = [];
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    // todo, this method could use some refactoring
    // note that the top loop is on the configuration, which makes the default config run fast
    runParsed(file) {
        let skip = false;
        const issues = [];
        for (const p of this.conf.pragmas) {
            for (const s of file.getStatements()) {
                if (this.conf.ignoreGlobalClassDefinition === true) {
                    if (s.get() instanceof Statements.ClassDefinition
                        && s.findFirstExpression(Expressions.ClassGlobal)) {
                        skip = true;
                        continue;
                    }
                    else if (skip === true && s.get() instanceof Statements.EndClass) {
                        skip = false;
                        continue;
                    }
                }
                if (this.conf.ignoreGlobalInterface === true) {
                    if (s.get() instanceof Statements.Interface
                        && s.findFirstExpression(Expressions.ClassGlobal)) {
                        skip = true;
                        continue;
                    }
                    else if (skip === true && s.get() instanceof Statements.EndInterface) {
                        skip = false;
                        continue;
                    }
                }
                if (skip === true) {
                    continue;
                }
                const list = s.getPragmas();
                const found = list.find((a) => a.getStr().toUpperCase() === p.toUpperCase());
                if (found) {
                    const fix = edit_helper_1.EditHelper.deleteToken(file, found);
                    const message = "Forbidden pragma";
                    issues.push(issue_1.Issue.atToken(file, found, message, this.getMetadata().key, this.conf.severity, fix));
                }
            }
        }
        skip = false;
        for (const p of this.conf.pseudo) {
            for (const s of file.getStatements()) {
                if (this.conf.ignoreGlobalClassDefinition === true) {
                    if (s.get() instanceof Statements.ClassDefinition
                        && s.findFirstExpression(Expressions.ClassGlobal)) {
                        skip = true;
                        continue;
                    }
                    else if (skip === true && s.get() instanceof Statements.EndClass) {
                        skip = false;
                        continue;
                    }
                }
                if (this.conf.ignoreGlobalInterface === true) {
                    if (s.get() instanceof Statements.Interface
                        && s.findFirstExpression(Expressions.ClassGlobal)) {
                        skip = true;
                        continue;
                    }
                    else if (skip === true && s.get() instanceof Statements.EndInterface) {
                        skip = false;
                        continue;
                    }
                }
                if (skip === true) {
                    continue;
                }
                if (!(s.get() instanceof _statement_1.Comment)) {
                    continue;
                }
                if (s.concatTokens().toUpperCase().includes(p.toUpperCase())) {
                    const fix = edit_helper_1.EditHelper.deleteStatement(file, s);
                    const message = "Forbidden pseudo comment";
                    issues.push(issue_1.Issue.atStatement(file, s, message, this.getMetadata().key, this.conf.severity, fix));
                }
            }
        }
        return issues;
    }
}
exports.ForbiddenPseudoAndPragma = ForbiddenPseudoAndPragma;
//# sourceMappingURL=forbidden_pseudo_and_pragma.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/forbidden_void_type.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/forbidden_void_type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ForbiddenVoidType = exports.ForbiddenVoidTypeConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const void_type_1 = __webpack_require__(/*! ../abap/types/basic/void_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/void_type.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class ForbiddenVoidTypeConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** List of forbidden void types, array of string regex, case in-sensitive
         * @uniqueItems true
        */
        this.check = [];
    }
}
exports.ForbiddenVoidTypeConf = ForbiddenVoidTypeConf;
class ForbiddenVoidType {
    constructor() {
        this.conf = new ForbiddenVoidTypeConf();
    }
    getMetadata() {
        return {
            key: "forbidden_void_type",
            title: "Forbidden Void Types",
            shortDescription: `Avoid usage of specified void types.`,
            extendedInformation: `Inspiration:
BOOLEAN, BOOLE_D, CHAR01, CHAR1, CHAR10, CHAR12, CHAR128, CHAR2, CHAR20, CHAR4, CHAR70,
DATS, TIMS, DATUM, FLAG, INT4, NUMC3, NUMC4, SAP_BOOL, TEXT25, TEXT80, X255, XFELD`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.check === undefined) {
            this.conf.check = [];
        }
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject) || this.conf.check.length === 0) {
            return [];
        }
        return this.traverse(new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop());
    }
    ///////////////
    traverse(node) {
        var _a, _b, _c;
        let ret = [];
        const message = "Forbidden void type: ";
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.BuiltIn) {
            for (const r of node.getData().references) {
                if (r.referenceType === _reference_1.ReferenceType.ObjectOrientedVoidReference
                    && ((_a = r.extra) === null || _a === void 0 ? void 0 : _a.ooName) !== undefined
                    && this.isForbiddenName((_b = r.extra) === null || _b === void 0 ? void 0 : _b.ooName)) {
                    ret.push(issue_1.Issue.atIdentifier(r.position, message + ((_c = r.extra) === null || _c === void 0 ? void 0 : _c.ooName), this.getMetadata().key, this.conf.severity));
                }
                if ((r.referenceType === _reference_1.ReferenceType.VoidType
                    || r.referenceType === _reference_1.ReferenceType.TableVoidReference)
                    && this.isForbiddenName(r.position.getName())) {
                    ret.push(issue_1.Issue.atIdentifier(r.position, message + r.position.getName(), this.getMetadata().key, this.conf.severity));
                }
            }
        }
        for (const c of node.getChildren()) {
            ret = ret.concat(this.traverse(c));
        }
        return ret;
    }
    isForbiddenType(type) {
        if (type instanceof basic_1.StructureType) {
            return type.getComponents().some(c => this.isForbiddenType(c.type));
        }
        else if (!(type instanceof void_type_1.VoidType)) {
            return false;
        }
        const name = type.getVoided();
        return this.isForbiddenName(name);
    }
    isForbiddenName(name) {
        if (name === undefined) {
            return false;
        }
        for (const c of this.conf.check) {
            const reg = new RegExp(c, "i");
            const match = reg.test(name);
            if (match === true) {
                return true;
            }
        }
        return false;
    }
}
exports.ForbiddenVoidType = ForbiddenVoidType;
//# sourceMappingURL=forbidden_void_type.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/form_tables_obsolete.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/form_tables_obsolete.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormTablesObsolete = exports.FormTablesObsoleteConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class FormTablesObsoleteConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.FormTablesObsoleteConf = FormTablesObsoleteConf;
class FormTablesObsolete extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new FormTablesObsoleteConf();
    }
    getMetadata() {
        return {
            key: "form_tables_obsolete",
            title: "TABLES parameters are obsolete",
            shortDescription: `Checks for TABLES parameters in forms.`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abapform_tables.htm`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "FORM TABLES parameters are obsolete";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const ret = [];
        const stru = file.getStructure();
        if (obj instanceof objects_1.Class || stru === undefined) {
            return ret;
        }
        for (const form of stru.findAllExpressions(Expressions.FormTables)) {
            const token = form.getFirstToken();
            const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
            ret.push(issue);
        }
        return ret;
    }
}
exports.FormTablesObsolete = FormTablesObsolete;
//# sourceMappingURL=form_tables_obsolete.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/fully_type_constants.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/fully_type_constants.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullyTypeConstants = exports.FullyTypeConsantsConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class FullyTypeConsantsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Add check for implicit data definition, require full typing. */
        this.checkData = true;
    }
}
exports.FullyTypeConsantsConf = FullyTypeConsantsConf;
class FullyTypeConstants extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new FullyTypeConsantsConf();
    }
    getMetadata() {
        return {
            key: "fully_type_constants",
            title: "Fully type constants",
            shortDescription: `Checks constants for full typing - no implicit typing allowed.`,
            badExample: "CONSTANTS foo VALUE 'a'.",
            goodExample: "CONSTANTS foo TYPE c LENGTH 1 VALUE 'a'.",
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(type) {
        return `Fully type ${type}, no implicit typing`;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b;
        const issues = [];
        for (const stat of file.getStatements()) {
            if ((stat.get() instanceof Statements.Constant
                || (this.conf.checkData === true && stat.get() instanceof Statements.Data))
                && (!this.isTyped(stat))) {
                const type = stat.get() instanceof Statements.Constant ? "constant definition" : "data definition";
                let token = (_a = stat.findFirstExpression(expressions_1.NamespaceSimpleName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                if (token === undefined) {
                    token = (_b = stat.findFirstExpression(expressions_1.DefinitionName)) === null || _b === void 0 ? void 0 : _b.getFirstToken();
                }
                if (token === undefined) {
                    throw new Error("fully type constants, unexpected node");
                }
                issues.push(issue_1.Issue.atToken(file, token, this.getDescription(type), this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
    isTyped(stat) {
        return (stat.findFirstExpression(expressions_1.Type) || stat.findFirstExpression(expressions_1.TypeTable));
    }
}
exports.FullyTypeConstants = FullyTypeConstants;
//# sourceMappingURL=fully_type_constants.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/fully_type_itabs.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/fully_type_itabs.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FullyTypeITabs = exports.FullyTypeITabsConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class FullyTypeITabsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.FullyTypeITabsConf = FullyTypeITabsConf;
class FullyTypeITabs extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new FullyTypeITabsConf();
    }
    getMetadata() {
        return {
            key: "fully_type_itabs",
            title: "Fully type internal tables",
            shortDescription: `No implict table types or table keys`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-the-right-table-type
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-default-key`,
            badExample: `DATA lt_foo TYPE TABLE OF ty.
DATA lt_bar TYPE STANDARD TABLE OF ty.`,
            goodExample: `DATA lt_foo TYPE STANDARD TABLE OF ty WITH EMPTY KEY.`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const statement of file.getStatements()) {
            if (!(statement.get() instanceof Statements.Data)) {
                continue;
            }
            const tt = statement.findFirstExpression(Expressions.TypeTable);
            if (tt === undefined) {
                continue;
            }
            const concat = tt.concatTokens().toUpperCase();
            if (concat.includes("TYPE TABLE OF")) {
                const message = "Specify table type";
                issues.push(issue_1.Issue.atPosition(file, tt.getFirstToken().getStart(), message, this.getMetadata().key, this.conf.severity));
            }
            else if (concat.includes(" WITH ") === false && concat.includes(" RANGE OF ") === false) {
                const message = "Specify table key";
                issues.push(issue_1.Issue.atPosition(file, tt.getFirstToken().getStart(), message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.FullyTypeITabs = FullyTypeITabs;
//# sourceMappingURL=fully_type_itabs.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/function_module_recommendations.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/function_module_recommendations.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionModuleRecommendations = exports.FunctionModuleRecommendationsConf = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class FunctionModuleRecommendationsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Tuple of Function Module Name to be replaced, the recommended alternative and
         * the version from which the recommendation is valid.
         * @uniqueItems true
         */
        this.recommendations = [
            { name: "CALCULATE_HASH_FOR_RAW", replace: "use CL_ABAP_HMAC or CL_ABAP_MESSAGE_DIGEST" },
            { name: "CCU_TIMESTAMP_DIFFERENCE", replace: "use CL_ABAP_TSTMP" },
            { name: "CONVERT_DATE_TO_EXTERNAL", replace: "use CL_ABAP_DATFM" },
            { name: "CONVERT_TIME_INPUT", replace: "use CL_ABAP_TIMEFM" },
            { name: "ECATT_CONV_XSTRING_TO_STRING", replace: "use CL_BINARY_CONVERT" },
            { name: "F4_FILENAME", replace: "use CL_GUI_FRONTEND_SERVICES" },
            { name: "FUNCTION_EXISTS", replace: "surround with try-catch CX_SY_DYN_CALL_ILLEGAL_METHOD instead" },
            { name: "GUI_DOWNLOAD", replace: "use CL_GUI_FRONTEND_SERVICES" },
            { name: "GUI_UPLOAD", replace: "use CL_GUI_FRONTEND_SERVICES" },
            { name: "GUID_CREATE", replace: "use CL_SYSTEM_UUID" },
            { name: "IGN_TIMESTAMP_DIFFERENCE", replace: "use CL_ABAP_TSTMP" },
            { name: "IGN_TIMESTAMP_PLUSMINUS", replace: "use CL_ABAP_TSTMP" },
            { name: "ISM_SD_GET_PRICING_CONDITIONS", replace: "use CL_PRC_RESULT_FACTORY as per note 2220005" },
            { name: "JOB_CREATE", replace: "use CL_BP_ABAP_JOB" },
            { name: "JOB_SUBMIT", replace: "use CL_BP_ABAP_JOB" },
            { name: "POPUP_TO_CONFIRM_STEP", replace: "use POPUP_TO_CONFIRM" },
            { name: "POPUP_TO_DECIDE", replace: "use POPUP_TO_CONFIRM" },
            { name: "POPUP_TO_GET_VALUE", replace: "use POPUP_GET_VALUES" },
            { name: "QF05_RANDOM_INTEGER", replace: "use CL_ABAP_RANDOM_INT" },
            { name: "REUSE_ALV_GRID_DISPLAY", replace: "use CL_SALV_TABLE=>FACTORY or CL_GUI_ALV_GRID" },
            { name: "ROUND", replace: "use built in function: round()" },
            { name: "SAPGUI_PROGRESS_INDICATOR", replace: "use CL_PROGRESS_INDICATOR" },
            { name: "SCMS_BASE64_DECODE_STR", replace: "use class CL_HTTP_UTILITY methods" },
            { name: "SCMS_STRING_TO_XSTRING", replace: "use CL_BINARY_CONVERT" },
            { name: "SO_NEW_DOCUMENT_ATT_SEND_API1", replace: "use CL_BCS" },
            { name: "SSFC_BASE64_DECODE", replace: "use class CL_HTTP_UTILITY methods" },
            { name: "SSFC_BASE64_ENCODE", replace: "use class CL_HTTP_UTILITY methods" },
            { name: "SUBST_GET_FILE_LIST", replace: "see note 1686357" },
            { name: "WS_FILENAME_GET", replace: "use CL_GUI_FRONTEND_SERVICES" },
        ];
    }
}
exports.FunctionModuleRecommendationsConf = FunctionModuleRecommendationsConf;
class FunctionModuleRecommendations extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new FunctionModuleRecommendationsConf();
    }
    getMetadata() {
        return {
            key: "function_module_recommendations",
            title: "Function Module Recommendations",
            shortDescription: `Suggests replacements for various function modules`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/53/`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        if (!this.conf.recommendations) {
            return issues;
        }
        const configVersion = this.reg.getConfig().getVersion();
        for (const exNode of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(expressions_1.FunctionName)) || []) {
            const token = exNode.getFirstToken();
            let funcName = token.getStr().toUpperCase();
            // only check constant FM names
            if (!funcName.startsWith("'")) {
                continue;
            }
            // remove leading and trailing single quote
            funcName = funcName.slice(1, funcName.length - 1);
            const index = this.conf.recommendations.findIndex(i => i.name.toUpperCase() === funcName && (i.from === undefined || configVersion >= i.from));
            if (index >= 0) {
                issues.push(__1.Issue.atToken(file, token, this.getMessage(index), this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
    getMessage(index) {
        return `Recommendation: Replace Function ${this.conf.recommendations[index].name} with: ${this.conf.recommendations[index].replace}`;
    }
}
exports.FunctionModuleRecommendations = FunctionModuleRecommendations;
//# sourceMappingURL=function_module_recommendations.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/functional_writing.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/functional_writing.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FunctionalWriting = exports.FunctionalWritingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class FunctionalWritingConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore functional writing in exception classes, local + global */
        this.ignoreExceptions = true;
    }
}
exports.FunctionalWritingConf = FunctionalWritingConf;
class FunctionalWriting extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new FunctionalWritingConf();
    }
    getMetadata() {
        return {
            key: "functional_writing",
            title: "Use functional writing",
            shortDescription: `Detects usage of call method when functional style calls can be used.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-functional-to-procedural-calls
https://docs.abapopenchecks.org/checks/07/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `CALL METHOD zcl_class=>method( ).
CALL METHOD cl_abap_typedescr=>describe_by_name
  EXPORTING
    p_name         = 'NAME'
  RECEIVING
    p_descr_ref    = lr_typedescr
  EXCEPTIONS
    type_not_found = 1
    OTHERS         = 2.`,
            goodExample: `zcl_class=>method( ).
cl_abap_typedescr=>describe_by_name(
  EXPORTING
    p_name         = 'NAME'
  RECEIVING
    p_descr_ref    = lr_typedescr
  EXCEPTIONS
    type_not_found = 1
    OTHERS         = 2 ).`,
        };
    }
    getMessage() {
        return "Use functional writing style for method calls";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a, _b;
        const issues = [];
        let exception = false;
        if (obj.getType() === "INTF") {
            return [];
        }
        let definition = undefined;
        if (obj instanceof objects_1.Class) {
            definition = obj.getClassDefinition();
        }
        const ddic = new ddic_1.DDIC(this.reg);
        for (const statNode of file.getStatements()) {
            if (statNode.get() instanceof Statements.ClassImplementation
                && definition
                && ddic.isException(definition, obj)
                && this.conf.ignoreExceptions) {
                exception = true;
            }
            else if (statNode.get() instanceof Statements.EndClass) {
                exception = false;
            }
            else if (exception === false && statNode.get() instanceof Statements.Call) {
                if (((_a = statNode.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.MethodCallChain) {
                    continue;
                }
                const dynamic = (_b = statNode.findDirectExpression(Expressions.MethodSource)) === null || _b === void 0 ? void 0 : _b.findDirectExpression(Expressions.Dynamic);
                if (dynamic !== undefined) {
                    continue;
                }
                issues.push(this.createIssueForStatementNode(file, statNode));
            }
        }
        return issues;
    }
    createIssueForStatementNode(file, statNode) {
        const fixString = this.buildFixString(statNode);
        const fix = edit_helper_1.EditHelper.replaceRange(file, statNode.getStart(), statNode.getEnd(), fixString);
        return issue_1.Issue.atStatement(file, statNode, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
    }
    buildFixString(statNode) {
        // Note: line breaks from source are lost
        const methodSource = statNode.findDirectExpression(Expressions.MethodSource);
        let methodSourceStr = methodSource === null || methodSource === void 0 ? void 0 : methodSource.concatTokens();
        const methodBody = statNode.findDirectExpression(Expressions.MethodCallBody);
        let methodBodyStr = "";
        if (methodBody) {
            const methodCallParam = methodBody.findDirectExpression(Expressions.MethodCallParam);
            if (methodCallParam && methodCallParam.getFirstToken().getStr() === "(") {
                // has parameters and parantheses
                methodBodyStr = `${methodBody.concatTokens()}.`;
            }
            else {
                // has parameters, but parentheses are missing
                methodSourceStr = `${methodSourceStr}( `;
                methodBodyStr = `${methodBody.concatTokens()} ).`;
            }
        }
        else {
            // no body means no parentheses and no parameters
            methodBodyStr = "( ).";
        }
        return methodSourceStr + methodBodyStr;
    }
}
exports.FunctionalWriting = FunctionalWriting;
//# sourceMappingURL=functional_writing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/global_class.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/global_class.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.GlobalClass = exports.GlobalClassConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class GlobalClassConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.GlobalClassConf = GlobalClassConf;
class GlobalClass extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new GlobalClassConf();
    }
    getMetadata() {
        return {
            key: "global_class",
            title: "Global class checks",
            shortDescription: `Checks related to global classes`,
            extendedInformation: `* global classes must be in own files

* file names must match class name

* file names must match interface name

* global classes must be global definitions

* global interfaces must be global definitions`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const output = [];
        for (const definition of file.getInfo().listClassDefinitions()) {
            if (definition.isLocal && obj instanceof Objects.Class && file.getFilename().match(/\.clas\.abap$/)) {
                const issue = issue_1.Issue.atIdentifier(definition.identifier, "Global classes must be global", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
            if (definition.isGlobal && obj instanceof Objects.Class && definition.name.toUpperCase() !== obj.getName().toUpperCase()) {
                const issue = issue_1.Issue.atIdentifier(definition.identifier, "Class definition name must match filename", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
            if (definition.isGlobal && !(obj instanceof Objects.Class)) {
                const issue = issue_1.Issue.atIdentifier(definition.identifier, "Class must be local", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        for (const impl of file.getInfo().listClassImplementations()) {
            if (file.getFilename().match(/\.clas\.abap$/)
                && obj instanceof Objects.Class
                && impl.identifier.getName().toUpperCase() !== obj.getName().toUpperCase()) {
                const issue = issue_1.Issue.atIdentifier(impl.identifier, "Class implementation name must match filename", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        for (const impl of file.getInfo().listInterfaceDefinitions()) {
            if (file.getFilename().match(/\.intf\.abap$/)
                && obj instanceof Objects.Interface
                && impl.identifier.getName().toUpperCase() !== obj.getName().toUpperCase()) {
                const issue = issue_1.Issue.atIdentifier(impl.identifier, "Interface implementation name must match filename", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        for (const intf of file.getInfo().listInterfaceDefinitions()) {
            if (intf.isLocal && obj instanceof Objects.Interface && file.getFilename().match(/\.intf\.abap$/)) {
                const issue = issue_1.Issue.atIdentifier(intf.identifier, "Global interface must be global", this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        return output;
    }
}
exports.GlobalClass = GlobalClass;
//# sourceMappingURL=global_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/identical_conditions.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/identical_conditions.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdenticalConditions = exports.IdenticalConditionsConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
class Conditions {
    constructor() {
        this.arr = [];
        this.arr = [];
    }
    push(e) {
        this.arr.push(e.concatTokens());
    }
    findFirstDuplicate() {
        return this.arr.find(x => this.arr.indexOf(x) !== this.arr.lastIndexOf(x));
    }
}
class IdenticalConditionsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.IdenticalConditionsConf = IdenticalConditionsConf;
class IdenticalConditions extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new IdenticalConditionsConf();
    }
    getMetadata() {
        return {
            key: "identical_conditions",
            title: "Identical conditions",
            shortDescription: `Find identical conditions in IF + CASE + WHILE etc

Prerequsites: code is pretty printed with identical cAsE`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `IF foo = bar OR 1 = a OR foo = bar.
ENDIF.
CASE bar.
  WHEN '1'.
  WHEN 'A' OR '1'.
ENDCASE.`,
            goodExample: `IF foo = bar OR 1 = a.
ENDIF.
CASE bar.
  WHEN '1'.
  WHEN 'A'.
ENDCASE.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        let issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        for (const i of structure.findAllStructures(Structures.If)) {
            issues = issues.concat(this.analyzeIf(file, i));
        }
        for (const i of structure.findAllStructures(Structures.Case)) {
            issues = issues.concat(this.analyzeWhen(file, i));
        }
        for (const i of structure.findAllExpressions(Expressions.Cond)) {
            issues = issues.concat(this.analyzeCond(file, i));
        }
        return issues;
    }
    ////////////////
    analyzeCond(file, node) {
        const conditions = new Conditions();
        let operator = "";
        for (const c of node.getChildren()) {
            if (c instanceof nodes_1.ExpressionNode) {
                conditions.push(c);
            }
            else if (operator === "") {
                operator = c.get().getStr().toUpperCase();
            }
            else if (operator !== c.get().getStr().toUpperCase()) {
                return [];
            }
        }
        const duplicate = conditions.findFirstDuplicate();
        if (duplicate) {
            const message = "Identical conditions: " + duplicate;
            const issue = issue_1.Issue.atToken(file, node.getFirstToken(), message, this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
    analyzeIf(file, node) {
        var _a;
        const conditions = new Conditions();
        const i = node.findDirectStatement(Statements.If);
        if (i === undefined) {
            throw new Error("identical_conditions, no IF found");
        }
        const c = i === null || i === void 0 ? void 0 : i.findDirectExpression(Expressions.Cond);
        if (c) {
            conditions.push(c);
        }
        for (const e of node.findDirectStructures(Structures.ElseIf)) {
            const c = (_a = e.findDirectStatement(Statements.ElseIf)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Cond);
            if (c) {
                conditions.push(c);
            }
        }
        const duplicate = conditions.findFirstDuplicate();
        if (duplicate) {
            const message = "Identical conditions: " + duplicate;
            const issue = issue_1.Issue.atStatement(file, i, message, this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
    analyzeWhen(file, node) {
        const conditions = new Conditions();
        const i = node.findDirectStatement(Statements.Case);
        if (i === undefined) {
            throw new Error("identical_conditions, no CASE found");
        }
        for (const e of node.findDirectStructures(Structures.When)) {
            const w = e.findDirectStatement(Statements.When);
            if (w === undefined) {
                continue;
            }
            for (const s of w.findAllExpressions(Expressions.Source)) {
                conditions.push(s);
            }
        }
        const duplicate = conditions.findFirstDuplicate();
        if (duplicate) {
            const message = "Identical conditions: " + duplicate;
            const issue = issue_1.Issue.atStatement(file, i, message, this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
}
exports.IdenticalConditions = IdenticalConditions;
//# sourceMappingURL=identical_conditions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/identical_contents.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/identical_contents.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdenticalContents = exports.IdenticalContentsConf = void 0;
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class IdenticalContentsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.IdenticalContentsConf = IdenticalContentsConf;
class IdenticalContents extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new IdenticalContentsConf();
    }
    getMetadata() {
        return {
            key: "identical_contents",
            title: "Identical contents",
            shortDescription: `Find identical contents in blocks inside IFs, both in the beginning and in the end.`,
            extendedInformation: `
Prerequsites: code is pretty printed with identical cAsE

Chained statments are ignored`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `IF foo = bar.
  WRITE 'bar'.
  WRITE 'world'.
ELSE.
  WRITE 'foo'.
  WRITE 'world'.
ENDIF.`,
            goodExample: `IF foo = bar.
  WRITE 'bar'.
ELSE.
  WRITE 'foo'.
ENDIF.
WRITE 'world'.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        let issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof _statement_1.Unknown) {
                return []; // contains parser errors
            }
        }
        for (const i of structure.findAllStructuresRecursive(Structures.If)) {
            issues = issues.concat(this.analyzeIf(file, i));
        }
        return issues;
    }
    ////////////////
    analyzeIf(file, node) {
        var _a;
        if (node.getChildren().length !== 4) {
            return [];
        }
        const ifBody = node.findDirectStructure(Structures.Body);
        if (node.findDirectStructure(Structures.ElseIf)) {
            return [];
        }
        const elseBody = (_a = node.findDirectStructure(Structures.Else)) === null || _a === void 0 ? void 0 : _a.findDirectStructure(Structures.Body);
        if (elseBody === undefined || ifBody === undefined) {
            return [];
        }
        {
            const ifFirst = ifBody.getFirstChild();
            const elseFirst = elseBody.getFirstChild();
            if (ifFirst === undefined || elseFirst === undefined || this.isChained(ifFirst)) {
                return [];
            }
            else if (ifFirst.concatTokens() === elseFirst.concatTokens()) {
                const message = "Identical contents";
                const issue = issue_1.Issue.atToken(file, node.getFirstToken(), message, this.getMetadata().key, this.conf.severity);
                return [issue];
            }
        }
        {
            const ifLast = ifBody.getLastChild();
            const elseLast = elseBody.getLastChild();
            if (ifLast === undefined || elseLast === undefined || this.isChained(ifLast)) {
                return [];
            }
            else if (ifLast.concatTokens() === elseLast.concatTokens()) {
                const message = "Identical contents";
                const issue = issue_1.Issue.atToken(file, node.getFirstToken(), message, this.getMetadata().key, this.conf.severity);
                return [issue];
            }
        }
        return [];
    }
    isChained(node) {
        if (node === undefined) {
            return false;
        }
        else if (node instanceof nodes_1.StatementNode) {
            return node.getColon() !== undefined;
        }
        else {
            return this.isChained(node.getFirstStatement());
        }
    }
}
exports.IdenticalContents = IdenticalContents;
//# sourceMappingURL=identical_contents.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/identical_descriptions.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/identical_descriptions.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdenticalDescriptions = exports.IdenticalDescriptionsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class IdenticalDescriptionsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.IdenticalDescriptionsConf = IdenticalDescriptionsConf;
class IdenticalDescriptions {
    constructor() {
        this.conf = new IdenticalDescriptionsConf();
    }
    getMetadata() {
        return {
            key: "identical_descriptions",
            title: "Identical descriptions",
            shortDescription: `Searches for objects with the same type and same description`,
            extendedInformation: `Case insensitive

Only checks the master language descriptions

Dependencies are skipped

Works for: INTF, CLAS, DOMA, DTEL, FUNC in same FUGR`,
            tags: [],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        var _a;
        this.descriptions = {};
        this.types = ["INTF", "CLAS", "DOMA", "DTEL"];
        for (const o of reg.getObjects()) {
            if (reg.isDependency(o)) {
                continue;
            }
            const type = o.getType();
            if (this.types.includes(type)) {
                const description = (_a = o.getDescription()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
                if (description === undefined || description === "") {
                    continue;
                }
                if (this.descriptions[type] === undefined) {
                    this.descriptions[type] = {};
                }
                if (this.descriptions[type][description] === undefined) {
                    this.descriptions[type][description] = [];
                }
                this.descriptions[type][description].push(o.getName());
            }
        }
        return this;
    }
    run(o) {
        var _a;
        const issues = [];
        const type = o.getType();
        if (this.types.includes(type)) {
            const description = (_a = o.getDescription()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
            if (description === undefined || description === "") {
                return issues;
            }
            const found = this.descriptions[type][description].filter(a => a !== o.getName());
            if (found.length > 0) {
                const message = "Identical description: " + found[0];
                issues.push(issue_1.Issue.atRow(o.getXMLFile(), 1, message, this.getMetadata().key, this.getConfig().severity));
            }
        }
        if (o instanceof objects_1.FunctionGroup) {
            issues.push(...this.checkFunctionModules(o));
        }
        return issues;
    }
    checkFunctionModules(fugr) {
        var _a;
        const descriptions = {};
        for (const fm of fugr.getModules()) {
            const d = (_a = fm.getDescription()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
            if (d === undefined || d === "") {
                continue;
            }
            if (descriptions[d] !== undefined) {
                const message = "FUGR " + fugr.getName() + " contains function modules with identical descriptions";
                return [issue_1.Issue.atRow(fugr.getXMLFile(), 1, message, this.getMetadata().key, this.getConfig().severity)];
            }
            descriptions[d] = true;
        }
        return [];
    }
}
exports.IdenticalDescriptions = IdenticalDescriptions;
//# sourceMappingURL=identical_descriptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/identical_form_names.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/identical_form_names.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IdenticalFormNames = exports.IdenticalFormNamesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class IdenticalFormNamesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.IdenticalFormNamesConf = IdenticalFormNamesConf;
// todo: deprecation candidate? this is/should be handled by the syntax check?
class IdenticalFormNames {
    constructor() {
        this.conf = new IdenticalFormNamesConf();
    }
    getMetadata() {
        return {
            key: "identical_form_names",
            title: "Identical FORM names",
            shortDescription: `Detects identically named FORMs`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const ret = [];
        const found = [];
        for (const file of obj.getABAPFiles()) {
            for (const form of file.getInfo().listFormDefinitions()) {
                const name = form.name.toUpperCase();
                if (found.indexOf(name) >= 0) {
                    const message = "Identical FORM Names: \"" + name + "\"";
                    const issue = issue_1.Issue.atIdentifier(form.identifier, message, this.getMetadata().key, this.conf.severity);
                    ret.push(issue);
                }
                else {
                    found.push(name);
                }
            }
        }
        return ret;
    }
}
exports.IdenticalFormNames = IdenticalFormNames;
//# sourceMappingURL=identical_form_names.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/if_in_if.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/if_in_if.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IfInIf = exports.IfInIfConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class IfInIfConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.IfInIfConf = IfInIfConf;
class IfInIf extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new IfInIfConf();
    }
    getMetadata() {
        return {
            key: "if_in_if",
            title: "IF in IF",
            shortDescription: `Detects nested ifs which can be refactored.`,
            extendedInformation: `
Directly nested IFs without ELSE can be refactored to a single condition using AND.

ELSE condtions with directly nested IF refactored to ELSEIF, quickfixes are suggested for this case.

https://docs.abapopenchecks.org/checks/01/
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#keep-the-nesting-depth-low`,
            badExample: `IF condition1.
  IF condition2.
    ...
  ENDIF.
ENDIF.

IF condition1.
  ...
ELSE.
  IF condition2.
    ...
  ENDIF.
ENDIF.`,
            goodExample: `IF ( condition1 ) AND ( condition2 ).
  ...
ENDIF.

IF condition1.
  ...
ELSEIF condition2.
  ...
ENDIF.

CASE variable.
  WHEN value1.
  ...
  WHEN value2.
    IF condition2.
      ...
    ENDIF.
ENDCASE.`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a, _b;
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        let fixed = false;
        let possible = stru.findAllStructures(Structures.If);
        possible = possible.concat(stru.findAllStructures(Structures.Else));
        for (const i of possible) {
            if (i.findDirectStructures(Structures.ElseIf).length > 0
                || i.findDirectStructures(Structures.Else).length > 0) {
                continue;
            }
            const blist = i.findDirectStructures(Structures.Body);
            if (blist.length === 0) {
                continue;
            }
            const nlist = blist[0].findDirectStructures(Structures.Normal);
            if (nlist.length !== 1) {
                continue;
            }
            const niflist = nlist[0].findDirectStructures(Structures.If);
            if (niflist.length !== 1) {
                continue;
            }
            const nestedIf = niflist[0];
            if (i.get() instanceof Structures.If
                && (nestedIf.findDirectStructures(Structures.ElseIf).length > 0
                    || nestedIf.findDirectStructures(Structures.Else).length > 0)) {
                continue;
            }
            let message = "IF in IF. Use IF cond1 AND cond2 instead";
            let fix = undefined;
            if (i.get() instanceof Structures.Else) {
                message = "Change ELSE part to ELSEIF";
                const els = i.findFirstStatement(Statements.Else);
                const iff = (_a = i.findFirstStructure(Structures.If)) === null || _a === void 0 ? void 0 : _a.findDirectStatement(Statements.If);
                const endif = (_b = i.findFirstStructure(Structures.If)) === null || _b === void 0 ? void 0 : _b.findDirectStatement(Statements.EndIf);
                if (fixed === false && iff && els && endif) {
                    const fix1 = edit_helper_1.EditHelper.deleteRange(file, els.getLastToken().getStart(), iff === null || iff === void 0 ? void 0 : iff.getFirstToken().getStart());
                    const fix2 = edit_helper_1.EditHelper.deleteStatement(file, endif);
                    fix = edit_helper_1.EditHelper.merge(fix1, fix2);
                    // max one fix per file at a time
                    fixed = true;
                }
            }
            const token = i.getFirstToken();
            const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity, fix);
            issues.push(issue);
        }
        return issues;
    }
}
exports.IfInIf = IfInIf;
//# sourceMappingURL=if_in_if.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/implement_methods.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/implement_methods.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplementMethods = exports.ImplementMethodsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
// todo: abstract methods from superclass parents(might be multiple), if class is not abstract
class ImplementMethodsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ImplementMethodsConf = ImplementMethodsConf;
class ImplementMethods extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ImplementMethodsConf();
    }
    getMetadata() {
        return {
            key: "implement_methods",
            title: "Implement methods",
            shortDescription: `Checks for abstract methods and methods from interfaces which need implementing.`,
            extendedInformation: `INCLUDE programs are only checked in connection with their main programs.`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.Quickfix],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        let ret = [];
        if (file.getStructure() === undefined) {
            return [];
        }
        else if (obj instanceof objects_1.Program && obj.isInclude() === true) {
            return [];
        }
        this.obj = obj;
        for (const classDefinition of file.getInfo().listClassDefinitions()) {
            const classImplementation = this.lookupImplementationInObject(classDefinition.name, obj);
            ret = ret.concat(this.checkClass(classDefinition, classImplementation));
            ret = ret.concat(this.checkInterfaces(classDefinition, classImplementation));
        }
        return ret;
    }
    /////////////////////////////////
    lookupImplementationInObject(name, obj) {
        for (const sub of obj.getABAPFiles()) {
            const impl = sub.getInfo().getClassImplementationByName(name);
            if (impl !== undefined) {
                return impl;
            }
        }
        return undefined;
    }
    lookupDefinitionInObject(name) {
        for (const sub of this.obj.getABAPFiles()) {
            const def = sub.getInfo().getClassDefinitionByName(name);
            if (def !== undefined) {
                return def;
            }
        }
        return undefined;
    }
    checkClass(def, impl) {
        const ret = [];
        for (const md of def.methods) {
            const found = impl === null || impl === void 0 ? void 0 : impl.methods.find(m => m.getName().toUpperCase() === md.name.toUpperCase());
            if (md.isAbstract === true) {
                if (found !== undefined) {
                    const issue = issue_1.Issue.atIdentifier(found, "Do not implement abstract method \"" + md.name + "\"", this.getMetadata().key, this.conf.severity);
                    ret.push(issue);
                }
                continue;
            }
            if (impl === undefined) {
                const message = "Class implementation for \"" + def.name + "\" not found";
                const issue = issue_1.Issue.atIdentifier(def.identifier, message, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
            else if (found === undefined) {
                const message = "Implement method \"" + md.name + "\"";
                const fix = this.buildFix(impl, md.name);
                const issue = issue_1.Issue.atIdentifier(impl.identifier, message, this.getMetadata().key, this.conf.severity, fix);
                ret.push(issue);
            }
        }
        return ret;
    }
    buildFix(impl, methodName) {
        var _a, _b;
        const file = this.obj.getABAPFileByName(impl.identifier.getFilename());
        if (file === undefined) {
            return undefined;
        }
        for (const i of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllStatements(Statements.ClassImplementation)) || []) {
            const name = (_b = i.findFirstExpression(Expressions.ClassName)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr().toUpperCase();
            if (name === impl.identifier.getName().toUpperCase()) {
                return edit_helper_1.EditHelper.insertAt(file, i.getLastToken().getEnd(), `
  METHOD ${methodName.toLowerCase()}.
    RETURN. " todo, implement method
  ENDMETHOD.`);
            }
        }
        return undefined;
    }
    findInterface(identifier, name) {
        const idef = this.findInterfaceByName(name);
        if (idef === undefined) {
            const message = "Implemented interface \"" + name + "\" not found";
            const issue = issue_1.Issue.atIdentifier(identifier, message, this.getMetadata().key, this.conf.severity);
            return issue;
        }
        return idef;
    }
    findInterfaceByName(name) {
        var _a;
        let idef = undefined;
        const intf = this.reg.getObject("INTF", name);
        if (intf === undefined) {
            // lookup in localfiles
            for (const file of this.obj.getABAPFiles()) {
                const found = file.getInfo().getInterfaceDefinitionByName(name);
                if (found) {
                    idef = found;
                    break;
                }
            }
        }
        else {
            idef = (_a = intf.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getInfo().listInterfaceDefinitions()[0];
        }
        return idef;
    }
    /** including implemented super interfaces */
    findInterfaceMethods(idef) {
        const methods = idef.methods.map((m) => {
            return { objectName: idef.name, method: m };
        });
        for (const i of idef.interfaces) {
            const sup = this.findInterface(idef.identifier, i.name);
            if (sup !== undefined && !(sup instanceof issue_1.Issue)) {
                sup.methods.forEach(m => {
                    methods.push({ objectName: sup.name, method: m });
                });
            }
        }
        return methods;
    }
    findClass(name) {
        let def = this.lookupDefinitionInObject(name);
        let impl = this.lookupImplementationInObject(name, this.obj);
        if (def && impl) {
            return { def, impl };
        }
        const global = this.reg.getObject("CLAS", name);
        if (global) {
            def = global.getClassDefinition();
            impl = this.lookupImplementationInObject(name, global);
            if (def && impl) {
                return { def, impl };
            }
        }
        return undefined;
    }
    checkInterfaces(def, impl) {
        const ret = [];
        for (const interfaceInfo of def.interfaces) {
            const idef = this.findInterface(def.identifier, interfaceInfo.name);
            if (idef === undefined || interfaceInfo.partial === true || interfaceInfo.allAbstract === true) {
                continue; // ignore parser errors in interface
            }
            else if (idef instanceof issue_1.Issue) {
                return [idef];
            }
            for (const m of this.findInterfaceMethods(idef)) {
                if (interfaceInfo.abstractMethods.includes(m.method.name.toUpperCase())) {
                    continue;
                }
                if (this.isImplemented(m, def, impl) === false) {
                    const message = "Implement method \"" + m.method.name + "\" from interface \"" + m.objectName + "\"";
                    if (impl) {
                        const fix = this.buildFix(impl, m.objectName + "~" + m.method.name);
                        const issue = issue_1.Issue.atIdentifier(impl.identifier, message, this.getMetadata().key, this.conf.severity, fix);
                        ret.push(issue);
                    }
                    else {
                        const issue = issue_1.Issue.atIdentifier(def.identifier, message, this.getMetadata().key, this.conf.severity);
                        ret.push(issue);
                    }
                }
            }
        }
        return ret;
    }
    isImplemented(m, def, impl) {
        if (impl === undefined) {
            return false;
        }
        const name = m.objectName + "~" + m.method.name;
        let found = impl.methods.find(m => m.getName().toUpperCase() === name.toUpperCase());
        if (found === undefined) {
            // try looking for ALIASes
            for (const alias of def.aliases) {
                if (alias.component.toUpperCase() === name.toUpperCase()) {
                    found = impl.methods.find(m => m.getName().toUpperCase() === alias.name.toUpperCase());
                    break;
                }
            }
        }
        if (found === undefined && def.superClassName !== undefined) {
            const clas = this.findClass(def.superClassName);
            if (clas) {
                return this.isImplemented(m, clas === null || clas === void 0 ? void 0 : clas.def, clas === null || clas === void 0 ? void 0 : clas.impl);
            }
        }
        if (found === undefined) {
            for (const i of def.interfaces) {
                const idef = this.findInterfaceByName(i.name);
                if (idef === undefined) {
                    continue;
                }
                const ali = this.viaAliasInInterface(m, idef, impl);
                if (ali) {
                    return ali;
                }
            }
        }
        return found !== undefined;
    }
    viaAliasInInterface(m, intf, impl) {
        for (const a of intf.aliases) {
            if (a.component.toUpperCase() === m.objectName.toUpperCase() + "~" + m.method.name.toUpperCase()) {
                const name = intf.name + "~" + a.name;
                const found = impl.methods.find(m => m.getName().toUpperCase() === name.toUpperCase());
                if (found) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.ImplementMethods = ImplementMethods;
//# sourceMappingURL=implement_methods.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/implicit_start_of_selection.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/implicit_start_of_selection.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ImplicitStartOfSelection = exports.ImplicitStartOfSelectionConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const selection_events_1 = __webpack_require__(/*! ../abap/flow/selection_events */ "./node_modules/@abaplint/core/build/src/abap/flow/selection_events.js");
class ImplicitStartOfSelectionConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ImplicitStartOfSelectionConf = ImplicitStartOfSelectionConf;
class ImplicitStartOfSelection extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ImplicitStartOfSelectionConf();
    }
    getMetadata() {
        return {
            key: "implicit_start_of_selection",
            title: "Implicit START-OF-SELECTION",
            shortDescription: `Add explicit selection screen event handling`,
            extendedInformation: `Only runs for executable programs

https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapstart-of-selection.htm`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `REPORT zfoo.
WRITE 'hello'.`,
            goodExample: `
START-OF-SELECTION.
  WRITE 'hello'.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (!(obj instanceof objects_1.Program) || obj.isInclude()) {
            return issues;
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        let inEvent = false;
        let collected = [];
        for (const s of stru.getChildren() || []) {
            if (selection_events_1.SELECTION_EVENTS.some(f => s.get() instanceof f)) {
                if (inEvent === false && collected.length > 0) {
                    // implicit START-OF-SELECTION
                    let first = collected[0];
                    if (first instanceof nodes_1.StructureNode) {
                        first = first.getFirstStatement();
                    }
                    issues.push(issue_1.Issue.atStatement(file, first, "Implicit START-OF-SELECTION", this.getMetadata().key, this.getConfig().severity));
                }
                collected = [];
                inEvent = true;
            }
            else if (s.get() instanceof Structures.Normal) {
                const stru = s;
                // ignore declaration stuff
                if (selection_events_1.DECLARATION_STUFF.some(d => { var _a; return ((_a = stru.getFirstStatement()) === null || _a === void 0 ? void 0 : _a.get()) instanceof d; })) {
                    continue;
                }
                collected.push(s);
            }
            else {
                if (inEvent === true) {
                    inEvent = false;
                }
                collected = [];
            }
        }
        if (inEvent === false && collected.length > 0) {
            // implicit START-OF-SELECTION
            let first = collected[0];
            if (first instanceof nodes_1.StructureNode) {
                first = first.getFirstStatement();
            }
            issues.push(issue_1.Issue.atStatement(file, first, "Implicit START-OF-SELECTION", this.getMetadata().key, this.getConfig().severity));
        }
        return issues;
    }
}
exports.ImplicitStartOfSelection = ImplicitStartOfSelection;
//# sourceMappingURL=implicit_start_of_selection.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/in_statement_indentation.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/in_statement_indentation.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InStatementIndentation = exports.InStatementIndentationConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class InStatementIndentationConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Additional indent for first statement of blocks */
        this.blockStatements = 2;
        /** Ignore global exception classes */
        this.ignoreExceptions = true;
    }
}
exports.InStatementIndentationConf = InStatementIndentationConf;
class InStatementIndentation extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new InStatementIndentationConf();
    }
    getMetadata() {
        return {
            key: "in_statement_indentation",
            title: "In-statement indentation",
            shortDescription: "Checks alignment within statements which span multiple lines.",
            extendedInformation: `Lines following the first line should be indented once (2 spaces).
      
For block declaration statements, lines after the first should be indented an additional time (default: +2 spaces)
to distinguish them better from code within the block.`,
            badExample: `IF 1 = 1
  AND 2 = 2.
  WRITE 'hello' &&
  'world'.
ENDIF.`,
            goodExample: `IF 1 = 1
    AND 2 = 2.
  WRITE 'hello' &&
    'world'.
ENDIF.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "Fix in-statement indentation";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const ret = [];
        const ddic = new ddic_1.DDIC(this.reg);
        if (obj instanceof objects_1.Class) {
            const definition = obj.getClassDefinition();
            if (definition === undefined) {
                return [];
            }
            else if (this.conf.ignoreExceptions && ddic.isException(definition, obj)) {
                return [];
            }
        }
        for (const s of file.getStatements()) {
            if (s.get() instanceof _statement_1.Comment || s.get() instanceof _statement_1.Unknown) {
                continue;
            }
            const tokens = s.getTokens();
            if (tokens.length === 0) {
                continue;
            }
            const beginLine = tokens[0].getRow();
            let expected = tokens[0].getCol() + 2;
            const type = s.get();
            if (type instanceof Statements.If
                || type instanceof Statements.While
                || type instanceof Statements.Module
                || type instanceof Statements.SelectLoop
                || type instanceof Statements.FunctionModule
                || type instanceof Statements.Do
                || type instanceof Statements.At
                || type instanceof Statements.Catch
                || type instanceof Statements.Case
                || type instanceof Statements.When
                || type instanceof Statements.Cleanup
                || type instanceof Statements.Loop
                || type instanceof Statements.Form
                || type instanceof Statements.Else
                || type instanceof Statements.ElseIf
                || type instanceof Statements.MethodImplementation) {
                expected = expected + this.conf.blockStatements;
            }
            for (const t of tokens) {
                if (t.getRow() === beginLine) {
                    continue;
                }
                if (t.getCol() < expected) {
                    const fix = edit_helper_1.EditHelper.replaceRange(file, new position_1.Position(t.getRow(), 1), t.getStart(), " ".repeat(expected - 1));
                    const issue = issue_1.Issue.atToken(file, t, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                    ret.push(issue);
                    break;
                }
            }
        }
        return ret;
    }
}
exports.InStatementIndentation = InStatementIndentation;
//# sourceMappingURL=in_statement_indentation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/indentation.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/indentation.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Indentation = exports.IndentationConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const indent_1 = __webpack_require__(/*! ../pretty_printer/indent */ "./node_modules/@abaplint/core/build/src/pretty_printer/indent.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class IndentationConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore global exception classes */
        this.ignoreExceptions = true;
        /** Align TRY CATCH, TRY and CATCH should have the same indentation */
        this.alignTryCatch = false;
        /** Add indentation for SELECTION SCREEN BLOCK, standard pretty printer indents this from 754 */
        this.selectionScreenBlockIndentation = false;
        this.globalClassSkipFirst = false;
        this.ignoreGlobalClassDefinition = false;
        this.ignoreGlobalInterface = false;
    }
}
exports.IndentationConf = IndentationConf;
class Indentation extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new IndentationConf();
    }
    getMetadata() {
        return {
            key: "indentation",
            title: "Indentation",
            shortDescription: `Checks indentation`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `CLASS lcl DEFINITION.
PRIVATE SECTION.
METHODS constructor.
ENDCLASS.

CLASS lcl IMPLEMENTATION.
METHOD constructor.
ENDMETHOD.
ENDCLASS.`,
            goodExample: `CLASS lcl DEFINITION.
  PRIVATE SECTION.
    METHODS constructor.
ENDCLASS.

CLASS lcl IMPLEMENTATION.
  METHOD constructor.
  ENDMETHOD.
ENDCLASS.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a, _b;
        const MAX_ISSUES = 100;
        let skip = false;
        if (file.getStructure() === undefined) {
            return []; // syntax error in file
        }
        if (obj instanceof objects_1.Class) {
            const definition = obj.getClassDefinition();
            const ddic = new ddic_1.DDIC(this.reg);
            if (definition === undefined) {
                return [];
            }
            else if (this.conf.ignoreExceptions && ddic.isException(definition, obj)) {
                return [];
            }
        }
        const indentOpts = {
            selectionScreenBlockIndentation: (_a = this.conf) === null || _a === void 0 ? void 0 : _a.selectionScreenBlockIndentation,
            alignTryCatch: (_b = this.conf) === null || _b === void 0 ? void 0 : _b.alignTryCatch,
            globalClassSkipFirst: this.conf.globalClassSkipFirst,
        };
        const expected = new indent_1.Indent(indentOpts).getExpectedIndents(file);
        const ret = [];
        let previous = undefined;
        for (const statement of file.getStatements()) {
            const position = statement.getFirstToken().getStart();
            if (position instanceof virtual_position_1.VirtualPosition) {
                continue;
            }
            const indent = expected.shift();
            if (this.conf.ignoreGlobalClassDefinition) {
                if (statement.get() instanceof Statements.ClassDefinition
                    && statement.findFirstExpression(Expressions.ClassGlobal)) {
                    skip = true;
                    continue;
                }
                else if (skip === true && statement.get() instanceof Statements.EndClass) {
                    skip = false;
                    continue;
                }
                else if (skip === true) {
                    continue;
                }
            }
            if (this.conf.ignoreGlobalInterface) {
                if (statement.get() instanceof Statements.Interface
                    && statement.findFirstExpression(Expressions.ClassGlobal)) {
                    skip = true;
                    continue;
                }
                else if (skip === true && statement.get() instanceof Statements.EndInterface) {
                    skip = false;
                    continue;
                }
                else if (skip === true) {
                    continue;
                }
            }
            // only apply for the first statement in a chain
            if (statement.getColon() !== undefined
                && (previous === null || previous === void 0 ? void 0 : previous.getColon()) !== undefined
                && statement.getColon().getStart().equals(previous.getColon().getStart())) {
                continue;
            }
            if (indent && indent > 0 && indent !== position.getCol()) {
                const expected = indent - 1;
                const fix = edit_helper_1.EditHelper.replaceRange(file, new position_1.Position(position.getRow(), 1), position, " ".repeat(expected));
                const message = "Indentation problem, expected " + expected + " spaces";
                const issue = issue_1.Issue.atPosition(file, position, message, this.getMetadata().key, this.conf.severity, fix);
                ret.push(issue);
                if (ret.length >= MAX_ISSUES) {
                    break;
                }
            }
            previous = statement;
        }
        return ret;
    }
}
exports.Indentation = Indentation;
//# sourceMappingURL=indentation.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/index.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";

var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", ({ value: true }));
__exportStar(__webpack_require__(/*! ./7bit_ascii */ "./node_modules/@abaplint/core/build/src/rules/7bit_ascii.js"), exports);
__exportStar(__webpack_require__(/*! ./abapdoc */ "./node_modules/@abaplint/core/build/src/rules/abapdoc.js"), exports);
__exportStar(__webpack_require__(/*! ./add_test_attributes */ "./node_modules/@abaplint/core/build/src/rules/add_test_attributes.js"), exports);
__exportStar(__webpack_require__(/*! ./align_parameters */ "./node_modules/@abaplint/core/build/src/rules/align_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./align_pseudo_comments */ "./node_modules/@abaplint/core/build/src/rules/align_pseudo_comments.js"), exports);
__exportStar(__webpack_require__(/*! ./align_type_expressions */ "./node_modules/@abaplint/core/build/src/rules/align_type_expressions.js"), exports);
__exportStar(__webpack_require__(/*! ./allowed_object_naming */ "./node_modules/@abaplint/core/build/src/rules/allowed_object_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./allowed_object_types */ "./node_modules/@abaplint/core/build/src/rules/allowed_object_types.js"), exports);
__exportStar(__webpack_require__(/*! ./ambiguous_statement */ "./node_modules/@abaplint/core/build/src/rules/ambiguous_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./avoid_use */ "./node_modules/@abaplint/core/build/src/rules/avoid_use.js"), exports);
__exportStar(__webpack_require__(/*! ./begin_end_names */ "./node_modules/@abaplint/core/build/src/rules/begin_end_names.js"), exports);
__exportStar(__webpack_require__(/*! ./begin_single_include */ "./node_modules/@abaplint/core/build/src/rules/begin_single_include.js"), exports);
__exportStar(__webpack_require__(/*! ./call_transaction_authority_check */ "./node_modules/@abaplint/core/build/src/rules/call_transaction_authority_check.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_comment_style */ "./node_modules/@abaplint/core/build/src/rules/cds_comment_style.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_legacy_view */ "./node_modules/@abaplint/core/build/src/rules/cds_legacy_view.js"), exports);
__exportStar(__webpack_require__(/*! ./cds_parser_error */ "./node_modules/@abaplint/core/build/src/rules/cds_parser_error.js"), exports);
__exportStar(__webpack_require__(/*! ./chain_mainly_declarations */ "./node_modules/@abaplint/core/build/src/rules/chain_mainly_declarations.js"), exports);
__exportStar(__webpack_require__(/*! ./change_if_to_case */ "./node_modules/@abaplint/core/build/src/rules/change_if_to_case.js"), exports);
__exportStar(__webpack_require__(/*! ./check_abstract */ "./node_modules/@abaplint/core/build/src/rules/check_abstract.js"), exports);
__exportStar(__webpack_require__(/*! ./check_comments */ "./node_modules/@abaplint/core/build/src/rules/check_comments.js"), exports);
__exportStar(__webpack_require__(/*! ./check_ddic */ "./node_modules/@abaplint/core/build/src/rules/check_ddic.js"), exports);
__exportStar(__webpack_require__(/*! ./check_include */ "./node_modules/@abaplint/core/build/src/rules/check_include.js"), exports);
__exportStar(__webpack_require__(/*! ./check_subrc */ "./node_modules/@abaplint/core/build/src/rules/check_subrc.js"), exports);
__exportStar(__webpack_require__(/*! ./check_syntax */ "./node_modules/@abaplint/core/build/src/rules/check_syntax.js"), exports);
__exportStar(__webpack_require__(/*! ./check_text_elements */ "./node_modules/@abaplint/core/build/src/rules/check_text_elements.js"), exports);
__exportStar(__webpack_require__(/*! ./check_transformation_exists */ "./node_modules/@abaplint/core/build/src/rules/check_transformation_exists.js"), exports);
__exportStar(__webpack_require__(/*! ./class_attribute_names */ "./node_modules/@abaplint/core/build/src/rules/class_attribute_names.js"), exports);
__exportStar(__webpack_require__(/*! ./classic_exceptions_overlap */ "./node_modules/@abaplint/core/build/src/rules/classic_exceptions_overlap.js"), exports);
__exportStar(__webpack_require__(/*! ./cloud_types */ "./node_modules/@abaplint/core/build/src/rules/cloud_types.js"), exports);
__exportStar(__webpack_require__(/*! ./colon_missing_space */ "./node_modules/@abaplint/core/build/src/rules/colon_missing_space.js"), exports);
__exportStar(__webpack_require__(/*! ./commented_code */ "./node_modules/@abaplint/core/build/src/rules/commented_code.js"), exports);
__exportStar(__webpack_require__(/*! ./constant_classes */ "./node_modules/@abaplint/core/build/src/rules/constant_classes.js"), exports);
__exportStar(__webpack_require__(/*! ./constructor_visibility_public */ "./node_modules/@abaplint/core/build/src/rules/constructor_visibility_public.js"), exports);
__exportStar(__webpack_require__(/*! ./contains_tab */ "./node_modules/@abaplint/core/build/src/rules/contains_tab.js"), exports);
__exportStar(__webpack_require__(/*! ./cyclic_oo */ "./node_modules/@abaplint/core/build/src/rules/cyclic_oo.js"), exports);
__exportStar(__webpack_require__(/*! ./cyclomatic_complexity */ "./node_modules/@abaplint/core/build/src/rules/cyclomatic_complexity.js"), exports);
__exportStar(__webpack_require__(/*! ./dangerous_statement */ "./node_modules/@abaplint/core/build/src/rules/dangerous_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./db_operation_in_loop */ "./node_modules/@abaplint/core/build/src/rules/db_operation_in_loop.js"), exports);
__exportStar(__webpack_require__(/*! ./definitions_top */ "./node_modules/@abaplint/core/build/src/rules/definitions_top.js"), exports);
__exportStar(__webpack_require__(/*! ./description_empty */ "./node_modules/@abaplint/core/build/src/rules/description_empty.js"), exports);
__exportStar(__webpack_require__(/*! ./double_space */ "./node_modules/@abaplint/core/build/src/rules/double_space.js"), exports);
__exportStar(__webpack_require__(/*! ./downport */ "./node_modules/@abaplint/core/build/src/rules/downport.js"), exports);
__exportStar(__webpack_require__(/*! ./dynpro_checks */ "./node_modules/@abaplint/core/build/src/rules/dynpro_checks.js"), exports);
__exportStar(__webpack_require__(/*! ./easy_to_find_messages */ "./node_modules/@abaplint/core/build/src/rules/easy_to_find_messages.js"), exports);
__exportStar(__webpack_require__(/*! ./empty_event */ "./node_modules/@abaplint/core/build/src/rules/empty_event.js"), exports);
__exportStar(__webpack_require__(/*! ./empty_line_in_statement */ "./node_modules/@abaplint/core/build/src/rules/empty_line_in_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./empty_statement */ "./node_modules/@abaplint/core/build/src/rules/empty_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./empty_structure */ "./node_modules/@abaplint/core/build/src/rules/empty_structure.js"), exports);
__exportStar(__webpack_require__(/*! ./exit_or_check */ "./node_modules/@abaplint/core/build/src/rules/exit_or_check.js"), exports);
__exportStar(__webpack_require__(/*! ./expand_macros */ "./node_modules/@abaplint/core/build/src/rules/expand_macros.js"), exports);
__exportStar(__webpack_require__(/*! ./exporting */ "./node_modules/@abaplint/core/build/src/rules/exporting.js"), exports);
__exportStar(__webpack_require__(/*! ./forbidden_identifier */ "./node_modules/@abaplint/core/build/src/rules/forbidden_identifier.js"), exports);
__exportStar(__webpack_require__(/*! ./forbidden_pseudo_and_pragma */ "./node_modules/@abaplint/core/build/src/rules/forbidden_pseudo_and_pragma.js"), exports);
__exportStar(__webpack_require__(/*! ./forbidden_void_type */ "./node_modules/@abaplint/core/build/src/rules/forbidden_void_type.js"), exports);
__exportStar(__webpack_require__(/*! ./form_tables_obsolete */ "./node_modules/@abaplint/core/build/src/rules/form_tables_obsolete.js"), exports);
__exportStar(__webpack_require__(/*! ./fully_type_constants */ "./node_modules/@abaplint/core/build/src/rules/fully_type_constants.js"), exports);
__exportStar(__webpack_require__(/*! ./fully_type_itabs */ "./node_modules/@abaplint/core/build/src/rules/fully_type_itabs.js"), exports);
__exportStar(__webpack_require__(/*! ./function_module_recommendations */ "./node_modules/@abaplint/core/build/src/rules/function_module_recommendations.js"), exports);
__exportStar(__webpack_require__(/*! ./functional_writing */ "./node_modules/@abaplint/core/build/src/rules/functional_writing.js"), exports);
__exportStar(__webpack_require__(/*! ./global_class */ "./node_modules/@abaplint/core/build/src/rules/global_class.js"), exports);
__exportStar(__webpack_require__(/*! ./identical_conditions */ "./node_modules/@abaplint/core/build/src/rules/identical_conditions.js"), exports);
__exportStar(__webpack_require__(/*! ./identical_contents */ "./node_modules/@abaplint/core/build/src/rules/identical_contents.js"), exports);
__exportStar(__webpack_require__(/*! ./identical_descriptions */ "./node_modules/@abaplint/core/build/src/rules/identical_descriptions.js"), exports);
__exportStar(__webpack_require__(/*! ./identical_form_names */ "./node_modules/@abaplint/core/build/src/rules/identical_form_names.js"), exports);
__exportStar(__webpack_require__(/*! ./if_in_if */ "./node_modules/@abaplint/core/build/src/rules/if_in_if.js"), exports);
__exportStar(__webpack_require__(/*! ./implement_methods */ "./node_modules/@abaplint/core/build/src/rules/implement_methods.js"), exports);
__exportStar(__webpack_require__(/*! ./implicit_start_of_selection */ "./node_modules/@abaplint/core/build/src/rules/implicit_start_of_selection.js"), exports);
__exportStar(__webpack_require__(/*! ./in_statement_indentation */ "./node_modules/@abaplint/core/build/src/rules/in_statement_indentation.js"), exports);
__exportStar(__webpack_require__(/*! ./indentation */ "./node_modules/@abaplint/core/build/src/rules/indentation.js"), exports);
__exportStar(__webpack_require__(/*! ./inline_data_old_versions */ "./node_modules/@abaplint/core/build/src/rules/inline_data_old_versions.js"), exports);
__exportStar(__webpack_require__(/*! ./intf_referencing_clas */ "./node_modules/@abaplint/core/build/src/rules/intf_referencing_clas.js"), exports);
__exportStar(__webpack_require__(/*! ./invalid_table_index */ "./node_modules/@abaplint/core/build/src/rules/invalid_table_index.js"), exports);
__exportStar(__webpack_require__(/*! ./keep_single_parameter_on_one_line */ "./node_modules/@abaplint/core/build/src/rules/keep_single_parameter_on_one_line.js"), exports);
__exportStar(__webpack_require__(/*! ./keyword_case */ "./node_modules/@abaplint/core/build/src/rules/keyword_case.js"), exports);
__exportStar(__webpack_require__(/*! ./line_break_multiple_parameters */ "./node_modules/@abaplint/core/build/src/rules/line_break_multiple_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./line_break_style */ "./node_modules/@abaplint/core/build/src/rules/line_break_style.js"), exports);
__exportStar(__webpack_require__(/*! ./line_length */ "./node_modules/@abaplint/core/build/src/rules/line_length.js"), exports);
__exportStar(__webpack_require__(/*! ./line_only_punc */ "./node_modules/@abaplint/core/build/src/rules/line_only_punc.js"), exports);
__exportStar(__webpack_require__(/*! ./local_class_naming */ "./node_modules/@abaplint/core/build/src/rules/local_class_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./local_testclass_consistency */ "./node_modules/@abaplint/core/build/src/rules/local_testclass_consistency.js"), exports);
__exportStar(__webpack_require__(/*! ./local_variable_names */ "./node_modules/@abaplint/core/build/src/rules/local_variable_names.js"), exports);
__exportStar(__webpack_require__(/*! ./macro_naming */ "./node_modules/@abaplint/core/build/src/rules/macro_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./main_file_contents */ "./node_modules/@abaplint/core/build/src/rules/main_file_contents.js"), exports);
__exportStar(__webpack_require__(/*! ./many_parentheses */ "./node_modules/@abaplint/core/build/src/rules/many_parentheses.js"), exports);
__exportStar(__webpack_require__(/*! ./max_one_method_parameter_per_line */ "./node_modules/@abaplint/core/build/src/rules/max_one_method_parameter_per_line.js"), exports);
__exportStar(__webpack_require__(/*! ./max_one_statement */ "./node_modules/@abaplint/core/build/src/rules/max_one_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./message_exists */ "./node_modules/@abaplint/core/build/src/rules/message_exists.js"), exports);
__exportStar(__webpack_require__(/*! ./method_implemented_twice */ "./node_modules/@abaplint/core/build/src/rules/method_implemented_twice.js"), exports);
__exportStar(__webpack_require__(/*! ./method_length */ "./node_modules/@abaplint/core/build/src/rules/method_length.js"), exports);
__exportStar(__webpack_require__(/*! ./method_overwrites_builtin */ "./node_modules/@abaplint/core/build/src/rules/method_overwrites_builtin.js"), exports);
__exportStar(__webpack_require__(/*! ./method_parameter_names */ "./node_modules/@abaplint/core/build/src/rules/method_parameter_names.js"), exports);
__exportStar(__webpack_require__(/*! ./mix_returning */ "./node_modules/@abaplint/core/build/src/rules/mix_returning.js"), exports);
__exportStar(__webpack_require__(/*! ./modify_only_own_db_tables */ "./node_modules/@abaplint/core/build/src/rules/modify_only_own_db_tables.js"), exports);
__exportStar(__webpack_require__(/*! ./msag_consistency */ "./node_modules/@abaplint/core/build/src/rules/msag_consistency.js"), exports);
__exportStar(__webpack_require__(/*! ./names_no_dash */ "./node_modules/@abaplint/core/build/src/rules/names_no_dash.js"), exports);
__exportStar(__webpack_require__(/*! ./nesting */ "./node_modules/@abaplint/core/build/src/rules/nesting.js"), exports);
__exportStar(__webpack_require__(/*! ./newline_between_methods */ "./node_modules/@abaplint/core/build/src/rules/newline_between_methods.js"), exports);
__exportStar(__webpack_require__(/*! ./no_aliases */ "./node_modules/@abaplint/core/build/src/rules/no_aliases.js"), exports);
__exportStar(__webpack_require__(/*! ./no_chained_assignment */ "./node_modules/@abaplint/core/build/src/rules/no_chained_assignment.js"), exports);
__exportStar(__webpack_require__(/*! ./no_external_form_calls */ "./node_modules/@abaplint/core/build/src/rules/no_external_form_calls.js"), exports);
__exportStar(__webpack_require__(/*! ./no_inline_in_optional_branches */ "./node_modules/@abaplint/core/build/src/rules/no_inline_in_optional_branches.js"), exports);
__exportStar(__webpack_require__(/*! ./no_prefixes */ "./node_modules/@abaplint/core/build/src/rules/no_prefixes.js"), exports);
__exportStar(__webpack_require__(/*! ./no_public_attributes */ "./node_modules/@abaplint/core/build/src/rules/no_public_attributes.js"), exports);
__exportStar(__webpack_require__(/*! ./no_yoda_conditions */ "./node_modules/@abaplint/core/build/src/rules/no_yoda_conditions.js"), exports);
__exportStar(__webpack_require__(/*! ./nrob_consistency */ "./node_modules/@abaplint/core/build/src/rules/nrob_consistency.js"), exports);
__exportStar(__webpack_require__(/*! ./object_naming */ "./node_modules/@abaplint/core/build/src/rules/object_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./obsolete_statement */ "./node_modules/@abaplint/core/build/src/rules/obsolete_statement.js"), exports);
__exportStar(__webpack_require__(/*! ./omit_parameter_name */ "./node_modules/@abaplint/core/build/src/rules/omit_parameter_name.js"), exports);
__exportStar(__webpack_require__(/*! ./omit_preceding_zeros */ "./node_modules/@abaplint/core/build/src/rules/omit_preceding_zeros.js"), exports);
__exportStar(__webpack_require__(/*! ./omit_receiving */ "./node_modules/@abaplint/core/build/src/rules/omit_receiving.js"), exports);
__exportStar(__webpack_require__(/*! ./parser_702_chaining */ "./node_modules/@abaplint/core/build/src/rules/parser_702_chaining.js"), exports);
__exportStar(__webpack_require__(/*! ./parser_error */ "./node_modules/@abaplint/core/build/src/rules/parser_error.js"), exports);
__exportStar(__webpack_require__(/*! ./parser_missing_space */ "./node_modules/@abaplint/core/build/src/rules/parser_missing_space.js"), exports);
__exportStar(__webpack_require__(/*! ./pragma_style */ "./node_modules/@abaplint/core/build/src/rules/pragma_style.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_corresponding */ "./node_modules/@abaplint/core/build/src/rules/prefer_corresponding.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_inline */ "./node_modules/@abaplint/core/build/src/rules/prefer_inline.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_is_not */ "./node_modules/@abaplint/core/build/src/rules/prefer_is_not.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_pragmas */ "./node_modules/@abaplint/core/build/src/rules/prefer_pragmas.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_raise_exception_new */ "./node_modules/@abaplint/core/build/src/rules/prefer_raise_exception_new.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_returning_to_exporting */ "./node_modules/@abaplint/core/build/src/rules/prefer_returning_to_exporting.js"), exports);
__exportStar(__webpack_require__(/*! ./prefer_xsdbool */ "./node_modules/@abaplint/core/build/src/rules/prefer_xsdbool.js"), exports);
__exportStar(__webpack_require__(/*! ./preferred_compare_operator */ "./node_modules/@abaplint/core/build/src/rules/preferred_compare_operator.js"), exports);
__exportStar(__webpack_require__(/*! ./prefix_is_current_class */ "./node_modules/@abaplint/core/build/src/rules/prefix_is_current_class.js"), exports);
__exportStar(__webpack_require__(/*! ./reduce_procedural_code */ "./node_modules/@abaplint/core/build/src/rules/reduce_procedural_code.js"), exports);
__exportStar(__webpack_require__(/*! ./reduce_string_templates */ "./node_modules/@abaplint/core/build/src/rules/reduce_string_templates.js"), exports);
__exportStar(__webpack_require__(/*! ./release_idoc */ "./node_modules/@abaplint/core/build/src/rules/release_idoc.js"), exports);
__exportStar(__webpack_require__(/*! ./remove_descriptions */ "./node_modules/@abaplint/core/build/src/rules/remove_descriptions.js"), exports);
__exportStar(__webpack_require__(/*! ./rfc_error_handling */ "./node_modules/@abaplint/core/build/src/rules/rfc_error_handling.js"), exports);
__exportStar(__webpack_require__(/*! ./select_add_order_by */ "./node_modules/@abaplint/core/build/src/rules/select_add_order_by.js"), exports);
__exportStar(__webpack_require__(/*! ./select_performance */ "./node_modules/@abaplint/core/build/src/rules/select_performance.js"), exports);
__exportStar(__webpack_require__(/*! ./select_single_full_key */ "./node_modules/@abaplint/core/build/src/rules/select_single_full_key.js"), exports);
__exportStar(__webpack_require__(/*! ./selection_screen_naming */ "./node_modules/@abaplint/core/build/src/rules/selection_screen_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./sequential_blank */ "./node_modules/@abaplint/core/build/src/rules/sequential_blank.js"), exports);
__exportStar(__webpack_require__(/*! ./short_case */ "./node_modules/@abaplint/core/build/src/rules/short_case.js"), exports);
__exportStar(__webpack_require__(/*! ./sicf_consistency */ "./node_modules/@abaplint/core/build/src/rules/sicf_consistency.js"), exports);
__exportStar(__webpack_require__(/*! ./slow_parameter_passing */ "./node_modules/@abaplint/core/build/src/rules/slow_parameter_passing.js"), exports);
__exportStar(__webpack_require__(/*! ./smim_consistency */ "./node_modules/@abaplint/core/build/src/rules/smim_consistency.js"), exports);
__exportStar(__webpack_require__(/*! ./space_before_colon */ "./node_modules/@abaplint/core/build/src/rules/space_before_colon.js"), exports);
__exportStar(__webpack_require__(/*! ./space_before_dot */ "./node_modules/@abaplint/core/build/src/rules/space_before_dot.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_escape_host_variables */ "./node_modules/@abaplint/core/build/src/rules/sql_escape_host_variables.js"), exports);
__exportStar(__webpack_require__(/*! ./sql_value_conversion */ "./node_modules/@abaplint/core/build/src/rules/sql_value_conversion.js"), exports);
__exportStar(__webpack_require__(/*! ./start_at_tab */ "./node_modules/@abaplint/core/build/src/rules/start_at_tab.js"), exports);
__exportStar(__webpack_require__(/*! ./static_call_via_instance */ "./node_modules/@abaplint/core/build/src/rules/static_call_via_instance.js"), exports);
__exportStar(__webpack_require__(/*! ./strict_sql */ "./node_modules/@abaplint/core/build/src/rules/strict_sql.js"), exports);
__exportStar(__webpack_require__(/*! ./superclass_final */ "./node_modules/@abaplint/core/build/src/rules/superclass_final.js"), exports);
__exportStar(__webpack_require__(/*! ./superfluous_value */ "./node_modules/@abaplint/core/build/src/rules/superfluous_value.js"), exports);
__exportStar(__webpack_require__(/*! ./sy_modification */ "./node_modules/@abaplint/core/build/src/rules/sy_modification.js"), exports);
__exportStar(__webpack_require__(/*! ./tabl_enhancement_category */ "./node_modules/@abaplint/core/build/src/rules/tabl_enhancement_category.js"), exports);
__exportStar(__webpack_require__(/*! ./tables_declared_locally */ "./node_modules/@abaplint/core/build/src/rules/tables_declared_locally.js"), exports);
__exportStar(__webpack_require__(/*! ./try_without_catch */ "./node_modules/@abaplint/core/build/src/rules/try_without_catch.js"), exports);
__exportStar(__webpack_require__(/*! ./type_form_parameters */ "./node_modules/@abaplint/core/build/src/rules/type_form_parameters.js"), exports);
__exportStar(__webpack_require__(/*! ./types_naming */ "./node_modules/@abaplint/core/build/src/rules/types_naming.js"), exports);
__exportStar(__webpack_require__(/*! ./uncaught_exception */ "./node_modules/@abaplint/core/build/src/rules/uncaught_exception.js"), exports);
__exportStar(__webpack_require__(/*! ./unknown_types */ "./node_modules/@abaplint/core/build/src/rules/unknown_types.js"), exports);
__exportStar(__webpack_require__(/*! ./unnecessary_chaining */ "./node_modules/@abaplint/core/build/src/rules/unnecessary_chaining.js"), exports);
__exportStar(__webpack_require__(/*! ./unnecessary_pragma */ "./node_modules/@abaplint/core/build/src/rules/unnecessary_pragma.js"), exports);
__exportStar(__webpack_require__(/*! ./unnecessary_return */ "./node_modules/@abaplint/core/build/src/rules/unnecessary_return.js"), exports);
__exportStar(__webpack_require__(/*! ./unreachable_code */ "./node_modules/@abaplint/core/build/src/rules/unreachable_code.js"), exports);
__exportStar(__webpack_require__(/*! ./unsecure_fae */ "./node_modules/@abaplint/core/build/src/rules/unsecure_fae.js"), exports);
__exportStar(__webpack_require__(/*! ./unused_ddic */ "./node_modules/@abaplint/core/build/src/rules/unused_ddic.js"), exports);
__exportStar(__webpack_require__(/*! ./unused_macros */ "./node_modules/@abaplint/core/build/src/rules/unused_macros.js"), exports);
__exportStar(__webpack_require__(/*! ./unused_methods */ "./node_modules/@abaplint/core/build/src/rules/unused_methods.js"), exports);
__exportStar(__webpack_require__(/*! ./unused_types */ "./node_modules/@abaplint/core/build/src/rules/unused_types.js"), exports);
__exportStar(__webpack_require__(/*! ./unused_variables */ "./node_modules/@abaplint/core/build/src/rules/unused_variables.js"), exports);
__exportStar(__webpack_require__(/*! ./use_bool_expression */ "./node_modules/@abaplint/core/build/src/rules/use_bool_expression.js"), exports);
__exportStar(__webpack_require__(/*! ./use_class_based_exceptions */ "./node_modules/@abaplint/core/build/src/rules/use_class_based_exceptions.js"), exports);
__exportStar(__webpack_require__(/*! ./use_line_exists */ "./node_modules/@abaplint/core/build/src/rules/use_line_exists.js"), exports);
__exportStar(__webpack_require__(/*! ./use_new */ "./node_modules/@abaplint/core/build/src/rules/use_new.js"), exports);
__exportStar(__webpack_require__(/*! ./when_others_last */ "./node_modules/@abaplint/core/build/src/rules/when_others_last.js"), exports);
__exportStar(__webpack_require__(/*! ./whitespace_end */ "./node_modules/@abaplint/core/build/src/rules/whitespace_end.js"), exports);
__exportStar(__webpack_require__(/*! ./xml_consistency */ "./node_modules/@abaplint/core/build/src/rules/xml_consistency.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/inline_data_old_versions.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/inline_data_old_versions.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InlineDataOldVersions = exports.InlineDataOldVersionsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class InlineDataOldVersionsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.InlineDataOldVersionsConf = InlineDataOldVersionsConf;
class InlineDataOldVersions extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new InlineDataOldVersionsConf();
    }
    getMetadata() {
        return {
            key: "inline_data_old_versions",
            title: "Inline data, old versions",
            shortDescription: `Checks for inline data declarations in older releases. Only active for versions less than v740sp02`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (this.reg.getConfig().getVersion() >= version_1.Version.v740sp02
            || this.reg.getConfig().getVersion() === version_1.Version.Cloud) {
            return [];
        }
        for (const statement of file.getStatements()) {
            // when parsed in old versions these expressions are NOT InlineData
            for (const target of statement.findAllExpressions(expressions_1.Target)) {
                const tokens = target.getAllTokens();
                if (tokens.length !== 4) {
                    continue;
                }
                if (!tokens[0].getStr().match(/DATA/i)) {
                    continue;
                }
                if (tokens[1].getStr() !== "(") {
                    continue;
                }
                if (tokens[3].getStr() !== ")") {
                    continue;
                }
                const message = "Inline DATA not possible in " + this.reg.getConfig().getVersion();
                const issue = issue_1.Issue.atToken(file, tokens[0], message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.InlineDataOldVersions = InlineDataOldVersions;
//# sourceMappingURL=inline_data_old_versions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/intf_referencing_clas.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/intf_referencing_clas.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IntfReferencingClas = exports.IntfReferencingClasConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class IntfReferencingClasConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** List of classes allowed to be referenced, regex, case insensitive
         * @uniqueItems true
        */
        this.allow = [];
    }
}
exports.IntfReferencingClasConf = IntfReferencingClasConf;
class IntfReferencingClas {
    constructor() {
        this.conf = new IntfReferencingClasConf();
    }
    getMetadata() {
        return {
            key: "intf_referencing_clas",
            title: "INTF referencing CLAS",
            shortDescription: `Interface contains references to class`,
            extendedInformation: `Only global interfaces are checked.
      Only first level references are checked.
      Exception class references are ignored.
      Void references are ignored.`,
        };
    }
    getConfig() {
        if (this.conf.allow === undefined) {
            this.conf.allow = [];
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof objects_1.Interface)) {
            return [];
        }
        return this.traverse(new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop());
    }
    ////////////////
    traverse(node) {
        var _a, _b;
        let ret = [];
        const message = "Referencing CLAS: ";
        const ddic = new ddic_1.DDIC(this.reg);
        for (const r of node.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.ObjectOrientedReference
                && ((_a = r.extra) === null || _a === void 0 ? void 0 : _a.ooType) === "CLAS"
                && ((_b = r.extra) === null || _b === void 0 ? void 0 : _b.ooName) !== undefined) {
                const found = this.reg.getObject("CLAS", r.extra.ooName) || undefined;
                if (found && ddic.isException(found.getClassDefinition(), found)) {
                    continue;
                }
                else if (this.getConfig().allow.some(reg => new RegExp(reg, "i").test(r.extra.ooName))) {
                    continue;
                }
                ret.push(issue_1.Issue.atIdentifier(r.position, message + r.extra.ooName, this.getMetadata().key, this.conf.severity));
            }
        }
        for (const c of node.getChildren()) {
            ret = ret.concat(this.traverse(c));
        }
        return ret;
    }
}
exports.IntfReferencingClas = IntfReferencingClas;
//# sourceMappingURL=intf_referencing_clas.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/invalid_table_index.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/invalid_table_index.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.InvalidTableIndex = exports.InvalidTableIndexConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
class InvalidTableIndexConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.InvalidTableIndexConf = InvalidTableIndexConf;
class InvalidTableIndex extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new InvalidTableIndexConf();
    }
    getMetadata() {
        return {
            key: "invalid_table_index",
            title: "Invalid Table Index",
            shortDescription: `Issues error for constant table index zero, as ABAP starts from 1`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `DATA(first) = table[ 0 ].
READ TABLE gt_stack ASSIGNING <ls_stack> INDEX 0.`,
            goodExample: `DATA(first) = table[ 1 ].
READ TABLE gt_stack ASSIGNING <ls_stack> INDEX 1.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b, _c, _d, _e, _f;
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues; // parser error
        }
        const expr = stru.findAllExpressionsRecursive(Expressions.TableExpression);
        for (const e of expr) {
            const token = (_c = (_b = (_a = e.findDirectExpression(Expressions.Source)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.Constant)) === null || _b === void 0 ? void 0 : _b.findFirstExpression(Expressions.Integer)) === null || _c === void 0 ? void 0 : _c.getFirstToken();
            if (token === undefined) {
                continue;
            }
            if (token.getStr() === "0") {
                const message = "Table index starts from 1";
                const fix = edit_helper_1.EditHelper.replaceToken(file, token, "1");
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        for (const rt of stru.findAllStatements(statements_1.ReadTable)) {
            const token = (_f = (_e = (_d = rt.findExpressionAfterToken("INDEX")) === null || _d === void 0 ? void 0 : _d.findDirectExpression(Expressions.Constant)) === null || _e === void 0 ? void 0 : _e.findFirstExpression(Expressions.Integer)) === null || _f === void 0 ? void 0 : _f.getFirstToken();
            if (token === undefined) {
                continue;
            }
            if (token.getStr() === "0") {
                const message = "Table index starts from 1";
                const fix = edit_helper_1.EditHelper.replaceToken(file, token, "1");
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.InvalidTableIndex = InvalidTableIndex;
//# sourceMappingURL=invalid_table_index.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/keep_single_parameter_on_one_line.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/keep_single_parameter_on_one_line.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeepSingleParameterCallsOnOneLine = exports.KeepSingleParameterCallsOnOneLineConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class KeepSingleParameterCallsOnOneLineConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Max line length, in characters */
        this.length = 120;
    }
}
exports.KeepSingleParameterCallsOnOneLineConf = KeepSingleParameterCallsOnOneLineConf;
class KeepSingleParameterCallsOnOneLine extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new KeepSingleParameterCallsOnOneLineConf();
    }
    getMetadata() {
        return {
            key: "keep_single_parameter_on_one_line",
            title: "Keep single parameters on one line",
            shortDescription: `Keep single parameter calls on one line`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#keep-single-parameter-calls-on-one-line`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `call_method(\n  2 ).`,
            goodExample: `call_method( 2 ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        let issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const s of file.getStatements()) {
            if (this.isMultiLine(s) === false
                || this.calcStatementLength(s) > this.getConfig().length
                || this.containsNewLineValue(s)
                || this.containsNewLineTableExpression(s)
                || this.containsFieldAssigments(s)
                || this.containsNewLineTemplate(s)) {
                continue;
            }
            for (const c of s.findAllExpressions(Expressions.MethodCallParam)) {
                issues = issues.concat(this.check(c, file));
            }
        }
        return issues;
    }
    ///////////////////////////////////////
    containsFieldAssigments(s) {
        const fs = s.findAllExpressions(Expressions.FieldAssignment);
        return fs.length > 1;
    }
    containsNewLineTableExpression(s) {
        for (const st of s.findAllExpressions(Expressions.TableExpression)) {
            if (st.getFirstToken().getRow() !== st.getLastToken().getRow()) {
                return true;
            }
        }
        return false;
    }
    containsNewLineValue(s) {
        for (const st of s.findAllExpressions(Expressions.Source)) {
            const first = st.getFirstToken().getStr().toUpperCase();
            if (first === "VALUE" && st.getFirstToken().getRow() !== st.getLastToken().getRow()) {
                return true;
            }
        }
        return false;
    }
    containsNewLineTemplate(s) {
        for (const st of s.findAllExpressions(Expressions.StringTemplate)) {
            for (const t of st.getAllTokens()) {
                if (t.getStr().includes("\\n")) {
                    return true;
                }
            }
        }
        return false;
    }
    check(c, file) {
        if (this.isSingleParameter(c) === true && this.isMultiLine(c) === true) {
            for (const sub of c.findAllExpressions(Expressions.MethodCallParam)) {
                if (this.isSingleParameter(sub) === false
                    && this.isWithoutParameters(sub) === false) {
                    return [];
                }
            }
            const message = "Keep single parameter on one line";
            return [issue_1.Issue.atToken(file, c.getFirstToken(), message, this.getMetadata().key, this.conf.severity)];
        }
        return [];
    }
    // including first indentation, worst case calculation add space after each token
    calcStatementLength(c) {
        let length = 0;
        for (const t of c.getTokens()) {
            if (length === 0) {
                length = length + t.getStart().getCol();
            }
            length = length + t.getStr().length + 1;
        }
        return length;
    }
    isMultiLine(c) {
        const first = c.getFirstToken();
        const last = c.getLastToken();
        return first.getStart().getRow() < last.getStart().getRow();
    }
    isWithoutParameters(c) {
        return c.getChildren().length === 2;
    }
    isSingleParameter(c) {
        if (c.findDirectExpression(Expressions.Source)) {
            for (const params of c.findAllExpressions(Expressions.ParameterListS)) {
                if (params.getChildren().length > 1) {
                    return false;
                }
            }
            return true;
        }
        const list = c.findDirectExpression(Expressions.ParameterListS);
        if (list) {
            return list.getChildren().length === 1;
        }
        const param = c.findDirectExpression(Expressions.MethodParameters);
        if (param) {
            if (param.getChildren().length > 2) {
                return false;
            }
            const paramsource = param.findDirectExpression(Expressions.ParameterListS);
            if (paramsource && paramsource.getChildren().length === 1) {
                return true;
            }
            const paramtarget = param.findDirectExpression(Expressions.ParameterListT);
            if (paramtarget && paramtarget.getChildren().length === 1) {
                return true;
            }
        }
        return false;
    }
}
exports.KeepSingleParameterCallsOnOneLine = KeepSingleParameterCallsOnOneLine;
//# sourceMappingURL=keep_single_parameter_on_one_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/keyword_case.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/keyword_case.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.KeywordCase = exports.KeywordCaseConf = exports.KeywordCaseStyle = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
var KeywordCaseStyle;
(function (KeywordCaseStyle) {
    KeywordCaseStyle["Upper"] = "upper";
    KeywordCaseStyle["Lower"] = "lower";
})(KeywordCaseStyle || (exports.KeywordCaseStyle = KeywordCaseStyle = {}));
class KeywordCaseConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.style = KeywordCaseStyle.Upper;
        /** Ignore global exception classes */
        this.ignoreExceptions = true;
        this.ignoreLowerClassImplmentationStatement = true;
        this.ignoreGlobalClassDefinition = false;
        this.ignoreGlobalInterface = false;
        this.ignoreFunctionModuleName = false;
        // this ignores keywords in CLASS/ENDCLASS statements of a global class (and only in them, the rest is checked)
        this.ignoreGlobalClassBoundaries = false;
        /** A list of keywords to be ignored */
        this.ignoreKeywords = [];
    }
}
exports.KeywordCaseConf = KeywordCaseConf;
class Skip {
    constructor(conf) {
        this.skip = false;
        this.isGlobalClass = false;
        this.isGlobalIf = false;
        this.conf = conf;
    }
    skipStatement(statement) {
        const get = statement.get();
        if (get instanceof _statement_1.Unknown
            || get instanceof _statement_1.MacroContent
            || get instanceof _statement_1.MacroCall
            || statement.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition
            || get instanceof _statement_1.Comment) {
            return true;
        }
        if (this.conf.ignoreGlobalClassBoundaries) {
            const node = get;
            if (node instanceof Statements.Interface && statement.findFirstExpression(Expressions.ClassGlobal)) {
                this.isGlobalIf = true;
                return true;
            }
            else if (this.isGlobalIf === true && node instanceof Statements.EndInterface) {
                return true;
            }
            if (node instanceof Statements.ClassDefinition && statement.findFirstExpression(Expressions.ClassGlobal)) {
                this.isGlobalClass = true;
                return true;
            }
            else if (this.isGlobalClass === true
                && (node instanceof Statements.EndClass || node instanceof Statements.ClassImplementation)) {
                return true;
            }
        }
        if (this.conf.ignoreGlobalClassDefinition) {
            if (get instanceof Statements.ClassDefinition
                && statement.findFirstExpression(Expressions.ClassGlobal)) {
                this.skip = true;
                return true;
            }
            else if (this.skip === true && get instanceof Statements.EndClass) {
                this.skip = false;
                return true;
            }
            else if (this.skip === true) {
                return true;
            }
        }
        if (this.conf.ignoreGlobalInterface) {
            if (get instanceof Statements.Interface
                && statement.findFirstExpression(Expressions.ClassGlobal)) {
                this.skip = true;
                return true;
            }
            else if (this.skip === true && get instanceof Statements.EndInterface) {
                this.skip = false;
                return true;
            }
            else if (this.skip === true) {
                return true;
            }
        }
        return false;
    }
}
class KeywordCase extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new KeywordCaseConf();
    }
    getMetadata() {
        return {
            key: "keyword_case",
            title: "Keyword case",
            shortDescription: `Checks that keywords have the same case. Non-keywords must be lower case.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-your-pretty-printer-team-settings`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `write 'hello world'.`,
            goodExample: `WRITE 'hello world'.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf === undefined) {
            this.conf = new KeywordCaseConf();
        }
        if (this.conf.style === undefined) {
            this.conf = new KeywordCaseConf();
        }
        if (this.conf.ignoreExceptions === undefined) {
            this.conf.ignoreExceptions = new KeywordCaseConf().ignoreExceptions;
        }
    }
    runParsed(file, obj) {
        const issues = [];
        const ddic = new ddic_1.DDIC(this.reg);
        const MAX_ISSUES = 100;
        if (this.conf.ignoreExceptions && obj instanceof objects_1.Class) {
            const definition = obj.getClassDefinition();
            if (definition === undefined || ddic.isException(definition, obj)) {
                return [];
            }
        }
        const skip = new Skip(this.getConfig());
        let prev = undefined;
        for (const statement of file.getStatements()) {
            if (skip.skipStatement(statement) === true) {
                continue;
            }
            let result = this.traverse(statement, statement.get());
            if (result.length > 0) {
                if (prev && result[0].token.getStart().equals(prev.getStart())) {
                    continue;
                }
                if (statement.getColon() !== undefined) {
                    // if its a chained statement, go token by token
                    result = [result[0]];
                }
                const issue = this.build(result, file);
                issues.push(issue);
                if (issues.length > MAX_ISSUES) {
                    break;
                }
                prev = result[0].token;
            }
        }
        return issues;
    }
    //////////////////
    build(tokens, file) {
        const first = tokens[0];
        const firstToken = tokens[0].token;
        const lastToken = tokens[tokens.length - 1].token;
        const firstTokenValue = firstToken.getStr();
        let description = "";
        if (first.keyword === true) {
            description = `Keyword should be ${this.conf.style} case: "${firstTokenValue}"`;
        }
        else {
            description = `Identifiers should be lower case: "${firstTokenValue}"`;
        }
        const draft = new edit_helper_1.EditDraft(file);
        for (const token of tokens) {
            const str = token.token.getStr();
            const pos = token.token.getStart();
            if (token.keyword === true) {
                if (this.conf.style === KeywordCaseStyle.Lower) {
                    draft.replace(pos, str.toLowerCase());
                }
                else {
                    draft.replace(pos, str.toUpperCase());
                }
            }
            else {
                draft.replace(pos, str.toLowerCase());
            }
        }
        const fix = draft.toEdit();
        return issue_1.Issue.atRange(file, firstToken.getStart(), lastToken.getEnd(), description, this.getMetadata().key, this.conf.severity, fix);
    }
    /** returns a list of tokens which violates the keyword_case rule */
    traverse(s, parent) {
        let ret = [];
        const children = s.getChildren();
        for (let i = 0; i < children.length; i++) {
            const child = children[i];
            if (child instanceof nodes_1.TokenNodeRegex) {
                const next = children[i + 1];
                if (this.conf.ignoreLowerClassImplmentationStatement
                    && parent instanceof Statements.ClassImplementation) {
                    continue;
                }
                const str = child.get().getStr();
                const upper = str.toUpperCase();
                // todo, this is a hack, the parser should recongize OTHERS/TEXT as a keyword
                if (upper === "OTHERS" || (upper === "TEXT" && (next === null || next === void 0 ? void 0 : next.concatTokens()) === "-")) {
                    continue;
                }
                if (this.conf.ignoreFunctionModuleName === true
                    && parent instanceof Statements.FunctionModule && upper !== "FUNCTION") {
                    continue;
                }
                // todo, this is a hack, the parser should recigize SCREEN as a keyword
                if (upper === "SCREEN"
                    && (parent instanceof Statements.ModifyDatabase
                        || parent instanceof Statements.ModifyInternal
                        || parent instanceof Statements.Loop)) {
                    continue;
                }
                if (str !== str.toLowerCase() && child.get() instanceof tokens_1.Identifier) {
                    ret.push({ token: child.get(), keyword: false });
                }
            }
            else if (child instanceof nodes_1.TokenNode) {
                const str = child.get().getStr();
                if (this.violatesRule(str) && child.get() instanceof tokens_1.Identifier) {
                    ret.push({ token: child.get(), keyword: true });
                }
            }
            else if (child instanceof nodes_1.ExpressionNode) {
                ret = ret.concat(this.traverse(child, parent));
            }
            else {
                throw new Error("keyword_case, traverseStatement, unexpected node type");
            }
        }
        return ret;
    }
    violatesRule(keyword) {
        if (this.conf.ignoreKeywords && this.conf.ignoreKeywords.map(k => { return k.toUpperCase(); }).includes(keyword.toUpperCase())) {
            return false;
        }
        if (this.conf.style === KeywordCaseStyle.Lower) {
            return keyword !== keyword.toLowerCase();
        }
        else if (this.conf.style === KeywordCaseStyle.Upper) {
            return keyword !== keyword.toUpperCase();
        }
        return false;
    }
}
exports.KeywordCase = KeywordCase;
//# sourceMappingURL=keyword_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/line_break_multiple_parameters.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/line_break_multiple_parameters.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineBreakMultipleParameters = exports.LineBreakMultipleParametersConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
class LineBreakMultipleParametersConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Amount of allowed parameters on one line */
        this.count = 1;
    }
}
exports.LineBreakMultipleParametersConf = LineBreakMultipleParametersConf;
class LineBreakMultipleParameters extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LineBreakMultipleParametersConf();
    }
    getMetadata() {
        return {
            key: "line_break_multiple_parameters",
            title: "Line break multiple parameters",
            shortDescription: `Line break multiple parameters`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#line-break-multiple-parameters`,
            badExample: `method( parameter1 = value parameter2 = value ).`,
            goodExample: `method( parameter1 = value\n        parameter2 = value ).`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        for (const s of file.getStatements()) {
            for (const e of s.findAllExpressions(Expressions.ParameterListS)) {
                if (s.getFirstToken().getStart() instanceof virtual_position_1.VirtualPosition) {
                    continue; // skip macro content
                }
                const parameters = e.findDirectExpressions(Expressions.ParameterS);
                if (parameters.length <= 1) {
                    continue;
                }
                let previous = parameters[0];
                for (let i = 1; i < parameters.length; i++) {
                    const current = parameters[i];
                    if (this.conf.count && i < this.conf.count) {
                        previous = current;
                        continue;
                    }
                    const first = current.getFirstToken();
                    if (previous.getFirstToken().getRow() === first.getRow()) {
                        const fix = edit_helper_1.EditHelper.insertAt(file, first.getStart(), "\n" + " ".repeat(parameters[0].getFirstToken().getStart().getCol() - 1));
                        issues.push(issue_1.Issue.atToken(file, current.getFirstToken(), this.getMetadata().title, this.getMetadata().key, this.conf.severity, fix));
                    }
                    previous = current;
                }
            }
        }
        return issues;
    }
}
exports.LineBreakMultipleParameters = LineBreakMultipleParameters;
//# sourceMappingURL=line_break_multiple_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/line_break_style.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/line_break_style.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineBreakStyle = exports.LineBreakStyleConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class LineBreakStyleConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.LineBreakStyleConf = LineBreakStyleConf;
class LineBreakStyle {
    constructor() {
        this.conf = new LineBreakStyleConf();
    }
    getMetadata() {
        return {
            key: "line_break_style",
            title: "Makes sure line breaks are consistent in the ABAP code",
            shortDescription: `Enforces LF as newlines in ABAP files

abapGit does not work with CRLF`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.SingleFile],
        };
    }
    initialize(_reg) {
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const output = [];
        for (const file of obj.getFiles()) {
            if (file.getFilename().endsWith(".abap")) {
                const rows = file.getRawRows();
                for (let i = 0; i < rows.length; i++) {
                    if (rows[i].endsWith("\r") === true) {
                        const message = "Line contains carriage return";
                        const issue = issue_1.Issue.atRow(file, i + 1, message, this.getMetadata().key, this.conf.severity);
                        output.push(issue);
                        break; // only one finding per file
                    }
                }
            }
        }
        return output;
    }
}
exports.LineBreakStyle = LineBreakStyle;
//# sourceMappingURL=line_break_style.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/line_length.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/line_length.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineLength = exports.LineLengthConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class LineLengthConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Maximum line length in characters, trailing whitespace ignored */
        this.length = 120;
    }
}
exports.LineLengthConf = LineLengthConf;
class LineLength extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LineLengthConf();
    }
    getMetadata() {
        return {
            key: "line_length",
            title: "Line length",
            shortDescription: `Detects lines exceeding the provided maximum length.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#stick-to-a-reasonable-line-length
https://docs.abapopenchecks.org/checks/04/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        // maximum line length in abap files
        const maxLineLength = 255;
        const array = file.getRawRows();
        for (let rowIndex = 0; rowIndex < array.length; rowIndex++) {
            const row = array[rowIndex].replace("\r", "");
            if (row.length > maxLineLength) {
                const message = `Maximum allowed line length of ${maxLineLength} exceeded, currently ${row.length}`;
                issues.push(issue_1.Issue.atRow(file, rowIndex + 1, message, this.getMetadata().key, this.conf.severity));
            }
            else if (row.length > this.conf.length) {
                const message = `Reduce line length to max ${this.conf.length}, currently ${row.length}`;
                issues.push(issue_1.Issue.atRow(file, rowIndex + 1, message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.LineLength = LineLength;
//# sourceMappingURL=line_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/line_only_punc.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/line_only_punc.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LineOnlyPunc = exports.LineOnlyPuncConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class LineOnlyPuncConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore lines with only puncutation in global exception classes */
        this.ignoreExceptions = true;
    }
}
exports.LineOnlyPuncConf = LineOnlyPuncConf;
class LineOnlyPunc extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LineOnlyPuncConf();
    }
    getMetadata() {
        return {
            key: "line_only_punc",
            title: "Line containing only punctuation",
            shortDescription: `Detects lines containing only punctuation.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#close-brackets-at-line-end
https://docs.abapopenchecks.org/checks/16/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: "zcl_class=>method(\n).",
            goodExample: "zcl_class=>method( ).",
        };
    }
    getMessage() {
        return "A line should not contain only \".\" or \").\"";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const ddic = new ddic_1.DDIC(this.reg);
        if (obj instanceof objects_1.Class) {
            const definition = obj.getClassDefinition();
            if (definition === undefined) {
                return [];
            }
            else if (this.conf.ignoreExceptions && ddic.isException(definition, obj)) {
                return [];
            }
        }
        const rows = file.getRawRows();
        const reg = new RegExp("^\\)?\\. *(\\\".*)?$");
        for (let i = 0; i < rows.length; i++) {
            if (reg.exec(rows[i].trim())) {
                const column = rows[i].indexOf(")") >= 0 ? rows[i].indexOf(")") + 1 : rows[i].indexOf(".") + 1;
                const position = new position_1.Position(i + 1, column);
                // merge punc into previous row
                let rowContent = rows[i].trim();
                // if reported row contains parentheses, prefix with space if needed
                if (rowContent.length > 1 && !rows[i - 1].endsWith(" ") && !rows[i - 1].endsWith(" \r")) {
                    rowContent = " " + rowContent;
                }
                let offset = 0;
                if (rows[i - 1].endsWith("\r")) {
                    offset = -1;
                }
                const startPos = new position_1.Position(i, rows[i - 1].length + 1 + offset);
                const endPos = new position_1.Position(i + 1, rows[i].length + 1);
                let fix = edit_helper_1.EditHelper.replaceRange(file, startPos, endPos, rowContent);
                if (rows[i - 1] === undefined || rows[i - 1].indexOf("*") === 0 || rows[i - 1].includes(`"`)) {
                    fix = undefined;
                }
                const issue = issue_1.Issue.atPosition(file, position, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.LineOnlyPunc = LineOnlyPunc;
//# sourceMappingURL=line_only_punc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/local_class_naming.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/local_class_naming.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalClassNaming = exports.LocalClassNamingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class LocalClassNamingConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** The pattern for local class names */
        this.local = "^LCL_.+$";
        /** The pattern for local exception names */
        this.exception = "^LCX_.+$";
        /** The pattern for local test class names */
        this.test = "^LTCL_.+$";
    }
}
exports.LocalClassNamingConf = LocalClassNamingConf;
class LocalClassNaming extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LocalClassNamingConf();
    }
    getMetadata() {
        return {
            key: "local_class_naming",
            title: "Local class naming conventions",
            shortDescription: `Allows you to enforce a pattern, such as a prefix, for local class names.`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(expected, actual) {
        return this.conf.patternKind === "required" ?
            "Local class name does not match pattern " + expected + ": " + actual :
            "Local class name must not match pattern " + expected + ": " + actual;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        const ddic = new ddic_1.DDIC(this.reg);
        for (const classDef of file.getInfo().listClassDefinitions()) {
            if (classDef.isGlobal) {
                continue;
            }
            const className = classDef.name;
            let expected = "";
            if (classDef.isForTesting) {
                expected = this.conf.test;
            }
            else if (ddic.isException(classDef, obj)) {
                expected = this.conf.exception;
            }
            else {
                expected = this.conf.local;
            }
            if (expected === undefined || expected.length === 0) {
                continue;
            }
            const regex = new RegExp(expected, "i");
            if (name_validator_1.NameValidator.violatesRule(className, regex, this.conf)) {
                issues.push(issue_1.Issue.atIdentifier(classDef.identifier, this.getDescription(expected, className), this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.LocalClassNaming = LocalClassNaming;
//# sourceMappingURL=local_class_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/local_testclass_consistency.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/local_testclass_consistency.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalTestclassConsistency = exports.LocalTestclassConsistencyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class LocalTestclassConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.LocalTestclassConsistencyConf = LocalTestclassConsistencyConf;
class LocalTestclassConsistency extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LocalTestclassConsistencyConf();
    }
    getMetadata() {
        return {
            key: "local_testclass_consistency",
            title: "Local testclass consistency",
            shortDescription: `Checks that local test classes are placed in the test include, and class unit test flag is set`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a;
        const issues = [];
        if (this.reg.getConfig().getVersion() === version_1.Version.v700) {
            // 700 does not have testclass includes
            return [];
        }
        if (!(obj instanceof objects_1.Class)) {
            return [];
        }
        for (const c of file.getInfo().listClassDefinitions()) {
            if (c.isLocal && c.isForTesting && !file.getFilename().includes(".testclasses.abap")) {
                const message = "Place local testclass \"" + c.name + "\" in the testclass include";
                const issue = issue_1.Issue.atIdentifier(c.identifier, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        if (file.getFilename().includes(".testclasses.") === true
            && obj.getTestclassFile() !== undefined
            && ((_a = obj.getXML()) === null || _a === void 0 ? void 0 : _a.includes("<WITH_UNIT_TESTS>X</WITH_UNIT_TESTS>")) === false) {
            const id = obj.getIdentifier();
            if (id) {
                const message = "Has testclass, but XML does not set <WITH_UNIT_TESTS>";
                const issue = issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.LocalTestclassConsistency = LocalTestclassConsistency;
//# sourceMappingURL=local_testclass_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/local_variable_names.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/local_variable_names.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.LocalVariableNames = exports.LocalVariableNamesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class LocalVariableNamesConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** The pattern for local variable names */
        this.expectedData = "^L._.+$";
        /** The pattern for local constant names */
        this.expectedConstant = "^LC_.+$";
        /** The pattern for field symbol names */
        this.expectedFS = "^<L._.+>$";
    }
}
exports.LocalVariableNamesConf = LocalVariableNamesConf;
class LocalVariableNames extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new LocalVariableNamesConf();
    }
    getMetadata() {
        return {
            key: "local_variable_names",
            title: "Local variable naming conventions",
            shortDescription: `
Allows you to enforce a pattern, such as a prefix, for local variables, constants and field symbols.
Regexes are case-insensitive.`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
            badExample: `FORM bar.
  DATA foo.
ENDFORM.`,
            goodExample: `FORM bar.
  DATA lv_foo.
ENDFORM.`,
        };
    }
    getDescription(expected, actual) {
        return this.conf.patternKind === "required" ?
            "Local variable name does not match pattern " + expected + ": " + actual :
            "Local variable name must not match pattern " + expected + ": " + actual;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const ret = [];
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        // inside METHOD, FORM, FUNCTION MODULE
        for (const node of stru.findAllStructures(Structures.Form)) {
            ret.push(...this.checkLocals(node, file));
        }
        for (const node of stru.findAllStructures(Structures.Method)) {
            ret.push(...this.checkLocals(node, file));
        }
        for (const node of stru.findAllStructures(Structures.FunctionModule)) {
            ret.push(...this.checkLocals(node, file));
        }
        return ret;
    }
    checkLocals(structure, file) {
        let ret = [];
        // data, field symbols
        for (const dat of structure.findAllStatements(Statements.Data)) {
            const parent = structure.findParent(dat);
            if (parent && parent.get() instanceof Structures.Data) {
                continue; // inside DATA BEGIN OF
            }
            const found = dat.findFirstExpression(Expressions.DefinitionName);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedData));
            }
        }
        // inline data
        for (const dat of structure.findAllExpressions(Expressions.InlineData)) {
            const found = dat.findFirstExpression(Expressions.TargetField);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedData));
            }
        }
        // data structures, data begin of, first level
        const dataStructures = structure.findAllStructures(Structures.Data);
        for (const struc of dataStructures) {
            // ignore nested DATA BEGIN
            const stat = struc.findFirstStatement(Statements.DataBegin);
            const found = stat === null || stat === void 0 ? void 0 : stat.findFirstExpression(Expressions.DefinitionName);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedData));
            }
        }
        for (const fieldsymbol of structure.findAllStatements(Statements.FieldSymbol)) {
            const found = fieldsymbol.findFirstExpression(Expressions.FieldSymbol);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedFS));
            }
        }
        // inline field symbols
        for (const fieldsymbol of structure.findAllExpressions(Expressions.InlineFS)) {
            const found = fieldsymbol.findFirstExpression(Expressions.TargetFieldSymbol);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedFS));
            }
        }
        const constants = structure.findAllStatements(Statements.Constant);
        for (const constant of constants) {
            const parent = structure.findParent(constant);
            if (parent && parent.get() instanceof Structures.Constants) {
                continue; // inside DATA BEGIN OF
            }
            const found = constant.findFirstExpression(Expressions.DefinitionName);
            if (found) {
                const token = found.getFirstToken();
                ret = ret.concat(this.checkName(token, file, this.conf.expectedConstant));
            }
        }
        return ret;
    }
    checkName(token, file, expected) {
        const ret = [];
        const regex = new RegExp(expected, "i");
        const name = token.getStr();
        if (name_validator_1.NameValidator.violatesRule(name, regex, this.conf)) {
            const message = this.getDescription(expected, name);
            const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
            ret.push(issue);
        }
        return ret;
    }
}
exports.LocalVariableNames = LocalVariableNames;
//# sourceMappingURL=local_variable_names.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/macro_naming.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/macro_naming.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MacroNaming = exports.MacroNamingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class MacroNamingConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** The pattern for macros, case insensitive */
        this.pattern = "^_.+$";
    }
}
exports.MacroNamingConf = MacroNamingConf;
class MacroNaming extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MacroNamingConf();
    }
    getMetadata() {
        return {
            key: "macro_naming",
            title: "Macro naming conventions",
            shortDescription: `Allows you to enforce a pattern for macro definitions`,
            extendedInformation: `Use rule "avoid_use" to avoid macros altogether.`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
            badExample: `DEFINE something.
END-OF-DEFINITION.`,
            goodExample: `DEFINE _something.
END-OF-DEFINITION.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const testRegex = new RegExp(this.conf.pattern, "i");
        if (obj instanceof objects_1.TypePool) {
            return [];
        }
        for (const stat of file.getStatements()) {
            if (!(stat.get() instanceof Statements.Define)) {
                continue;
            }
            const expr = stat.findDirectExpression(Expressions.MacroName);
            if (expr === undefined) {
                continue;
            }
            const token = expr.getFirstToken();
            if (testRegex.exec(token.getStr())) {
                continue;
            }
            else {
                const message = "Bad macro name naming, expected \"" + this.conf.pattern + "\", got \"" + token.getStr() + "\"";
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.MacroNaming = MacroNaming;
//# sourceMappingURL=macro_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/main_file_contents.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/main_file_contents.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MainFileContents = exports.MainFileContentsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class MainFileContentsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MainFileContentsConf = MainFileContentsConf;
class MainFileContents {
    constructor() {
        this.conf = new MainFileContentsConf();
    }
    getMetadata() {
        return {
            key: "main_file_contents",
            title: "Main file contents",
            shortDescription: `Checks related to report declarations.`,
            extendedInformation: `Does not run if the target version is Cloud

* PROGs must begin with "REPORT <name>." or "PROGRAM <name>.
* TYPEs must begin with "TYPE-POOL <name>."
`,
        };
    }
    getDescription(details) {
        return "Main file must have specific contents: " + details;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)
            || this.reg.getConfig().getVersion() === version_1.Version.Cloud) {
            return [];
        }
        const main = obj.getMainABAPFile();
        if (main === undefined) {
            return [];
        }
        const stru = main.getStructure();
        if (stru === undefined) {
            return [];
        }
        if (obj instanceof Objects.Program
            && obj.isInclude() === false
            && obj.isModulePool() === false) {
            let count = 0;
            let first = main.getStatements()[count];
            while (first !== undefined && first.get() instanceof _statement_1.Comment) {
                count = count + 1;
                first = main.getStatements()[count];
            }
            if (first === undefined || !(first.get() instanceof Statements.Report
                || first.get() instanceof Statements.Program)) {
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(main, position, this.getDescription("Report must begin with REPORT or PROGRAM"), this.getMetadata().key, this.conf.severity);
                return [issue];
            }
            const name = first.findFirstExpression(Expressions.ReportName);
            if (name === undefined) {
                const token = first.getFirstToken();
                const issue = issue_1.Issue.atToken(main, token, this.getDescription("Add report name to REPORT or PROGRAM statement"), this.getMetadata().key, this.conf.severity);
                return [issue];
            }
            else if (name.getFirstToken().getStr().toUpperCase() !== obj.getName()) {
                const token = name.getFirstToken();
                const issue = issue_1.Issue.atToken(main, token, this.getDescription("REPORT or PROGRAM name must match filename"), this.getMetadata().key, this.conf.severity);
                return [issue];
            }
        }
        else if (obj instanceof Objects.TypePool) {
            let count = 0;
            let first = main.getStatements()[count];
            while (first !== undefined && first.get() instanceof _statement_1.Comment) {
                count = count + 1;
                first = main.getStatements()[count];
            }
            if (first === undefined || !(first.get() instanceof Statements.TypePool)) {
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(main, position, this.getDescription("Type pool must begin with TYPE-POOL"), this.getMetadata().key, this.conf.severity);
                return [issue];
            }
            const name = first.getChildren()[3];
            if (name.getFirstToken().getStr().toUpperCase() !== obj.getName()) {
                const token = name.getFirstToken();
                const issue = issue_1.Issue.atToken(main, token, this.getDescription("TYPE-POOL name must match filename"), this.getMetadata().key, this.conf.severity);
                return [issue];
            }
        }
        return [];
    }
}
exports.MainFileContents = MainFileContents;
//# sourceMappingURL=main_file_contents.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/many_parentheses.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/many_parentheses.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ManyParentheses = exports.ManyParenthesesConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class ManyParenthesesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ManyParenthesesConf = ManyParenthesesConf;
class ManyParentheses extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ManyParenthesesConf();
    }
    getMetadata() {
        return {
            key: "many_parentheses",
            title: "Too many parentheses",
            shortDescription: `Searches for expressions where extra parentheses can safely be removed`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `
IF ( destination IS INITIAL ).
ENDIF.
IF foo = boo AND ( bar = lar AND moo = loo ).
ENDIF.
`,
            goodExample: `
IF destination IS INITIAL.
ENDIF.
IF foo = boo AND bar = lar AND moo = loo.
ENDIF.
`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        for (const cond of structure.findAllExpressionsMulti([Expressions.Cond, Expressions.ComponentCond])) {
            issues.push(...this.analyze(file, cond));
        }
        for (const sub of structure.findAllExpressionsMulti([Expressions.CondSub, Expressions.ComponentCondSub])) {
            let cond = [];
            if (sub.get() instanceof Expressions.CondSub) {
                cond = sub.findDirectExpressions(Expressions.Cond);
            }
            else {
                cond = sub.findDirectExpressions(Expressions.ComponentCond);
            }
            if (cond.length !== 1) {
                continue;
            }
            if (cond[0].getChildren().length === 1) {
                const message = "Too many parentheses, simple";
                const children = sub.getChildren();
                let startToken = sub.getFirstToken();
                let fixText = sub.getChildren()[1].concatTokens();
                if (startToken.getStr().toUpperCase() === "NOT") {
                    startToken = children[1].getFirstToken();
                    fixText = sub.getChildren()[2].concatTokens();
                }
                const fix = edit_helper_1.EditHelper.replaceRange(file, startToken.getStart(), sub.getLastToken().getEnd(), fixText);
                const issue = issue_1.Issue.atToken(file, startToken, message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        for (const m of structure.findAllStatements(Statements.Move)) {
            issues.push(...this.analyzeMove(file, m));
        }
        for (const m of structure.findAllStatements(Statements.Select)) {
            issues.push(...this.analyzeInto(file, m));
        }
        return issues;
    }
    ////////////////////
    analyzeInto(file, m) {
        const into = m.findFirstExpression(Expressions.SQLIntoList);
        if (into === undefined) {
            return [];
        }
        const second = into.getAllTokens()[1];
        if (second === undefined || second.getStr() !== "(") {
            return [];
        }
        const concat = into.concatTokens();
        if (concat.endsWith(")") === true && concat.includes(",") === false) {
            const issue = issue_1.Issue.atStatement(file, m, "Too many parentheses", this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
    analyzeMove(file, m) {
        const issues = [];
        const children = m.getChildren();
        const last = children[children.length - 2];
        const lastChildren = last.getChildren();
        if (lastChildren.length === 3
            && lastChildren[0].getFirstToken().getStr() === "("
            && lastChildren[2].getFirstToken().getStr() === ")") {
            const issue = issue_1.Issue.atToken(file, last.getFirstToken(), "Too many parentheses", this.getMetadata().key, this.conf.severity);
            issues.push(issue);
        }
        return issues;
    }
    analyze(file, cond) {
        const issues = [];
        let comparator = "";
        let found = false;
        for (const c of cond.getChildren()) {
            let current = "";
            if (c instanceof nodes_1.TokenNode) {
                current = c.get().getStr().toUpperCase();
            }
            else if (c instanceof nodes_1.ExpressionNode
                && (c.get() instanceof Expressions.CondSub || c.get() instanceof Expressions.ComponentCondSub)) {
                if (c.getFirstToken().getStr().toUpperCase() === "NOT") {
                    return [];
                }
                let i = c.findDirectExpression(Expressions.Cond);
                if (i === undefined) {
                    i = c.findDirectExpression(Expressions.ComponentCond);
                }
                if (i === undefined) {
                    return [];
                }
                current = this.findComparator(i);
                if (current !== "") {
                    found = true; // dont report for the simple case that contains quick fixes
                }
            }
            if (comparator === "") {
                comparator = current;
            }
            else if (comparator !== "" && current !== "" && comparator !== current) {
                return [];
            }
        }
        if (comparator !== "" && comparator !== "MIXED" && found === true) {
            const message = "Too many parentheses, complex";
            const issue = issue_1.Issue.atToken(file, cond.getFirstToken(), message, this.getMetadata().key, this.conf.severity);
            issues.push(issue);
        }
        return issues;
    }
    findComparator(cond) {
        let comparator = "";
        const children = cond.getChildren();
        for (const c of children) {
            if (c instanceof nodes_1.TokenNode) {
                const current = c.get().getStr().toUpperCase();
                if (comparator === "") {
                    comparator = current;
                }
                else if (current !== comparator) {
                    return "MIXED";
                }
            }
        }
        return comparator;
    }
}
exports.ManyParentheses = ManyParentheses;
//# sourceMappingURL=many_parentheses.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/max_one_method_parameter_per_line.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/max_one_method_parameter_per_line.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxOneMethodParameterPerLine = exports.MaxOneMethodParameterPerLineConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class MaxOneMethodParameterPerLineConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MaxOneMethodParameterPerLineConf = MaxOneMethodParameterPerLineConf;
class MaxOneMethodParameterPerLine extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MaxOneMethodParameterPerLineConf();
    }
    getMetadata() {
        return {
            key: "max_one_method_parameter_per_line",
            title: "Max one method parameter definition per line",
            shortDescription: `Keep max one method parameter description per line`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Whitespace],
            badExample: `
METHODS apps_scope_token
  IMPORTING
    body TYPE bodyapps_scope_token client_id TYPE str.`,
            goodExample: `
METHODS apps_scope_token
  IMPORTING
    body      TYPE bodyapps_scope_token
    client_id TYPE str.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        for (const statement of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllStatements(Statements.MethodDef)) || []) {
            let prev = undefined;
            for (const p of statement.findAllExpressions(Expressions.MethodParam)) {
                if (prev === undefined) {
                    prev = p;
                    continue;
                }
                if (prev.getFirstToken().getStart().getRow() === p.getFirstToken().getStart().getRow()) {
                    const issue = issue_1.Issue.atToken(file, prev.getFirstToken(), this.getMetadata().title, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                prev = p;
            }
        }
        return issues;
    }
}
exports.MaxOneMethodParameterPerLine = MaxOneMethodParameterPerLine;
//# sourceMappingURL=max_one_method_parameter_per_line.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/max_one_statement.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/max_one_statement.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MaxOneStatement = exports.MaxOneStatementConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const virtual_position_1 = __webpack_require__(/*! ../virtual_position */ "./node_modules/@abaplint/core/build/src/virtual_position.js");
class MaxOneStatementConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MaxOneStatementConf = MaxOneStatementConf;
class MaxOneStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MaxOneStatementConf();
    }
    getMetadata() {
        return {
            key: "max_one_statement",
            title: "Max one statement per line",
            shortDescription: `Checks that each line contains only a single statement.`,
            extendedInformation: `Does not report empty statements, use rule empty_statement for detecting empty statements.

Does not report anything for chained statements.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#no-more-than-one-statement-per-line
https://docs.abapopenchecks.org/checks/11/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE foo. WRITE bar.`,
            goodExample: `WRITE foo.\nWRITE bar.`,
        };
    }
    getMessage() {
        return "Only one statement is allowed per line";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let prev = 0;
        let reported = 0;
        for (const statement of file.getStatements()) {
            const term = statement.getTerminator();
            if (statement.get() instanceof _statement_1.Comment
                || statement.get() instanceof _statement_1.NativeSQL
                || term === ",") {
                continue;
            }
            const pos = statement.getStart();
            if (pos instanceof virtual_position_1.VirtualPosition) {
                continue;
            }
            const row = pos.getRow();
            if (prev === row && row !== reported && statement.getFirstToken().getStr() !== ".") {
                const fix = edit_helper_1.EditHelper.insertAt(file, pos, "\n");
                const issue = issue_1.Issue.atPosition(file, pos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
                reported = row;
            }
            prev = row;
        }
        return issues;
    }
}
exports.MaxOneStatement = MaxOneStatement;
//# sourceMappingURL=max_one_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/message_exists.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/message_exists.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MessageExistsRule = exports.MessageExistsConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
class MessageExistsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.checkPlaceholders = true;
    }
}
exports.MessageExistsConf = MessageExistsConf;
class MessageExistsRule {
    constructor() {
        this.conf = new MessageExistsConf();
    }
    getMetadata() {
        return {
            key: "message_exists",
            title: "Check MESSAGE exists",
            shortDescription: `In message statements, check that the message class + id exist`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.msagReferences = reg.getMSAGReferences();
        this.reg = reg;
        // the SyntaxLogic builds the references
        for (const obj of reg.getObjects()) {
            if (obj instanceof _abap_object_1.ABAPObject) {
                new syntax_1.SyntaxLogic(reg, obj).run();
            }
        }
        return this;
    }
    run(obj) {
        const issues = [];
        if (obj instanceof _abap_object_1.ABAPObject) {
            for (const file of obj.getABAPFiles()) {
                const struc = file.getStructure();
                if (struc === undefined) {
                    return [];
                }
                issues.push(...this.checkReportStatement(file));
                issues.push(...this.checkSource(file));
            }
        }
        return issues;
    }
    ////////////////////////////////
    checkReportStatement(file) {
        const issues = [];
        for (const statement of file.getStatements()) {
            if (!(statement.get() instanceof Statements.Report)) {
                continue;
            }
            const expression = statement.findFirstExpression(Expressions.MessageClass);
            if (expression) {
                const issue = this.checkClass(expression, file);
                if (issue) {
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
    checkClass(node, file) {
        const token = node.getFirstToken();
        const name = token.getStr();
        if (this.reg.getObject("MSAG", name) === undefined
            && new ddic_1.DDIC(this.reg).inErrorNamespace(name) === true) {
            const message = "Message class \"" + name + "\" not found";
            return issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
        }
        return undefined;
    }
    checkSource(file) {
        const issues = [];
        const references = this.msagReferences.listByFilename(file.getFilename());
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof Statements.Raise || statement.get() instanceof Statements.Message) {
                for (const ref of references) {
                    // always max one message reference per statement? chained statements?
                    if (ref.token.getStart().isBetween(statement.getStart(), statement.getEnd())) {
                        const msag = this.reg.getObject("MSAG", ref.messageClass);
                        if (msag === undefined) {
                            if (new ddic_1.DDIC(this.reg).inErrorNamespace(ref.messageClass) === true) {
                                const message = "Message class \"" + ref.messageClass + "\" not found";
                                issues.push(issue_1.Issue.atToken(file, ref.token, message, this.getMetadata().key, this.conf.severity));
                            }
                            continue;
                        }
                        const text = msag.getByNumber(ref.number);
                        if (text === undefined) {
                            const message = "Message number \"" + ref.number + "\" not found in class \"" + ref.messageClass + "\"";
                            issues.push(issue_1.Issue.atToken(file, ref.token, message, this.getMetadata().key, this.conf.severity));
                            continue;
                        }
                        if (this.getConfig().checkPlaceholders === true) {
                            const count = this.countWith(statement);
                            const textCount = text.getPlaceholderCount();
                            if (count !== textCount) {
                                const message = `Message ${ref.number}, expected ${textCount} WITH parameters`;
                                issues.push(issue_1.Issue.atToken(file, ref.token, message, this.getMetadata().key, this.conf.severity));
                            }
                        }
                    }
                }
            }
        }
        return issues;
    }
    countWith(statement) {
        const raiseWith = statement.findDirectExpression(Expressions.RaiseWith);
        if (raiseWith) {
            return raiseWith.getChildren().length - 1;
        }
        let count = 0;
        let afterWith = false;
        for (const expression of statement.getChildren()) {
            if (expression instanceof nodes_1.TokenNode && expression.concatTokens().toUpperCase() === "WITH") {
                afterWith = true;
                continue;
            }
            if (afterWith === true) {
                if (expression instanceof nodes_1.ExpressionNode) {
                    count++;
                }
                else {
                    break;
                }
            }
        }
        return count;
    }
}
exports.MessageExistsRule = MessageExistsRule;
//# sourceMappingURL=message_exists.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/method_implemented_twice.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/method_implemented_twice.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodImplementedTwice = exports.MethodImplementedTwiceConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class MethodImplementedTwiceConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MethodImplementedTwiceConf = MethodImplementedTwiceConf;
class MethodImplementedTwice extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MethodImplementedTwiceConf();
    }
    getMetadata() {
        return {
            key: "method_implemented_twice",
            title: "Method implemented twice",
            shortDescription: `Reports an error if a method is implemented or defined twice`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const classDef of file.getInfo().listClassImplementations()) {
            const names = {};
            for (const m of classDef.methods) {
                const name = m.getName().toUpperCase();
                if (names[name] === undefined) {
                    names[name] = true;
                }
                else {
                    const message = `Method ${name} implemented twice`;
                    issues.push(issue_1.Issue.atToken(file, m.getToken(), message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        for (const classDef of file.getInfo().listClassDefinitions()) {
            const names = {};
            for (const m of classDef.methods) {
                const name = m.name.toUpperCase();
                if (names[name] === undefined) {
                    names[name] = true;
                }
                else {
                    const message = `Method ${name} defined twice`;
                    issues.push(issue_1.Issue.atToken(file, m.identifier.getToken(), message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        for (const iDef of file.getInfo().listInterfaceDefinitions()) {
            const names = {};
            for (const m of iDef.methods) {
                const name = m.name.toUpperCase();
                if (names[name] === undefined) {
                    names[name] = true;
                }
                else {
                    const message = `Method ${name} implemented twice`;
                    issues.push(issue_1.Issue.atIdentifier(m.identifier, message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return issues;
    }
}
exports.MethodImplementedTwice = MethodImplementedTwice;
//# sourceMappingURL=method_implemented_twice.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/method_length.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/method_length.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodLength = exports.MethodLengthConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const method_length_stats_1 = __webpack_require__(/*! ../utils/method_length_stats */ "./node_modules/@abaplint/core/build/src/utils/method_length_stats.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const form_length_stats_1 = __webpack_require__(/*! ../utils/form_length_stats */ "./node_modules/@abaplint/core/build/src/utils/form_length_stats.js");
class MethodLengthConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Maximum method/form length in statements. */
        this.statements = 100;
        /** Checks for empty methods/forms. */
        this.errorWhenEmpty = true;
        /** Option to ignore test classes for this check. */
        this.ignoreTestClasses = false;
        /** Option to check forms. */
        this.checkForms = true;
    }
}
exports.MethodLengthConf = MethodLengthConf;
var IssueType;
(function (IssueType) {
    IssueType[IssueType["EmptyMethod"] = 0] = "EmptyMethod";
    IssueType[IssueType["MaxStatements"] = 1] = "MaxStatements";
})(IssueType || (IssueType = {}));
class MethodLength {
    constructor() {
        this.conf = new MethodLengthConf();
    }
    getMetadata() {
        return {
            key: "method_length",
            title: "Method/Form Length",
            shortDescription: `Checks relating to method/form length.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#keep-methods-small

Abstract methods without statements are considered okay.`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(issueType, actual, type) {
        switch (issueType) {
            case IssueType.EmptyMethod: {
                return "Empty " + type;
            }
            case IssueType.MaxStatements: {
                return "Reduce " + type + " length to max " + this.conf.statements + " statements, currently " + actual;
            }
            default: {
                return "";
            }
        }
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        var _a;
        if (this.conf.ignoreTestClasses === true
            && obj instanceof Objects.Class
            && ((_a = obj.getClassDefinition()) === null || _a === void 0 ? void 0 : _a.isForTesting) === true) {
            return [];
        }
        const methodStats = method_length_stats_1.MethodLengthStats.run(obj);
        const methodIssues = this.check(methodStats, "METHOD");
        let formIssues = [];
        if (this.conf.checkForms) {
            const formStats = form_length_stats_1.FormLengthStats.run(obj);
            formIssues = this.check(formStats, "FORM");
        }
        return methodIssues.concat(formIssues);
    }
    // ***********************
    check(stats, type) {
        const issues = [];
        for (const s of stats) {
            if ((this.conf.ignoreTestClasses === true)
                && s.file.getFilename().includes(".testclasses.")) {
                continue;
            }
            if (s.count === 0 && this.conf.errorWhenEmpty === true) {
                if (this.isAbstract(s)) {
                    continue;
                }
                const issue = issue_1.Issue.atPosition(s.file, s.pos, this.getDescription(IssueType.EmptyMethod, "0", type), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                continue;
            }
            if (s.count > this.conf.statements) {
                const message = this.getDescription(IssueType.MaxStatements, s.count.toString(), type);
                const issue = issue_1.Issue.atPosition(s.file, s.pos, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
    isAbstract(result) {
        const cdef = result.file.getInfo().getClassDefinitionByName(result.className);
        return (cdef === null || cdef === void 0 ? void 0 : cdef.isAbstract) === true;
    }
}
exports.MethodLength = MethodLength;
//# sourceMappingURL=method_length.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/method_overwrites_builtin.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/method_overwrites_builtin.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodOverwritesBuiltIn = exports.MethodOverwritesBuiltInConf = void 0;
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
const _builtin_1 = __webpack_require__(/*! ../abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class MethodOverwritesBuiltInConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MethodOverwritesBuiltInConf = MethodOverwritesBuiltInConf;
class MethodOverwritesBuiltIn extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MethodOverwritesBuiltInConf();
    }
    getMetadata() {
        return {
            key: "method_overwrites_builtin",
            title: "Method name overwrites builtin function",
            shortDescription: `Checks Method names that overwrite builtin SAP functions`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abenbuilt_in_functions_overview.htm

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-obscuring-built-in-functions

Interface method names are ignored`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `CLASS lcl DEFINITION.
  PUBLIC SECTION.
    METHODS matches.
ENDCLASS.

CLASS lcl IMPLEMENTATION.
  METHOD matches.
  ENDMETHOD.
ENDCLASS.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let methods = [];
        for (const classDef of file.getInfo().listClassDefinitions()) {
            methods = methods.concat(classDef.methods);
        }
        const builtIn = new _builtin_1.BuiltIn();
        for (const method of methods) {
            if (builtIn.searchBuiltin(method.name.toUpperCase())) {
                const message = `Method name "${method.name}" overwrites built-in SAP function name`;
                issues.push(__1.Issue.atIdentifier(method.identifier, message, this.getMetadata().key));
            }
        }
        return issues;
    }
}
exports.MethodOverwritesBuiltIn = MethodOverwritesBuiltIn;
//# sourceMappingURL=method_overwrites_builtin.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/method_parameter_names.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/method_parameter_names.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodParameterNames = exports.MethodParameterNamesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
const _abap_file_information_1 = __webpack_require__(/*! ../abap/4_file_information/_abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class MethodParameterNamesConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore parameters in methods of exception classes */
        this.ignoreExceptions = true;
        /** The pattern for importing parameters */
        this.importing = "^I._.+$";
        /** The pattern for returning parameters */
        this.returning = "^R._.+$";
        /** The pattern for changing parameters */
        this.changing = "^C._.+$";
        /** The pattern for exporting parameters */
        this.exporting = "^E._.+$";
    }
}
exports.MethodParameterNamesConf = MethodParameterNamesConf;
class MethodParameterNames {
    constructor() {
        this.conf = new MethodParameterNamesConf();
    }
    getMetadata() {
        return {
            key: "method_parameter_names",
            title: "Method parameter naming conventions",
            shortDescription: `Allows you to enforce a pattern, such as a prefix, for method parameter names`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(expected, actual) {
        return this.conf.patternKind === "required" ?
            "Method parameter name does not match pattern " + expected + ": " + actual :
            "Method parameter name must not match pattern " + expected + ": " + actual;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        let ret = [];
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const ddic = new ddic_1.DDIC(this.reg);
        for (const file of obj.getABAPFiles()) {
            for (const def of file.getInfo().listInterfaceDefinitions()) {
                for (const method of def.methods) {
                    ret = ret.concat(this.checkMethod(method));
                }
            }
            for (const def of file.getInfo().listClassDefinitions()) {
                if (this.conf.ignoreExceptions && ddic.isException(def, obj)) {
                    continue;
                }
                for (const method of def.methods) {
                    if (method.isEventHandler) {
                        continue;
                    }
                    ret = ret.concat(this.checkMethod(method));
                }
            }
        }
        return ret;
    }
    checkMethod(method) {
        let ret = [];
        for (const p of method.parameters) {
            switch (p.direction) {
                case _abap_file_information_1.MethodParameterDirection.Importing:
                    ret = ret.concat(this.checkParameter(p, this.conf.importing));
                    break;
                case _abap_file_information_1.MethodParameterDirection.Exporting:
                    ret = ret.concat(this.checkParameter(p, this.conf.exporting));
                    break;
                case _abap_file_information_1.MethodParameterDirection.Changing:
                    ret = ret.concat(this.checkParameter(p, this.conf.changing));
                    break;
                case _abap_file_information_1.MethodParameterDirection.Returning:
                    ret = ret.concat(this.checkParameter(p, this.conf.returning));
                    break;
                default:
                    break;
            }
        }
        return ret;
    }
    checkParameter(param, expected) {
        const ret = [];
        const regex = new RegExp(expected, "i");
        const name = param.name;
        if (name_validator_1.NameValidator.violatesRule(name, regex, this.conf)) {
            const message = this.getDescription(expected, name);
            const issue = issue_1.Issue.atIdentifier(param.identifier, message, this.getMetadata().key, this.conf.severity);
            ret.push(issue);
        }
        return ret;
    }
}
exports.MethodParameterNames = MethodParameterNames;
//# sourceMappingURL=method_parameter_names.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/mix_returning.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/mix_returning.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MixReturning = exports.MixReturningConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class MixReturningConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.MixReturningConf = MixReturningConf;
class MixReturning extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new MixReturningConf();
    }
    getMetadata() {
        return {
            key: "mix_returning",
            title: "Mix of returning and exporting",
            shortDescription: `Checks that methods don't have a mixture of returning and exporting/changing parameters`,
            // eslint-disable-next-line max-len
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-either-returning-or-exporting-or-changing-but-not-a-combination`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `CLASS lcl DEFINITION.
  PUBLIC SECTION.
    METHODS
      foobar
        EXPORTING foo TYPE i
        RETURNING VALUE(rv_string) TYPE string.
ENDCLASS.`,
        };
    }
    getMessage() {
        return "Don't mix RETURNING and EXPORTING/CHANGING parameters in a single method.";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const ret = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const def of stru.findAllStatements(Statements.MethodDef)) {
            if (!def.findFirstExpression(Expressions.MethodDefReturning)) {
                continue;
            }
            if (def.findFirstExpression(Expressions.MethodDefExporting)
                || def.findFirstExpression(Expressions.MethodDefChanging)) {
                const token = def.getFirstToken();
                const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
}
exports.MixReturning = MixReturning;
//# sourceMappingURL=mix_returning.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/modify_only_own_db_tables.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/modify_only_own_db_tables.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ModifyOnlyOwnDBTables = exports.ModifyOnlyOwnDBTablesConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
class ModifyOnlyOwnDBTablesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.reportDynamic = true;
        /** Case insensitve regex for own tables */
        this.ownTables = "^[yz]";
    }
}
exports.ModifyOnlyOwnDBTablesConf = ModifyOnlyOwnDBTablesConf;
class ModifyOnlyOwnDBTables {
    constructor() {
        this.conf = new ModifyOnlyOwnDBTablesConf();
    }
    getMetadata() {
        return {
            key: "modify_only_own_db_tables",
            title: "Modify only own DB tables",
            shortDescription: `Modify only own DB tables`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/26/`,
            tags: [_irule_1.RuleTag.Security],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        var _a;
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        let spaghetti = undefined;
        const output = [];
        for (const file of obj.getABAPFiles()) {
            const struc = file.getStructure();
            if (struc === undefined) {
                return [];
            }
            const regExp = new RegExp(this.getConfig().ownTables, "i");
            for (const s of file.getStatements()) {
                const g = s.get();
                if (g instanceof Statements.DeleteDatabase
                    || g instanceof Statements.UpdateDatabase
                    || g instanceof Statements.InsertDatabase
                    || g instanceof Statements.ModifyDatabase) {
                    const databaseTable = s.findFirstExpression(Expressions.DatabaseTable);
                    if (databaseTable === undefined) {
                        continue;
                    }
                    if (((_a = databaseTable.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.Dynamic) {
                        if (this.getConfig().reportDynamic === true) {
                            output.push(issue_1.Issue.atStatement(file, s, this.getMetadata().title, this.getMetadata().key, this.getConfig().severity));
                        }
                        continue;
                    }
                    const concat = databaseTable.concatTokens().toUpperCase();
                    if (regExp.test(concat) === false) {
                        // must contain a ReferenceType.TableVoidReference or a ReferenceType.TableReference if its a dependency
                        if (spaghetti === undefined) {
                            spaghetti = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
                        }
                        const start = databaseTable.getFirstToken().getStart();
                        const scope = spaghetti.lookupPosition(start, file.getFilename());
                        const found1 = scope === null || scope === void 0 ? void 0 : scope.findTableVoidReference(start);
                        if (found1) {
                            output.push(issue_1.Issue.atStatement(file, s, this.getMetadata().title, this.getMetadata().key, this.getConfig().severity));
                        }
                        const found2 = scope === null || scope === void 0 ? void 0 : scope.findTableReference(start);
                        if (found2) {
                            output.push(issue_1.Issue.atStatement(file, s, this.getMetadata().title, this.getMetadata().key, this.getConfig().severity));
                        }
                    }
                }
            }
        }
        return output;
    }
}
exports.ModifyOnlyOwnDBTables = ModifyOnlyOwnDBTables;
//# sourceMappingURL=modify_only_own_db_tables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/msag_consistency.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/msag_consistency.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MSAGConsistency = exports.MSAGConsistencyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class MSAGConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** parameters must be numbered */
        this.numericParameters = true;
    }
}
exports.MSAGConsistencyConf = MSAGConsistencyConf;
class MSAGConsistency {
    constructor() {
        this.conf = new MSAGConsistencyConf();
    }
    getMetadata() {
        return {
            key: "msag_consistency",
            title: "MSAG consistency check",
            shortDescription: `Checks the validity of messages in message classes`,
            extendedInformation: `Message numbers must be 3 digits, message text must not be empty, no message number duplicates`,
        };
    }
    getDescription(reason) {
        return "Message class invalid: " + reason;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        const issues = [];
        if (!(obj instanceof objects_1.MessageClass)) {
            return [];
        }
        const numbers = new Set();
        for (const message of obj.getMessages()) {
            // todo, get the right positions in xml file, and report the issue there
            if (!message.getNumber().match(/\d\d\d/)) {
                const text = this.getDescription("Message number must be 3 digits: message " + message.getNumber());
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            if (message.getMessage() === "") {
                const text = "Message text empty: message " + message.getNumber();
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            const num = message.getNumber();
            if (numbers.has(num)) {
                const text = "Duplicate message number " + num;
                const position = new position_1.Position(1, 1);
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            else {
                numbers.add(num);
            }
            if (this.getConfig().numericParameters === true) {
                const placeholderCount = message.getPlaceholderCount();
                if (placeholderCount > 4) {
                    const text = `More than 4 placeholders in mesasge ${message.getNumber()}`;
                    const position = new position_1.Position(1, 1);
                    const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                for (let i = 1; i <= placeholderCount; i++) {
                    const placeholder = "&" + i;
                    if (message.getMessage().includes(placeholder) === false) {
                        const text = `Expected placeholder ${placeholder} in message ${message.getNumber()}`;
                        const position = new position_1.Position(1, 1);
                        const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, text, this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                        break;
                    }
                }
            }
        }
        return issues;
    }
}
exports.MSAGConsistency = MSAGConsistency;
//# sourceMappingURL=msag_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/names_no_dash.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/names_no_dash.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NamesNoDash = exports.NamesNoDashConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NamesNoDashConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NamesNoDashConf = NamesNoDashConf;
// todo, also check for other characters like %&$, rename rule? and extend to more kinds of identifiers?
class NamesNoDash extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NamesNoDashConf();
    }
    getMetadata() {
        return {
            key: "names_no_dash",
            title: "No dashes in FORM and DATA names",
            shortDescription: `Checks for a "-" in FORM, DATA, PARAMETER and SELECT-OPTION names`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Naming],
            badExample: "DATA foo-bar TYPE i.",
            goodExample: "DATA foobar TYPE i.",
        };
    }
    getMessage() {
        return "No dash allowed in FORM and DATA names";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return issues;
        }
        if (obj.getType() !== "CLAS" && obj.getType() !== "INTF") {
            for (const form of struc.findAllStatements(Statements.Form)) {
                const expr = form.findFirstExpression(expressions_1.FormName);
                for (const token of expr.getTokens()) {
                    if (token instanceof tokens_1.Dash || token instanceof tokens_1.DashW) {
                        const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                        break;
                    }
                }
            }
            for (const form of struc.findAllStatements(Statements.Parameter)) {
                const expr = form.findFirstExpression(Expressions.FieldSub);
                for (const token of expr.getTokens()) {
                    if (token instanceof tokens_1.Dash || token instanceof tokens_1.DashW) {
                        const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                        break;
                    }
                }
            }
            for (const form of struc.findAllStatements(Statements.SelectOption)) {
                const expr = form.findFirstExpression(Expressions.FieldSub);
                for (const token of expr.getTokens()) {
                    if (token instanceof tokens_1.Dash || token instanceof tokens_1.DashW) {
                        const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                        break;
                    }
                }
            }
        }
        for (const name of struc.findAllExpressions(Expressions.DefinitionName)) {
            const text = name.concatTokens();
            if (text.includes("-")) {
                const issue = issue_1.Issue.atToken(file, name.getFirstToken(), this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.NamesNoDash = NamesNoDash;
//# sourceMappingURL=names_no_dash.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/nesting.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/nesting.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Nesting = exports.NestingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NestingConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Maximum allowed nesting depth */
        this.depth = 5;
    }
}
exports.NestingConf = NestingConf;
class Nesting extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NestingConf();
    }
    getMetadata() {
        return {
            key: "nesting",
            title: "Check nesting depth",
            shortDescription: `Checks for methods exceeding a maximum nesting depth`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#keep-the-nesting-depth-low
https://docs.abapopenchecks.org/checks/74/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(max) {
        return "Reduce nesting depth to max " + max;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let depth = 0;
        for (const statement of file.getStatements()) {
            const type = statement.get();
            if (type instanceof Statements.If
                || type instanceof Statements.Case
                || type instanceof Statements.While
                || type instanceof Statements.Loop
                || type instanceof Statements.SelectLoop
                || type instanceof Statements.Do
                || type instanceof Statements.Try) {
                depth = depth + 1;
            }
            else if (type instanceof Statements.EndIf
                || type instanceof Statements.EndCase
                || type instanceof Statements.EndWhile
                || type instanceof Statements.EndLoop
                || type instanceof Statements.EndSelect
                || type instanceof Statements.EndDo
                || type instanceof Statements.EndTry) {
                depth = depth - 1;
            }
            if (depth > this.conf.depth) {
                const pos = statement.getFirstToken().getStart();
                const issue = issue_1.Issue.atPosition(file, pos, this.getDescription(this.conf.depth.toString()), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                break; // only one finding per file
            }
        }
        return issues;
    }
}
exports.Nesting = Nesting;
//# sourceMappingURL=nesting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/newline_between_methods.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/newline_between_methods.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NewlineBetweenMethods = exports.NewlineBetweenMethodsConf = exports.NewlineLogic = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const sequential_blank_1 = __webpack_require__(/*! ./sequential_blank */ "./node_modules/@abaplint/core/build/src/rules/sequential_blank.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
var NewlineLogic;
(function (NewlineLogic) {
    NewlineLogic["Exact"] = "exact";
    NewlineLogic["Less"] = "less";
})(NewlineLogic || (exports.NewlineLogic = NewlineLogic = {}));
class NewlineBetweenMethodsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Amount of newlines, works in conjunction with "newlineLogic" */
        this.count = 3;
        /**
         *  Exact: the exact number of required newlines between methods is defined by "newlineAmount"
         *
         *  Less: the required number of newlines has to be less than "newlineAmount"
         */
        this.logic = NewlineLogic.Less;
    }
}
exports.NewlineBetweenMethodsConf = NewlineBetweenMethodsConf;
class NewlineBetweenMethods extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NewlineBetweenMethodsConf();
    }
    getMetadata() {
        return {
            key: "newline_between_methods",
            title: "New line between methods",
            shortDescription: `Checks for newlines between method implementations.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        switch (this.conf.logic) {
            case NewlineLogic.Exact: return `Exactly ${this.conf.count} newlines are required in between methods`;
            case NewlineLogic.Less: return `Less than ${this.conf.count} newlines and at least a single newline are required in between methods`;
            default: return "";
        }
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        const rows = file.getRawRows();
        if (!this.isConfigurationValid()) {
            return [];
        }
        for (const statement of file.getStatements()) {
            let nextRow = statement.getStart().getRow();
            if (!(statement.get() instanceof Statements.EndMethod) || ((_a = rows[nextRow]) === null || _a === void 0 ? void 0 : _a.toUpperCase().includes("ENDCLASS."))) {
                continue;
            }
            let counter = 0;
            while (sequential_blank_1.SequentialBlank.isBlankOrWhitespace(rows[nextRow]) && (counter <= this.conf.count + 1)) {
                counter++;
                nextRow++;
            }
            if ((counter !== this.conf.count && this.conf.logic === NewlineLogic.Exact)
                || (counter >= this.conf.count && this.conf.logic === NewlineLogic.Less)
                || counter === 0) {
                issues.push(issue_1.Issue.atStatement(file, statement, this.getMessage(), this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
    isConfigurationValid() {
        if (this.conf.count < 1 || (this.conf.count === 1 && this.conf.logic === NewlineLogic.Less)) {
            return false;
        }
        else {
            return true;
        }
    }
}
exports.NewlineBetweenMethods = NewlineBetweenMethods;
//# sourceMappingURL=newline_between_methods.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_aliases.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_aliases.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoAliases = exports.NoAliasesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoAliasesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NoAliasesConf = NoAliasesConf;
class NoAliases extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoAliasesConf();
    }
    getMetadata() {
        return {
            key: "no_aliases",
            title: "No ALIASES",
            shortDescription: `Detects use of the ALIAS statement`,
            extendedInformation: `Only one issue is reported for chained statements`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const message = "Do not use ALIASES";
        let prev = undefined;
        for (const stat of file.getStatements()) {
            if (stat.get() instanceof Statements.Aliases) {
                if (prev && prev.getColon() === stat.getColon()) {
                    continue;
                }
                issues.push(issue_1.Issue.atStatement(file, stat, message, this.getMetadata().key, this.conf.severity));
                prev = stat;
            }
        }
        return issues;
    }
}
exports.NoAliases = NoAliases;
//# sourceMappingURL=no_aliases.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_chained_assignment.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_chained_assignment.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoChainedAssignment = exports.NoChainedAssignmentConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoChainedAssignmentConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NoChainedAssignmentConf = NoChainedAssignmentConf;
class NoChainedAssignment extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoChainedAssignmentConf();
    }
    getMetadata() {
        return {
            key: "no_chained_assignment",
            title: "No chained assignment",
            shortDescription: `Find chained assingments and reports issues`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#dont-chain-assignments`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `var1 = var2 = var3.`,
            goodExample: `var2 = var3.
var1 = var2.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const s of file.getStatements()) {
            if (!(s.get() instanceof Statements.Move)) {
                continue;
            }
            if (s.findDirectExpressions(Expressions.Target).length >= 2) {
                const message = "No chained assignment";
                const issue = issue_1.Issue.atStatement(file, s, message, this.getMetadata().key);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.NoChainedAssignment = NoChainedAssignment;
//# sourceMappingURL=no_chained_assignment.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_external_form_calls.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_external_form_calls.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoExternalFormCalls = exports.NoExternalFormCallsConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoExternalFormCallsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NoExternalFormCallsConf = NoExternalFormCallsConf;
class NoExternalFormCalls extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoExternalFormCallsConf();
    }
    getMetadata() {
        return {
            key: "no_external_form_calls",
            title: "No external FORM calls",
            shortDescription: `Detect external form calls`,
            badExample: `PERFORM foo IN PROGRAM bar.

PERFORM foo(bar).`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return issues; // parser error
        }
        for (const p of stru.findAllStatements(Statements.Perform)) {
            if (p.findDirectExpression(Expressions.IncludeName) || p.findDirectTokenByText("PROGRAM")) {
                const message = "No external FORM calls";
                issues.push(issue_1.Issue.atStatement(file, p, message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.NoExternalFormCalls = NoExternalFormCalls;
//# sourceMappingURL=no_external_form_calls.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_inline_in_optional_branches.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_inline_in_optional_branches.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoInlineInOptionalBranches = exports.NoInlineInOptionalBranchesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class NoInlineInOptionalBranchesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NoInlineInOptionalBranchesConf = NoInlineInOptionalBranchesConf;
class NoInlineInOptionalBranches extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoInlineInOptionalBranchesConf();
    }
    getMetadata() {
        return {
            key: "no_inline_in_optional_branches",
            title: "Don't declare inline in optional branches",
            shortDescription: `Don't declare inline in optional branches`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#dont-declare-inline-in-optional-branches

Considered optional branches:
* inside IF/ELSEIF/ELSE
* inside LOOP
* inside WHILE
* inside CASE/WHEN, CASE TYPE OF
* inside DO
* inside SELECT loops

Not considered optional branches:
* TRY/CATCH/CLEANUP`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const output = [];
        const version = this.reg.getConfig().getVersion();
        if (version === version_1.Version.v700
            || version === version_1.Version.v702
            || version === version_1.Version.OpenABAP) {
            return [];
        }
        const struc = file.getStructure();
        if (struc === undefined) {
            return []; // syntax error
        }
        const candidates = [
            ...struc.findAllStructures(Structures.If),
            ...struc.findAllStructures(Structures.Loop),
            ...struc.findAllStructures(Structures.While),
            ...struc.findAllStructures(Structures.Case),
            ...struc.findAllStructures(Structures.CaseType),
            ...struc.findAllStructures(Structures.Do),
            ...struc.findAllStructures(Structures.Select)
        ];
        for (const c of candidates) {
            const inline = c.findFirstExpression(Expressions.InlineData);
            if (inline) {
                const message = "Don't declare inline in optional branches";
                const issue = issue_1.Issue.atToken(file, inline.getFirstToken(), message, this.getMetadata().key, this.getConfig().severity);
                output.push(issue);
            }
        }
        return output;
    }
}
exports.NoInlineInOptionalBranches = NoInlineInOptionalBranches;
//# sourceMappingURL=no_inline_in_optional_branches.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_prefixes.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_prefixes.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoPrefixes = exports.NoPrefixesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoPrefixesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** DATA, CLASS-DATA, DATA BEGIN OF, CLASS-DATA BEGIN OF, FINAL(), DATA(), case insensitive regex */
        this.data = "^[LGM].?_";
        /** STATICS, STATICS BEGIN OF, case insensitive regex */
        this.statics = "^S.?_";
        /** FIELD-SYMBOLS and inline FIELD-SYMBOLS(), case insensitive regex */
        this.fieldSymbols = "^<[LGM].?_";
        /** CONSTANTS, CONSTANTS BEGIN OF, case insensitive regex */
        this.constants = "^[LGM]?C.?_";
        /** TYPES, ENUM, MESH, case insensitive regex */
        this.types = "^TY_";
        /** importing, exporting, returning and changing parameters, case insensitive regex */
        this.methodParameters = "^[ICER].?_";
        this.allowIsPrefixBoolean = true;
        // todo, public localClass: string = "";
        // todo, public localInterface: string = "";
        // todo, public functionModuleParameters: string = "";
        // todo, public parameters: string = "";
        // todo, public selectOptions: string = "";
        // todo, public formParameters: string = "";
    }
}
exports.NoPrefixesConf = NoPrefixesConf;
const MESSAGE = "Avoid hungarian notation";
class NoPrefixes extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoPrefixesConf();
    }
    getMetadata() {
        return {
            key: "no_prefixes",
            title: "No Prefixes",
            shortDescription: `Dont use hungarian notation`,
            extendedInformation: `
Note: not prefixing TYPES will require changing the errorNamespace in the abaplint configuration,
allowing all types to become voided, abaplint will then provide less precise syntax errors.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-encodings-esp-hungarian-notation-and-prefixes

https://github.com/SAP/styleguides/blob/main/clean-abap/sub-sections/AvoidEncodings.md`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `DATA lv_foo TYPE i.`,
            goodExample: `DATA foo TYPE i.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const ret = [];
        const config = this.getConfig();
        const structure = file.getStructure();
        if (structure === undefined) {
            // syntax error, skip
            return [];
        }
        if (config.data !== undefined && config.data !== "") {
            ret.push(...this.checkData(structure, new RegExp(config.data, "i"), file));
        }
        if (config.statics !== undefined && config.statics !== "") {
            ret.push(...this.checkStatics(structure, new RegExp(config.statics, "i"), file));
        }
        if (config.fieldSymbols !== undefined && config.fieldSymbols !== "") {
            ret.push(...this.checkFieldSymbols(structure, new RegExp(config.fieldSymbols, "i"), file));
        }
        if (config.constants !== undefined && config.constants !== "") {
            ret.push(...this.checkConstants(structure, new RegExp(config.constants, "i"), file));
        }
        if (config.types !== undefined && config.types !== "") {
            ret.push(...this.checkTypes(structure, new RegExp(config.types, "i"), file));
        }
        if (config.methodParameters !== undefined && config.methodParameters !== "") {
            ret.push(...this.checkMethodParameters(structure, new RegExp(config.methodParameters, "i"), file));
        }
        return ret;
    }
    checkData(topNode, regex, file) {
        const ret = [];
        for (const data of topNode.findAllStatements(Statements.Data).concat(topNode.findAllStatements(Statements.DataBegin)).concat(topNode.findAllStatements(Statements.ClassDataBegin)).concat(topNode.findAllStatements(Statements.ClassData))) {
            const nameExpression = data.findFirstExpression(Expressions.DefinitionName)
                || data.findFirstExpression(Expressions.NamespaceSimpleName);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        for (const data of topNode.findAllExpressions(Expressions.InlineData)) {
            const nameExpression = data.findFirstExpression(Expressions.TargetField);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
    checkStatics(topNode, regex, file) {
        const ret = [];
        for (const data of topNode.findAllStatements(Statements.Static).concat(topNode.findAllStatements(Statements.StaticBegin))) {
            const nameExpression = data.findFirstExpression(Expressions.DefinitionName);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
    checkFieldSymbols(topNode, regex, file) {
        const ret = [];
        for (const data of topNode.findAllStatements(Statements.FieldSymbol)) {
            const nameExpression = data.findFirstExpression(Expressions.FieldSymbol);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        for (const data of topNode.findAllExpressions(Expressions.InlineFS)) {
            const nameExpression = data.findFirstExpression(Expressions.FieldSymbol);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
    checkConstants(topNode, regex, file) {
        const ret = [];
        for (const data of topNode.findAllStatements(Statements.Constant).concat(topNode.findAllStatements(Statements.ConstantBegin))) {
            const nameExpression = data.findFirstExpression(Expressions.DefinitionName);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
    checkTypes(topNode, regex, file) {
        const ret = [];
        for (const data of topNode.findAllStatements(Statements.Type).concat(topNode.findAllStatements(Statements.TypeEnum)).concat(topNode.findAllStatements(Statements.TypeEnumBegin)).concat(topNode.findAllStatements(Statements.TypeMesh)).concat(topNode.findAllStatements(Statements.TypeMeshBegin)).concat(topNode.findAllStatements(Statements.TypeBegin))) {
            const nameExpression = data.findFirstExpression(Expressions.NamespaceSimpleName);
            const name = (nameExpression === null || nameExpression === void 0 ? void 0 : nameExpression.concatTokens()) || "";
            if (name !== "" && nameExpression && name.match(regex)) {
                const issue = issue_1.Issue.atToken(file, nameExpression.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
    checkMethodParameters(topNode, regex, file) {
        var _a, _b;
        const ret = [];
        for (const method of topNode.findAllStatements(Statements.MethodDef)) {
            for (const param of method.findAllExpressionsMulti([Expressions.MethodDefReturning, Expressions.MethodParam])) {
                const nameToken = param === null || param === void 0 ? void 0 : param.findFirstExpression(Expressions.MethodParamName);
                const type = (_b = (_a = param === null || param === void 0 ? void 0 : param.findFirstExpression(Expressions.TypeParam)) === null || _a === void 0 ? void 0 : _a.concatTokens()) === null || _b === void 0 ? void 0 : _b.toUpperCase();
                if (this.getConfig().allowIsPrefixBoolean === true && (type === null || type === void 0 ? void 0 : type.endsWith("TYPE ABAP_BOOL"))) {
                    continue;
                }
                const name = nameToken === null || nameToken === void 0 ? void 0 : nameToken.concatTokens();
                if (nameToken && name && name !== "" && name.match(regex)) {
                    const issue = issue_1.Issue.atToken(file, nameToken.getFirstToken(), MESSAGE, this.getMetadata().key, this.conf.severity);
                    ret.push(issue);
                }
            }
        }
        return ret;
    }
}
exports.NoPrefixes = NoPrefixes;
//# sourceMappingURL=no_prefixes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_public_attributes.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_public_attributes.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoPublicAttributes = exports.NoPublicAttributesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const visibility_1 = __webpack_require__(/*! ../abap/4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const _abap_file_information_1 = __webpack_require__(/*! ../abap/4_file_information/_abap_file_information */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/_abap_file_information.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoPublicAttributesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allows public attributes, if they are declared as READ-ONLY. */
        this.allowReadOnly = false;
        /** Option to ignore test classes for this check. */
        this.ignoreTestClasses = false;
    }
}
exports.NoPublicAttributesConf = NoPublicAttributesConf;
class NoPublicAttributes extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoPublicAttributesConf();
    }
    getMetadata() {
        return {
            key: "no_public_attributes",
            title: "No public attributes",
            shortDescription: `Checks that classes and interfaces don't contain any public attributes.
Exceptions are excluded from this rule.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#members-private-by-default-protected-only-if-needed`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(name) {
        return "Public attributes are not allowed, attribute \"" + name + "\"";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        this.file = file;
        const attributes = this.getAllPublicAttributes(obj);
        return this.findAllIssues(attributes);
    }
    getAllPublicAttributes(obj) {
        let attributes = [];
        attributes = attributes.concat(this.getAllPublicClassAttributes(obj));
        attributes = attributes.concat(this.getAllPublicInterfaceAttributes());
        return attributes;
    }
    getAllPublicClassAttributes(obj) {
        let attributes = [];
        const ddic = new ddic_1.DDIC(this.reg);
        for (const classDef of this.file.getInfo().listClassDefinitions()) {
            if (ddic.isException(classDef, obj)) {
                continue;
            }
            attributes = attributes.concat(classDef.attributes.filter(a => a.visibility === visibility_1.Visibility.Public));
        }
        return attributes;
    }
    getAllPublicInterfaceAttributes() {
        let attributes = [];
        for (const interfaceDef of this.file.getInfo().listInterfaceDefinitions()) {
            attributes = attributes.concat(interfaceDef.attributes.filter(a => a.visibility === visibility_1.Visibility.Public));
        }
        return attributes;
    }
    findAllIssues(attributes) {
        const issues = [];
        for (const attr of attributes) {
            if (this.conf.allowReadOnly === true && attr.readOnly) {
                continue;
            }
            else if (attr.level === _abap_file_information_1.AttributeLevel.Constant) {
                continue;
            }
            else if ((this.conf.ignoreTestClasses === true)
                && this.file.getFilename().includes(".testclasses.")) {
                continue;
            }
            const issue = issue_1.Issue.atIdentifier(attr.identifier, this.getDescription(attr.name), this.getMetadata().key, this.conf.severity);
            issues.push(issue);
        }
        return issues;
    }
}
exports.NoPublicAttributes = NoPublicAttributes;
//# sourceMappingURL=no_public_attributes.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/no_yoda_conditions.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/no_yoda_conditions.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NoYodaConditions = exports.NoYodaConditionsConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class NoYodaConditionsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Only report issues where the left side is a constant */
        this.onlyConstants = false;
    }
}
exports.NoYodaConditionsConf = NoYodaConditionsConf;
class NoYodaConditions extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new NoYodaConditionsConf();
    }
    getMetadata() {
        return {
            key: "no_yoda_conditions",
            title: "No Yoda conditions",
            shortDescription: `Finds Yoda conditions and reports issues`,
            extendedInformation: `https://en.wikipedia.org/wiki/Yoda_conditions

Conditions with operators CP, NP, CS, NS, CA, NA, CO, CN are ignored`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `IF 0 <> sy-subrc.
ENDIF.`,
            goodExample: `IF sy-subrc <> 0.
ENDIF.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b;
        const issues = [];
        for (const c of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.Compare)) || []) {
            const operator = (_b = c.findDirectExpression(Expressions.CompareOperator)) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase();
            if (operator === undefined
                || operator === "CP"
                || operator === "NP"
                || operator === "CS"
                || operator === "NS"
                || operator === "CA"
                || operator === "NA"
                || operator === "CO"
                || operator === "CN") {
                continue;
            }
            const sources = c.findDirectExpressions(Expressions.Source);
            if (sources.length !== 2) {
                continue;
            }
            if (this.conf.onlyConstants === true) {
                if (this.isConstant(sources[0]) === true && this.isConstant(sources[1]) === false) {
                    const start = sources[0].getFirstToken().getStart();
                    const end = sources[1].getLastToken().getEnd();
                    const issue = issue_1.Issue.atRange(file, start, end, "No Yoda conditions", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                continue;
            }
            // Scenarios:
            //   constant COMPARE chain
            //   constant COMPARE multiple tokens with spaces
            //   fieldChain COMPARE multiple tokens with spaces
            if ((this.withoutSpaces(sources[0]) === false && this.withoutSpaces(sources[1]) === true) || ((this.isConstant(sources[0]) === true && this.isFieldChain(sources[1]) === true))) {
                const start = sources[0].getFirstToken().getStart();
                const end = sources[1].getLastToken().getEnd();
                const issue = issue_1.Issue.atRange(file, start, end, "No Yoda conditions", this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
    isConstant(node) {
        var _a;
        if (node.getChildren().length > 1) {
            return false;
        }
        return ((_a = node.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.Constant;
    }
    isFieldChain(node) {
        var _a;
        if (node.getChildren().length > 1) {
            return false;
        }
        return ((_a = node.getFirstChild()) === null || _a === void 0 ? void 0 : _a.get()) instanceof Expressions.FieldChain;
    }
    withoutSpaces(node) {
        return node.concatTokensWithoutStringsAndComments().includes(" ");
    }
}
exports.NoYodaConditions = NoYodaConditions;
//# sourceMappingURL=no_yoda_conditions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/nrob_consistency.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/nrob_consistency.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NROBConsistency = exports.NROBConsistencyConf = void 0;
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
class NROBConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.NROBConsistencyConf = NROBConsistencyConf;
class NROBConsistency {
    constructor() {
        this.conf = new NROBConsistencyConf();
    }
    getMetadata() {
        return {
            key: "nrob_consistency",
            title: "Number range consistency",
            shortDescription: `Consistency checks for number ranges`,
            extendedInformation: `Issue reported if percentage warning is over 50%

Issue reported if the referenced domain is not found(taking error namespace into account)`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof Objects.NumberRange)) {
            return [];
        }
        const issues = [];
        const id = obj.getIdentifier();
        if (id === undefined) {
            return [];
        }
        if (obj.getPercentage() || 0 > 50) {
            const message = "Percentage more than 50";
            issues.push(issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.getConfig().severity));
        }
        const domain = obj.getDomain();
        if (domain
            && this.reg.getObject("DOMA", domain) === undefined
            && this.reg.inErrorNamespace(domain) === true) {
            const message = "Domain " + domain + " not found";
            issues.push(issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.getConfig().severity));
        }
        return [];
    }
}
exports.NROBConsistency = NROBConsistency;
//# sourceMappingURL=nrob_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/object_naming.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/object_naming.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObjectNaming = exports.ObjectNamingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
class ObjectNamingConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** The regex pattern for global class names */
        this.clas = "^ZC(L|X)";
        /** The regex pattern for global interface names */
        this.intf = "^ZIF";
        /** The regex pattern for program (report) names */
        this.prog = "^Z";
        /** The regex pattern for function group names */
        this.fugr = "^Z";
        /** The regex pattern for DDIC table names */
        this.tabl = "^Z";
        /** The regex pattern for DDIC table type names */
        this.ttyp = "^Z";
        /** The regex pattern for data element names */
        this.dtel = "^Z";
        /** The regex pattern for domain names */
        this.doma = "^Z";
        /** The regex pattern for message class names */
        this.msag = "^Z";
        /** The regex pattern for transaction names */
        this.tran = "^Z";
        /** The regex pattern for lock object names */
        this.enqu = "^EZ";
        /** The regex pattern for authorization object names */
        this.auth = "^Z";
        /** The regex pattern for package interface names */
        this.pinf = "^Z";
        /** The regex pattern for idoc names */
        this.idoc = "^Z";
        /** The regex pattern for transformation names */
        this.xslt = "^Z";
        /** The regex pattern for smartform names */
        this.ssfo = "^Z";
        /** The regex pattern for smartstyle names */
        this.ssst = "^Z";
        /** The regex pattern for search helps */
        this.shlp = "^Z";
        /** The regex pattern for BADI Implementation */
        this.sxci = "^Z";
        /** The regex pattern for Enhancement Spot */
        this.enhs = "^Z";
        /** The regex pattern for Enhancement Implementation */
        this.enho = "^Z";
        /** The regex pattern for Customer enhancement projects */
        this.cmod = "^Z";
        /** The regex pattern for SAPscript form */
        this.form = "^Z";
        /** The regex pattern for Adobe Form Definition */
        this.sfpf = "^Z";
        /** The regex pattern for Adobe Interface Definition */
        this.sfpi = "^Z";
        /** The regex pattern for ABAP Query: Query */
        this.aqqu = "^Z";
        /** The regex pattern for ABAP Query: Functional area */
        this.aqsg = "^Z";
        /** The regex pattern for ABAP Query: User group */
        this.aqbg = "^Z";
        /** The regex pattern for Authorization Object */
        this.suso = "^Z";
        /** The regex pattern for Authorization Group */
        this.sucu = "^Z";
        /** The regex pattern for Web Dynpro Application */
        this.wdya = "^Z";
        /** The regex pattern for Web Dynpro Component */
        this.wdyn = "^Z";
    }
}
exports.ObjectNamingConf = ObjectNamingConf;
class ObjectNaming {
    constructor() {
        this.conf = new ObjectNamingConf();
    }
    getMetadata() {
        return {
            key: "object_naming",
            title: "Object naming conventions",
            shortDescription: `Allows you to enforce a pattern, such as a prefix, for object names`,
            tags: [_irule_1.RuleTag.Naming],
        };
    }
    getDescription(expected, actual) {
        return this.conf.patternKind === "required" ?
            "Object name does not match pattern " + expected + ": " + actual :
            "Object name must not match pattern " + expected + ": " + actual;
    }
    getConfig() {
        if (typeof this.conf === "boolean" && this.conf === true) {
            return new ObjectNamingConf();
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        let message = undefined;
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        const abapType = obj.getType().toLowerCase();
        const config = this.getConfig();
        // @ts-ignore
        const pattern = config[abapType];
        if (pattern === undefined) {
            return [];
        }
        const regex = new RegExp(pattern, "i");
        if (name_validator_1.NameValidator.violatesRule(obj.getName(), regex, this.conf)) {
            message = this.getDescription(pattern, obj.getName());
        }
        if (message) {
            return [issue_1.Issue.atRow(obj.getFiles()[0], 1, message, this.getMetadata().key, this.conf.severity)];
        }
        return [];
    }
}
exports.ObjectNaming = ObjectNaming;
//# sourceMappingURL=object_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/obsolete_statement.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/obsolete_statement.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ObsoleteStatement = exports.ObsoleteStatementConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class ObsoleteStatementConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Check for REFRESH statement */
        this.refresh = true;
        /** Check for COMPUTE statement */
        this.compute = true;
        /** Check for ADD statement */
        this.add = true;
        /** Check for SUBTRACT statement */
        this.subtract = true;
        /** Check for MULTIPLY statement */
        this.multiply = true;
        /** Check for DIVIDE statement */
        this.divide = true;
        /** Check for MOVE statement */
        this.move = true;
        /** Checks for usages of IS REQUESTED */
        this.requested = true;
        /** Checks for usages of OCCURS */
        this.occurs = true;
        /** Checks for SET EXTENDED CHECK */
        this.setExtended = true;
        /** Checks for WITH HEADER LINE */
        this.withHeaderLine = true;
        /** Checks for FIELD-SYMBOLS ... STRUCTURE */
        this.fieldSymbolStructure = true;
        /** Checks for TYPE-POOLS */
        this.typePools = true;
        /** Checks for addition LOAD */
        this.load = true;
        /** Checks for PARAMETER */
        this.parameter = true;
        /** Checks for RANGES */
        this.ranges = true;
        /** Checks for COMMUNICATION */
        this.communication = true;
        /** Checks for PACK */
        this.pack = true;
        /** Checks for SELECT without INTO */
        this.selectWithoutInto = true;
        /** FREE MEMORY, without ID */
        this.freeMemory = true;
        /** Checks for EXIT FROM SQL */
        this.exitFromSQL = true;
        /** Checks for SORT itab BY <fs> */
        this.sortByFS = true;
        /** Checks for CALL TRANSFORMATION OBJECTS */
        this.callTransformation = true;
        /** Check for POSIX REGEX usage */
        this.regex = true;
        /** Check for OCCURENCES vs OCCURRENCES usage */
        this.occurences = true;
        /** Check for CLIENT SPECIFIED */
        this.clientSpecified = true;
        /** Check for FORM DEFINITION */
        this.formDefinition = true;
        /** Check for FORM IMPLEMENTATION */
        this.formImplementation = true;
    }
}
exports.ObsoleteStatementConf = ObsoleteStatementConf;
class ObsoleteStatement extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ObsoleteStatementConf();
    }
    getMetadata() {
        return {
            key: "obsolete_statement",
            title: "Obsolete statements",
            shortDescription: `Checks for usages of certain obsolete statements`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix],
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-functional-to-procedural-language-constructs

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-obsolete-language-elements

SET EXTENDED CHECK: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapset_extended_check.htm

IS REQUESTED: https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abenlogexp_requested.htm

WITH HEADER LINE: https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abapdata_header_line.htm

FIELD-SYMBOLS STRUCTURE: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapfield-symbols_obsolete_typing.htm

TYPE-POOLS: from 702, https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abennews-71-program_load.htm

LOAD addition: from 702, https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abennews-71-program_load.htm

COMMUICATION: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapcommunication.htm

OCCURS: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapdata_occurs.htm

PARAMETER: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abapparameter.htm

RANGES: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapranges.htm

PACK: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abappack.htm

MOVE: https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abapmove_obs.htm

SELECT without INTO: https://help.sap.com/doc/abapdocu_731_index_htm/7.31/en-US/abapselect_obsolete.htm
SELECT COUNT(*) is considered okay

FREE MEMORY: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abapfree_mem_id_obsolete.htm

SORT BY FS: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapsort_itab_obsolete.htm

CALL TRANSFORMATION OBJECTS: https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-US/abapcall_transformation_objects.htm

POSIX REGEX: https://help.sap.com/doc/abapdocu_755_index_htm/7.55/en-US/index.htm

OCCURENCES: check for OCCURENCES vs OCCURRENCES

CLIENT SPECIFIED, from 754: https://help.sap.com/doc/abapdocu_latest_index_htm/latest/en-US/index.htm?file=abapselect_client_obsolete.htm`,
            badExample: `REFRESH itab.

COMPUTE foo = 2 + 2.

MULTIPLY lv_foo BY 2.

INTERFACE intf LOAD.

IF foo IS SUPPLIED.
ENDIF.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b, _c;
        const issues = [];
        const statements = file.getStatements();
        let prev = undefined;
        const configVersion = this.reg.getConfig().getVersion();
        for (const staNode of statements) {
            const sta = staNode.get();
            if ((sta instanceof Statements.Refresh && this.conf.refresh)
                || (sta instanceof Statements.Compute && this.conf.compute)
                || (sta instanceof Statements.Add && this.conf.add)
                || (sta instanceof Statements.Subtract && this.conf.subtract)
                || (sta instanceof Statements.ClassDefinitionLoad && this.conf.load && configVersion >= version_1.Version.v702)
                || (sta instanceof Statements.InterfaceLoad && this.conf.load && configVersion >= version_1.Version.v702)
                || (sta instanceof Statements.Multiply && this.conf.multiply)
                || (sta instanceof Statements.Divide && this.conf.divide)
                || (sta instanceof Statements.Move && this.conf.move
                    && staNode.getTokens()[0].getStr().toUpperCase() === "MOVE"
                    && staNode.getTokens()[1].getStr() !== "-"
                    && staNode.getTokens()[1].getStr().toUpperCase() !== "EXACT")) {
                if (prev === undefined || staNode.getStart().getCol() !== prev.getCol() || staNode.getStart().getRow() !== prev.getRow()) {
                    const message = "Statement \"" + staNode.getFirstToken().getStr() + "\" is obsolete";
                    const fix = this.getFix(file, sta, staNode);
                    const issue = issue_1.Issue.atStatement(file, staNode, message, this.getMetadata().key, this.conf.severity, fix);
                    issues.push(issue);
                }
                prev = staNode.getStart();
            }
            if (this.conf.setExtended && sta instanceof Statements.SetExtendedCheck) {
                const issue = issue_1.Issue.atStatement(file, staNode, "SET EXTENDED CHECK is obsolete", this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            if (this.conf.communication && sta instanceof Statements.Communication) {
                const issue = issue_1.Issue.atStatement(file, staNode, "COMMUNICATION is obsolete", this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            if (this.conf.pack && sta instanceof Statements.Pack) {
                const issue = issue_1.Issue.atStatement(file, staNode, "PACK is obsolete", this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            if (this.conf.parameter && sta instanceof Statements.Parameter) {
                const token = staNode.getFirstToken();
                if (token.getStr().toUpperCase() === "PARAMETER") {
                    const fix = edit_helper_1.EditHelper.replaceToken(file, token, "PARAMETERS");
                    const issue = issue_1.Issue.atStatement(file, staNode, "Use PARAMETERS instead of PARAMETER", this.getMetadata().key, this.conf.severity, fix);
                    issues.push(issue);
                }
            }
            if (this.conf.ranges && sta instanceof Statements.Ranges) {
                const children = staNode.getChildren();
                let fix = undefined;
                if (children.length === 5) {
                    const simpleNameString = children[1].concatTokens();
                    const fieldSubString = children[3].concatTokens();
                    const replacement = "TYPES " + simpleNameString + " LIKE RANGE OF " + fieldSubString + ".";
                    fix = edit_helper_1.EditHelper.replaceRange(file, staNode.getStart(), staNode.getEnd(), replacement);
                }
                const issue = issue_1.Issue.atStatement(file, staNode, "Use LIKE RANGE OF instead of RANGES", this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            if (this.conf.selectWithoutInto
                && (sta instanceof Statements.Select || sta instanceof Statements.SelectLoop)
                && staNode.findFirstExpression(Expressions.SQLIntoStructure) === undefined
                && staNode.findFirstExpression(Expressions.SQLIntoList) === undefined
                && staNode.findFirstExpression(Expressions.SQLIntoTable) === undefined) {
                const concat = (_a = staNode.findFirstExpression(Expressions.SQLFieldList)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
                if (concat !== "COUNT(*)" && concat !== "COUNT( * )") {
                    const issue = issue_1.Issue.atStatement(file, staNode, "SELECT without INTO", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.requested && sta instanceof Statements.If) {
                for (const compare of staNode.findAllExpressions(Expressions.Compare)) {
                    const token = compare.findDirectTokenByText("REQUESTED");
                    if (token) {
                        const fix = edit_helper_1.EditHelper.replaceToken(file, token, "SUPPLIED");
                        const issue = issue_1.Issue.atToken(file, token, "IS REQUESTED is obsolete", this.getMetadata().key, this.conf.severity, fix);
                        issues.push(issue);
                    }
                }
            }
            if (this.conf.occurs) {
                if ((sta instanceof Statements.Describe)
                    || (sta instanceof Statements.Ranges)
                    || (sta instanceof Statements.DataBegin)
                    || (sta instanceof Statements.TypeBegin)) {
                    const token = staNode.findDirectTokenByText("OCCURS");
                    if (token) {
                        const issue = issue_1.Issue.atToken(file, token, "OCCURS is obsolete", this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
                for (const dataDef of staNode.findAllExpressions(Expressions.DataDefinition)) {
                    const token = (_b = dataDef.findDirectExpression(Expressions.TypeTable)) === null || _b === void 0 ? void 0 : _b.findDirectTokenByText("OCCURS");
                    if (token) {
                        const issue = issue_1.Issue.atToken(file, token, "OCCURS is obsolete", this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
            }
            if (this.conf.withHeaderLine === true && sta instanceof Statements.Data) {
                if (staNode.concatTokens().toUpperCase().includes("WITH HEADER LINE")) {
                    const token = staNode.getTokens().find(t => t.getStr().toUpperCase() === "WITH");
                    if (token) {
                        const issue = issue_1.Issue.atToken(file, token, "WITH HEADER LINE is obsolete", this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
            }
            if (this.conf.fieldSymbolStructure && sta instanceof Statements.FieldSymbol) {
                const token = staNode.findDirectTokenByText("STRUCTURE");
                if (token) {
                    const issue = issue_1.Issue.atToken(file, token, "FIELD-SYMBOLS ... STRUCTURE is obsolete", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.typePools && sta instanceof Statements.TypePools && configVersion >= version_1.Version.v702) {
                const fix = edit_helper_1.EditHelper.deleteStatement(file, staNode);
                const issue = issue_1.Issue.atStatement(file, staNode, "Statement \"TYPE-POOLS\" is obsolete", this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            if (this.conf.freeMemory && sta instanceof Statements.FreeMemory) {
                const concat = staNode.concatTokens().toUpperCase();
                if (concat === "FREE MEMORY.") {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Statement \"FREE MEMORY\" without ID is obsolete", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.exitFromSQL && sta instanceof Statements.Exit) {
                const concat = staNode.concatTokens().toUpperCase();
                if (concat === "EXIT FROM SQL.") {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Statement \"EXIT FROM SQL\" is obsolete", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.sortByFS && sta instanceof Statements.Sort) {
                const afterBy = staNode.findExpressionAfterToken("BY");
                if (afterBy instanceof nodes_1.ExpressionNode && afterBy.get() instanceof expressions_1.SourceFieldSymbol) {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Statement \"SORT itab BY <fs>\" is obsolete", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.callTransformation && sta instanceof Statements.CallTransformation) {
                const objects = staNode.findExpressionAfterToken("OBJECTS");
                if (objects) {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Use PARAMETERS instead of OBJECTS", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.occurences && sta instanceof Statements.Replace) {
                const concat = staNode.concatTokens().toUpperCase();
                if (concat.includes(" OCCURENCES ")) {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Use \"OCCURRENCES\"", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (this.conf.formDefinition && sta instanceof Statements.FormDefinition) {
                const issue = issue_1.Issue.atStatement(file, staNode, "FORM DEFINITION", this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            if (this.conf.formImplementation && sta instanceof Statements.Form) {
                if (staNode.findDirectTokenByText("IMPLEMENTATION")) {
                    const issue = issue_1.Issue.atStatement(file, staNode, "FORM IMPLEMENTATION", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (configVersion >= version_1.Version.v754 && this.conf.clientSpecified
                && (sta instanceof Statements.Select
                    || sta instanceof Statements.SelectLoop
                    || sta instanceof Statements.DeleteDatabase
                    || sta instanceof Statements.InsertDatabase
                    || sta instanceof Statements.ModifyDatabase
                    || sta instanceof Statements.UpdateDatabase)) {
                const concat = staNode.concatTokens().toUpperCase();
                if (concat.includes(" CLIENT SPECIFIED")) {
                    const issue = issue_1.Issue.atStatement(file, staNode, "Use USING CLIENT", this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
            if (configVersion >= version_1.Version.v756 && this.conf.regex) {
                if (sta instanceof Statements.Find || sta instanceof Statements.Replace) {
                    if ((_c = staNode.findFirstExpression(Expressions.FindType)) === null || _c === void 0 ? void 0 : _c.concatTokens().includes("REGEX")) {
                        const issue = issue_1.Issue.atStatement(file, staNode, "REGEX obsolete, use PCRE", this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
                else {
                    const classNameExpression = staNode.findAllExpressions(Expressions.ClassName);
                    const methodNameExpression = staNode.findAllExpressions(Expressions.MethodName);
                    if (classNameExpression.length !== 0 && methodNameExpression.length !== 0) {
                        const className = classNameExpression[0].concatTokens();
                        const methodName = methodNameExpression[0].concatTokens();
                        if (className === "cl_abap_regex") {
                            if (methodName === "create_posix") {
                                const issue = issue_1.Issue.atStatement(file, staNode, "create_posix obsolete, use create_pcre", this.getMetadata().key, this.conf.severity);
                                issues.push(issue);
                            }
                        }
                        else if (className === "cl_abap_matcher") {
                            if (methodName.includes("posix")) {
                                const issue = issue_1.Issue.atStatement(file, staNode, "posix methods obsolete, use pcre methods", this.getMetadata().key, this.conf.severity);
                                issues.push(issue);
                            }
                        }
                    }
                }
            }
        }
        return issues;
    }
    getFix(file, statement, statementNode) {
        if (statement instanceof Statements.Refresh) {
            if (statementNode.getChildren().length === 6) {
                return undefined;
            }
            return edit_helper_1.EditHelper.replaceToken(file, statementNode.getFirstToken(), "CLEAR");
        }
        else if (statement instanceof Statements.Compute) {
            const children = statementNode.getChildren();
            if (children.length === 5) {
                const tokenForDeletion = statementNode.getFirstToken();
                let endPosition = tokenForDeletion.getEnd();
                endPosition = new position_1.Position(endPosition.getRow(), endPosition.getCol() + 1);
                return edit_helper_1.EditHelper.deleteRange(file, tokenForDeletion.getStart(), endPosition);
            }
            else {
                const targetString = children[2].concatTokens();
                const sourceString = children[4].concatTokens();
                const replacement = targetString + " = EXACT #( " + sourceString + " ).";
                return edit_helper_1.EditHelper.replaceRange(file, statementNode.getStart(), statementNode.getEnd(), replacement);
            }
        }
        else if (statement instanceof Statements.Add ||
            statement instanceof Statements.Subtract) {
            const children = statementNode.getChildren();
            const sourceString = children[1].concatTokens();
            const targetString = children[3].concatTokens();
            let replacement = "";
            if (statement instanceof Statements.Add) {
                replacement = targetString + " = " + targetString + " + " + sourceString + ".";
            }
            else if (statement instanceof Statements.Subtract) {
                replacement = targetString + " = " + targetString + " - " + sourceString + ".";
            }
            return edit_helper_1.EditHelper.replaceRange(file, statementNode.getStart(), statementNode.getEnd(), replacement);
        }
        else if (statement instanceof Statements.Multiply ||
            statement instanceof Statements.Divide) {
            const children = statementNode.getChildren();
            const targetString = children[1].concatTokens();
            const sourceString = children[3].concatTokens();
            let replacement = "";
            if (statement instanceof Statements.Multiply) {
                replacement = targetString + " = " + targetString + " * " + sourceString + ".";
            }
            else if (statement instanceof Statements.Divide) {
                replacement = targetString + " = " + targetString + " / " + sourceString + ".";
            }
            return edit_helper_1.EditHelper.replaceRange(file, statementNode.getStart(), statementNode.getEnd(), replacement);
        }
        else if (statement instanceof Statements.Move) {
            if (statementNode.getColon() !== undefined) {
                return undefined;
            }
            const children = statementNode.getChildren();
            const sourceString = children[1].concatTokens();
            const targetString = children[3].concatTokens();
            let operator = children[2].concatTokens().toUpperCase();
            if (operator === "TO") {
                operator = " = ";
            }
            else {
                operator = " ?= ";
            }
            const replacement = targetString + operator + sourceString + ".";
            return edit_helper_1.EditHelper.replaceRange(file, statementNode.getStart(), statementNode.getEnd(), replacement);
        }
        else if (statement instanceof Statements.ClassDefinitionLoad ||
            statement instanceof Statements.InterfaceLoad) {
            let token = undefined;
            if (statement instanceof Statements.ClassDefinitionLoad) {
                token = statementNode.getChildren()[3].getFirstToken();
            }
            else {
                token = statementNode.getChildren()[2].getFirstToken();
            }
            let startPosition = token.getStart();
            startPosition = new position_1.Position(startPosition.getRow(), startPosition.getCol() - 1);
            return edit_helper_1.EditHelper.deleteRange(file, startPosition, token.getEnd());
        }
        return undefined;
    }
}
exports.ObsoleteStatement = ObsoleteStatement;
//# sourceMappingURL=obsolete_statement.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/omit_parameter_name.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/omit_parameter_name.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmitParameterName = exports.OmitParameterNameConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const method_definition_1 = __webpack_require__(/*! ../abap/types/method_definition */ "./node_modules/@abaplint/core/build/src/abap/types/method_definition.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _builtin_1 = __webpack_require__(/*! ../abap/5_syntax/_builtin */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_builtin.js");
class OmitParameterNameConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.OmitParameterNameConf = OmitParameterNameConf;
class OmitParameterName {
    constructor() {
        this.conf = new OmitParameterNameConf();
    }
    getMetadata() {
        return {
            key: "omit_parameter_name",
            title: "Omit parameter name",
            shortDescription: `Omit the parameter name in single parameter calls`,
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#omit-the-parameter-name-in-single-parameter-calls

EXPORTING must already be omitted for this rule to take effect, https://rules.abaplint.org/exporting/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix],
            badExample: `method( param = 2 ).`,
            goodExample: `method( 2 ).`,
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        var _a, _b;
        const issues = [];
        if (!(obj instanceof _abap_object_1.ABAPObject) || obj.getType() === "INTF") {
            return [];
        }
        const spaghetti = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
        for (const file of obj.getABAPFiles()) {
            const stru = file.getStructure();
            if (stru === undefined) {
                continue;
            }
            for (const c of stru.findAllExpressions(Expressions.MethodCall)) {
                if (c.findFirstExpression(Expressions.MethodParameters)) {
                    continue;
                }
                // hmm, this will break for nested method calls?
                const parameters = c.findAllExpressions(Expressions.ParameterS);
                if (parameters.length > 1 || parameters.length === 0) {
                    continue;
                }
                const name = c.findDirectExpression(Expressions.MethodName);
                if (name === undefined) {
                    continue;
                }
                const param = c.findDirectExpression(Expressions.MethodCallParam);
                if (param === undefined) {
                    continue;
                }
                const ref = this.findMethodReference(name.getFirstToken(), spaghetti, file.getFilename());
                if (ref === undefined) {
                    continue;
                }
                const i = ref.getDefaultImporting();
                if (i === undefined) {
                    continue;
                }
                const p = (_a = parameters[0].findDirectExpression(Expressions.ParameterName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                if ((p === null || p === void 0 ? void 0 : p.getStr().toUpperCase()) === i.toUpperCase()) {
                    const message = "Omit default parameter name \"" + i + "\"";
                    const end = (_b = parameters[0].findDirectExpression(Expressions.Source)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStart();
                    if (end) {
                        const fix = edit_helper_1.EditHelper.deleteRange(file, p.getStart(), end);
                        issues.push(issue_1.Issue.atRange(file, p.getStart(), end, message, this.getMetadata().key, this.getConfig().severity, fix));
                    }
                    else {
                        issues.push(issue_1.Issue.atToken(file, name.getFirstToken(), message, this.getMetadata().key, this.getConfig().severity));
                    }
                }
            }
        }
        return issues;
    }
    ///////////////////
    findMethodReference(token, spaghetti, filename) {
        const scope = spaghetti.lookupPosition(token.getStart(), filename);
        if (scope === undefined) {
            return undefined;
        }
        for (const r of scope.getData().references) {
            if (r.referenceType !== _reference_1.ReferenceType.MethodReference
                && r.referenceType !== _reference_1.ReferenceType.BuiltinMethodReference) {
                continue;
            }
            else if (r.position.getStart().equals(token.getStart())) {
                if (r.resolved instanceof _builtin_1.BuiltInMethod) {
                    return r.resolved;
                }
                else if (r.resolved instanceof method_definition_1.MethodDefinition) {
                    return r.resolved.getParameters();
                }
            }
        }
        return undefined;
    }
}
exports.OmitParameterName = OmitParameterName;
//# sourceMappingURL=omit_parameter_name.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/omit_preceding_zeros.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/omit_preceding_zeros.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmitPrecedingZeros = exports.OmitPrecedingZerosConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class OmitPrecedingZerosConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.OmitPrecedingZerosConf = OmitPrecedingZerosConf;
class OmitPrecedingZeros extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new OmitPrecedingZerosConf();
    }
    getMetadata() {
        return {
            key: "omit_preceding_zeros",
            title: "Omit preceding zeros",
            shortDescription: `Omit preceding zeros from integer constants`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `int = -001.`,
            goodExample: `int = -1.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        const message = "Omit preceding zeros";
        for (const s of file.getStatements()) {
            for (const i of s.findAllExpressions(Expressions.Integer)) {
                const token = i.getLastToken();
                const str = token.getStr();
                if (str.length > 1 && str.startsWith("0")) {
                    if (s.get() instanceof statements_1.CallScreen || s.get() instanceof statements_1.SetScreen) {
                        continue;
                    }
                    const replace = str.replace(/^0+/, "");
                    const fix = edit_helper_1.EditHelper.replaceRange(file, token.getStart(), token.getEnd(), replace);
                    const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.getConfig().severity, fix);
                    issues.push(issue);
                }
            }
            for (const i of s.findAllExpressions(Expressions.ParameterException)) {
                const token = (_a = i.findDirectExpression(Expressions.SimpleName)) === null || _a === void 0 ? void 0 : _a.getFirstToken();
                const str = token === null || token === void 0 ? void 0 : token.getStr();
                if (token && str && str.length > 1 && str.startsWith("0")) {
                    const replace = str.replace(/^0+/, "");
                    const fix = edit_helper_1.EditHelper.replaceRange(file, token.getStart(), token.getEnd(), replace);
                    const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.getConfig().severity, fix);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.OmitPrecedingZeros = OmitPrecedingZeros;
//# sourceMappingURL=omit_preceding_zeros.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/omit_receiving.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/omit_receiving.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.OmitReceiving = exports.OmitReceivingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
class OmitReceivingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.OmitReceivingConf = OmitReceivingConf;
class OmitReceiving extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new OmitReceivingConf();
    }
    getMetadata() {
        return {
            key: "omit_receiving",
            title: "Omit RECEIVING",
            shortDescription: `Omit RECEIVING`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#omit-receiving`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `
      upload_pack(
        EXPORTING
          io_client       = lo_client
          iv_url          = iv_url
          iv_deepen_level = iv_deepen_level
          it_hashes       = lt_hashes
        RECEIVING
          rt_objects      = et_objects ).`,
            goodExample: `
      et_objects = upload_pack(
        io_client       = lo_client
        iv_url          = iv_url
        iv_deepen_level = iv_deepen_level
        it_hashes       = lt_hashes ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        for (const e of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.MethodCallParam)) || []) {
            const p = e.findDirectExpression(Expressions.MethodParameters);
            if (p === undefined) {
                continue;
            }
            const r = p.findDirectTokenByText("RECEIVING");
            if (r === undefined) {
                continue;
            }
            const ex = p.findDirectTokenByText("EXCEPTIONS");
            if (ex !== undefined) {
                continue;
            }
            issues.push(issue_1.Issue.atToken(file, r, "Omit RECEIVING", this.getMetadata().key, this.getConfig().severity));
        }
        return issues;
    }
}
exports.OmitReceiving = OmitReceiving;
//# sourceMappingURL=omit_receiving.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/parser_702_chaining.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/parser_702_chaining.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Parser702Chaining = exports.Parser702ChainingConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class Parser702ChainingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.Parser702ChainingConf = Parser702ChainingConf;
class Parser702Chaining extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new Parser702ChainingConf();
    }
    getMetadata() {
        return {
            key: "parser_702_chaining",
            title: "Parser Error, bad chanining on 702",
            shortDescription: `ABAP on 702 does not allow for method chaining with IMPORTING/EXPORTING/CHANGING keywords,
this rule finds these and reports errors.
Only active on target version 702 and below.`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (this.reg.getConfig().getVersion() !== version_1.Version.v702
            && this.reg.getConfig().getVersion() !== version_1.Version.v700) {
            return [];
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const chain of stru.findAllExpressions(Expressions.MethodCallChain)) {
            const calls = chain.findDirectExpressions(Expressions.MethodCall);
            if (calls.length < 2) {
                continue;
            }
            for (const call of calls) {
                const callParam = call.findDirectExpression(Expressions.MethodCallParam);
                if (callParam === undefined) {
                    continue;
                }
                const param = callParam.findDirectExpression(Expressions.MethodParameters);
                if (param === undefined) {
                    continue;
                }
                if (param.findDirectTokenByText("IMPORTING")
                    || param.findDirectTokenByText("CHANGING")
                    || param.findDirectTokenByText("EXCEPTIONS")) {
                    const message = "This kind of method chaining not possible in 702";
                    const issue = issue_1.Issue.atPosition(file, param.getFirstToken().getStart(), message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.Parser702Chaining = Parser702Chaining;
//# sourceMappingURL=parser_702_chaining.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/parser_error.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/parser_error.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParserError = exports.ParserErrorConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const statement_parser_1 = __webpack_require__(/*! ../abap/2_statements/statement_parser */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statement_parser.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class ParserErrorConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ParserErrorConf = ParserErrorConf;
class ParserError {
    constructor() {
        this.conf = new ParserErrorConf();
    }
    getMetadata() {
        return {
            key: "parser_error",
            title: "Parser error",
            shortDescription: `Checks for syntax not recognized by abaplint.

See recognized syntax at https://syntax.abaplint.org`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.SingleFile],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        const issues = [];
        issues.push(...obj.getParsingIssues());
        if (obj instanceof _abap_object_1.ABAPObject) {
            for (const file of obj.getABAPFiles()) {
                for (const statement of file.getStatements()) {
                    if (!(statement.get() instanceof _statement_1.Unknown)) {
                        continue;
                    }
                    if (statement.getTokens().length > statement_parser_1.STATEMENT_MAX_TOKENS) {
                        const message = "Statement too long, refactor statement";
                        const issue = issue_1.Issue.atToken(file, statement.getTokens()[0], message, this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                    else {
                        const tok = statement.getFirstToken();
                        const message = "Statement does not exist in ABAP" + this.reg.getConfig().getVersion() + "(or a parser error), \"" + tok.getStr() + "\"";
                        const issue = issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
                if (this.reg.getConfig().getVersion() === version_1.Version.v700) {
                    for (const statement of file.getStatements()) {
                        if (statement.getPragmas().length > 0) {
                            const message = "Pragmas not allowed in v700";
                            const issue = issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity);
                            issues.push(issue);
                        }
                    }
                }
            }
        }
        return issues;
    }
}
exports.ParserError = ParserError;
//# sourceMappingURL=parser_error.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/parser_missing_space.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/parser_missing_space.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ParserMissingSpace = exports.ParserMissingSpaceConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
// todo: this rule needs refactoring
class ParserMissingSpaceConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ParserMissingSpaceConf = ParserMissingSpaceConf;
class ParserMissingSpace extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ParserMissingSpaceConf();
    }
    getMetadata() {
        return {
            key: "parser_missing_space",
            title: "Parser Error, missing space",
            shortDescription: `In special cases the ABAP language allows for not having spaces before or after string literals.
This rule makes sure the spaces are consistently required across the language.`,
            tags: [_irule_1.RuleTag.Syntax, _irule_1.RuleTag.Whitespace, _irule_1.RuleTag.SingleFile],
            badExample: `IF ( foo = 'bar').`,
            goodExample: `IF ( foo = 'bar' ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let start = new position_1.Position(0, 0);
        for (const statement of file.getStatements()) {
            const missing = this.missingSpace(statement);
            if (missing) {
                const message = "Missing space between string or character literal and parentheses";
                start = missing;
                const issue = issue_1.Issue.atPosition(file, start, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
    missingSpace(statement) {
        const found = statement.findAllExpressionsMulti([
            Expressions.CondSub, Expressions.SQLCond, Expressions.ValueBodyLine,
            Expressions.NewObject, Expressions.Cond, Expressions.ComponentCond,
            Expressions.Source,
            Expressions.ComponentCondSub, Expressions.MethodCallParam
        ], true);
        let pos = undefined;
        for (const f of found) {
            const type = f.get();
            if (type instanceof Expressions.Cond) {
                pos = this.checkCond(f);
            }
            else if (type instanceof Expressions.Source) {
                pos = this.checkSource(f);
            }
            else if (type instanceof Expressions.CondSub) {
                pos = this.checkCondSub(f);
            }
            else if (type instanceof Expressions.ComponentCond) {
                pos = this.checkComponentCond(f);
            }
            else if (type instanceof Expressions.ComponentCondSub) {
                pos = this.checkComponentCondSub(f);
            }
            else if (type instanceof Expressions.SQLCond) {
                pos = this.checkSQLCond(f);
            }
            else if (type instanceof Expressions.ValueBodyLine) {
                pos = this.checkValueBodyLine(f);
            }
            else if (type instanceof Expressions.NewObject) {
                pos = this.checkNewObject(f);
            }
            else if (type instanceof Expressions.MethodCallParam) {
                pos = this.checkMethodCallParam(f);
            }
            if (pos) {
                return pos;
            }
        }
        return undefined;
    }
    checkSQLCond(cond) {
        const children = cond.getChildren();
        for (let i = 0; i < children.length; i++) {
            if (children[i].get() instanceof Expressions.SQLCond) {
                const current = children[i];
                const prev = children[i - 1].getLastToken();
                const next = children[i + 1].getFirstToken();
                if (prev.getStr() === "("
                    && prev.getRow() === current.getFirstToken().getRow()
                    && prev.getCol() + 1 === current.getFirstToken().getStart().getCol()) {
                    return current.getFirstToken().getStart();
                }
                if (next.getStr() === ")"
                    && next.getRow() === current.getLastToken().getRow()
                    && next.getCol() === current.getLastToken().getEnd().getCol()) {
                    return current.getLastToken().getEnd();
                }
            }
        }
        return undefined;
    }
    checkNewObject(cond) {
        const children = cond.getChildren();
        {
            const first = children[children.length - 2].getLastToken();
            const second = children[children.length - 1].getFirstToken();
            if (first.getRow() === second.getRow()
                && first.getEnd().getCol() === second.getStart().getCol()) {
                return second.getStart();
            }
        }
        return undefined;
    }
    checkCondSub(cond) {
        const children = cond.getChildren();
        for (let i = 0; i < children.length; i++) {
            if (children[i].get() instanceof Expressions.Cond) {
                const current = children[i];
                const prev = children[i - 1].getLastToken();
                const next = children[i + 1].getFirstToken();
                if (prev.getStr() === "("
                    && prev.getRow() === current.getFirstToken().getRow()
                    && prev.getCol() + 1 === current.getFirstToken().getStart().getCol()) {
                    return current.getFirstToken().getStart();
                }
                if (next.getStr() === ")"
                    && next.getRow() === current.getLastToken().getRow()
                    && next.getCol() === current.getLastToken().getEnd().getCol()) {
                    return current.getLastToken().getEnd();
                }
            }
        }
        return undefined;
    }
    checkComponentCondSub(cond) {
        const children = cond.getChildren();
        for (let i = 0; i < children.length; i++) {
            if (children[i].get() instanceof Expressions.ComponentCond) {
                const current = children[i];
                const prev = children[i - 1].getLastToken();
                const next = children[i + 1].getFirstToken();
                if (prev.getStr() === "("
                    && prev.getRow() === current.getFirstToken().getRow()
                    && prev.getCol() + 1 === current.getFirstToken().getStart().getCol()) {
                    return current.getFirstToken().getStart();
                }
                if (next.getStr() === ")"
                    && next.getRow() === current.getLastToken().getRow()
                    && next.getCol() === current.getLastToken().getEnd().getCol()) {
                    return current.getLastToken().getEnd();
                }
            }
        }
        return undefined;
    }
    checkComponentCond(cond) {
        const children = cond.getAllTokens();
        for (let i = 0; i < children.length - 1; i++) {
            const current = children[i];
            const next = children[i + 1];
            if (next.getStr().startsWith("'")
                && next.getRow() === current.getRow()
                && next.getCol() === current.getEnd().getCol()) {
                return current.getEnd();
            }
        }
        return undefined;
    }
    checkValueBodyLine(vb) {
        var _a, _b;
        const children = vb.getChildren();
        for (let i = 0; i < children.length; i++) {
            const current = children[i];
            if (current instanceof nodes_1.TokenNode) {
                const prev = (_a = children[i - 1]) === null || _a === void 0 ? void 0 : _a.getLastToken();
                const next = (_b = children[i + 1]) === null || _b === void 0 ? void 0 : _b.getFirstToken();
                if (current.getFirstToken().getStr() === "("
                    && next
                    && next.getRow() === current.getLastToken().getRow()
                    && next.getCol() === current.getLastToken().getEnd().getCol()) {
                    return current.getFirstToken().getStart();
                }
                if (current.getFirstToken().getStr() === ")"
                    && prev
                    && prev.getRow() === current.getFirstToken().getRow()
                    && prev.getEnd().getCol() === current.getFirstToken().getStart().getCol()) {
                    return current.getLastToken().getEnd();
                }
            }
        }
        return undefined;
    }
    checkCond(cond) {
        const children = cond.getAllTokens();
        for (let i = 0; i < children.length - 1; i++) {
            const current = children[i];
            const next = children[i + 1];
            if (next.getStr().startsWith("'")
                && next.getRow() === current.getRow()
                && next.getCol() === current.getEnd().getCol()) {
                return current.getEnd();
            }
        }
        return undefined;
    }
    checkSource(cond) {
        const children = cond.getAllTokens();
        if (children.length < 2) {
            return undefined;
        }
        if (children.length >= 4
            && children[0].getStr().toUpperCase() === "CONV") {
            const first = children[2];
            const second = children[3];
            if (first.getRow() === second.getRow()
                && first.getCol() + 1 === second.getStart().getCol()) {
                return second.getStart();
            }
        }
        {
            const nextLast = children[children.length - 2];
            const last = children[children.length - 1];
            if (nextLast.getStr().startsWith("'")
                && nextLast.getRow() === last.getRow()
                && nextLast.getEnd().getCol() === last.getStart().getCol()) {
                return last.getEnd();
            }
        }
        return undefined;
    }
    checkMethodCallParam(call) {
        const children = call.getChildren();
        {
            const first = children[0].getFirstToken();
            const second = children[1].getFirstToken();
            if (first.getRow() === second.getRow()
                && first.getCol() + 1 === second.getStart().getCol()) {
                return second.getStart();
            }
        }
        {
            const first = children[children.length - 2].getLastToken();
            const second = children[children.length - 1].getFirstToken();
            if (first.getRow() === second.getRow()
                && first.getEnd().getCol() === second.getStart().getCol()) {
                return second.getStart();
            }
        }
        return undefined;
    }
}
exports.ParserMissingSpace = ParserMissingSpace;
//# sourceMappingURL=parser_missing_space.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/pragma_style.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/pragma_style.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PragmaStyle = exports.PragmaStyleConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const keyword_case_1 = __webpack_require__(/*! ./keyword_case */ "./node_modules/@abaplint/core/build/src/rules/keyword_case.js");
class PragmaStyleConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.style = keyword_case_1.KeywordCaseStyle.Upper;
    }
}
exports.PragmaStyleConf = PragmaStyleConf;
class PragmaStyle extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PragmaStyleConf();
    }
    getMetadata() {
        return {
            key: "pragma_style",
            title: "Pragma Style",
            shortDescription: `Check pragmas placement and case`,
            tags: [_irule_1.RuleTag.SingleFile],
            extendedInformation: `https://help.sap.com/doc/abapdocu_cp_index_htm/CLOUD/en-US/abenpragma.htm`,
            badExample: `DATA field ##NO_TEXT TYPE i.`,
            goodExample: `DATA field TYPE i ##NO_TEXT.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.style === undefined) {
            this.conf.style = keyword_case_1.KeywordCaseStyle.Upper;
        }
    }
    runParsed(file) {
        const issues = [];
        for (const s of file.getStatements()) {
            if (s.getPragmas().length === 0) {
                continue;
            }
            for (const p of s.getPragmas()) {
                const children = s.getChildren();
                if (children.length === 1) {
                    break; // empty statement with pragma
                }
                if (children[children.length - 2].getLastToken().getStart().isAfter(p.getStart())) {
                    const message = "Place pragma at end of statement";
                    const issue = issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                    continue; // max one finding per statement
                }
                if (this.conf.style === keyword_case_1.KeywordCaseStyle.Upper && p.getStr() !== p.getStr().toUpperCase()) {
                    const message = "Upper case pragmas";
                    const issue = issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                else if (this.conf.style === keyword_case_1.KeywordCaseStyle.Lower && p.getStr() !== p.getStr().toLowerCase()) {
                    const message = "Lower case pragmas";
                    const issue = issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.PragmaStyle = PragmaStyle;
//# sourceMappingURL=pragma_style.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_corresponding.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_corresponding.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferCorresponding = exports.PreferCorrespondingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class PreferCorrespondingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferCorrespondingConf = PreferCorrespondingConf;
class PreferCorresponding extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferCorrespondingConf();
    }
    getMetadata() {
        return {
            key: "prefer_corresponding",
            title: "Prefer corresponding( ) to MOVE-CORRESPONDING",
            shortDescription: `Prefer corresponding( ) to MOVE-CORRESPONDING, from v740sp05 and up`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-functional-to-procedural-language-constructs`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Upport, _irule_1.RuleTag.Styleguide],
            badExample: `MOVE-CORRESPONDING foo TO bar.`,
            goodExample: `bar = CORRESPONDING #( foo ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp05) {
            return issues;
        }
        const message = "Use CORRESPONDING type( ... ) instead of MOVE-CORRESPONDING";
        for (const stat of file.getStatements()) {
            if (stat.get() instanceof Statements.MoveCorresponding
                && stat.getChildren().length === 7) {
                issues.push(issue_1.Issue.atStatement(file, stat, message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.PreferCorresponding = PreferCorresponding;
//# sourceMappingURL=prefer_corresponding.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_inline.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_inline.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferInline = exports.PreferInlineConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class PreferInlineConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferInlineConf = PreferInlineConf;
class PreferInline {
    constructor() {
        this.conf = new PreferInlineConf();
    }
    getMetadata() {
        return {
            key: "prefer_inline",
            title: "Prefer Inline Declarations",
            shortDescription: `Prefer inline to up-front declarations.`,
            extendedInformation: `EXPERIMENTAL

Activates if language version is v740sp02 or above.

Variables must be local(METHOD or FORM).

No generic or void typed variables. No syntax errors.

First position used must be a full/pure write.

Move statment is not a cast(?=)

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-inline-to-up-front-declarations`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Upport, _irule_1.RuleTag.Experimental, _irule_1.RuleTag.Quickfix],
            badExample: `DATA foo TYPE i.
foo = 2.
DATA percentage TYPE decfloat34.
percentage = ( comment_number / abs_statement_number ) * 100.`,
            goodExample: `DATA(foo) = 2.
DATA(percentage) = CONV decfloat34( comment_number / abs_statement_number ) * 100.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (obj.getType() === "INTF") {
            return [];
        }
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp02 && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        else if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const run = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (run.issues.length > 0) {
            return [];
        }
        const scopes = this.findScopeCandidates(run.spaghetti.getTop());
        const ret = [];
        for (const s of scopes) {
            ret.push(...this.analyzeScope(s, obj));
        }
        return ret;
    }
    ///////////////////////////
    analyzeScope(node, obj) {
        var _a, _b;
        const ret = [];
        const vars = node.getData().vars;
        for (const name in vars) {
            const identifier = vars[name];
            if (this.isLocalDefinition(node, identifier) === false
                || identifier.getMeta().includes("inline" /* IdentifierMeta.InlineDefinition */)
                || identifier.getMeta().includes("form_parameter" /* IdentifierMeta.FormParameter */)) {
                continue;
            }
            else if (identifier.getType().isGeneric() === true) {
                continue;
            }
            else if (identifier.getType().containsVoid() === true) {
                continue;
            }
            const write = this.firstUseIsWrite(node, identifier);
            if (write === undefined) {
                continue;
            }
            // check that it is a pure write, eg not sub component assignment
            const next = this.findNextToken(write, obj);
            if (next === undefined) {
                continue;
            }
            else if ((next === null || next === void 0 ? void 0 : next.getStart().equals(write.position.getEnd())) && next.getStr() !== "." && next.getStr() !== ",") {
                continue;
            }
            const file = obj.getABAPFileByName(identifier.getFilename());
            const writeStatement = edit_helper_1.EditHelper.findStatement(next, file);
            const statementType = writeStatement === null || writeStatement === void 0 ? void 0 : writeStatement.get();
            if (statementType === undefined) {
                continue;
            }
            // for now only allow some specific target statements, todo refactor
            if (!(statementType instanceof Statements.Move
                || statementType instanceof Statements.Catch
                || statementType instanceof Statements.ReadTable
                || statementType instanceof Statements.Loop)
                || ((_a = writeStatement === null || writeStatement === void 0 ? void 0 : writeStatement.concatTokens()) === null || _a === void 0 ? void 0 : _a.includes("?="))
                || ((_b = writeStatement === null || writeStatement === void 0 ? void 0 : writeStatement.concatTokens()) === null || _b === void 0 ? void 0 : _b.includes(" #("))) {
                continue;
            }
            const statement = edit_helper_1.EditHelper.findStatement(identifier.getToken(), file);
            const concat = statement === null || statement === void 0 ? void 0 : statement.concatTokens().toUpperCase();
            if (concat === null || concat === void 0 ? void 0 : concat.includes("BEGIN OF")) {
                continue;
            }
            let fix = undefined;
            if (file && statement) {
                const fix1 = edit_helper_1.EditHelper.deleteStatement(file, statement);
                const name = identifier.getName();
                const replace = name.startsWith("<") ? "FIELD-SYMBOL(" + name + ")" : "DATA(" + name + ")";
                const fix2 = edit_helper_1.EditHelper.replaceRange(file, write.position.getStart(), write.position.getEnd(), replace);
                fix = edit_helper_1.EditHelper.merge(fix1, fix2);
            }
            const message = this.getMetadata().title + ", " + name;
            ret.push(issue_1.Issue.atIdentifier(identifier, message, this.getMetadata().key, this.conf.severity, fix));
        }
        return ret;
    }
    ////////////////////////
    findNextToken(ref, obj) {
        const file = obj.getABAPFileByName(ref.resolved.getFilename());
        if (file === undefined) {
            return undefined;
        }
        for (const t of file.getTokens()) {
            if (t.getStart().isAfter(ref.position.getEnd())) {
                return t;
            }
        }
        return undefined;
    }
    firstUseIsWrite(node, identifier) {
        // assumption: variables are local, so only the current scope must be searched
        var _a, _b, _c;
        for (const r of node.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.TypeReference
                && ((_a = r.resolved) === null || _a === void 0 ? void 0 : _a.getStart().equals(identifier.getStart())) === true) {
                return undefined;
            }
        }
        let firstRead = undefined;
        for (const r of node.getData().references) {
            if (r.referenceType !== _reference_1.ReferenceType.DataReadReference
                || ((_b = r.resolved) === null || _b === void 0 ? void 0 : _b.getStart().equals(identifier.getStart())) === false) {
                continue;
            }
            if (r.resolved) {
                firstRead = { position: r.position, resolved: r.resolved };
                break;
            }
        }
        let firstWrite = undefined;
        for (const w of node.getData().references) {
            if (w.referenceType !== _reference_1.ReferenceType.DataWriteReference
                || ((_c = w.resolved) === null || _c === void 0 ? void 0 : _c.getStart().equals(identifier.getStart())) === false) {
                continue;
            }
            if (w.resolved) {
                firstWrite = { position: w.position, resolved: w.resolved };
                break;
            }
        }
        if (firstRead === undefined) {
            return firstWrite;
        }
        else if (firstWrite === undefined) {
            return undefined;
        }
        else if (firstWrite.position.getStart().getRow() === firstRead.position.getStart().getRow()) {
            // if the same statement both reads and write the same variable
            // note that currently just the line number is compared, this is not correct, it should check if its the same statement
            return undefined;
        }
        else if (firstWrite.position.getStart().isBefore(firstRead.position.getStart())) {
            return firstWrite;
        }
        return undefined;
    }
    isLocalDefinition(node, identifier) {
        const { start, end } = node.calcCoverage();
        if (identifier.getStart().isAfter(start) && identifier.getStart().isBefore(end)) {
            return true;
        }
        else {
            return false;
        }
    }
    findScopeCandidates(node) {
        if (node.getIdentifier().stype === _scope_type_1.ScopeType.Form
            || node.getIdentifier().stype === _scope_type_1.ScopeType.Method) {
            return [node];
        }
        let ret = [];
        for (const c of node.getChildren()) {
            ret = ret.concat(this.findScopeCandidates(c));
        }
        return ret;
    }
}
exports.PreferInline = PreferInline;
//# sourceMappingURL=prefer_inline.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_is_not.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_is_not.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferIsNot = exports.PreferIsNotConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class PreferIsNotConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferIsNotConf = PreferIsNotConf;
class PreferIsNot extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferIsNotConf();
    }
    getMetadata() {
        return {
            key: "prefer_is_not",
            title: "Prefer IS NOT to NOT IS",
            shortDescription: `Prefer IS NOT to NOT IS`,
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-is-not-to-not-is

"if not is_valid( )." examples are skipped`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            goodExample: `IF variable IS NOT INITIAL.
IF variable NP 'TODO*'.
IF variable <> 42.
IF variable CO 'hello'.`,
            badExample: `IF NOT variable IS INITIAL.
IF NOT variable CP 'TODO*'.
IF NOT variable = 42.
IF NOT variable CA 'hello'.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        for (const s of file.getStatements()) {
            for (const c of s.findAllExpressions(Expressions.Compare)) {
                if (c.concatTokens().toUpperCase().startsWith("NOT ") === false) {
                    continue;
                }
                else if (c.getChildren().length === 2 && c.getChildren()[1].get() instanceof Expressions.MethodCallChain) {
                    continue;
                }
                const message = "Prefer IS NOT to NOT IS";
                const fix = this.getFix(file, c);
                issues.push(issue_1.Issue.atToken(file, c.getFirstToken(), message, this.getMetadata().key, this.conf.severity, fix));
            }
        }
        return issues;
    }
    getFix(file, c) {
        let insertFix;
        if (c.getChildren()[2].getFirstToken().getStr().toUpperCase() === "IS") {
            const tokenPositionBeforeDelete = c.getChildren()[2].getLastToken().getEnd();
            const tokenPosition = new position_1.Position(tokenPositionBeforeDelete.getRow(), tokenPositionBeforeDelete.getCol() + 1);
            insertFix = edit_helper_1.EditHelper.insertAt(file, tokenPosition, "NOT ");
        }
        else if (c.getChildren()[2].getFirstToken().getStr().toUpperCase() === "IN" || c.getChildren()[2].getFirstToken().getStr().toUpperCase() === "BETWEEN") {
            const tokenPositionBeforeDelete = c.getChildren()[1].getLastToken().getEnd();
            const tokenPosition = new position_1.Position(tokenPositionBeforeDelete.getRow(), tokenPositionBeforeDelete.getCol() + 1);
            insertFix = edit_helper_1.EditHelper.insertAt(file, tokenPosition, "NOT ");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === "=") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), "<>");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === "<>") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), "=");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === "<") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), ">");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === ">") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), "<");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === "<=") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), ">=");
        }
        else if (c.getChildren()[2].getFirstToken().getStr() === ">=") {
            insertFix = edit_helper_1.EditHelper.replaceToken(file, c.getChildren()[2].getLastToken(), "<=");
        }
        else {
            return;
        }
        const endCol = c.getChildren()[0].getFirstToken().getEnd().getCol() + 1;
        const endPosition = new position_1.Position(c.getChildren()[0].getFirstToken().getEnd().getRow(), endCol);
        const deleteFix = edit_helper_1.EditHelper.deleteRange(file, c.getChildren()[0].getFirstToken().getStart(), endPosition);
        const finalFix = edit_helper_1.EditHelper.merge(insertFix, deleteFix);
        return finalFix;
    }
}
exports.PreferIsNot = PreferIsNot;
//# sourceMappingURL=prefer_is_not.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_pragmas.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_pragmas.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferPragmas = exports.PreferPragmasConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class PreferPragmasConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.check = [
            {
                pseudo: "#EC CI_SUBRC",
                pragma: "SUBRC_OK",
            },
            {
                pseudo: "#EC NEEDED",
                pragma: "NEEDED",
            },
            {
                pseudo: "#EC NOTEXT",
                pragma: "NO_TEXT",
            },
            {
                pseudo: "#EC NO_HANDLER",
                pragma: "NO_HANDLER",
            },
        ];
    }
}
exports.PreferPragmasConf = PreferPragmasConf;
class PreferPragmas extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferPragmasConf();
    }
    getMetadata() {
        return {
            key: "prefer_pragmas",
            title: "prefer pragmas over pseudo comments ",
            shortDescription: `prefer pragmas over pseudo comments `,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-pragmas-to-pseudo-comments`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `DATA foo1 TYPE i. "#EC NEEDED`,
            goodExample: `DATA foo2 TYPE i ##NEEDED.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const config = this.getConfig();
        for (const statement of file.getStatements()) {
            if (!(statement.get() instanceof _statement_1.Comment)) {
                continue;
            }
            const concat = statement.concatTokens().toUpperCase();
            if (concat.includes("#EC") === false) {
                continue;
            }
            for (const check of config.check) {
                if (concat.includes(check.pseudo.toUpperCase())) {
                    const message = `Prefer pragma ${check.pragma}`;
                    issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return issues;
    }
}
exports.PreferPragmas = PreferPragmas;
//# sourceMappingURL=prefer_pragmas.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_raise_exception_new.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_raise_exception_new.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferRaiseExceptionNew = exports.PreferRaiseExceptionNewConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
class PreferRaiseExceptionNewConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferRaiseExceptionNewConf = PreferRaiseExceptionNewConf;
class PreferRaiseExceptionNew extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferRaiseExceptionNewConf();
    }
    getMetadata() {
        return {
            key: "prefer_raise_exception_new",
            title: "Prefer RAISE EXCEPTION NEW to RAISE EXCEPTION TYPE",
            shortDescription: `Prefer RAISE EXCEPTION NEW to RAISE EXCEPTION TYPE`,
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-raise-exception-new-to-raise-exception-type

From 752 and up`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Upport],
            goodExample: `RAISE EXCEPTION NEW cx_generation_error( previous = exception ).`,
            badExample: `RAISE EXCEPTION TYPE cx_generation_error
  EXPORTING
    previous = exception.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        if (this.reg.getConfig().getVersion() < __1.Version.v752) {
            return [];
        }
        const issues = [];
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof __1.Statements.Raise) {
                const concat = statement.concatTokens().toUpperCase();
                if (concat.includes(" MESSAGE")) {
                    continue;
                }
                if (concat.startsWith("RAISE EXCEPTION TYPE ")) {
                    const message = "Prefer RAISE EXCEPTION NEW to RAISE EXCEPTION TYPE";
                    const fix = this.getFix(file, statement, concat.includes(" EXPORTING") ? true : false);
                    issues.push(issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity, fix));
                }
            }
        }
        return issues;
    }
    getFix(file, statement, withExporting) {
        const children = statement.getChildren();
        let contentFix = undefined;
        if (withExporting) {
            const fixText = "( " + children[5].concatTokens() + " ).";
            contentFix = edit_helper_1.EditHelper.replaceRange(file, children[3].getLastToken().getEnd(), statement.getEnd(), fixText);
        }
        else {
            contentFix = edit_helper_1.EditHelper.replaceRange(file, children[3].getLastToken().getEnd(), statement.getEnd(), "( ).");
        }
        const replaceType = edit_helper_1.EditHelper.replaceToken(file, children[2].getFirstToken(), "NEW");
        return edit_helper_1.EditHelper.merge(contentFix, replaceType);
    }
}
exports.PreferRaiseExceptionNew = PreferRaiseExceptionNew;
//# sourceMappingURL=prefer_raise_exception_new.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_returning_to_exporting.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_returning_to_exporting.js ***!
  \**************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferReturningToExporting = exports.PreferReturningToExportingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class PreferReturningToExportingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferReturningToExportingConf = PreferReturningToExportingConf;
class PreferReturningToExporting extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferReturningToExportingConf();
    }
    getMetadata() {
        return {
            key: "prefer_returning_to_exporting",
            title: "Prefer RETURNING to EXPORTING",
            shortDescription: `Prefer RETURNING to EXPORTING. Generic types cannot be RETURNING.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-returning-to-exporting
https://docs.abapopenchecks.org/checks/44/`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `CLASS lcl DEFINITION.
  PUBLIC SECTION.
    METHODS test EXPORTING ev_foo TYPE i.
ENDCLASS.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const ret = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        for (const def of stru.findAllStatements(Statements.MethodDef)) {
            if (def.findFirstExpression(Expressions.MethodDefChanging)) {
                continue;
            }
            const exporting = def.findFirstExpression(Expressions.MethodDefExporting);
            if (exporting === undefined) {
                continue;
            }
            const returning = def.findFirstExpression(Expressions.MethodDefReturning);
            if (returning !== undefined) {
                continue;
            }
            const params = exporting.findDirectExpressions(Expressions.MethodParam);
            if (params.length !== 1) {
                continue;
            }
            const concat = params[0].concatTokens().toUpperCase();
            if (concat.endsWith("TYPE ANY")
                || concat.endsWith("TYPE ANY TABLE")
                || concat.endsWith("TYPE C")
                || concat.endsWith("TYPE CLIKE")
                || concat.endsWith("TYPE CSEQUENCE")
                || concat.endsWith("TYPE DATA")
                || concat.endsWith("TYPE DECFLOAT")
                || concat.endsWith("TYPE HASHED TABLE")
                || concat.endsWith("TYPE INDEX TABLE")
                || concat.endsWith("TYPE N")
                || concat.endsWith("TYPE NUMERIC")
                || concat.endsWith("TYPE OBJECT")
                || concat.endsWith("TYPE P")
                || concat.endsWith("TYPE SIMPLE")
                || concat.endsWith("TYPE SORTED TABLE")
                || concat.endsWith("TYPE STANDARD TABLE")
                || concat.endsWith("TYPE TABLE")
                || concat.endsWith("TYPE X")
                || concat.endsWith("TYPE XSEQUENCE")) {
                continue;
            }
            const token = params[0].getFirstToken();
            const issue = issue_1.Issue.atToken(file, token, "Prefer RETURNING to EXPORTING", this.getMetadata().key, this.conf.severity);
            ret.push(issue);
        }
        return ret;
    }
}
exports.PreferReturningToExporting = PreferReturningToExporting;
//# sourceMappingURL=prefer_returning_to_exporting.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefer_xsdbool.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefer_xsdbool.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferXsdbool = exports.PreferXsdboolConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class PreferXsdboolConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.PreferXsdboolConf = PreferXsdboolConf;
class PreferXsdbool extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferXsdboolConf();
    }
    getMetadata() {
        return {
            key: "prefer_xsdbool",
            title: "Prefer xsdbool over boolc",
            shortDescription: `Prefer xsdbool over boolc`,
            extendedInformation: `Activates if language version is v740sp08 or above.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-xsdbool-to-set-boolean-variables`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Upport, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `DATA(sdf) = boolc( 1 = 2 ).`,
            goodExample: `DATA(sdf) = xsdbool( 1 = 2 ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp08 && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        for (const s of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.Source)) || []) {
            if (s.concatTokens().toUpperCase().startsWith("BOOLC( ") === false) {
                continue;
            }
            const token = s.getFirstToken();
            const message = "Prefer xsdbool over boolc";
            const fix = edit_helper_1.EditHelper.replaceToken(file, token, "xsdbool");
            issues.push(issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity, fix));
        }
        return issues;
    }
}
exports.PreferXsdbool = PreferXsdbool;
//# sourceMappingURL=prefer_xsdbool.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/preferred_compare_operator.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/preferred_compare_operator.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PreferredCompareOperator = exports.PreferredCompareOperatorConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class PreferredCompareOperatorConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Operators which are not allowed */
        this.badOperators = ["EQ", "><", "NE", "GE", "GT", "LT", "LE"];
    }
}
exports.PreferredCompareOperatorConf = PreferredCompareOperatorConf;
class PreferredCompareOperator extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PreferredCompareOperatorConf();
        this.operatorMapping = new Map();
    }
    getMetadata() {
        return {
            key: "preferred_compare_operator",
            title: "Preferred compare operator",
            shortDescription: `Configure undesired operator variants`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `IF foo EQ bar.
ENDIF.`,
            goodExample: `IF foo = bar.
ENDIF.`,
        };
    }
    getDescription(operator) {
        return "Compare operator \"" + operator + "\" not preferred";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        this.buildMapping();
        const issues = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        const operators = struc.findAllExpressionsMulti([Expressions.CompareOperator, Expressions.SQLCompareOperator]);
        for (const op of operators) {
            const token = op.getLastToken();
            // todo, performance, lookup in hash map instead(JS object)
            if (this.conf.badOperators.indexOf(token.getStr().toUpperCase()) >= 0) {
                issues.push(this.createIssue(token, file));
            }
        }
        return issues;
    }
    buildMapping() {
        if (this.operatorMapping.size === 0) {
            this.operatorMapping.set("EQ", "=");
            this.operatorMapping.set("><", "<>");
            this.operatorMapping.set("NE", "<>");
            this.operatorMapping.set("GE", ">=");
            this.operatorMapping.set("GT", ">");
            this.operatorMapping.set("LT", "<");
            this.operatorMapping.set("LE", "<=");
            this.operatorMapping.set("=", "EQ");
            this.operatorMapping.set("<>", "NE");
            this.operatorMapping.set(">=", "GE");
            this.operatorMapping.set(">", "GT");
            this.operatorMapping.set("<", "LT");
            this.operatorMapping.set("<=", "LE");
        }
    }
    createIssue(token, file) {
        var _a;
        const message = this.getDescription(token.getStr());
        const replacementToken = (_a = this.operatorMapping) === null || _a === void 0 ? void 0 : _a.get(token.getStr());
        // values in badOperators can be entered by the user and may not necessarily be actual operators
        if (replacementToken) {
            const fix = edit_helper_1.EditHelper.replaceRange(file, token.getStart(), token.getEnd(), replacementToken);
            const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity, fix);
            return issue;
        }
        else {
            const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
            return issue;
        }
    }
}
exports.PreferredCompareOperator = PreferredCompareOperator;
//# sourceMappingURL=preferred_compare_operator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/prefix_is_current_class.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/prefix_is_current_class.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PrefixIsCurrentClass = exports.PrefixIsCurrentClassConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class PrefixIsCurrentClassConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /**
         * Checks usages of self references with 'me' when calling instance methods
         */
        this.omitMeInstanceCalls = true;
    }
}
exports.PrefixIsCurrentClassConf = PrefixIsCurrentClassConf;
class PrefixIsCurrentClass extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new PrefixIsCurrentClassConf();
    }
    getMetadata() {
        return {
            key: "prefix_is_current_class",
            title: "Prefix is current class",
            shortDescription: `Reports errors if the current class or interface references itself with "current_class=>"`,
            // eslint-disable-next-line max-len
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#omit-the-self-reference-me-when-calling-an-instance-attribute-or-method`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        return this.checkClasses(file).concat(this.checkInterfaces(file));
    }
    checkInterfaces(file) {
        var _a;
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        const issues = [];
        for (const s of struc.findDirectStructures(Structures.Interface)) {
            const name = (_a = s.findFirstExpression(expressions_1.InterfaceName)) === null || _a === void 0 ? void 0 : _a.getFirstToken().getStr().toUpperCase();
            if (name === undefined) {
                continue;
            }
            const staticAccess = name + "=>";
            for (const e of s.findAllExpressions(expressions_1.TypeName)) {
                const concat = e.concatTokens().toUpperCase();
                if (concat.startsWith(staticAccess)) {
                    const stat = e.findDirectTokenByText("=>");
                    if (stat === undefined) {
                        continue;
                    }
                    const start = new position_1.Position(stat.getRow(), stat.getCol() - name.length);
                    const end = new position_1.Position(stat.getRow(), stat.getCol() + 2);
                    const fix = edit_helper_1.EditHelper.deleteRange(file, start, end);
                    issues.push(issue_1.Issue.atToken(file, e.getFirstToken(), "Reference to current interface can be omitted", this.getMetadata().key, this.conf.severity, fix));
                }
            }
        }
        return issues;
    }
    checkClasses(file) {
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        const issues = [];
        const classStructures = struc.findDirectStructures(Structures.ClassImplementation);
        classStructures.push(...struc.findDirectStructures(Structures.ClassDefinition));
        const meAccess = "ME->";
        for (const c of classStructures) {
            const className = c.findFirstExpression(expressions_1.ClassName).getFirstToken().getStr().toUpperCase();
            const staticAccess = className + "=>";
            for (const s of c.findAllStatementNodes()) {
                const concat = s.concatTokensWithoutStringsAndComments().toUpperCase();
                if (concat.includes(staticAccess)) {
                    const tokenPos = s.findTokenSequencePosition(className, "=>");
                    if (tokenPos) {
                        const end = new position_1.Position(tokenPos.getRow(), tokenPos.getCol() + className.length + 2);
                        const fix = edit_helper_1.EditHelper.deleteRange(file, tokenPos, end);
                        issues.push(issue_1.Issue.atRange(file, tokenPos, end, "Reference to current class can be omitted: \"" + staticAccess + "\"", this.getMetadata().key, this.conf.severity, fix));
                    }
                }
                else if (this.conf.omitMeInstanceCalls === true
                    && concat.includes(meAccess)
                    && s.findFirstExpression(expressions_1.MethodCall)) {
                    const tokenPos = s.findTokenSequencePosition("me", "->");
                    if (tokenPos) {
                        const end = new position_1.Position(tokenPos.getRow(), tokenPos.getCol() + 4);
                        const fix = edit_helper_1.EditHelper.deleteRange(file, tokenPos, end);
                        issues.push(issue_1.Issue.atRange(file, tokenPos, end, "Omit 'me->' in instance calls", this.getMetadata().key, this.conf.severity, fix));
                    }
                }
            }
        }
        return issues;
    }
}
exports.PrefixIsCurrentClass = PrefixIsCurrentClass;
//# sourceMappingURL=prefix_is_current_class.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/reduce_procedural_code.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/reduce_procedural_code.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceProceduralCode = exports.ReduceProceduralCodeConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class ReduceProceduralCodeConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.maxStatements = 10;
    }
}
exports.ReduceProceduralCodeConf = ReduceProceduralCodeConf;
class ReduceProceduralCode extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ReduceProceduralCodeConf();
    }
    getMetadata() {
        return {
            key: "reduce_procedural_code",
            title: "Reduce procedural code",
            shortDescription: `Checks FORM and FUNCTION-MODULE have few statements`,
            extendedInformation: `Delegate logic to a class method instead of using FORM or FUNCTION-MODULE.

https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-object-orientation-to-procedural-programming

Comments are not counted as statements.`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Styleguide],
            badExample: `FORM foo.
  DATA lv_bar TYPE i.
  lv_bar = 2 + 2.
  IF lv_bar = 4.
    WRITE 'hello world'.
  ENDIF.
  DATA lv_bar TYPE i.
  lv_bar = 2 + 2.
  IF lv_bar = 4.
    WRITE 'hello world'.
  ENDIF.
ENDFORM.`,
            goodExample: `FORM foo.
  NEW zcl_global_class( )->run_logic( ).
ENDFORM.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (file.getStructure() === undefined) {
            // constains syntax errors, skip this check
            return issues;
        }
        let doCount = undefined;
        let count = 0;
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof Statements.Form || statement.get() instanceof Statements.FunctionModule) {
                doCount = statement;
                count = 0;
            }
            else if (statement.get() instanceof Statements.EndForm || statement.get() instanceof Statements.EndFunction) {
                if (count >= this.conf.maxStatements && doCount !== undefined) {
                    const message = "Reduce procedural code, max " + this.conf.maxStatements + " statements";
                    const issue = issue_1.Issue.atStatement(file, doCount, message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                doCount = undefined;
            }
            else if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            else if (doCount !== undefined) {
                count = count + 1;
            }
        }
        return issues;
    }
}
exports.ReduceProceduralCode = ReduceProceduralCode;
//# sourceMappingURL=reduce_procedural_code.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/reduce_string_templates.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/reduce_string_templates.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReduceStringTemplates = exports.ReduceStringTemplatesConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ReduceStringTemplatesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ReduceStringTemplatesConf = ReduceStringTemplatesConf;
class ReduceStringTemplates extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ReduceStringTemplatesConf();
    }
    getMetadata() {
        return {
            key: "reduce_string_templates",
            title: "Reduce string templates",
            shortDescription: `Checks for string templates`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `WRITE |{ |sdf| }|.\nWRITE |{ 'sdf' }|.`,
            goodExample: `WRITE |sdf|.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, _obj) {
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        for (const template of structure.findAllExpressions(Expressions.StringTemplate)) {
            for (const ts of template.findAllExpressions(Expressions.StringTemplateSource)) {
                for (const source of ts.findDirectExpressions(Expressions.Source)) {
                    for (const second of source.findDirectExpressions(Expressions.StringTemplate)) {
                        issues.push(issue_1.Issue.atToken(file, second.getFirstToken(), "Nested string templates, reduce", this.getMetadata().key, this.conf.severity));
                    }
                    if (ts.findDirectExpression(Expressions.StringTemplateFormatting)) {
                        continue;
                    }
                    for (const constant of source.findDirectExpressions(Expressions.Constant)) {
                        for (const constantString of constant.findDirectExpressions(Expressions.ConstantString)) {
                            issues.push(issue_1.Issue.atToken(file, constantString.getFirstToken(), "Constant string in text template, reduce", this.getMetadata().key, this.conf.severity));
                        }
                    }
                }
            }
        }
        for (const source of structure.findAllExpressions(Expressions.Source)) {
            const children = source.getChildren();
            if (children.length !== 3) {
                continue;
            }
            else if (!(children[0].get() instanceof Expressions.StringTemplate)) {
                continue;
            }
            else if (children[1].getFirstToken().getStr() !== "&&") {
                continue;
            }
            else if (!(children[2].get() instanceof Expressions.Source)) {
                continue;
            }
            const sub = children[2].getChildren();
            if (sub.length !== 1) {
                continue;
            }
            const start = children[0].getFirstToken().getStart();
            const end = sub[0].getLastToken().getEnd();
            if (start.getRow() === end.getRow()) {
                const message = "Reduce template, remove \"&&\"";
                issues.push(issue_1.Issue.atToken(file, children[1].getFirstToken(), message, this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.ReduceStringTemplates = ReduceStringTemplates;
//# sourceMappingURL=reduce_string_templates.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/release_idoc.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/release_idoc.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ReleaseIdoc = exports.ReleaseIdocConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class ReleaseIdocConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.ReleaseIdocConf = ReleaseIdocConf;
class ReleaseIdoc {
    constructor() {
        this.conf = new ReleaseIdocConf();
    }
    getMetadata() {
        return {
            key: "release_idoc",
            title: "Release iDoc",
            shortDescription: `Checks idoc types and segments are set to status released`,
        };
    }
    getMessage() {
        return "Idoc type/segement status must be set to released";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        const file = obj.getXMLFile();
        if (file === undefined) {
            return [];
        }
        if (obj instanceof Objects.Table) {
            if (file.getRaw().includes("<SEGMENTDEFINITION>") === false) {
                return [];
            }
        }
        else if (!(obj instanceof Objects.Idoc)) {
            return [];
        }
        if (file.getRaw().includes("<CLOSED>X</CLOSED>") === false) {
            const position = new position_1.Position(1, 1);
            const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, this.getMessage(), this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        else {
            return [];
        }
    }
}
exports.ReleaseIdoc = ReleaseIdoc;
//# sourceMappingURL=release_idoc.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/remove_descriptions.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/remove_descriptions.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RemoveDescriptions = exports.RemoveDescriptionsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const fast_xml_parser_1 = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const xml_utils_1 = __webpack_require__(/*! ../xml_utils */ "./node_modules/@abaplint/core/build/src/xml_utils.js");
class RemoveDescriptionsConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Ignore global exception classes */
        this.ignoreExceptions = false;
        /** Ignore global workflow classes */
        this.ignoreWorkflow = true;
    }
}
exports.RemoveDescriptionsConf = RemoveDescriptionsConf;
class RemoveDescriptions {
    constructor() {
        this.conf = new RemoveDescriptionsConf();
    }
    getMetadata() {
        return {
            key: "remove_descriptions",
            title: "Remove descriptions",
            shortDescription: `Ensures you have no descriptions in metadata of methods, parameters, etc.

Class descriptions are required, see rule description_empty.

Consider using ABAP Doc for documentation.`,
            tags: [],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        // plan is omitting knowledge about descriptions in abaplint, so this rule must parse the XML
        const ddic = new ddic_1.DDIC(this.reg);
        if (obj instanceof Objects.Class) {
            let def;
            try {
                def = obj.getClassDefinition();
            }
            catch (_a) {
                return [];
            }
            if (def === undefined) {
                return [];
            }
            else if (this.conf.ignoreExceptions && ddic.isException(def, obj)) {
                return [];
            }
            else if (this.conf.ignoreWorkflow === true && def.interfaces.find(e => e.name.toUpperCase() === "IF_WORKFLOW")) {
                return [];
            }
            return this.checkClass(obj);
        }
        else if (obj instanceof Objects.Interface) {
            return this.checkInterface(obj);
        }
        return [];
    }
    //////////////
    checkInterface(obj) {
        const xml = obj.getXML();
        if (xml === undefined) {
            return [];
        }
        const file = obj.getXMLFile();
        if (file === undefined) {
            return [];
        }
        return this.checkXML(xml, file);
    }
    checkClass(obj) {
        const xml = obj.getXML();
        if (xml === undefined) {
            return [];
        }
        const file = obj.getXMLFile();
        if (file === undefined) {
            return [];
        }
        return this.checkXML(xml, file);
    }
    checkXML(xml, file) {
        const parsed = new fast_xml_parser_1.XMLParser({ parseTagValue: false, ignoreAttributes: true, trimValues: false }).parse(xml);
        if (parsed === undefined || parsed.abapGit["asx:abap"]["asx:values"] === undefined) {
            return [];
        }
        const desc = parsed.abapGit["asx:abap"]["asx:values"].DESCRIPTIONS;
        if (desc === undefined) {
            return [];
        }
        const reported = {}; // there might be multiple translations
        const ret = [];
        for (const d of (0, xml_utils_1.xmlToArray)(desc.SEOCOMPOTX)) {
            const message = "Remove description for " + d.CMPNAME;
            if (reported[d.CMPNAME] !== undefined) {
                continue;
            }
            const position = new position_1.Position(1, 1);
            const issue = issue_1.Issue.atPosition(file, position, message, this.getMetadata().key, this.conf.severity);
            ret.push(issue);
            reported[d.CMPNAME] = true;
        }
        return ret;
    }
}
exports.RemoveDescriptions = RemoveDescriptions;
//# sourceMappingURL=remove_descriptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/rfc_error_handling.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/rfc_error_handling.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RFCErrorHandling = exports.RFCErrorHandlingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class RFCErrorHandlingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.RFCErrorHandlingConf = RFCErrorHandlingConf;
class RFCErrorHandling extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new RFCErrorHandlingConf();
    }
    getMetadata() {
        return {
            key: "rfc_error_handling",
            title: "RFC error handling",
            tags: [_irule_1.RuleTag.SingleFile],
            shortDescription: `Checks that exceptions 'system_failure' and 'communication_failure' are handled in RFC calls`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abenrfc_exception.htm`,
            badExample: `CALL FUNCTION 'ZRFC'
  DESTINATION lv_rfc.`,
            goodExample: `CALL FUNCTION 'ZRFC'
  DESTINATION lv_rfc
  EXCEPTIONS
    system_failure        = 1 MESSAGE msg
    communication_failure = 2 MESSAGE msg
    resource_failure      = 3
    OTHERS                = 4.`,
        };
    }
    getMessage() {
        return "RFC error handling: At least one unhandled exception from SYSTEM_FAILURE, COMMUNICATION_FAILURE, RESOURCE_FAILURE";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const output = [];
        for (const stat of file.getStatements()) {
            const token = stat.getFirstToken();
            if (!(stat.get() instanceof Statements.CallFunction)) {
                continue;
            }
            if (!stat.findFirstExpression(Expressions.Destination)) {
                continue;
            }
            const list = stat.findFirstExpression(Expressions.ParameterListExceptions);
            if (list === undefined) {
                const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                output.push(issue);
                continue;
            }
            const parameters = list.findAllExpressions(Expressions.ParameterName);
            const names = [];
            for (const par of parameters) {
                names.push(par.getFirstToken().getStr().toUpperCase());
            }
            if (names.indexOf("SYSTEM_FAILURE") < 0
                || names.indexOf("COMMUNICATION_FAILURE") < 0
                || names.indexOf("RESOURCE_FAILURE") < 0) {
                const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                output.push(issue);
                continue;
            }
        }
        return output;
    }
}
exports.RFCErrorHandling = RFCErrorHandling;
//# sourceMappingURL=rfc_error_handling.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/select_add_order_by.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/select_add_order_by.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectAddOrderBy = exports.SelectAddOrderByConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class SelectAddOrderByConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.skipForAllEntries = false;
    }
}
exports.SelectAddOrderByConf = SelectAddOrderByConf;
class SelectAddOrderBy {
    constructor() {
        this.conf = new SelectAddOrderByConf();
    }
    getMetadata() {
        return {
            key: "select_add_order_by",
            title: "SELECT add ORDER BY",
            shortDescription: `SELECTs add ORDER BY clause`,
            extendedInformation: `
This will make sure that the SELECT statement returns results in the same sequence on different databases

add ORDER BY PRIMARY KEY if in doubt

If the target is a sorted/hashed table, no issue is reported`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `SELECT * FROM db INTO TABLE @DATA(tab).`,
            goodExample: `SELECT * FROM db INTO TABLE @DATA(tab) ORDER BY PRIMARY KEY.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        var _a, _b;
        const issues = [];
        if (!(obj instanceof _abap_object_1.ABAPObject) || obj.getType() === "INTF") {
            return [];
        }
        const spaghetti = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
        for (const file of obj.getABAPFiles()) {
            const stru = file.getStructure();
            if (stru === undefined) {
                return issues;
            }
            const selects = stru.findAllStatements(Statements.Select);
            selects.push(...stru.findAllStatements(Statements.SelectLoop));
            for (const s of selects) {
                const concat = s.concatTokens().toUpperCase();
                if (concat.startsWith("SELECT SINGLE ")) {
                    continue;
                }
                else if (((_a = this.getConfig()) === null || _a === void 0 ? void 0 : _a.skipForAllEntries) === true && concat.includes(" FOR ALL ENTRIES ")) {
                    continue;
                }
                // skip COUNT(*)
                const list = s.findAllExpressions(Expressions.SQLField);
                if (list.length === 1 && ((_b = list[0].getFirstChild()) === null || _b === void 0 ? void 0 : _b.get()) instanceof Expressions.SQLAggregation) {
                    continue;
                }
                else if (s.findFirstExpression(Expressions.SQLOrderBy)) {
                    continue;
                }
                if (this.isTargetSortedOrHashed(s, spaghetti, file)) {
                    continue;
                }
                else if (s.findFirstExpression(Expressions.SQLJoin) && s.findFirstExpression(Expressions.SQLForAllEntries)) {
                    // see https://github.com/abaplint/abaplint/issues/2957
                    continue;
                }
                issues.push(issue_1.Issue.atStatement(file, s, "Add ORDER BY", this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
    isTargetSortedOrHashed(s, spaghetti, file) {
        var _a, _b;
        const target = (_a = s.findFirstExpression(Expressions.SQLIntoTable)) === null || _a === void 0 ? void 0 : _a.findFirstExpression(Expressions.Target);
        if (target) {
            const start = target.getFirstToken().getStart();
            const scope = spaghetti.lookupPosition(start, file.getFilename());
            let type = (_b = scope === null || scope === void 0 ? void 0 : scope.findWriteReference(start)) === null || _b === void 0 ? void 0 : _b.getType();
            const children = target.getChildren();
            if (type instanceof basic_1.StructureType && children.length >= 3 && children[1].concatTokens() === "-") {
                const found = type.getComponentByName(children[2].concatTokens());
                if (found === undefined) {
                    return false;
                }
                type = found;
            }
            if (type instanceof basic_1.TableType
                && ((type === null || type === void 0 ? void 0 : type.getAccessType()) === basic_1.TableAccessType.sorted
                    || (type === null || type === void 0 ? void 0 : type.getAccessType()) === basic_1.TableAccessType.hashed)) {
                return true;
            }
        }
        return false;
    }
}
exports.SelectAddOrderBy = SelectAddOrderBy;
//# sourceMappingURL=select_add_order_by.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/select_performance.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/select_performance.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectPerformance = exports.SelectPerformanceConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const structure_type_1 = __webpack_require__(/*! ../abap/types/basic/structure_type */ "./node_modules/@abaplint/core/build/src/abap/types/basic/structure_type.js");
const DEFAULT_COLUMNS = 10;
class SelectPerformanceConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Detects ENDSELECT */
        this.endSelect = true;
        /** Detects SELECT * */
        this.selectStar = true;
        /** "SELECT" * is considered okay if the table is less than X columns, the table must be known to the linter
         * @default 10
         */
        this.starOkayIfFewColumns = DEFAULT_COLUMNS;
    }
}
exports.SelectPerformanceConf = SelectPerformanceConf;
class SelectPerformance {
    constructor() {
        this.conf = new SelectPerformanceConf();
    }
    getMetadata() {
        return {
            key: "select_performance",
            title: "SELECT performance",
            shortDescription: `Various checks regarding SELECT performance.`,
            extendedInformation: `ENDSELECT: not reported when the corresponding SELECT has PACKAGE SIZE

SELECT *: not reported if using INTO/APPENDING CORRESPONDING FIELDS OF`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Performance],
            badExample: `SELECT field1, field2 FROM table
    INTO @DATA(structure) UP TO 1 ROWS ORDER BY field3 DESCENDING.
ENDSELECT.`,
            goodExample: `SELECT field1, field2 FROM table UP TO 1 ROWS
  INTO TABLE @DATA(table) ORDER BY field3 DESCENDING`,
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        if (this.conf.starOkayIfFewColumns === undefined) {
            this.conf.starOkayIfFewColumns = DEFAULT_COLUMNS;
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const issues = [];
        for (const file of obj.getABAPFiles()) {
            const stru = file.getStructure();
            if (stru === undefined) {
                return issues;
            }
            if (this.conf.endSelect) {
                for (const s of stru.findAllStructures(Structures.Select) || []) {
                    const select = s.findDirectStatement(Statements.SelectLoop);
                    if (select === undefined || select.concatTokens().toUpperCase().includes("PACKAGE SIZE")) {
                        continue;
                    }
                    const message = "Avoid use of ENDSELECT";
                    issues.push(issue_1.Issue.atStatement(file, select, message, this.getMetadata().key, this.conf.severity));
                }
            }
            if (this.conf.selectStar) {
                const spaghetti = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
                const selects = stru.findAllStatements(Statements.Select);
                selects.push(...stru.findAllStatements(Statements.SelectLoop));
                for (const s of selects) {
                    const concat = s.concatTokens().toUpperCase();
                    if (concat.startsWith("SELECT * ") === false
                        && concat.startsWith("SELECT SINGLE * ") === false) {
                        continue;
                    }
                    else if (concat.includes(" INTO CORRESPONDING FIELDS OF ")
                        || concat.includes(" APPENDING CORRESPONDING FIELDS OF ")) {
                        continue;
                    }
                    const columnCount = this.findNumberOfColumns(s, file, spaghetti);
                    if (columnCount
                        && columnCount <= this.getConfig().starOkayIfFewColumns) {
                        continue;
                    }
                    const message = "Avoid use of SELECT *";
                    issues.push(issue_1.Issue.atToken(file, s.getFirstToken(), message, this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
    findNumberOfColumns(s, file, spaghetti) {
        const dbnames = s.findAllExpressions(Expressions.DatabaseTable);
        if (dbnames.length === 1) {
            const start = dbnames[0].getFirstToken().getStart();
            const scope = spaghetti.lookupPosition(start, file.getFilename());
            const name = scope === null || scope === void 0 ? void 0 : scope.findTableReference(start);
            const tabl = this.reg.getObject("TABL", name);
            const parsed = tabl === null || tabl === void 0 ? void 0 : tabl.parseType(this.reg);
            if (parsed instanceof structure_type_1.StructureType) {
                return parsed.getComponents().length;
            }
        }
        return undefined;
    }
}
exports.SelectPerformance = SelectPerformance;
//# sourceMappingURL=select_performance.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/select_single_full_key.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/select_single_full_key.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectSingleFullKey = exports.SelectSingleFullKeyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const __1 = __webpack_require__(/*! .. */ "./node_modules/@abaplint/core/build/src/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class SelectSingleFullKeyConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.allowPseudo = true;
    }
}
exports.SelectSingleFullKeyConf = SelectSingleFullKeyConf;
class SelectSingleFullKey {
    constructor() {
        this.conf = new SelectSingleFullKeyConf();
    }
    getMetadata() {
        return {
            key: "select_single_full_key",
            title: "Detect SELECT SINGLE which are possibily not unique",
            shortDescription: `Detect SELECT SINGLE which are possibily not unique`,
            extendedInformation: `Table definitions must be known, ie. inside the errorNamespace

If the statement contains a JOIN it is not checked`,
            pseudoComment: "EC CI_NOORDER",
            tags: [_irule_1.RuleTag.Quickfix],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        if (this.conf === undefined) {
            this.conf = {
                allowPseudo: true,
            };
        }
        if (this.conf.allowPseudo === undefined) {
            this.conf.allowPseudo = true;
        }
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    buildFix(file, statement) {
        return {
            description: `Add "#EC CI_NOORDER`,
            edit: edit_helper_1.EditHelper.insertAt(file, statement.getLastToken().getStart(), ` "#EC CI_NOORDER`),
        };
    }
    run(obj) {
        var _a, _b;
        if (!(obj instanceof __1.ABAPObject)) {
            return [];
        }
        const syntax = new __1.SyntaxLogic(this.reg, obj).run();
        if (syntax.issues.length > 0) {
            return [];
        }
        const issues = [];
        const message = "SELECT SINGLE possibily not unique";
        for (const file of obj.getABAPFiles()) {
            const statements = file.getStatements();
            for (let i = 0; i < statements.length; i++) {
                const s = statements[i];
                if (!(s.get() instanceof __1.Statements.Select)) {
                    continue;
                }
                else if (s.findFirstExpression(__1.Expressions.SQLJoin)) {
                    continue;
                }
                else if (s.findTokenSequencePosition("SELECT", "SINGLE") === undefined) {
                    continue;
                }
                const databaseTable = s.findFirstExpression(__1.Expressions.DatabaseTable);
                if (databaseTable === undefined) {
                    continue;
                }
                const next = statements[i + 1];
                if ((next === null || next === void 0 ? void 0 : next.get()) instanceof __1.Comment
                    && next.concatTokens().includes(this.getMetadata().pseudoComment + "")) {
                    if (this.getConfig().allowPseudo !== true) {
                        issues.push(issue_1.Issue.atStatement(file, s, "Pseudo comment not allowed", this.getMetadata().key, this.getConfig().severity));
                    }
                    continue;
                }
                const tabl = this.findReference(databaseTable.getFirstToken().getStart(), syntax.spaghetti, file);
                const table = this.reg.getObject("TABL", tabl);
                if (table === undefined) {
                    continue;
                }
                const keys = table.listKeys(this.reg);
                const cond = s.findFirstExpression(__1.Expressions.SQLCond);
                const set = new Set();
                for (const key of keys) {
                    if (key === "MANDT") {
                        // todo, it should check for the correct type instead
                        continue;
                    }
                    set.add(key);
                }
                for (const compare of (cond === null || cond === void 0 ? void 0 : cond.findAllExpressionsRecursive(__1.Expressions.SQLCompare)) || []) {
                    if (compare.getChildren().length === 3) {
                        const fname = (_a = compare.findDirectExpression(__1.Expressions.SQLFieldName)) === null || _a === void 0 ? void 0 : _a.concatTokens().toUpperCase();
                        const operator = (_b = compare.findDirectExpression(__1.Expressions.SQLCompareOperator)) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase();
                        if (fname && (operator === "=" || operator === "EQ")) {
                            set.delete(fname);
                        }
                    }
                }
                if (set.size > 0) {
                    const fix = this.buildFix(file, s);
                    issues.push(issue_1.Issue.atStatement(file, s, message, this.getMetadata().key, this.getConfig().severity, undefined, [fix]));
                }
            }
        }
        return issues;
    }
    findReference(position, spaghetti, file) {
        const scope = spaghetti.lookupPosition(position, file.getFilename());
        return scope === null || scope === void 0 ? void 0 : scope.findTableReference(position);
    }
}
exports.SelectSingleFullKey = SelectSingleFullKey;
//# sourceMappingURL=select_single_full_key.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/selection_screen_naming.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/selection_screen_naming.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SelectionScreenNaming = exports.SelectionScreenNamingConf = void 0;
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _naming_rule_config_1 = __webpack_require__(/*! ./_naming_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_naming_rule_config.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const name_validator_1 = __webpack_require__(/*! ../utils/name_validator */ "./node_modules/@abaplint/core/build/src/utils/name_validator.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class SelectionScreenNamingConf extends _naming_rule_config_1.NamingRuleConfig {
    constructor() {
        super(...arguments);
        /** The pattern for selection-screen parameters */
        this.parameter = "^P_.+$";
        /** The pattern for selection-screen select-options */
        this.selectOption = "^S_.+$";
        /** The pattern for selection-screen screen elements */
        this.screenElement = "^SC_.+$";
    }
}
exports.SelectionScreenNamingConf = SelectionScreenNamingConf;
class SelectionScreenNaming extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SelectionScreenNamingConf();
    }
    getMetadata() {
        return {
            key: "selection_screen_naming",
            title: "Selection screen naming conventions",
            shortDescription: `Allows you to enforce a pattern, such as a prefix, for selection-screen variable names.`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
        };
    }
    getDescription(expected, actual) {
        return this.conf.patternKind === "required" ?
            `Selection-Screen variable name does not match pattern ${expected}: ${actual}` :
            `Selection-Screen variable name must not match pattern ${expected}: ${actual}`;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        if (this.conf.patternKind === undefined) {
            this.conf.patternKind = "required";
        }
        let parameterCheckDisabled = false;
        let selectOptionDisabled = false;
        let screenElementDisabled = false;
        if (this.conf.parameter === undefined || this.conf.parameter.length === 0) {
            parameterCheckDisabled = true;
        }
        if (this.conf.selectOption === undefined || this.conf.selectOption.length === 0) {
            selectOptionDisabled = true;
        }
        if (this.conf.screenElement === undefined || this.conf.screenElement.length === 0) {
            screenElementDisabled = true;
        }
        for (const stat of file.getStatements()) {
            if ((stat.get() instanceof statements_1.Parameter && !parameterCheckDisabled)
                || (stat.get() instanceof statements_1.SelectOption && !selectOptionDisabled)
                || (stat.get() instanceof statements_1.SelectionScreen && !screenElementDisabled)) {
                const fieldNode = this.getFieldForStatementNode(stat);
                const regex = new RegExp(this.getPatternForStatement(stat.get()), "i");
                if (fieldNode && name_validator_1.NameValidator.violatesRule(fieldNode.getFirstToken().getStr(), regex, this.conf)) {
                    issues.push(issue_1.Issue.atToken(file, fieldNode.getFirstToken(), this.getDescription(this.getPatternForStatement(stat.get()), fieldNode.getFirstToken().getStr()), this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
    getPatternForStatement(statement) {
        let pattern = "";
        if (statement instanceof statements_1.Parameter) {
            pattern = this.conf.parameter;
        }
        else if (statement instanceof statements_1.SelectOption) {
            pattern = this.conf.selectOption;
        }
        else if (statement instanceof statements_1.SelectionScreen) {
            pattern = this.conf.screenElement;
        }
        return pattern;
    }
    getFieldForStatementNode(statNode) {
        if (statNode.get() instanceof statements_1.Parameter) {
            return statNode.findFirstExpression(expressions_1.FieldSub);
        }
        else if (statNode.get() instanceof statements_1.SelectOption) {
            return statNode.findFirstExpression(expressions_1.FieldSub);
        }
        else if (statNode.get() instanceof statements_1.SelectionScreen) {
            return statNode.findFirstExpression(expressions_1.InlineField);
        }
        else {
            return undefined;
        }
    }
}
exports.SelectionScreenNaming = SelectionScreenNaming;
//# sourceMappingURL=selection_screen_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/sequential_blank.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/sequential_blank.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SequentialBlank = exports.SequentialBlankConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class SequentialBlankConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** An equal or higher number of sequential blank lines will trigger a violation.
         * Example: if lines = 3, a maximum of 2 is allowed.
         */
        this.lines = 4;
    }
}
exports.SequentialBlankConf = SequentialBlankConf;
class SequentialBlank extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SequentialBlankConf();
    }
    static isBlankOrWhitespace(line) {
        return /^\s*$/.test(line);
    }
    getMetadata() {
        return {
            key: "sequential_blank",
            title: "Sequential blank lines",
            shortDescription: `Checks that code does not contain more than the configured number of blank lines in a row.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "Remove sequential blank lines";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const rows = file.getRawRows();
        let blanks = 0;
        for (let i = 0; i < rows.length; i++) {
            if (SequentialBlank.isBlankOrWhitespace(rows[i])) {
                blanks++;
            }
            else {
                blanks = 0;
            }
            if (blanks === this.conf.lines) {
                let blankCounter = 1;
                while (i + blankCounter < rows.length && SequentialBlank.isBlankOrWhitespace(rows[i + blankCounter])) {
                    ++blankCounter;
                }
                const reportPos = new position_1.Position(i + 1, 1);
                // fix has to start at end of previous row for it to properly delete the first row
                const startPos = new position_1.Position(i, rows[i].length + 1);
                const endPos = new position_1.Position(i + blankCounter, rows[i + blankCounter - 1].length + 1);
                const fix = edit_helper_1.EditHelper.deleteRange(file, startPos, endPos);
                const issue = issue_1.Issue.atPosition(file, reportPos, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.SequentialBlank = SequentialBlank;
//# sourceMappingURL=sequential_blank.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/short_case.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/short_case.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ShortCase = exports.ShortCaseConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class ShortCaseConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** The smallest number of WHEN branches which will trigger a violation.
         * Example: if length = 1, at least 2 branches are required
         */
        this.length = 1;
        /** List of inputs for CASE which are allowed
         * @uniqueItems true
        */
        this.allow = [];
    }
}
exports.ShortCaseConf = ShortCaseConf;
class ShortCase extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new ShortCaseConf();
    }
    getMetadata() {
        return {
            key: "short_case",
            title: "Short CASE",
            shortDescription: `Checks for CASE statements which have fewer than the specified number of branches`,
            extendedInformation: `Short CASE constructs can be changed to IF`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: "CASE moo.\nWHEN 'X'.\nENDCASE.",
            goodExample: "IF moo = 'X'.\nENDIF.",
        };
    }
    getMessage() {
        return "CASE construct too short, it must have a minimum of " + (this.conf.length + 1) + " WHEN branches";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        for (const c of struc.findAllStructures(Structures.Case)) {
            const clist = c.findDirectStatements(Statements.Case);
            if (clist.length > 0 && this.conf.allow && this.conf.allow.find((e) => { return e === clist[0].getTokens()[1].getStr(); })) {
                continue;
            }
            if (c.findDirectStructures(Structures.When).length <= this.conf.length) {
                if (c.findAllExpressions(Expressions.Or).length > 0) {
                    continue;
                }
                const issue = issue_1.Issue.atToken(file, c.getFirstToken(), this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.ShortCase = ShortCase;
//# sourceMappingURL=short_case.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/sicf_consistency.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/sicf_consistency.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SICFConsistency = exports.SICFConsistencyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class SICFConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** skip specific names, case insensitive
         * @uniqueItems true
         */
        this.skipNames = [];
    }
}
exports.SICFConsistencyConf = SICFConsistencyConf;
class SICFConsistency {
    constructor() {
        this.conf = new SICFConsistencyConf();
    }
    getMetadata() {
        return {
            key: "sicf_consistency",
            title: "SICF consistency",
            shortDescription: `Checks the validity of ICF services`,
            extendedInformation: `* Class defined in handler must exist
* Class must not have any syntax errors
* Class must implement interface IF_HTTP_EXTENSION`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skipNames === undefined) {
            this.conf.skipNames = [];
        }
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        const issues = [];
        if (!(obj instanceof objects_1.ICFService)) {
            return [];
        }
        const handlers = obj.getHandlerList();
        if (handlers === undefined) {
            return [];
        }
        for (const h of handlers) {
            const clas = this.reg.getObject("CLAS", h);
            if (clas === undefined) {
                if (this.conf.skipNames && this.conf.skipNames.some((a) => a.toUpperCase() === h.toUpperCase())) {
                    continue;
                }
                const pattern = new RegExp(this.reg.getConfig().getSyntaxSetttings().errorNamespace, "i");
                if (pattern.test(h) === true) {
                    const message = "Handler class " + h + " not found";
                    const issue = issue_1.Issue.atPosition(obj.getFiles()[0], new position_1.Position(1, 1), message, this.getMetadata().key, this.conf.severity);
                    issues.push(issue);
                }
                continue;
            }
            const def = clas.getClassDefinition();
            if (def === undefined) {
                const message = "Syntax error in class " + h;
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], new position_1.Position(1, 1), message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                continue;
            }
            const implementing = this.findImplementing(def);
            if (implementing.findIndex((i) => { return i.name.toUpperCase() === "IF_HTTP_EXTENSION"; }) < 0) {
                const message = "Handler class " + h + " must implement IF_HTTP_EXTENSION";
                const issue = issue_1.Issue.atPosition(obj.getFiles()[0], new position_1.Position(1, 1), message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                continue;
            }
        }
        return issues;
    }
    ///////////////////////////
    findImplementing(def) {
        let ret = def.interfaces;
        let superName = def.superClassName;
        while (superName !== undefined) {
            const clas = this.reg.getObject("CLAS", superName);
            if (clas === undefined) {
                break;
            }
            const superDef = clas.getClassDefinition();
            if (superDef === undefined) {
                break;
            }
            ret = ret.concat(superDef.interfaces);
            superName = superDef.superClassName;
        }
        return ret;
    }
}
exports.SICFConsistency = SICFConsistency;
//# sourceMappingURL=sicf_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/slow_parameter_passing.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/slow_parameter_passing.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SlowParameterPassing = exports.SlowParameterPassingConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class SlowParameterPassingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SlowParameterPassingConf = SlowParameterPassingConf;
class SlowParameterPassing {
    constructor() {
        this.conf = new SlowParameterPassingConf();
    }
    getMetadata() {
        return {
            key: "slow_parameter_passing",
            title: "Slow Parameter Passing",
            shortDescription: `Detects slow pass by value passing for methods where parameter is not changed`,
            extendedInformation: `Method parameters defined in interfaces is not checked`,
            tags: [_irule_1.RuleTag.Performance],
            badExample: `CLASS lcl DEFINITION.
  PUBLIC SECTION.
    METHODS bar IMPORTING VALUE(sdf) TYPE string.
ENDCLASS.
CLASS lcl IMPLEMENTATION.
  METHOD bar.
    WRITE sdf.
  ENDMETHOD.
ENDCLASS.`,
            goodExample: `CLASS lcl DEFINITION.
  PUBLIC SECTION.
    METHODS bar IMPORTING sdf TYPE string.
ENDCLASS.
CLASS lcl IMPLEMENTATION.
  METHOD bar.
    WRITE sdf.
  ENDMETHOD.
ENDCLASS.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        const issues = [];
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const top = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop();
        const methods = this.listMethodNodes(top);
        for (const m of methods) {
            const vars = m.getData().vars;
            if (m.getIdentifier().sname.includes("~")) {
                // skip methods defined in interfaces
                // todo: checking for just "~" is not correct, there might be ALIASES
                continue;
            }
            for (const v in vars) {
                const id = vars[v];
                if (id.getMeta().includes("pass_by_value" /* IdentifierMeta.PassByValue */) === false) {
                    continue;
                }
                else if (this.reg.isFileDependency(id.getFilename()) === true) {
                    continue;
                }
                const writes = this.listWritePositions(m, id);
                if (writes.length === 0) {
                    const message = "Parameter " + id.getName() + " passed by VALUE but not changed";
                    issues.push(issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.getConfig().severity));
                }
            }
        }
        return issues;
    }
    listWritePositions(node, id) {
        var _a, _b;
        const ret = [];
        for (const v of node.getData().references) {
            if (v.referenceType === _reference_1.ReferenceType.DataWriteReference
                && ((_a = v.resolved) === null || _a === void 0 ? void 0 : _a.getFilename()) === id.getFilename()
                && ((_b = v.resolved) === null || _b === void 0 ? void 0 : _b.getStart().equals(id.getStart()))) {
                ret.push(v.position.getStart());
            }
        }
        return ret;
    }
    listMethodNodes(node) {
        const ret = [];
        if (node.getIdentifier().stype === _scope_type_1.ScopeType.Method) {
            ret.push(node);
        }
        else {
            for (const c of node.getChildren()) {
                ret.push(...this.listMethodNodes(c));
            }
        }
        return ret;
    }
}
exports.SlowParameterPassing = SlowParameterPassing;
//# sourceMappingURL=slow_parameter_passing.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/smim_consistency.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/smim_consistency.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SMIMConsistency = exports.SMIMConsistencyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class SMIMConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SMIMConsistencyConf = SMIMConsistencyConf;
class SMIMConsistency {
    constructor() {
        this.conf = new SMIMConsistencyConf();
    }
    getMetadata() {
        return {
            key: "smim_consistency",
            title: "SMIM consistency check",
            shortDescription: `SMIM consistency check`,
            extendedInformation: "Check folders exists",
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        const issues = [];
        if (!(obj instanceof objects_1.MIMEObject)) {
            return [];
        }
        const base = this.base(obj.getURL() || "");
        if (base !== "" && this.findFolder(base) === false) {
            const message = `Parent folder "${base}" not found`;
            const position = new position_1.Position(1, 1);
            const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, message, this.getMetadata().key, this.conf.severity);
            issues.push(issue);
        }
        return issues;
    }
    base(full) {
        const components = full.split("/");
        components.pop();
        return components.join("/");
    }
    findFolder(base) {
        for (const smim of this.reg.getObjectsByType("SMIM")) {
            const mime = smim;
            if (base === mime.getURL() && mime.isFolder() === true) {
                return true;
            }
        }
        return false;
    }
}
exports.SMIMConsistency = SMIMConsistency;
//# sourceMappingURL=smim_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/space_before_colon.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/space_before_colon.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpaceBeforeColon = exports.SpaceBeforeColonConf = void 0;
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class SpaceBeforeColonConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SpaceBeforeColonConf = SpaceBeforeColonConf;
class SpaceBeforeColon extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SpaceBeforeColonConf();
    }
    getMetadata() {
        return {
            key: "space_before_colon",
            title: "Space before colon",
            shortDescription: `Checks that there are no spaces in front of colons in chained statements.`,
            extendedInformation: `https://docs.abapopenchecks.org/checks/80/`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `DATA : foo TYPE string.`,
            goodExample: `DATA: foo TYPE string.`,
        };
    }
    getMessage() {
        return "Remove space before colon";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let prev = file.getTokens()[0];
        for (const token of file.getTokens()) {
            if (token.getStr() === ":" && !prev) {
                const issue = issue_1.Issue.atToken(file, token, this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
            else if (token.getStr() === ":"
                && prev.getRow() === token.getRow()
                && prev.getCol() + prev.getStr().length < token.getCol()) {
                const start = new position_1.Position(token.getRow(), prev.getEnd().getCol());
                const end = new position_1.Position(token.getRow(), token.getStart().getCol());
                const fix = edit_helper_1.EditHelper.deleteRange(file, start, end);
                const issue = issue_1.Issue.atRowRange(file, start.getRow(), start.getCol(), end.getCol(), this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            prev = token;
        }
        return issues;
    }
}
exports.SpaceBeforeColon = SpaceBeforeColon;
//# sourceMappingURL=space_before_colon.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/space_before_dot.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/space_before_dot.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SpaceBeforeDot = exports.SpaceBeforeDotConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const tokens_1 = __webpack_require__(/*! ../abap/1_lexer/tokens */ "./node_modules/@abaplint/core/build/src/abap/1_lexer/tokens/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
class SpaceBeforeDotConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.ignoreGlobalDefinition = true;
        this.ignoreExceptions = true;
    }
}
exports.SpaceBeforeDotConf = SpaceBeforeDotConf;
class SpaceBeforeDot extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SpaceBeforeDotConf();
    }
    getMetadata() {
        return {
            key: "space_before_dot",
            title: "Space before dot",
            shortDescription: `Checks for extra spaces before dots at the ends of statements`,
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#be-consistent
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#condense-your-code`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE bar .`,
            goodExample: `WRITE bar.`,
        };
    }
    getMessage() {
        return "Remove space before \",\" or \".\"";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        let prev = undefined;
        let startRow = 0;
        if (file.getStructure() === undefined) {
            // some parser error exists in file
            return [];
        }
        const ddic = new ddic_1.DDIC(this.reg);
        if (this.conf.ignoreGlobalDefinition) {
            const structure = file.getStructure();
            if (obj instanceof objects_1.Class && structure !== undefined) {
                const endclass = structure.findFirstStatement(Statements.EndClass);
                if (endclass !== undefined) {
                    startRow = endclass.getFirstToken().getRow();
                }
                const definition = obj.getClassDefinition();
                if (definition !== undefined && this.conf.ignoreExceptions && ddic.isException(definition, obj)) {
                    return [];
                }
            }
            else if (obj instanceof objects_1.Interface && structure !== undefined) {
                const endinterface = structure.findFirstStatement(Statements.EndInterface);
                if (endinterface !== undefined) {
                    startRow = endinterface.getFirstToken().getRow();
                }
            }
        }
        for (const t of file.getTokens()) {
            if (t.getRow() < startRow) {
                continue;
            }
            if (prev !== undefined && t instanceof tokens_1.Punctuation && prev.getCol() + prev.getStr().length < t.getCol()) {
                const start = new position_1.Position(t.getStart().getRow(), prev.getEnd().getCol());
                const end = new position_1.Position(t.getStart().getRow(), t.getStart().getCol());
                const fix = edit_helper_1.EditHelper.deleteRange(file, start, end);
                const issue = issue_1.Issue.atRange(file, start, end, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
            prev = t;
        }
        return issues;
    }
}
exports.SpaceBeforeDot = SpaceBeforeDot;
//# sourceMappingURL=space_before_dot.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/sql_escape_host_variables.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/sql_escape_host_variables.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLEscapeHostVariables = exports.SQLEscapeHostVariablesConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class SQLEscapeHostVariablesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SQLEscapeHostVariablesConf = SQLEscapeHostVariablesConf;
class SQLEscapeHostVariables extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SQLEscapeHostVariablesConf();
    }
    getMetadata() {
        return {
            key: "sql_escape_host_variables",
            title: "Escape SQL host variables",
            shortDescription: `Escape SQL host variables, from 740sp05`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#avoid-obsolete-language-elements`,
            tags: [_irule_1.RuleTag.Upport, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.Syntax],
            badExample: `SELECT * FROM tab INTO TABLE res WHERE field = val.`,
            goodExample: `SELECT * FROM tab INTO TABLE @res WHERE field = @val.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const type = obj.getType();
        if (type === "INTF" || type === "TYPE") {
            return [];
        }
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp02
            && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        for (const s of file.getStatements()) {
            if (s.get() instanceof Statements.UpdateDatabase
                || s.get() instanceof Statements.ModifyDatabase
                || s.get() instanceof Statements.Select
                || s.get() instanceof Statements.SelectLoop
                || s.get() instanceof Statements.InsertDatabase
                || s.get() instanceof Statements.DeleteDatabase) {
                for (const o of s.findAllExpressionsMulti([Expressions.SQLSource, Expressions.SQLSourceSimple])) {
                    const first = o.getFirstChild();
                    if (((first === null || first === void 0 ? void 0 : first.get()) instanceof Expressions.Source && first.getChildren()[0].get() instanceof Expressions.FieldChain)
                        || ((first === null || first === void 0 ? void 0 : first.get()) instanceof Expressions.SimpleSource3 && first.getChildren()[0].get() instanceof Expressions.FieldChain)) {
                        const message = "Escape SQL host variables";
                        const firstToken = o.getFirstChild().getFirstToken();
                        const fix = edit_helper_1.EditHelper.replaceToken(file, firstToken, "@" + (firstToken === null || firstToken === void 0 ? void 0 : firstToken.getStr()));
                        const issue = issue_1.Issue.atToken(file, first.getFirstToken(), message, this.getMetadata().key, this.conf.severity, fix);
                        issues.push(issue);
                        break;
                    }
                }
                for (const o of s.findAllExpressions(Expressions.SQLTarget)) {
                    const escaped = o.findDirectTokenByText("@");
                    if (escaped !== undefined) {
                        continue;
                    }
                    const message = "Escape SQL host variables";
                    const firstToken = o.getFirstChild().getFirstToken();
                    const fix = edit_helper_1.EditHelper.replaceToken(file, firstToken, "@" + (firstToken === null || firstToken === void 0 ? void 0 : firstToken.getStr()));
                    const issue = issue_1.Issue.atToken(file, o.getFirstToken(), message, this.getMetadata().key, this.conf.severity, fix);
                    issues.push(issue);
                    break;
                }
            }
        }
        return issues;
    }
}
exports.SQLEscapeHostVariables = SQLEscapeHostVariables;
//# sourceMappingURL=sql_escape_host_variables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/sql_value_conversion.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/sql_value_conversion.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SQLValueConversion = exports.SQLValueConversionConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class SQLValueConversionConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SQLValueConversionConf = SQLValueConversionConf;
class SQLValueConversion {
    constructor() {
        this.conf = new SQLValueConversionConf();
    }
    getMetadata() {
        return {
            key: "sql_value_conversion",
            title: "Implicit SQL Value Conversion",
            shortDescription: `Ensure types match when selecting from database`,
            extendedInformation: `
* Integer to CHAR conversion
* Integer to NUMC conversion
* NUMC to Integer conversion
* CHAR to Integer conversion
* Source field longer than database field, CHAR -> CHAR
* Source field longer than database field, NUMC -> NUMC`,
            tags: [],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject) || obj instanceof objects_1.Interface) {
            return [];
        }
        // messages defined in sql_compare.ts
        const issues = this.traverse(new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop());
        return issues;
    }
    traverse(node) {
        const ret = [];
        for (const r of node.getData().sqlConversion) {
            const file = this.reg.getFileByName(node.getIdentifier().filename);
            if (file === undefined) {
                continue;
            }
            ret.push(issue_1.Issue.atToken(file, r.token, r.message, this.getMetadata().key, this.getConfig().severity));
        }
        for (const c of node.getChildren()) {
            ret.push(...this.traverse(c));
        }
        return ret;
    }
}
exports.SQLValueConversion = SQLValueConversion;
//# sourceMappingURL=sql_value_conversion.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/start_at_tab.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/start_at_tab.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StartAtTab = exports.StartAtTabConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class StartAtTabConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.StartAtTabConf = StartAtTabConf;
class StartAtTab extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new StartAtTabConf();
    }
    getMetadata() {
        return {
            key: "start_at_tab",
            title: "Start at tab",
            shortDescription: `Checks that statements start at tabstops.`,
            extendedInformation: `Reports max 100 issues per file
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#indent-and-snap-to-tab`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: ` WRITE a.`,
            goodExample: `  WRITE a.`,
        };
    }
    getMessage() {
        return "Start statement at tab position";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let inType = false;
        let previous = undefined;
        const raw = file.getRawRows();
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            else if (statement.get() instanceof statements_1.TypeBegin) {
                inType = true;
            }
            else if (statement.get() instanceof statements_1.TypeEnd) {
                inType = false;
            }
            else if (inType) {
                continue;
            }
            const pos = statement.getStart();
            if (previous !== undefined && pos.getRow() === previous.getRow()) {
                continue;
            }
            // just skip rows that contains tabs, this will be reported by the contains_tab rule
            if ((pos.getCol() - 1) % 2 !== 0 && raw[pos.getRow() - 1].includes("\t") === false) {
                const issue = issue_1.Issue.atPosition(file, pos, this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                if (issues.length >= 100) {
                    return issues; // only max 100 issues perfile
                }
            }
            previous = pos;
        }
        return issues;
    }
}
exports.StartAtTab = StartAtTab;
//# sourceMappingURL=start_at_tab.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/static_call_via_instance.js":
/*!*********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/static_call_via_instance.js ***!
  \*********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StaticCallViaInstance = exports.StaticCallViaInstanceConf = void 0;
/* eslint-disable max-len */
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
class StaticCallViaInstanceConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow in test class includes */
        this.allowInTestclassIncludes = false;
    }
}
exports.StaticCallViaInstanceConf = StaticCallViaInstanceConf;
class StaticCallViaInstance extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new StaticCallViaInstanceConf();
    }
    getMetadata() {
        return {
            key: "static_call_via_instance",
            title: "Static call via instance variable",
            shortDescription: `Static method call via instance variable`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#dont-call-static-methods-through-instance-variables`,
            tags: [_irule_1.RuleTag.Styleguide],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (this.getConfig().allowInTestclassIncludes === true && file.getFilename().includes(".testclasses.")) {
            return [];
        }
        const staticMethodCalls = this.listMethodCalls(file.getFilename(), new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti.getTop());
        const tokens = file.getTokens();
        for (let i = 0; i < tokens.length - 1; i++) {
            const token = tokens[i];
            if (token.getStr() !== "->") {
                continue;
            }
            const next = tokens[i + 1];
            for (const s of staticMethodCalls) {
                if (s.equals(next.getStart())) {
                    const message = "Avoid calling static method via instance";
                    issues.push(issue_1.Issue.atToken(file, token, message, this.getMetadata().key));
                    break;
                }
            }
        }
        return issues;
    }
    listMethodCalls(filename, node) {
        const ret = [];
        for (const r of node.getData().references) {
            if (r.referenceType !== _reference_1.ReferenceType.MethodReference || r.position.getFilename() !== filename) {
                continue;
            }
            if (r.resolved instanceof types_1.MethodDefinition && r.resolved.isStatic() === true) {
                ret.push(r.position.getStart());
            }
        }
        for (const child of node.getChildren()) {
            ret.push(...this.listMethodCalls(filename, child));
        }
        return ret;
    }
}
exports.StaticCallViaInstance = StaticCallViaInstance;
//# sourceMappingURL=static_call_via_instance.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/strict_sql.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/strict_sql.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.StrictSQL = exports.StrictSQLConf = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class StrictSQLConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.StrictSQLConf = StrictSQLConf;
class StrictSQL extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new StrictSQLConf();
    }
    getMetadata() {
        return {
            key: "strict_sql",
            title: "Strict SQL",
            shortDescription: `Strict SQL`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-US/abapinto_clause.htm

https://help.sap.com/doc/abapdocu_751_index_htm/7.51/en-us/abenopensql_strict_mode_750.htm

Also see separate rule sql_escape_host_variables

Activates from v750 and up`,
            tags: [_irule_1.RuleTag.Upport, _irule_1.RuleTag.Quickfix],
            badExample: `SELECT * FROM ztabl INTO TABLE @rt_content WHERE type = @iv_type ORDER BY PRIMARY KEY.`,
            goodExample: `SELECT * FROM ztabl WHERE type = @iv_type ORDER BY PRIMARY KEY INTO TABLE @rt_content.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const type = obj.getType();
        if (type === "INTF" || type === "TYPE") {
            return [];
        }
        if (this.reg.getConfig().getVersion() < version_1.Version.v750
            && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        for (const s of file.getStatements()) {
            if (s.get() instanceof Statements.Select
                || s.get() instanceof Statements.SelectLoop) {
                const expr = s.findDirectExpression(Expressions.Select);
                const where = expr === null || expr === void 0 ? void 0 : expr.findDirectExpression(Expressions.SQLCond);
                const order = expr === null || expr === void 0 ? void 0 : expr.findDirectExpression(Expressions.SQLOrderBy);
                const into = (expr === null || expr === void 0 ? void 0 : expr.findDirectExpression(Expressions.SQLIntoStructure))
                    || (expr === null || expr === void 0 ? void 0 : expr.findDirectExpression(Expressions.SQLIntoList))
                    || (expr === null || expr === void 0 ? void 0 : expr.findDirectExpression(Expressions.SQLIntoTable));
                if (into === undefined || where === undefined) {
                    continue;
                }
                else if (where.getFirstToken().getStart().isBefore(into.getFirstToken().getStart())) {
                    continue;
                }
                const fix1 = edit_helper_1.EditHelper.deleteRange(file, into.getFirstToken().getStart(), into.getLastToken().getEnd());
                let last = where.getLastToken();
                if (order && order.getLastToken().getEnd().isAfter(last.getEnd())) {
                    last = order.getLastToken();
                }
                const fix2 = edit_helper_1.EditHelper.insertAt(file, last.getEnd(), " " + into.concatTokens());
                const fix = edit_helper_1.EditHelper.merge(fix2, fix1);
                const message = "INTO/APPENDING must be last in strict SQL";
                const issue = issue_1.Issue.atToken(file, s.getFirstToken(), message, this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.StrictSQL = StrictSQL;
//# sourceMappingURL=strict_sql.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/superclass_final.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/superclass_final.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuperclassFinal = exports.SuperclassFinalConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class SuperclassFinalConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SuperclassFinalConf = SuperclassFinalConf;
class SuperclassFinal extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SuperclassFinalConf();
    }
    getMetadata() {
        return {
            key: "superclass_final",
            title: "Super class final",
            shortDescription: `Checks that classes which are inherited from are not declared as FINAL.`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getMessage() {
        return "Superclasses cannot be FINAL";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const output = [];
        for (const definition of file.getInfo().listClassDefinitions()) {
            const sup = definition.superClassName;
            if (sup === undefined) {
                continue;
            }
            let localLookup = true;
            if (obj instanceof Objects.Class && file.getFilename().match(/\.clas\.abap$/)) {
                localLookup = false;
            }
            let found = undefined;
            if (localLookup) {
                for (const f of obj.getABAPFiles()) {
                    found = f.getInfo().getClassDefinitionByName(sup);
                    if (found !== undefined) {
                        break;
                    }
                }
            }
            if (found === undefined) {
                const clas = this.reg.getObject("CLAS", sup);
                if (clas) {
                    found = clas.getClassDefinition();
                }
            }
            if (found === undefined) {
                const message = "Super class \"" + sup + "\" not found";
                const issue = issue_1.Issue.atIdentifier(definition.identifier, message, this.getMetadata().key, this.conf.severity);
                output.push(issue);
                continue;
            }
            if (found.isFinal === true) {
                const issue = issue_1.Issue.atIdentifier(definition.identifier, this.getMessage(), this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        return output;
    }
}
exports.SuperclassFinal = SuperclassFinal;
//# sourceMappingURL=superclass_final.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/superfluous_value.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/superfluous_value.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SuperfluousValue = exports.SuperfluousValueConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
class SuperfluousValueConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SuperfluousValueConf = SuperfluousValueConf;
class SuperfluousValue extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SuperfluousValueConf();
    }
    getMetadata() {
        return {
            key: "superfluous_value",
            title: "Superfluous VALUE",
            shortDescription: `Find superfluous VALUE expressions`,
            extendedInformation: `Left hand side is inline, VALUE is inferred, value body is simple, from v740sp02 and up`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `DATA(message_entry) = VALUE #( message_table[ msgno = msgno ] ).`,
            goodExample: `DATA(message_entry) = message_table[ msgno = msgno ].`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b;
        const output = [];
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp02
            && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        const struc = file.getStructure();
        if (struc === undefined) {
            return []; // syntax error
        }
        for (const m of struc.findAllStatements(Statements.Move)) {
            if (((_a = m.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.findDirectExpression(Expressions.InlineData)) === undefined) {
                continue;
            }
            const source = m.findDirectExpression(Expressions.Source);
            if (source === undefined) {
                continue;
            }
            const type = (_b = source.findDirectExpression(Expressions.TypeNameOrInfer)) === null || _b === void 0 ? void 0 : _b.concatTokens();
            if (type !== "#") {
                continue;
            }
            const body = source.findDirectExpression(Expressions.ValueBody);
            if (body === undefined) {
                continue;
            }
            if (body.getChildren().length === 1) {
                const message = "Superfluous VALUE expression";
                const issue = issue_1.Issue.atStatement(file, m, message, this.getMetadata().key, this.conf.severity);
                output.push(issue);
            }
        }
        return output;
    }
}
exports.SuperfluousValue = SuperfluousValue;
//# sourceMappingURL=superfluous_value.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/sy_modification.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/sy_modification.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SyModification = exports.SyModificationConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class SyModificationConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.SyModificationConf = SyModificationConf;
class SyModification extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new SyModificationConf();
    }
    getMetadata() {
        return {
            key: "sy_modification",
            title: "Modification of SY fields",
            shortDescription: `Finds modification of sy fields`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_750_index_htm/7.50/en-US/abensystem_fields.htm

Changes to SY-TVAR* fields are not reported`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `sy-uname = 2.
sy = sy.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a;
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        for (const t of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.Target)) || []) {
            const firstChild = t.getChildren()[0];
            if (firstChild.get() instanceof Expressions.TargetField
                && firstChild.getFirstToken().getStr().toUpperCase() === "SY") {
                if (t.concatTokens().toUpperCase().startsWith("SY-TVAR")) {
                    continue;
                }
                const message = "Modification of SY field";
                const issue = issue_1.Issue.atToken(file, firstChild.getFirstToken(), message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.SyModification = SyModification;
//# sourceMappingURL=sy_modification.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/tabl_enhancement_category.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/tabl_enhancement_category.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TABLEnhancementCategory = exports.TABLEnhancementCategoryConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
class TABLEnhancementCategoryConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.TABLEnhancementCategoryConf = TABLEnhancementCategoryConf;
class TABLEnhancementCategory {
    constructor() {
        this.conf = new TABLEnhancementCategoryConf();
    }
    getMetadata() {
        return {
            key: "tabl_enhancement_category",
            title: "TABL enhancement category must be set",
            shortDescription: `Checks that tables do not have the enhancement category 'not classified'.`,
            extendedInformation: `SAP note 3063227 changes the default to 'Cannot be enhanced'.

You may use standard report RS_DDIC_CLASSIFICATION_FINAL for adjustment.`,
            tags: [],
        };
    }
    getDescription(name) {
        return "TABL enhancement category not classified in " + name;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        if (!(obj instanceof objects_1.Table)) {
            return [];
        }
        if (obj.getEnhancementCategory() === objects_1.EnhancementCategory.NotClassified) {
            const position = new position_1.Position(1, 1);
            const issue = issue_1.Issue.atPosition(obj.getFiles()[0], position, this.getDescription(obj.getName()), this.getMetadata().key, this.conf.severity);
            return [issue];
        }
        return [];
    }
}
exports.TABLEnhancementCategory = TABLEnhancementCategory;
//# sourceMappingURL=tabl_enhancement_category.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/tables_declared_locally.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/tables_declared_locally.js ***!
  \********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TablesDeclaredLocally = exports.TablesDeclaredLocallyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class TablesDeclaredLocallyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.TablesDeclaredLocallyConf = TablesDeclaredLocallyConf;
class TablesDeclaredLocally extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new TablesDeclaredLocallyConf();
    }
    getMetadata() {
        return {
            key: "tables_declared_locally",
            title: "Check for locally declared TABLES",
            shortDescription: `TABLES are always global, so declare them globally`,
            extendedInformation: `https://help.sap.com/doc/abapdocu_752_index_htm/7.52/en-us/abaptables.htm`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `FORM foo.
  TABLES t100.
ENDFORM.`,
            goodExample: `TABLES t000.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return issues;
        }
        const procedures = structure.findAllStructuresMulti([Structures.Form, Structures.FunctionModule]);
        for (const p of procedures) {
            const tablesStatement = p.findFirstStatement(Statements.Tables);
            if (tablesStatement) {
                const message = "Declare TABLES globaly";
                const issue = issue_1.Issue.atStatement(file, tablesStatement, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.TablesDeclaredLocally = TablesDeclaredLocally;
//# sourceMappingURL=tables_declared_locally.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/try_without_catch.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/try_without_catch.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TryWithoutCatch = exports.TryWithoutCatchConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const structures_1 = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class TryWithoutCatchConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.TryWithoutCatchConf = TryWithoutCatchConf;
class TryWithoutCatch extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new TryWithoutCatchConf();
    }
    getMetadata() {
        return {
            key: "try_without_catch",
            title: "TRY without CATCH",
            shortDescription: `Checks for TRY blocks without a CATCH and CLEANUP block`,
            badExample: `TRY.\n  WRITE 'hello world'.\nENDTRY.`,
            tags: [_irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "A TRY block must have a corresponding CATCH or CLEANUP block.";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        const tries = stru.findAllStructures(structures_1.Try);
        for (const t of tries) {
            const clean = t.findDirectStructures(structures_1.Cleanup);
            const c = t.findDirectStructures(structures_1.Catch);
            if (c.length === 0 && clean.length === 0) {
                const issue = issue_1.Issue.atToken(file, t.getFirstToken(), this.getMessage(), this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.TryWithoutCatch = TryWithoutCatch;
//# sourceMappingURL=try_without_catch.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/type_form_parameters.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/type_form_parameters.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypeFormParameters = exports.TypeFormParametersConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class TypeFormParametersConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.TypeFormParametersConf = TypeFormParametersConf;
class TypeFormParameters extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new TypeFormParametersConf();
    }
    getMetadata() {
        return {
            key: "type_form_parameters",
            title: "Type FORM parameters",
            shortDescription: `Checks for untyped FORM parameters`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `FORM foo USING bar.
ENDFORM.`,
            goodExample: `FORM foo USING bar TYPE string.
ENDFORM.`,
        };
    }
    getDescription(parameterName) {
        return "Add TYPE for FORM parameter \"" + parameterName + "\"";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const ret = [];
        const stru = file.getStructure();
        if (obj instanceof objects_1.Class || stru === undefined) {
            return ret;
        }
        for (const formparam of stru.findAllExpressions(Expressions.FormParam)) {
            if (formparam.findFirstExpression(Expressions.FormParamType) === undefined) {
                const token = formparam.getFirstToken();
                const issue = issue_1.Issue.atToken(file, token, this.getDescription(token.getStr()), this.getMetadata().key, this.conf.severity);
                ret.push(issue);
            }
        }
        return ret;
    }
}
exports.TypeFormParameters = TypeFormParameters;
//# sourceMappingURL=type_form_parameters.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/types_naming.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/types_naming.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.TypesNaming = exports.TypesNamingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class TypesNamingConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** The pattern for TYPES, case insensitive */
        this.pattern = "^TY_.+$";
    }
}
exports.TypesNamingConf = TypesNamingConf;
class TypesNaming extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new TypesNamingConf();
    }
    getMetadata() {
        return {
            key: "types_naming",
            title: "TYPES naming conventions",
            shortDescription: `Allows you to enforce a pattern for TYPES definitions`,
            extendedInformation: `Does not run for TYPE POOLS`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.SingleFile],
            badExample: `TYPES foo TYPE i.`,
            goodExample: `TYPES ty_foo TYPE i.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        const testRegex = new RegExp(this.conf.pattern, "i");
        let nesting = 0;
        if (obj instanceof objects_1.TypePool) {
            return [];
        }
        for (const stat of file.getStatements()) {
            let expr = undefined;
            if (stat.get() instanceof Statements.Type && nesting === 0) {
                expr = stat.findFirstExpression(Expressions.NamespaceSimpleName);
            }
            else if (stat.get() instanceof Statements.TypeBegin
                || stat.get() instanceof Statements.TypeEnumBegin) {
                if (nesting === 0) {
                    expr = stat.findFirstExpression(Expressions.NamespaceSimpleName);
                }
                nesting = nesting + 1;
            }
            else if (stat.get() instanceof Statements.TypeEnd
                || stat.get() instanceof Statements.TypeEnumEnd) {
                nesting = nesting - 1;
                continue;
            }
            else {
                continue;
            }
            if (expr === undefined) {
                continue;
            }
            const token = expr.getFirstToken();
            if (testRegex.exec(token.getStr())) {
                continue;
            }
            else {
                const message = "Bad TYPES naming, expected \"" + this.conf.pattern + "\", got \"" + token.getStr() + "\"";
                const issue = issue_1.Issue.atToken(file, token, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
            }
        }
        return issues;
    }
}
exports.TypesNaming = TypesNaming;
//# sourceMappingURL=types_naming.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/uncaught_exception.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/uncaught_exception.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UncaughtException = exports.UncaughtExceptionConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const nodes_1 = __webpack_require__(/*! ../abap/nodes */ "./node_modules/@abaplint/core/build/src/abap/nodes/index.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const ddic_1 = __webpack_require__(/*! ../ddic */ "./node_modules/@abaplint/core/build/src/ddic.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const types_1 = __webpack_require__(/*! ../abap/types */ "./node_modules/@abaplint/core/build/src/abap/types/index.js");
class UncaughtExceptionConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        this.reportDynamic = false;
        this.reportNoCheck = false;
    }
}
exports.UncaughtExceptionConf = UncaughtExceptionConf;
class UncaughtException extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UncaughtExceptionConf();
        this.issues = [];
    }
    getMetadata() {
        return {
            key: "uncaught_exception",
            title: "Uncaught Exception",
            shortDescription: `Checks for uncaught static exception`,
            extendedInformation: `Does not report any issues if the code contains syntax errors`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    initialize(reg) {
        super.initialize(reg);
        this.findGlobalExceptions();
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        if (obj.getType() === "INTF") { // nothing can be raised in interfaces
            return [];
        }
        if (obj instanceof objects_1.Program && obj.isInclude() === true) {
            return [];
        }
        const stru = file.getStructure();
        if (stru === undefined) {
            return [];
        }
        this.findLocalExceptions(obj);
        this.syntax = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (this.syntax.issues.length > 0) {
            return [];
        }
        this.issues = [];
        this.sinked = undefined;
        for (const c of stru.getChildren()) {
            this.traverse(c, file);
        }
        return this.issues;
    }
    traverse(n, file) {
        var _a, _b, _c, _d, _e, _f;
        const get = n.get();
        if (get instanceof Structures.ClassDefinition
            || get instanceof Structures.Interface) {
            return; // to optimize performance
        }
        if (n instanceof nodes_1.StructureNode) {
            if (get instanceof Structures.Try) {
                // note that TRY-CATCH might be arbitrarily nested
                const previous = this.sinked ? this.sinked.slice() : undefined;
                this.addFromTryStructure(n);
                for (const c of ((_a = n.findDirectStructure(Structures.Body)) === null || _a === void 0 ? void 0 : _a.getChildren()) || []) {
                    this.traverse(c, file);
                }
                this.sinked = previous;
                for (const c of ((_b = n.findDirectStructure(Structures.Catch)) === null || _b === void 0 ? void 0 : _b.getChildren()) || []) {
                    this.traverse(c, file);
                }
                for (const c of ((_c = n.findDirectStructure(Structures.Cleanup)) === null || _c === void 0 ? void 0 : _c.getChildren()) || []) {
                    this.traverse(c, file);
                }
                return;
            }
            else {
                for (const c of n.getChildren()) {
                    this.traverse(c, file);
                }
            }
        }
        else if (n instanceof nodes_1.StatementNode) {
            if (get instanceof Statements.MethodImplementation) {
                this.setSinkedFromMethod(n, file);
            }
            else if (get instanceof Statements.EndMethod) {
                this.sinked = undefined; // back to top level
            }
            else if (get instanceof Statements.Form) {
                this.sinked = [];
                const raising = n.findDirectExpression(Expressions.FormRaising);
                for (const c of (raising === null || raising === void 0 ? void 0 : raising.findAllExpressions(Expressions.ClassName)) || []) {
                    this.sinked.push(c.concatTokens().toUpperCase());
                }
            }
            else if (get instanceof Statements.EndForm) {
                this.sinked = undefined; // back to top level
            }
            else if (get instanceof Statements.Raise) {
                let name = undefined;
                const concat = n.concatTokens().toUpperCase();
                if (concat.startsWith("RAISE EXCEPTION TYPE ")) {
                    name = (_d = n.findFirstExpression(Expressions.ClassName)) === null || _d === void 0 ? void 0 : _d.getFirstToken().getStr().toUpperCase();
                }
                else if (concat.startsWith("RAISE EXCEPTION NEW ")) {
                    name = (_f = (_e = n.findFirstExpression(Expressions.NewObject)) === null || _e === void 0 ? void 0 : _e.findFirstExpression(Expressions.TypeNameOrInfer)) === null || _f === void 0 ? void 0 : _f.getFirstToken().getStr().toUpperCase();
                    // todo: else its a normal Source, infer the type from it
                }
                this.check(name, n, file);
            }
            else if (get instanceof Statements.Perform) {
                // todo, PERFORM, or is this not statically checked?
            }
            else {
                this.checkForMethodCalls(n, file);
            }
        }
    }
    ////////////////////////////////
    check(name, n, file) {
        if (this.isSinked(name) === false) {
            const issue = issue_1.Issue.atStatement(file, n, "Uncaught exception " + name, this.getMetadata().key, this.getConfig().severity);
            this.issues.push(issue);
        }
    }
    checkForMethodCalls(n, file) {
        const start = n.getFirstToken().getStart();
        const end = n.getLastToken().getEnd();
        const scope = this.syntax.spaghetti.lookupPosition(start, file.getFilename());
        for (const r of (scope === null || scope === void 0 ? void 0 : scope.getData().references) || []) {
            if (r.referenceType === _reference_1.ReferenceType.MethodReference
                && r.position.getStart().isAfter(start)
                && r.position.getEnd().isBefore(end)
                && r.resolved instanceof types_1.MethodDefinition) {
                for (const name of r.resolved.getRaising()) {
                    this.check(name, n, file);
                }
            }
        }
    }
    addFromTryStructure(s) {
        if (this.sinked === undefined) {
            return;
        }
        for (const structure of s.findDirectStructures(Structures.Catch)) {
            const c = structure.findDirectStatement(Statements.Catch);
            if (c === undefined) {
                continue;
            }
            for (const cn of c.findDirectExpressions(Expressions.ClassName)) {
                this.sinked.push(cn.concatTokens());
            }
        }
    }
    setSinkedFromMethod(s, file) {
        this.sinked = [];
        const scope = this.syntax.spaghetti.lookupPosition(s.getLastToken().getEnd(), file.getFilename());
        let def = undefined;
        for (const r of (scope === null || scope === void 0 ? void 0 : scope.getData().references) || []) {
            // there should be only one, so the first is okay
            if (r.referenceType === _reference_1.ReferenceType.MethodImplementationReference
                && r.resolved instanceof types_1.MethodDefinition) {
                def = r.resolved;
                break;
            }
        }
        if (def === undefined) {
            return; // this should not occur, so just report everything as errors
        }
        def.getRaising().forEach(r => { var _a; return (_a = this.sinked) === null || _a === void 0 ? void 0 : _a.push(r); });
    }
    isSinked(name) {
        if (this.sinked === undefined || name === undefined) {
            return true;
        }
        const sup = this.globalExceptions[name.toUpperCase()];
        if (sup === "CX_DYNAMIC_CHECK" && this.getConfig().reportDynamic !== true) {
            return true;
        }
        if (sup === "CX_NO_CHECK" && this.getConfig().reportNoCheck !== true) {
            return true;
        }
        const lsup = this.localExceptions[name.toUpperCase()];
        if (lsup === "CX_DYNAMIC_CHECK" && this.getConfig().reportDynamic !== true) {
            return true;
        }
        if (lsup === "CX_NO_CHECK" && this.getConfig().reportNoCheck !== true) {
            return true;
        }
        return this.sinked.some(a => a.toUpperCase() === name.toUpperCase())
            || (sup !== undefined && this.isSinked(sup) === true)
            || (lsup !== undefined && this.isSinked(lsup) === true);
    }
    findGlobalExceptions() {
        var _a, _b;
        this.globalExceptions = {};
        const ddic = new ddic_1.DDIC(this.reg);
        for (const o of this.reg.getObjects()) {
            if (!(o instanceof objects_1.Class)) {
                continue;
            }
            const def = (_a = o.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getInfo().getClassDefinitionByName(o.getName());
            if (def === undefined || ddic.isException(def, o) === false) {
                continue;
            }
            this.globalExceptions[o.getName().toUpperCase()] = (_b = def.superClassName) === null || _b === void 0 ? void 0 : _b.toUpperCase();
        }
    }
    findLocalExceptions(obj) {
        var _a;
        this.localExceptions = {};
        for (const file of obj.getABAPFiles()) {
            for (const def of file.getInfo().listClassDefinitions()) {
                if (def.isLocal === true && def.superClassName !== undefined) {
                    this.localExceptions[def.name.toUpperCase()] = (_a = def.superClassName) === null || _a === void 0 ? void 0 : _a.toUpperCase();
                }
            }
        }
    }
}
exports.UncaughtException = UncaughtException;
//# sourceMappingURL=uncaught_exception.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unknown_types.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unknown_types.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnknownTypes = exports.UnknownTypesConf = void 0;
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const BasicTypes = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _typed_identifier_1 = __webpack_require__(/*! ../abap/types/_typed_identifier */ "./node_modules/@abaplint/core/build/src/abap/types/_typed_identifier.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const basic_1 = __webpack_require__(/*! ../abap/types/basic */ "./node_modules/@abaplint/core/build/src/abap/types/basic/index.js");
class UnknownTypesConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnknownTypesConf = UnknownTypesConf;
class UnknownTypes {
    constructor() {
        this.conf = new UnknownTypesConf();
    }
    getMetadata() {
        return {
            key: "unknown_types",
            title: "Unknown types",
            shortDescription: `Enables check for unknown data types, respects errorNamespace`,
            tags: [_irule_1.RuleTag.Syntax],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const spaghetti = new syntax_1.SyntaxLogic(this.reg, obj).run().spaghetti;
        const found = this.traverse(spaghetti.getTop());
        return this.removeDuplicates(found);
    }
    /////////////////////
    removeDuplicates(list) {
        const deduplicated = [];
        for (const result of list) {
            let cont = false;
            for (const d of deduplicated) {
                if (result.getStart().equals(d.getStart())) {
                    cont = true;
                    break;
                }
            }
            if (cont === true) {
                continue;
            }
            deduplicated.push(result);
        }
        return deduplicated;
    }
    traverse(node) {
        var _a;
        const ret = [];
        const nodeData = node.getData();
        for (const r of nodeData.references) {
            if (r.referenceType === _reference_1.ReferenceType.ObjectOrientedUnknownReference && ((_a = r.extra) === null || _a === void 0 ? void 0 : _a.ooName)) {
                const message = r.extra.ooName + " unknown";
                ret.push(issue_1.Issue.atIdentifier(r.position, message, this.getMetadata().key, this.conf.severity));
            }
            if (r.referenceType === _reference_1.ReferenceType.TypeReference
                && r.resolved instanceof _typed_identifier_1.TypedIdentifier
                && r.resolved.getType() instanceof basic_1.UnknownType) {
                const message = r.resolved.getType().getError();
                ret.push(issue_1.Issue.atIdentifier(r.position, message, this.getMetadata().key, this.conf.severity));
            }
        }
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.ClassImplementation) {
            const vars = nodeData.vars;
            for (const name in vars) {
                const identifier = vars[name];
                const found = this.containsUnknown(identifier.getType());
                if (found) {
                    const message = "Variable \"" + name + "\" contains unknown: " + found;
                    ret.push(issue_1.Issue.atIdentifier(identifier, message, this.getMetadata().key, this.conf.severity));
                }
            }
            const types = nodeData.types;
            for (const name in types) {
                const identifier = types[name];
                const found = this.containsUnknown(identifier.getType());
                if (found) {
                    const message = "Type \"" + name + "\" contains unknown: " + found;
                    ret.push(issue_1.Issue.atIdentifier(identifier, message, this.getMetadata().key, this.conf.severity));
                }
            }
        }
        for (const name in nodeData.idefs) {
            const v = nodeData.idefs[name];
            const found = this.checkParameters(v);
            if (found) {
                const message = "Contains unknown, " + found.found;
                ret.push(issue_1.Issue.atIdentifier(found.id, message, this.getMetadata().key, this.conf.severity));
            }
        }
        for (const name in nodeData.cdefs) {
            const v = nodeData.cdefs[name];
            const found = this.checkParameters(v);
            if (found) {
                const message = "Contains unknown, " + found.found;
                ret.push(issue_1.Issue.atIdentifier(found.id, message, this.getMetadata().key, this.conf.severity));
            }
        }
        for (const n of node.getChildren()) {
            ret.push(...this.traverse(n));
        }
        return ret;
    }
    checkParameters(idef) {
        var _a;
        for (const m of ((_a = idef.getMethodDefinitions()) === null || _a === void 0 ? void 0 : _a.getAll()) || []) {
            for (const p of m.getParameters().getAll()) {
                const found = this.containsUnknown(p.getType());
                if (found) {
                    return { id: p, found };
                }
            }
        }
        for (const e of idef.getEvents() || []) {
            for (const p of e.getParameters()) {
                const found = this.containsUnknown(p.getType());
                if (found) {
                    return { id: p, found };
                }
            }
        }
        return undefined;
    }
    containsUnknown(type) {
        if (type instanceof BasicTypes.UnknownType) {
            return type.getError();
        }
        else if (type instanceof BasicTypes.StructureType) {
            for (const c of type.getComponents()) {
                const found = this.containsUnknown(c.type instanceof _typed_identifier_1.TypedIdentifier ? c.type.getType() : c.type);
                if (found) {
                    return found;
                }
            }
        }
        else if (type instanceof BasicTypes.TableType) {
            return this.containsUnknown(type.getRowType());
        }
        return undefined;
    }
}
exports.UnknownTypes = UnknownTypes;
//# sourceMappingURL=unknown_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unnecessary_chaining.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unnecessary_chaining.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnnecessaryChaining = exports.UnnecessaryChainingConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class UnnecessaryChainingConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnnecessaryChainingConf = UnnecessaryChainingConf;
class UnnecessaryChaining extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UnnecessaryChainingConf();
    }
    getMetadata() {
        return {
            key: "unnecessary_chaining",
            title: "Unnecessary Chaining",
            shortDescription: `Find unnecessary chaining, all statements are checked`,
            extendedInformation: ``,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `WRITE: bar.`,
            goodExample: `WRITE bar.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const statements = file.getStatements();
        for (let i = 0; i < statements.length; i++) {
            const colon = statements[i].getColon();
            if (colon === undefined) {
                continue;
            }
            let j = 1;
            let nextStatement = statements[i + j];
            while ((nextStatement === null || nextStatement === void 0 ? void 0 : nextStatement.get()) instanceof _statement_1.Comment) {
                j++;
                nextStatement = statements[i + j];
            }
            j = 1;
            let prevStatement = statements[i - j];
            while ((prevStatement === null || prevStatement === void 0 ? void 0 : prevStatement.get()) instanceof _statement_1.Comment) {
                j++;
                prevStatement = statements[i - j];
            }
            const next = nextStatement === null || nextStatement === void 0 ? void 0 : nextStatement.getColon();
            const prev = prevStatement === null || prevStatement === void 0 ? void 0 : prevStatement.getColon();
            if (next !== undefined && colon.getStart().equals(next.getStart())) {
                continue;
            }
            else if (prev !== undefined && colon.getStart().equals(prev.getStart())) {
                continue;
            }
            const fix = edit_helper_1.EditHelper.deleteRange(file, colon.getStart(), colon.getEnd());
            const message = "Unnecessary chaining";
            const issue = issue_1.Issue.atToken(file, colon, message, this.getMetadata().key, this.conf.severity, fix);
            issues.push(issue);
        }
        return issues;
    }
}
exports.UnnecessaryChaining = UnnecessaryChaining;
//# sourceMappingURL=unnecessary_chaining.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unnecessary_pragma.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unnecessary_pragma.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnnecessaryPragma = exports.UnnecessaryPragmaConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class UnnecessaryPragmaConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow NO_TEXT in global CLAS and INTF definitions,
            its added automatically by SE24 in some cases where it should not */
        this.allowNoTextGlobal = false;
    }
}
exports.UnnecessaryPragmaConf = UnnecessaryPragmaConf;
class UnnecessaryPragma extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UnnecessaryPragmaConf();
    }
    getMetadata() {
        return {
            key: "unnecessary_pragma",
            title: "Unnecessary Pragma",
            shortDescription: `Finds pragmas which can be removed`,
            extendedInformation: `* NO_HANDLER with handler

* NEEDED without definition

* NO_TEXT without texts

* SUBRC_OK where sy-subrc is checked

NO_HANDLER inside macros are not checked`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `TRY.
    ...
  CATCH zcx_abapgit_exception ##NO_HANDLER.
    RETURN. " it has a handler
ENDTRY.
MESSAGE w125(zbar) WITH c_foo INTO message ##NEEDED ##NO_TEXT.
SELECT SINGLE * FROM tadir INTO @DATA(sdfs) ##SUBRC_OK.
IF sy-subrc <> 0.
ENDIF.`,
            goodExample: `TRY.
    ...
  CATCH zcx_abapgit_exception.
    RETURN.
ENDTRY.
MESSAGE w125(zbar) WITH c_foo INTO message.
SELECT SINGLE * FROM tadir INTO @DATA(sdfs).
IF sy-subrc <> 0.
ENDIF.

DATA: BEGIN OF blah ##NEEDED,
        test1 TYPE string,
        test2 TYPE string,
      END OF blah.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        let noHandler = false;
        let globalDefinition = false;
        const statements = file.getStatements();
        for (let i = 0; i < statements.length; i++) {
            const statement = statements[i];
            const nextStatement = statements[i + 1];
            if (statement.get() instanceof Statements.EndTry) {
                noHandler = false;
            }
            else if (statement.get() instanceof Statements.ClassDefinition
                || statement.get() instanceof Statements.Interface) {
                if (statement.findDirectExpression(Expressions.ClassGlobal)) {
                    globalDefinition = true;
                }
            }
            else if (statement.get() instanceof Statements.EndClass
                || statement.get() instanceof Statements.EndInterface) {
                globalDefinition = false;
            }
            else if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            else if (noHandler === true && !(statement.get() instanceof Statements.Catch)) {
                const message = "NO_HANDLER pragma or pseudo comment can be removed";
                const issue = issue_1.Issue.atStatement(file, statement, message, this.getMetadata().key, this.conf.severity);
                issues.push(issue);
                noHandler = false;
            }
            else {
                noHandler = this.containsNoHandler(statement, statements[i + 1]);
            }
            if (this.getConfig().allowNoTextGlobal === true && globalDefinition === true) {
                // skip
            }
            else {
                issues.push(...this.checkText(statement, file));
            }
            issues.push(...this.checkNeeded(statement, file));
            if (globalDefinition === false) {
                issues.push(...this.checkSubrc(statement, nextStatement, file));
            }
        }
        return issues;
    }
    checkText(statement, file) {
        const p = statement.getPragmas().find(t => t.getStr().toUpperCase() === "##NO_TEXT");
        if (p === undefined) {
            return [];
        }
        if (statement.findFirstExpression(Expressions.ConstantString) === undefined
            && statement.findFirstExpression(Expressions.StringTemplate) === undefined) {
            const message = "There is no text, NO_TEXT can be removed";
            const fix = edit_helper_1.EditHelper.deleteToken(file, p);
            return [issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.getConfig().severity, fix)];
        }
        return [];
    }
    checkSubrc(statement, next, file) {
        const p = statement.getPragmas().find(t => t.getStr().toUpperCase() === "##SUBRC_OK");
        if (p === undefined) {
            return [];
        }
        const concat = (next === null || next === void 0 ? void 0 : next.concatTokens().toUpperCase()) || "";
        if (concat.includes(" SY-SUBRC")) {
            const message = "SUBRC_OK can be removed as sy-subrc is checked";
            const fix = edit_helper_1.EditHelper.deleteToken(file, p);
            return [issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.getConfig().severity, fix)];
        }
        return [];
    }
    checkNeeded(statement, file) {
        const p = statement.getPragmas().find(t => t.getStr().toUpperCase() === "##NEEDED");
        if (p === undefined) {
            return [];
        }
        if (statement.findFirstExpression(Expressions.InlineData) === undefined
            && !(statement.get() instanceof Statements.Parameter)
            && !(statement.get() instanceof Statements.Data)
            && !(statement.get() instanceof Statements.DataBegin)
            && !(statement.get() instanceof Statements.ClassData)
            && !(statement.get() instanceof Statements.ClassDataBegin)
            && !(statement.get() instanceof Statements.Type)
            && !(statement.get() instanceof Statements.Form)
            && !(statement.get() instanceof Statements.Tables)
            && !(statement.get() instanceof Statements.TypeBegin)
            && !(statement.get() instanceof Statements.Constant)
            && !(statement.get() instanceof Statements.ConstantBegin)
            && !(statement.get() instanceof Statements.TypeEnum)
            && !(statement.get() instanceof Statements.TypeEnumBegin)
            && !(statement.get() instanceof Statements.MethodImplementation)
            && !(statement.get() instanceof Statements.MethodDef)
            && statement.findFirstExpression(Expressions.InlineFS) === undefined) {
            const message = "There is no data definition, NEEDED can be removed";
            const fix = edit_helper_1.EditHelper.deleteToken(file, p);
            return [issue_1.Issue.atToken(file, p, message, this.getMetadata().key, this.getConfig().severity, fix)];
        }
        return [];
    }
    containsNoHandler(statement, next) {
        for (const t of statement.getPragmas()) {
            if (t.getStr().toUpperCase() === "##NO_HANDLER") {
                return true;
            }
        }
        if (next
            && next.get() instanceof _statement_1.Comment
            && !(statement.get() instanceof _statement_1.MacroContent)
            && next.concatTokens().toUpperCase().includes("#EC NO_HANDLER")) {
            return true;
        }
        return false;
    }
}
exports.UnnecessaryPragma = UnnecessaryPragma;
//# sourceMappingURL=unnecessary_pragma.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unnecessary_return.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unnecessary_return.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnnecessaryReturn = exports.UnnecessaryReturnConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class UnnecessaryReturnConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** Allow empty METHODs + FORMs + FUNCTION-MODULEs */
        this.allowEmpty = false;
    }
}
exports.UnnecessaryReturnConf = UnnecessaryReturnConf;
class UnnecessaryReturn extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UnnecessaryReturnConf();
    }
    getMetadata() {
        return {
            key: "unnecessary_return",
            title: "Unnecessary Return",
            shortDescription: `Finds unnecessary RETURN statements`,
            extendedInformation: `Finds unnecessary RETURN statements`,
            tags: [_irule_1.RuleTag.SingleFile, _irule_1.RuleTag.Quickfix],
            badExample: `FORM hello1.
  WRITE 'world'.
  RETURN.
ENDFORM.

FORM foo.
  IF 1 = 2.
    RETURN.
  ENDIF.
ENDFORM.`,
            goodExample: `FORM hello2.
  WRITE 'world'.
ENDFORM.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const issues = [];
        const structure = file.getStructure();
        if (structure === undefined) {
            return [];
        }
        const message = "Unnecessary RETURN";
        const statements = file.getStatements();
        let statementCounter = 0;
        for (let i = 0; i < statements.length; i++) {
            const node = statements[i];
            const nodeType = node.get();
            if ((nodeType instanceof Statements.MethodImplementation
                || nodeType instanceof Statements.Form
                || nodeType instanceof Statements.FunctionModule)) {
                statementCounter = 0;
                continue;
            }
            if (!(nodeType instanceof _statement_1.Comment)) {
                statementCounter++;
            }
            if (!(nodeType instanceof Statements.EndMethod
                || nodeType instanceof Statements.EndForm
                || nodeType instanceof Statements.EndFunction)) {
                continue;
            }
            const prev = statements[i - 1];
            if (prev && prev.get() instanceof Statements.Return) {
                if (this.conf.allowEmpty === true && statementCounter === 2) {
                    continue;
                }
                const fix = edit_helper_1.EditHelper.deleteStatement(file, prev);
                issues.push(issue_1.Issue.atStatement(file, prev, message, this.getMetadata().key, this.getConfig().severity, fix));
            }
            // note: ENDTRY is not checked, it will usually just make it an empty catch handler, which is also bad
            const prevprev = statements[i - 2];
            if (prev && prevprev
                && prevprev.get() instanceof Statements.Return
                && prev.get() instanceof Statements.EndIf) {
                const fix = edit_helper_1.EditHelper.deleteStatement(file, prevprev);
                issues.push(issue_1.Issue.atStatement(file, prevprev, message, this.getMetadata().key, this.getConfig().severity, fix));
            }
        }
        return issues;
    }
}
exports.UnnecessaryReturn = UnnecessaryReturn;
//# sourceMappingURL=unnecessary_return.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unreachable_code.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unreachable_code.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnreachableCode = exports.UnreachableCodeConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class UnreachableCodeConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnreachableCodeConf = UnreachableCodeConf;
class UnreachableCode extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UnreachableCodeConf();
    }
    getMetadata() {
        return {
            key: "unreachable_code",
            title: "Unreachable code",
            shortDescription: `Checks for unreachable code.`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `RETURN.\nWRITE 'hello'.`,
            goodExample: `WRITE 'hello'.\nRETURN.`,
        };
    }
    getMessage() {
        return "Unreachable code";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        const output = [];
        let exit = false;
        for (const node of file.getStatements()) {
            if (node.get() instanceof _statement_1.Comment
                || node.get() instanceof _statement_1.MacroContent
                || node.get() instanceof _statement_1.Empty) {
                continue;
            }
            else if (this.isExit(node)) {
                exit = true;
                continue;
            }
            else if (this.isStructure(node.get())) {
                exit = false;
                continue;
            }
            if (exit === true) {
                const issue = issue_1.Issue.atStatement(file, node, this.getMessage(), this.getMetadata().key, this.conf.severity);
                output.push(issue);
                exit = false;
            }
        }
        return output;
    }
    isExit(n) {
        const s = n.get();
        // todo, RESUMABLE exception
        if (s instanceof Statements.Submit && n.findFirstExpression(Expressions.AndReturn) === undefined) {
            return true;
        }
        else if (s instanceof Statements.Leave && n.findFirstExpression(Expressions.AndReturn) === undefined) {
            const concat = n.concatTokens();
            if (concat.includes(" TO LIST-PROCESSING")) {
                return false;
            }
            return true;
        }
        else if (s instanceof Statements.Return
            || s instanceof Statements.Continue
            || s instanceof Statements.Exit
            || s instanceof Statements.Raise) {
            return true;
        }
        return false;
    }
    isStructure(s) {
        if (s instanceof Statements.EndIf
            || s instanceof Statements.Else
            || s instanceof Statements.EndLoop
            || s instanceof Statements.EndTry
            || s instanceof Statements.EndMethod
            || s instanceof Statements.EndModule
            || s instanceof Statements.EndForm
            || s instanceof Statements.EndTestSeam
            || s instanceof Statements.EndAt
            || s instanceof Statements.EndSelect
            || s instanceof Statements.AtSelectionScreen
            || s instanceof Statements.EndFunction
            || s instanceof Statements.EndCase
            || s instanceof Statements.EndWhile
            || s instanceof Statements.EndDo
            || s instanceof Statements.Cleanup
            || s instanceof Statements.When
            || s instanceof Statements.WhenOthers
            || s instanceof Statements.WhenType
            || s instanceof Statements.Catch
            || s instanceof Statements.ElseIf) {
            return true;
        }
        return false;
    }
}
exports.UnreachableCode = UnreachableCode;
//# sourceMappingURL=unreachable_code.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unsecure_fae.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unsecure_fae.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnsecureFAE = exports.UnsecureFAEConf = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
class UnsecureFAEConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnsecureFAEConf = UnsecureFAEConf;
class UnsecureFAE {
    constructor() {
        this.conf = new UnsecureFAEConf();
    }
    getMetadata() {
        return {
            key: "unsecure_fae",
            title: "Unsecure FAE",
            shortDescription: `Checks for unsecure FAE`,
            extendedInformation: `Issues from rule check_syntax must be fixed before this rule takes effect`,
            tags: [_irule_1.RuleTag.Experimental, _irule_1.RuleTag.Performance],
        };
    }
    getConfig() {
        return this.conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        var _a;
        const issues = [];
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return issues;
        }
        const syntaxResult = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (syntaxResult.issues.length > 0) {
            return issues;
        }
        for (const f of obj.getABAPFiles()) {
            // todo
            for (const e of ((_a = f.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllExpressions(Expressions.SQLForAllEntries)) || []) {
                const token = e.getFirstToken();
                const message = "Unsecure FAE";
                issues.push(issue_1.Issue.atToken(f, token, message, this.getMetadata().key, this.getConfig().severity));
            }
        }
        return issues;
    }
}
exports.UnsecureFAE = UnsecureFAE;
//# sourceMappingURL=unsecure_fae.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unused_ddic.js":
/*!********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unused_ddic.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnusedDDIC = exports.UnusedDDICConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
class UnusedDDICConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnusedDDICConf = UnusedDDICConf;
class UnusedDDIC {
    constructor() {
        this.conf = new UnusedDDICConf();
    }
    getMetadata() {
        return {
            key: "unused_ddic",
            title: "Unused DDIC",
            shortDescription: `Checks the usage of DDIC objects`,
            extendedInformation: `Objects checked: DOMA + DTEL + TABL + TTYP + VIEW`,
            tags: [],
        };
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    run(obj) {
        if (obj instanceof Objects.Domain
            || obj instanceof Objects.TableType
            || obj instanceof Objects.View
            || obj instanceof Objects.Table
            || obj instanceof Objects.DataElement) {
            return this.check(obj);
        }
        return [];
    }
    check(obj) {
        const id = obj.getIdentifier();
        const refs = this.reg.getDDICReferences();
        const list = refs.listWhereUsed(obj);
        if (id && list.length === 0) {
            const message = obj.getType() + " " + obj.getName() + " not statically referenced";
            return [issue_1.Issue.atIdentifier(id, message, this.getMetadata().key, this.conf.severity)];
        }
        return [];
    }
}
exports.UnusedDDIC = UnusedDDIC;
//# sourceMappingURL=unused_ddic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unused_macros.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unused_macros.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnusedMacros = exports.UnusedMacrosConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class UnusedMacrosConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** skip specific names, case insensitive
         * @uniqueItems true
         */
        this.skipNames = [];
    }
}
exports.UnusedMacrosConf = UnusedMacrosConf;
class UnusedMacros {
    constructor() {
        this.conf = new UnusedMacrosConf();
    }
    getMetadata() {
        return {
            key: "unused_macros",
            title: "Unused macros",
            shortDescription: `Checks for unused macro definitions definitions`,
            tags: [_irule_1.RuleTag.Quickfix],
            badExample: `DEFINE foobar1.
  WRITE 'hello'.
END-OF-DEFINITION.`,
            goodExample: `DEFINE foobar2.
  WRITE 'hello'.
END-OF-DEFINITION.

foobar2.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skipNames === undefined) {
            this.conf.skipNames = [];
        }
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        var _a;
        const result = [];
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        const references = this.reg.getMacroReferences();
        for (const file of obj.getABAPFiles()) {
            for (const macroToken of references.listDefinitionsByFile(file.getFilename())) {
                const usages = references.listUsagesbyMacro(file.getFilename(), macroToken);
                if (usages.length === 0 && ((_a = this.conf.skipNames) === null || _a === void 0 ? void 0 : _a.includes(macroToken.getStr().toUpperCase())) === false) {
                    const message = "Unused macro definition: " + macroToken.getStr();
                    const pos = references.getDefinitionRange(file.getFilename(), macroToken);
                    const fix = edit_helper_1.EditHelper.deleteRange(file, pos.start, pos.end);
                    result.push(issue_1.Issue.atToken(file, macroToken, message, this.getMetadata().key, this.conf.severity, fix));
                }
            }
        }
        return result;
    }
}
exports.UnusedMacros = UnusedMacros;
//# sourceMappingURL=unused_macros.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unused_methods.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unused_methods.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnusedMethods = exports.UnusedMethodsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const visibility_1 = __webpack_require__(/*! ../abap/4_file_information/visibility */ "./node_modules/@abaplint/core/build/src/abap/4_file_information/visibility.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
class UnusedMethodsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UnusedMethodsConf = UnusedMethodsConf;
class WorkArea {
    constructor() {
        this.list = [];
        this.list = [];
    }
    push(id) {
        this.list.push(id);
    }
    removeIfExists(id) {
        // todo: optimize
        for (let i = 0; i < this.list.length; i++) {
            if (id.equals(this.list[i].identifier)) {
                this.list.splice(i, 1);
                return;
            }
        }
    }
    containsProteted() {
        for (const m of this.list) {
            if (m.visibility === visibility_1.Visibility.Protected) {
                return true;
            }
        }
        return false;
    }
    getLength() {
        return this.list.length;
    }
    get() {
        return this.list;
    }
}
// todo: add possibility to also search public methods
// todo: for protected methods, also search subclasses
class UnusedMethods {
    constructor() {
        this.conf = new UnusedMethodsConf();
    }
    getMetadata() {
        return {
            key: "unused_methods",
            title: "Unused methods",
            shortDescription: `Checks for unused methods`,
            extendedInformation: `Checks private and protected methods.

Unused methods are not reported if the object contains parser or syntax errors.
Quick fixes only appears for private methods or projected methods where the class doesnt have any subclasses.

Skips:
* methods FOR TESTING
* methods SETUP + TEARDOWN + CLASS_SETUP + CLASS_TEARDOWN in testclasses
* class_constructor + constructor methods
* event handlers
* methods that are redefined
* INCLUDEs
`,
            tags: [_irule_1.RuleTag.Quickfix],
            pragma: "##CALLED",
            pseudoComment: "EC CALLED",
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        else if (obj instanceof objects_1.Interface) { // todo, how to handle interfaces?
            return [];
        }
        else if (obj instanceof objects_1.Program && obj.isInclude() === true) {
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            for (const statement of file.getStatements()) {
                if (statement.get() instanceof _statement_1.Unknown) {
                    return []; // contains parser errors
                }
            }
        }
        // dont report anything when there are syntax errors
        const syntax = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (syntax.issues.length > 0) {
            return [];
        }
        this.wa = new WorkArea();
        for (const file of obj.getABAPFiles()) {
            for (const def of file.getInfo().listClassDefinitions()) {
                for (const method of def.methods) {
                    if (method.isForTesting === true
                        || method.isRedefinition === true
                        || method.isEventHandler === true) {
                        continue;
                    }
                    else if (def.isForTesting === true
                        && (method.name.toUpperCase() === "SETUP"
                            || method.name.toUpperCase() === "CLASS_SETUP"
                            || method.name.toUpperCase() === "TEARDOWN"
                            || method.name.toUpperCase() === "CLASS_TEARDOWN")) {
                        continue;
                    }
                    else if (method.name.toUpperCase() === "CONSTRUCTOR"
                        || method.name.toUpperCase() === "CLASS_CONSTRUCTOR") {
                        continue;
                    }
                    if (method.visibility === visibility_1.Visibility.Private
                        || method.visibility === visibility_1.Visibility.Protected) {
                        this.wa.push(method);
                    }
                }
            }
        }
        this.traverse(syntax.spaghetti.getTop());
        this.searchGlobalSubclasses(obj);
        const issues = [];
        for (const i of this.wa.get()) {
            const file = obj.getABAPFileByName(i.identifier.getFilename());
            if (file === undefined) {
                continue;
            }
            const statement = edit_helper_1.EditHelper.findStatement(i.identifier.getToken(), file);
            if (statement === undefined) {
                continue;
            }
            if (statement.getPragmas().some(t => t.getStr() === this.getMetadata().pragma)) {
                continue;
            }
            else if (this.suppressedbyPseudo(statement, file)) {
                continue;
            }
            let fix = undefined;
            if (i.visibility === visibility_1.Visibility.Private
                || i.isFinal === true
                || (i.visibility === visibility_1.Visibility.Protected && this.hasSubClass(obj) === false)) {
                const implementation = this.findMethodImplementation(i, file);
                if (implementation !== undefined) {
                    const fix1 = edit_helper_1.EditHelper.deleteStatement(file, statement);
                    const fix2 = edit_helper_1.EditHelper.deleteRange(file, implementation.getFirstToken().getStart(), implementation.getLastToken().getEnd());
                    fix = edit_helper_1.EditHelper.merge(fix1, fix2);
                }
            }
            const message = "Method \"" + i.identifier.getName() + "\" not used";
            issues.push(issue_1.Issue.atIdentifier(i.identifier, message, this.getMetadata().key, this.conf.severity, fix));
        }
        return issues;
    }
    hasSubClass(obj) {
        var _a, _b, _c;
        if (!(obj instanceof objects_1.Class)) {
            return false;
        }
        if (((_a = obj.getDefinition()) === null || _a === void 0 ? void 0 : _a.isFinal()) === true) {
            return false;
        }
        for (const r of this.reg.getObjects()) {
            if (r instanceof objects_1.Class
                && ((_c = (_b = r.getDefinition()) === null || _b === void 0 ? void 0 : _b.getSuperClass()) === null || _c === void 0 ? void 0 : _c.toUpperCase()) === obj.getName().toUpperCase()) {
                return true;
            }
        }
        return false;
    }
    findMethodImplementation(method, file) {
        var _a, _b;
        for (const classImplementation of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllStructures(Structures.ClassImplementation)) || []) {
            // todo, this will break if there are class implemtations with the same method names
            // const className = classImplementation.findFirstExpression(Expressions.ClassName)?.concatTokens().toUpperCase();
            for (const methodImplementation of classImplementation.findAllStructures(Structures.Method)) {
                const methodName = ((_b = methodImplementation.findFirstExpression(Expressions.MethodName)) === null || _b === void 0 ? void 0 : _b.concatTokens().toUpperCase()) || "";
                if (methodName !== method.name.toUpperCase()) {
                    continue;
                }
                return methodImplementation;
            }
        }
        return undefined;
    }
    suppressedbyPseudo(statement, file) {
        if (statement === undefined) {
            return false;
        }
        if (file === undefined) {
            return false;
        }
        let next = false;
        for (const s of file.getStatements()) {
            if (next === true && s.get() instanceof _statement_1.Comment) {
                return s.concatTokens().includes(this.getMetadata().pseudoComment + "");
            }
            if (s === statement) {
                next = true;
            }
        }
        return false;
    }
    searchGlobalSubclasses(obj) {
        var _a, _b;
        if (this.wa.getLength() === 0
            || !(obj instanceof objects_1.Class)
            || this.wa.containsProteted() === false) {
            return;
        }
        const sup = obj.getDefinition();
        if (sup === undefined) {
            return;
        }
        for (const r of this.reg.getObjects()) {
            if (r instanceof objects_1.Class
                && ((_b = (_a = r.getDefinition()) === null || _a === void 0 ? void 0 : _a.getSuperClass()) === null || _b === void 0 ? void 0 : _b.toUpperCase()) === sup.getName().toUpperCase()) {
                const syntax = new syntax_1.SyntaxLogic(this.reg, r).run();
                this.traverse(syntax.spaghetti.getTop());
                // recurse to sub-sub-* classes
                this.searchGlobalSubclasses(r);
            }
        }
    }
    traverse(node) {
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.BuiltIn) {
            this.checkNode(node);
        }
        for (const c of node.getChildren()) {
            this.traverse(c);
        }
    }
    checkNode(node) {
        for (const v of node.getData().references) {
            if (v.referenceType === _reference_1.ReferenceType.MethodReference && v.resolved) {
                this.wa.removeIfExists(v.resolved);
            }
        }
    }
}
exports.UnusedMethods = UnusedMethods;
//# sourceMappingURL=unused_methods.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unused_types.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unused_types.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnusedTypes = exports.UnusedTypesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class WorkArea {
    constructor() {
        this.workarea = [];
    }
    push(id) {
        for (const w of this.workarea) {
            if (id.equals(w)) {
                return;
            }
        }
        this.workarea.push(id);
    }
    removeIfExists(id) {
        for (let i = 0; i < this.workarea.length; i++) {
            if (id.equals(this.workarea[i])) {
                this.workarea.splice(i, 1);
                return;
            }
        }
    }
    get() {
        return this.workarea;
    }
    count() {
        return this.workarea.length;
    }
}
class UnusedTypesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** skip specific names, case insensitive
         * @uniqueItems true
         */
        this.skipNames = [];
    }
}
exports.UnusedTypesConf = UnusedTypesConf;
class UnusedTypes {
    constructor() {
        this.conf = new UnusedTypesConf();
    }
    getMetadata() {
        return {
            key: "unused_types",
            title: "Unused types",
            shortDescription: `Checks for unused TYPE definitions`,
            extendedInformation: `Unused types are not reported if the object contains parser or syntax errors.`,
            tags: [_irule_1.RuleTag.Quickfix],
            pragma: "##NEEDED",
            pseudoComment: "EC NEEDED",
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skipNames === undefined) {
            this.conf.skipNames = [];
        }
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            for (const statement of file.getStatements()) {
                if (statement.get() instanceof _statement_1.Unknown) {
                    return []; // contains parser errors
                }
            }
        }
        // dont report unused variables when there are syntax errors
        const syntax = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (syntax.issues.length > 0) {
            return [];
        }
        this.workarea = new WorkArea();
        this.traverse(syntax.spaghetti.getTop(), obj, true);
        this.traverse(syntax.spaghetti.getTop(), obj, false);
        if (this.workarea.count() === 0) {
            return []; // exit early if all types are used in the current object
        }
        for (const o of this.reg.getObjects()) {
            if (o === obj) {
                continue;
            }
            else if (o instanceof _abap_object_1.ABAPObject) {
                if (this.reg.isDependency(o)) {
                    continue; // do not search in dependencies
                }
                const syntax = new syntax_1.SyntaxLogic(this.reg, o).run();
                this.traverse(syntax.spaghetti.getTop(), o, false);
            }
            if (this.workarea.count() === 0) {
                return []; // exit early if all types are used
            }
        }
        // what is left is unused
        const ret = [];
        for (const t of this.workarea.get()) {
            const message = "Type \"" + t.getName() + "\" not used";
            const file = obj.getABAPFileByName(t.getFilename());
            if (file === undefined) {
                continue;
            }
            const statement = edit_helper_1.EditHelper.findStatement(t.getToken(), file);
            if (statement === undefined) {
                continue;
            }
            if (statement.getPragmas().some(t => t.getStr() === this.getMetadata().pragma)) {
                continue;
            }
            else if (this.suppressedbyPseudo(statement, file)) {
                continue;
            }
            const fix = this.buildFix(file, statement);
            ret.push(issue_1.Issue.atIdentifier(t, message, this.getMetadata().key, this.conf.severity, fix));
        }
        return ret;
    }
    suppressedbyPseudo(statement, file) {
        if (statement === undefined) {
            return false;
        }
        if (file === undefined) {
            return false;
        }
        let next = false;
        for (const s of file.getStatements()) {
            if (next === true && s.get() instanceof _statement_1.Comment) {
                return s.concatTokens().includes(this.getMetadata().pseudoComment + "");
            }
            if (s === statement) {
                next = true;
            }
        }
        return false;
    }
    ////////////////////////////
    traverse(node, obj, add) {
        if (node.getIdentifier().stype !== _scope_type_1.ScopeType.BuiltIn) {
            this.checkNode(node, obj, add);
        }
        for (const c of node.getChildren()) {
            this.traverse(c, obj, add);
        }
    }
    checkNode(node, obj, add) {
        const ret = [];
        if (add === true) {
            const types = node.getData().types;
            for (const name in types) {
                const identifier = types[name];
                if (obj.containsFile(identifier.getFilename()) === false) {
                    continue;
                }
                else if (this.conf.skipNames
                    && this.conf.skipNames.length > 0
                    && this.conf.skipNames.some((a) => a.toUpperCase() === name)) {
                    continue;
                }
                else if (name !== identifier.getName().toUpperCase()) {
                    continue; // may have aliases via interfaces
                }
                this.workarea.push(identifier);
            }
        }
        for (const r of node.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.TypeReference && r.resolved) {
                this.workarea.removeIfExists(r.resolved);
            }
        }
        return ret;
    }
    buildFix(file, statement) {
        if (statement.concatTokens().toUpperCase().includes("BEGIN OF")) {
            return undefined;
        }
        return edit_helper_1.EditHelper.deleteStatement(file, statement);
    }
}
exports.UnusedTypes = UnusedTypes;
//# sourceMappingURL=unused_types.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/unused_variables.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/unused_variables.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UnusedVariables = exports.UnusedVariablesConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const syntax_1 = __webpack_require__(/*! ../abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _scope_type_1 = __webpack_require__(/*! ../abap/5_syntax/_scope_type */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_scope_type.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
const _reference_1 = __webpack_require__(/*! ../abap/5_syntax/_reference */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/_reference.js");
class UnusedVariablesConf extends _basic_rule_config_1.BasicRuleConfig {
    constructor() {
        super(...arguments);
        /** skip specific names, case insensitive
         * @uniqueItems true
        */
        this.skipNames = [];
        /** skip parameters from abstract methods */
        this.skipAbstract = false;
    }
}
exports.UnusedVariablesConf = UnusedVariablesConf;
class WorkArea {
    constructor() {
        this.workarea = [];
    }
    push(id, count = 1) {
        for (const w of this.workarea) {
            if (id.equals(w.id)) {
                return;
            }
        }
        this.workarea.push({ id, count });
    }
    removeIfExists(id) {
        if (id === undefined) {
            return;
        }
        for (let i = 0; i < this.workarea.length; i++) {
            if (id.equals(this.workarea[i].id)) {
                this.workarea[i].count--;
                if (this.workarea[i].count === 0) {
                    this.workarea.splice(i, 1);
                }
                return;
            }
        }
    }
    get() {
        return this.workarea;
    }
    count() {
        return this.workarea.length;
    }
}
class UnusedVariables {
    constructor() {
        this.conf = new UnusedVariablesConf();
    }
    getMetadata() {
        return {
            key: "unused_variables",
            title: "Unused variables",
            shortDescription: `Checks for unused variables and constants`,
            extendedInformation: `Skips event parameters.

Note that this currently does not work if the source code uses macros.

Unused variables are not reported if the object contains parser or syntax errors.

Errors found in INCLUDES are reported for the main program.`,
            tags: [_irule_1.RuleTag.Quickfix],
            pragma: "##NEEDED",
            pseudoComment: "EC NEEDED",
            badExample: `DATA: BEGIN OF blah1,
      test  TYPE string,
      test2 TYPE string,
    END OF blah1.`,
            goodExample: `DATA: BEGIN OF blah2 ##NEEDED,
      test  TYPE string,
      test2 TYPE string,
    END OF blah2.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
        if (this.conf.skipNames === undefined) {
            this.conf.skipNames = [];
        }
    }
    initialize(reg) {
        this.reg = reg;
        return this;
    }
    run(obj) {
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        else if (obj instanceof objects_1.Interface) { // todo, how to handle interfaces?
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            for (const statement of file.getStatements()) {
                if (statement.get() instanceof _statement_1.Unknown) {
                    return []; // contains parser errors
                }
            }
        }
        // dont report unused variables when there are syntax errors
        const syntax = new syntax_1.SyntaxLogic(this.reg, obj).run();
        if (syntax.issues.length > 0) {
            return []; // contains syntax errors
        }
        this.workarea = new WorkArea();
        const top = syntax.spaghetti.getTop();
        this.buildWorkarea(top, obj);
        if (this.workarea.count() === 0) {
            return this.buildIssues(obj); // exit early if all variables are used
        }
        this.findUses(top, obj);
        for (const o of this.reg.getObjects()) {
            if (o === obj) {
                continue;
            }
            else if (o instanceof _abap_object_1.ABAPObject) {
                if (this.reg.isDependency(o)) {
                    continue; // do not search in dependencies
                }
                const syntax = new syntax_1.SyntaxLogic(this.reg, o).run();
                this.findUses(syntax.spaghetti.getTop(), o);
                if (this.workarea.count() === 0) {
                    return this.buildIssues(obj); // exit early if all variables are used
                }
            }
        }
        return this.buildIssues(obj);
    }
    findUses(node, obj) {
        for (const r of node.getData().references) {
            if (r.referenceType === _reference_1.ReferenceType.DataReadReference
                || r.referenceType === _reference_1.ReferenceType.DataWriteReference
                || r.referenceType === _reference_1.ReferenceType.TypeReference) {
                this.workarea.removeIfExists(r.resolved);
            }
        }
        for (const c of node.getChildren()) {
            this.findUses(c, obj);
        }
    }
    buildWorkarea(node, obj) {
        const stype = node.getIdentifier().stype;
        if (stype === _scope_type_1.ScopeType.OpenSQL) {
            return;
        }
        for (const c of node.getChildren()) {
            this.buildWorkarea(c, obj);
        }
        if (stype !== _scope_type_1.ScopeType.BuiltIn) {
            const vars = node.getData().vars;
            for (const name in vars) {
                const meta = vars[name].getMeta();
                if (this.conf.skipNames
                    && this.conf.skipNames.length > 0
                    && this.conf.skipNames.some((a) => a.toUpperCase() === name)) {
                    continue;
                }
                else if (this.conf.skipAbstract === true && meta.includes("abstract" /* IdentifierMeta.Abstract */)) {
                    continue;
                }
                else if (name === "ME"
                    || name === "SUPER"
                    || meta.includes("selection_screen_tab" /* IdentifierMeta.SelectionScreenTab */)
                    || meta.includes("event_parameter" /* IdentifierMeta.EventParameter */)) {
                    // todo, workaround for "me" and "super", these should somehow be typed to built-in
                    continue;
                }
                const isInline = meta.includes("inline" /* IdentifierMeta.InlineDefinition */);
                this.workarea.push(vars[name], isInline ? 2 : 1);
            }
        }
    }
    buildIssues(obj) {
        const ret = [];
        for (const w of this.workarea.get()) {
            const filename = w.id.getFilename();
            if (this.reg.isFileDependency(filename) === true) {
                continue;
            }
            else if (obj instanceof objects_1.Program === false && obj.containsFile(filename) === false) {
                continue;
            }
            const statement = this.findStatement(w.id);
            if (statement === null || statement === void 0 ? void 0 : statement.getPragmas().map(t => t.getStr()).includes(this.getMetadata().pragma + "")) {
                continue;
            }
            else if (this.suppressedbyPseudo(statement, w.id, obj)) {
                continue;
            }
            const name = w.id.getName();
            const message = "Variable \"" + name.toLowerCase() + "\" not used";
            const fix = this.buildFix(w.id, obj);
            ret.push(issue_1.Issue.atIdentifier(w.id, message, this.getMetadata().key, this.conf.severity, fix));
        }
        return ret;
    }
    suppressedbyPseudo(statement, v, obj) {
        if (statement === undefined) {
            return false;
        }
        const file = obj.getABAPFileByName(v.getFilename());
        if (file === undefined) {
            return false;
        }
        let next = false;
        for (const s of file.getStatements()) {
            if (next === true && s.get() instanceof _statement_1.Comment) {
                return s.concatTokens().includes(this.getMetadata().pseudoComment + "");
            }
            if (s === statement) {
                next = true;
            }
        }
        return false;
    }
    findStatement(v) {
        const file = this.reg.getFileByName(v.getFilename());
        if (file === undefined) {
            return undefined;
        }
        const object = this.reg.findObjectForFile(file);
        if (!(object instanceof _abap_object_1.ABAPObject)) {
            return undefined;
        }
        const abapfile = object.getABAPFileByName(v.getFilename());
        if (abapfile === undefined) {
            return undefined;
        }
        const statement = edit_helper_1.EditHelper.findStatement(v.getToken(), abapfile);
        return statement;
    }
    buildFix(v, obj) {
        const file = obj.getABAPFileByName(v.getFilename());
        if (file === undefined) {
            return undefined;
        }
        const statement = edit_helper_1.EditHelper.findStatement(v.getToken(), file);
        if (statement === undefined) {
            return undefined;
        }
        else if (statement.get() instanceof Statements.Data) {
            return edit_helper_1.EditHelper.deleteStatement(file, statement);
        }
        return undefined;
    }
}
exports.UnusedVariables = UnusedVariables;
//# sourceMappingURL=unused_variables.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/use_bool_expression.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/use_bool_expression.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UseBoolExpression = exports.UseBoolExpressionConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
// note this rule assumes abap_true and abap_false is used for boolean variables
// some other rule will in the future find assignments to abap_bool that are not abap_true/abap_false/abap_undefined
class UseBoolExpressionConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UseBoolExpressionConf = UseBoolExpressionConf;
class UseBoolExpression extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UseBoolExpressionConf();
    }
    getMetadata() {
        return {
            key: "use_bool_expression",
            title: "Use boolean expression",
            shortDescription: `Use boolean expression, xsdbool from 740sp08 and up, boolc from 702 and up`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-xsdbool-to-set-boolean-variables`,
            tags: [_irule_1.RuleTag.Upport, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `IF line IS INITIAL.
  has_entries = abap_false.
ELSE.
  has_entries = abap_true.
ENDIF.

DATA(fsdf) = COND #( WHEN foo <> bar THEN abap_true ELSE abap_false ).`,
            goodExample: `DATA(has_entries) = xsdbool( line IS NOT INITIAL ).

DATA(fsdf) = xsdbool( foo <> bar ).`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        const issues = [];
        const stru = file.getStructure();
        const version = this.reg.getConfig().getVersion();
        if (stru === undefined || (version < version_1.Version.v702 && version !== version_1.Version.Cloud)) {
            return [];
        }
        for (const i of stru.findAllStructures(Structures.If)) {
            if (i.findDirectStructure(Structures.ElseIf) !== undefined) {
                continue;
            }
            const bodyNodes = (_a = i.findDirectStructure(Structures.Body)) === null || _a === void 0 ? void 0 : _a.findAllStatementNodes();
            if (bodyNodes === undefined || bodyNodes.length !== 1) {
                continue;
            }
            const bodyStatement = bodyNodes[0];
            if (!(bodyStatement.get() instanceof Statements.Move)) {
                continue;
            }
            const elseNodes = (_c = (_b = i.findDirectStructure(Structures.Else)) === null || _b === void 0 ? void 0 : _b.findDirectStructure(Structures.Body)) === null || _c === void 0 ? void 0 : _c.findAllStatementNodes();
            if (elseNodes === undefined || elseNodes.length !== 1) {
                continue;
            }
            const elseStatement = elseNodes[0];
            if (!(elseStatement.get() instanceof Statements.Move)) {
                continue;
            }
            let bodyTarget = (_d = bodyStatement.findFirstExpression(Expressions.Target)) === null || _d === void 0 ? void 0 : _d.concatTokens();
            if (bodyTarget === null || bodyTarget === void 0 ? void 0 : bodyTarget.startsWith("DATA(")) {
                bodyTarget = bodyTarget.substr(5, bodyTarget.length - 6);
            }
            const elseTarget = (_e = elseStatement.findFirstExpression(Expressions.Target)) === null || _e === void 0 ? void 0 : _e.concatTokens();
            if (bodyTarget === undefined
                || elseTarget === undefined
                || bodyTarget.toUpperCase() !== elseTarget.toUpperCase()) {
                continue;
            }
            const bodySource = (_f = bodyStatement.findFirstExpression(Expressions.Source)) === null || _f === void 0 ? void 0 : _f.concatTokens().toUpperCase();
            const elseSource = (_g = elseStatement.findFirstExpression(Expressions.Source)) === null || _g === void 0 ? void 0 : _g.concatTokens().toUpperCase();
            if ((bodySource === "ABAP_TRUE" && elseSource === "ABAP_FALSE")
                || (bodySource === "ABAP_FALSE" && elseSource === "ABAP_TRUE")) {
                const func = (this.reg.getConfig().getVersion() >= version_1.Version.v740sp08
                    || this.reg.getConfig().getVersion() === version_1.Version.Cloud) ? "xsdbool" : "boolc";
                const negate = bodySource === "ABAP_FALSE";
                const message = `Use ${func} instead of IF` + (negate ? ", negate expression" : "");
                const start = i.getFirstToken().getStart();
                const end = i.getLastToken().getEnd();
                const statement = bodyTarget + " = " + func + "( " +
                    (negate ? "NOT ( " : "") +
                    ((_j = (_h = i.findFirstStatement(Statements.If)) === null || _h === void 0 ? void 0 : _h.findFirstExpression(Expressions.Cond)) === null || _j === void 0 ? void 0 : _j.concatTokens()) +
                    (negate ? " )" : "") +
                    " ).";
                const fix = edit_helper_1.EditHelper.replaceRange(file, start, end, statement);
                issues.push(issue_1.Issue.atRange(file, start, end, message, this.getMetadata().key, this.conf.severity, fix));
            }
        }
        if (version >= version_1.Version.v740sp08 || version === version_1.Version.Cloud) {
            for (const b of stru.findAllExpressions(Expressions.CondBody)) {
                const concat = b.concatTokens().toUpperCase();
                if (concat.endsWith(" THEN ABAP_TRUE ELSE ABAP_FALSE")
                    || concat.endsWith(" THEN ABAP_TRUE")
                    || concat.endsWith(" THEN ABAP_FALSE ELSE ABAP_TRUE")) {
                    const message = "Use xsdbool";
                    // eslint-disable-next-line max-len
                    issues.push(issue_1.Issue.atRange(file, b.getFirstToken().getStart(), b.getLastToken().getEnd(), message, this.getMetadata().key, this.conf.severity));
                }
            }
        }
        return issues;
    }
}
exports.UseBoolExpression = UseBoolExpression;
//# sourceMappingURL=use_bool_expression.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/use_class_based_exceptions.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/use_class_based_exceptions.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UseClassBasedExceptions = exports.UseClassBasedExceptionsConf = void 0;
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
class UseClassBasedExceptionsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UseClassBasedExceptionsConf = UseClassBasedExceptionsConf;
class UseClassBasedExceptions extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UseClassBasedExceptionsConf();
    }
    getMetadata() {
        return {
            key: "use_class_based_exceptions",
            title: "Use class based exceptions",
            shortDescription: `Use class based exceptions, checks interface and class definitions`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#use-class-based-exceptions`,
            tags: [_irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `INTERFACE lif.
  METHODS load_data
    EXCEPTIONS
      invalid_parameter.
ENDINTERFACE.`,
            goodExample: `INTERFACE lif.
  METHODS load_data
    RAISING
      cx_something.
ENDINTERFACE.`,
        };
    }
    getMessage() {
        return "Use class based exceptions";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file) {
        var _a;
        const issues = [];
        for (const s of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllStatements(Statements.MethodDef)) || []) {
            if (s.findDirectExpression(Expressions.MethodDefExceptions)) {
                issues.push(issue_1.Issue.atStatement(file, s, this.getMessage(), this.getMetadata().key));
            }
        }
        return issues;
    }
}
exports.UseClassBasedExceptions = UseClassBasedExceptions;
//# sourceMappingURL=use_class_based_exceptions.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/use_line_exists.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/use_line_exists.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UseLineExists = exports.UseLineExistsConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class UseLineExistsConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UseLineExistsConf = UseLineExistsConf;
class UseLineExists extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UseLineExistsConf();
    }
    getMetadata() {
        return {
            key: "use_line_exists",
            title: "Use line_exists",
            shortDescription: `Use line_exists, from 740sp02 and up`,
            extendedInformation: `
https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-line_exists-to-read-table-or-loop-at

Not reported if the READ TABLE statement contains BINARY SEARCH.`,
            tags: [_irule_1.RuleTag.Upport, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.SingleFile],
            badExample: `READ TABLE my_table TRANSPORTING NO FIELDS WITH KEY key = 'A'.
IF sy-subrc = 0.
ENDIF.`,
            goodExample: `IF line_exists( my_table[ key = 'A' ] ).
ENDIF.`,
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        const vers = this.reg.getConfig().getVersion();
        if (vers === version_1.Version.OpenABAP) {
            return [];
        }
        else if (vers < version_1.Version.v740sp02 && vers !== version_1.Version.Cloud) {
            return [];
        }
        const statements = file.getStatements();
        for (let i = 0; i < statements.length; i++) {
            const statement = statements[i];
            if (!(statement.get() instanceof Statements.ReadTable)) {
                continue;
            }
            const concat = statement.concatTokens().toUpperCase();
            if (concat.includes(" TRANSPORTING NO FIELDS") === true
                && concat.includes(" BINARY SEARCH") === false
                && this.checksSubrc(i, statements) === true
                && this.usesTabix(i, statements) === false) {
                issues.push(issue_1.Issue.atStatement(file, statement, "Use line_exists", this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
    ///////////////////////
    checksSubrc(index, statements) {
        for (let i = index + 1; i < statements.length; i++) {
            const statement = statements[i];
            if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            for (const c of statement.findAllExpressions(Expressions.Cond)) {
                for (const s of c.findAllExpressions(Expressions.Source)) {
                    if (s.concatTokens().toUpperCase() === "SY-SUBRC") {
                        return true;
                    }
                }
            }
            return false;
        }
        return false;
    }
    // this is a heuristic, data flow analysis is required to get the correct result
    usesTabix(index, statements) {
        for (let i = index + 1; i < index + 5; i++) {
            const statement = statements[i];
            if (statement === undefined) {
                break;
            }
            else if (statement.get() instanceof _statement_1.Comment) {
                continue;
            }
            else if (statement.concatTokens().toUpperCase().includes(" SY-TABIX")) {
                return true;
            }
        }
        return false;
    }
}
exports.UseLineExists = UseLineExists;
//# sourceMappingURL=use_line_exists.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/use_new.js":
/*!****************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/use_new.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.UseNew = exports.UseNewConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const version_1 = __webpack_require__(/*! ../version */ "./node_modules/@abaplint/core/build/src/version.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
class UseNewConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.UseNewConf = UseNewConf;
class UseNew extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new UseNewConf();
    }
    getMetadata() {
        return {
            key: "use_new",
            title: "Use NEW",
            shortDescription: `Checks for deprecated CREATE OBJECT statements.`,
            extendedInformation: `https://github.com/SAP/styleguides/blob/main/clean-abap/CleanABAP.md#prefer-new-to-create-object

If the target variable is referenced in the CREATE OBJECT statement, no errors are issued

Applicable from v740sp02 and up`,
            badExample: `CREATE OBJECT ref.`,
            goodExample: `ref = NEW #( ).`,
            tags: [_irule_1.RuleTag.Upport, _irule_1.RuleTag.Styleguide, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
        };
    }
    getMessage() {
        return "Use NEW #( ) to instantiate object.";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    runParsed(file, obj) {
        var _a;
        const issues = [];
        if (obj.getType() === "INTF") {
            return [];
        }
        if (this.reg.getConfig().getVersion() < version_1.Version.v740sp02 && this.reg.getConfig().getVersion() !== version_1.Version.Cloud) {
            return [];
        }
        for (const statement of file.getStatements()) {
            if (statement.get() instanceof Statements.CreateObject) {
                if (statement.findFirstExpression(expressions_1.Dynamic)) {
                    continue;
                }
                else if (statement.findDirectExpression(expressions_1.ParameterListExceptions)) {
                    continue;
                }
                else if (statement.findDirectTokenByText("AREA")) {
                    continue;
                }
                const target = ((_a = statement.findDirectExpression(expressions_1.Target)) === null || _a === void 0 ? void 0 : _a.concatTokens()) + "->";
                if (statement.concatTokens().includes(target)) {
                    continue;
                }
                const fix = this.buildFix(file, statement);
                const issue = issue_1.Issue.atPosition(file, statement.getStart(), this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                issues.push(issue);
            }
        }
        return issues;
    }
    buildFix(file, statement) {
        var _a, _b;
        const target = (_a = statement.findDirectExpression(Expressions.Target)) === null || _a === void 0 ? void 0 : _a.concatTokens();
        if (target === undefined) {
            return undefined;
        }
        const parameters = statement.findDirectExpression(Expressions.ParameterListS);
        const param = parameters ? parameters.concatTokens() + " " : "";
        let type = (_b = statement.findDirectExpression(Expressions.ClassName)) === null || _b === void 0 ? void 0 : _b.getFirstToken().getStr();
        if (type === undefined) {
            type = "#";
        }
        const string = `${target} = NEW ${type}( ${param}).`;
        return edit_helper_1.EditHelper.replaceRange(file, statement.getStart(), statement.getEnd(), string);
    }
}
exports.UseNew = UseNew;
//# sourceMappingURL=use_new.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/when_others_last.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/when_others_last.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhenOthersLast = exports.WhenOthersLastConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_rule_1 = __webpack_require__(/*! ./_abap_rule */ "./node_modules/@abaplint/core/build/src/rules/_abap_rule.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
class WhenOthersLastConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.WhenOthersLastConf = WhenOthersLastConf;
class WhenOthersLast extends _abap_rule_1.ABAPRule {
    constructor() {
        super(...arguments);
        this.conf = new WhenOthersLastConf();
    }
    getMetadata() {
        return {
            key: "when_others_last",
            title: "WHEN OTHERS last",
            shortDescription: `Checks that WHEN OTHERS is placed the last within a CASE statement.`,
            tags: [_irule_1.RuleTag.SingleFile],
            badExample: `CASE bar.
  WHEN OTHERS.
  WHEN 2.
ENDCASE.`,
            goodExample: `CASE bar.
  WHEN 2.
  WHEN OTHERS.
ENDCASE.`,
        };
    }
    getMessage() {
        return "WHEN OTHERS should be the last branch in a CASE statement.";
    }
    runParsed(file) {
        const issues = [];
        const struc = file.getStructure();
        if (struc === undefined) {
            return [];
        }
        const cases = struc.findAllStructures(Structures.Case);
        for (const c of cases) {
            const whentop = c.findDirectStructures(Structures.When);
            for (let i = 0; i < whentop.length - 1; i++) {
                const whens = whentop[i].findDirectStatements(Statements.When).concat(whentop[i].findDirectStatements(Statements.WhenOthers));
                for (const when of whens) {
                    if (when.get() instanceof Statements.WhenOthers) {
                        const start = when.getFirstToken().getStart();
                        const issue = issue_1.Issue.atPosition(file, start, this.getMessage(), this.getMetadata().key, this.conf.severity);
                        issues.push(issue);
                    }
                }
            }
        }
        return issues;
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
}
exports.WhenOthersLast = WhenOthersLast;
//# sourceMappingURL=when_others_last.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/whitespace_end.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/whitespace_end.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WhitespaceEnd = exports.WhitespaceEndConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const edit_helper_1 = __webpack_require__(/*! ../edit_helper */ "./node_modules/@abaplint/core/build/src/edit_helper.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
class WhitespaceEndConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.WhitespaceEndConf = WhitespaceEndConf;
class WhitespaceEnd {
    constructor() {
        this.conf = new WhitespaceEndConf();
    }
    getMetadata() {
        return {
            key: "whitespace_end",
            title: "Whitespace at end of line",
            shortDescription: `Checks for redundant whitespace at the end of each line.`,
            extendedInformation: `SMIM and W3MI files are not checked.`,
            tags: [_irule_1.RuleTag.Whitespace, _irule_1.RuleTag.Quickfix, _irule_1.RuleTag.SingleFile],
            badExample: `WRITE 'hello'.      `,
            goodExample: `WRITE 'hello'.`,
        };
    }
    getMessage() {
        return "Remove whitespace at end of line";
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        const issues = [];
        for (const file of obj.getFiles()) {
            if (obj instanceof objects_1.MIMEObject || obj instanceof objects_1.WebMIME) {
                continue;
            }
            const rows = file.getRawRows();
            for (let i = 0; i < rows.length; i++) {
                if (rows[i].endsWith(" ") || rows[i].endsWith(" \r")) {
                    const match = / +\r?$/.exec(rows[i]);
                    const start = new position_1.Position(i + 1, match.index + 1);
                    const end = new position_1.Position(i + 1, rows[i].length + 1);
                    const fix = edit_helper_1.EditHelper.deleteRange(file, start, end);
                    const issue = issue_1.Issue.atRange(file, start, end, this.getMessage(), this.getMetadata().key, this.conf.severity, fix);
                    issues.push(issue);
                }
            }
        }
        return issues;
    }
}
exports.WhitespaceEnd = WhitespaceEnd;
//# sourceMappingURL=whitespace_end.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules/xml_consistency.js":
/*!************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules/xml_consistency.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.XMLConsistency = exports.XMLConsistencyConf = void 0;
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _irule_1 = __webpack_require__(/*! ./_irule */ "./node_modules/@abaplint/core/build/src/rules/_irule.js");
const Objects = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const _basic_rule_config_1 = __webpack_require__(/*! ./_basic_rule_config */ "./node_modules/@abaplint/core/build/src/rules/_basic_rule_config.js");
const fast_xml_parser_1 = __webpack_require__(/*! fast-xml-parser */ "./node_modules/fast-xml-parser/src/fxp.js");
class XMLConsistencyConf extends _basic_rule_config_1.BasicRuleConfig {
}
exports.XMLConsistencyConf = XMLConsistencyConf;
class XMLConsistency {
    constructor() {
        this.conf = new XMLConsistencyConf();
    }
    getMetadata() {
        return {
            key: "xml_consistency",
            title: "XML consistency",
            shortDescription: `Checks the consistency of main XML files, eg. naming for CLAS and INTF objects`,
            tags: [_irule_1.RuleTag.Naming, _irule_1.RuleTag.Syntax],
        };
    }
    getConfig() {
        return this.conf;
    }
    setConfig(conf) {
        this.conf = conf;
    }
    initialize(_reg) {
        return this;
    }
    run(obj) {
        var _a, _b;
        const issues = [];
        const file = obj.getXMLFile();
        if (file === undefined) {
            return issues;
        }
        const xml = obj.getXML();
        if (xml) {
            const res = fast_xml_parser_1.XMLValidator.validate(xml);
            if (res !== true) {
                issues.push(issue_1.Issue.atRow(file, 1, "XML parser error: " + res.err.msg, this.getMetadata().key, this.conf.severity));
            }
        }
        // todo, have some XML validation in each object?
        if (obj instanceof Objects.Class) {
            const name = obj.getNameFromXML();
            if (name === undefined) {
                issues.push(issue_1.Issue.atRow(file, 1, "Name undefined in XML", this.getMetadata().key, this.conf.severity));
            }
            else if (obj.getDescription() && obj.getDescription().length > 60) {
                issues.push(issue_1.Issue.atRow(file, 1, "Description too long", this.getMetadata().key, this.conf.severity));
            }
            else if (name !== obj.getName().toUpperCase()) {
                issues.push(issue_1.Issue.atRow(file, 1, "Name in XML does not match object", this.getMetadata().key, this.conf.severity));
            }
            else if (((_a = obj.getMainABAPFile()) === null || _a === void 0 ? void 0 : _a.getStructure()) !== undefined && obj.getClassDefinition() === undefined) {
                issues.push(issue_1.Issue.atRow(file, 1, "Class matching XML name not found in ABAP file", this.getMetadata().key, this.conf.severity));
            }
        }
        if (obj instanceof Objects.Interface) {
            const name = obj.getNameFromXML();
            if (name === undefined) {
                issues.push(issue_1.Issue.atRow(file, 1, "Name undefined in XML", this.getMetadata().key, this.conf.severity));
            }
            else if (obj.getDescription() && obj.getDescription().length > 60) {
                issues.push(issue_1.Issue.atRow(file, 1, "Description too long", this.getMetadata().key, this.conf.severity));
            }
            else if (name !== obj.getName().toUpperCase()) {
                issues.push(issue_1.Issue.atRow(file, 1, "Name in XML does not match object", this.getMetadata().key, this.conf.severity));
            }
            else if (obj.getDefinition() !== undefined && ((_b = obj.getDefinition()) === null || _b === void 0 ? void 0 : _b.getName().toUpperCase()) !== name.toUpperCase()) {
                issues.push(issue_1.Issue.atRow(file, 1, "Interface matching XML name not found in ABAP file", this.getMetadata().key, this.conf.severity));
            }
        }
        return issues;
    }
}
exports.XMLConsistency = XMLConsistency;
//# sourceMappingURL=xml_consistency.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/rules_runner.js":
/*!***************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/rules_runner.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.RulesRunner = void 0;
const syntax_1 = __webpack_require__(/*! ./abap/5_syntax/syntax */ "./node_modules/@abaplint/core/build/src/abap/5_syntax/syntax.js");
const artifacts_rules_1 = __webpack_require__(/*! ./artifacts_rules */ "./node_modules/@abaplint/core/build/src/artifacts_rules.js");
const _abap_object_1 = __webpack_require__(/*! ./objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const skip_logic_1 = __webpack_require__(/*! ./skip_logic */ "./node_modules/@abaplint/core/build/src/skip_logic.js");
const excludeHelper_1 = __webpack_require__(/*! ./utils/excludeHelper */ "./node_modules/@abaplint/core/build/src/utils/excludeHelper.js");
class RulesRunner {
    constructor(reg) {
        this.reg = reg;
    }
    objectsToCheck(objects) {
        const check = [];
        const skipLogic = new skip_logic_1.SkipLogic(this.reg);
        for (const obj of objects) {
            if (skipLogic.skip(obj) || this.reg.isDependency(obj)) {
                continue;
            }
            check.push(obj);
        }
        return check;
    }
    runRules(objects, input) {
        var _a, _b, _c, _d, _e, _f;
        const rulePerformance = {};
        const issues = [];
        const rules = this.reg.getConfig().getEnabledRules();
        const check = this.objectsToCheck(objects);
        // note: SyntaxLogic is cached, logic is run as first step in order
        // not to penalize the performance of the first rule using SyntaxLogic information
        (_a = input === null || input === void 0 ? void 0 : input.progress) === null || _a === void 0 ? void 0 : _a.set(check.length, "Run Syntax");
        for (const obj of check) {
            (_b = input === null || input === void 0 ? void 0 : input.progress) === null || _b === void 0 ? void 0 : _b.tick("Run Syntax - " + obj.getName());
            if (obj instanceof _abap_object_1.ABAPObject) {
                new syntax_1.SyntaxLogic(this.reg, obj).run();
            }
        }
        (_c = input === null || input === void 0 ? void 0 : input.progress) === null || _c === void 0 ? void 0 : _c.set(rules.length, "Initialize Rules");
        for (const rule of rules) {
            (_d = input === null || input === void 0 ? void 0 : input.progress) === null || _d === void 0 ? void 0 : _d.tick("Initialize Rules - " + rule.getMetadata().key);
            if (rule.initialize === undefined) {
                throw new Error(rule.getMetadata().key + " missing initialize method");
            }
            rule.initialize(this.reg);
            rulePerformance[rule.getMetadata().key] = 0;
        }
        (_e = input === null || input === void 0 ? void 0 : input.progress) === null || _e === void 0 ? void 0 : _e.set(check.length, "Finding Issues");
        for (const obj of check) {
            (_f = input === null || input === void 0 ? void 0 : input.progress) === null || _f === void 0 ? void 0 : _f.tick("Finding Issues - " + obj.getType() + " " + obj.getName());
            for (const rule of rules) {
                const before = Date.now();
                issues.push(...rule.run(obj));
                const runtime = Date.now() - before;
                rulePerformance[rule.getMetadata().key] = rulePerformance[rule.getMetadata().key] + runtime;
            }
        }
        if ((input === null || input === void 0 ? void 0 : input.outputPerformance) === true) {
            const perf = [];
            for (const p in rulePerformance) {
                if (rulePerformance[p] > 100) { // ignore rules if it takes less than 100ms
                    perf.push({ name: p, time: rulePerformance[p] });
                }
            }
            perf.sort((a, b) => { return b.time - a.time; });
            for (const p of perf) {
                process.stderr.write("\t" + p.time + "ms\t" + p.name + "\n");
            }
        }
        return this.excludeIssues(issues);
    }
    excludeIssues(issues) {
        var _a;
        const ret = issues;
        const globalNoIssues = this.reg.getConfig().getGlobal().noIssues || [];
        const globalNoIssuesPatterns = globalNoIssues.map(x => new RegExp(x, "i"));
        if (globalNoIssuesPatterns.length > 0) {
            for (let i = ret.length - 1; i >= 0; i--) {
                const filename = ret[i].getFilename();
                if (excludeHelper_1.ExcludeHelper.isExcluded(filename, globalNoIssuesPatterns)) {
                    ret.splice(i, 1);
                }
            }
        }
        // exclude issues, as now we know both the filename and issue key
        for (const rule of artifacts_rules_1.ArtifactsRules.getRules()) {
            const key = rule.getMetadata().key;
            const ruleExclude = (_a = this.reg.getConfig().readByKey(key, "exclude")) !== null && _a !== void 0 ? _a : [];
            if (ruleExclude.length === 0) {
                continue;
            }
            const ruleExcludePatterns = ruleExclude.map(x => new RegExp(x, "i"));
            for (let i = ret.length - 1; i >= 0; i--) {
                if (ret[i].getKey() !== key) {
                    continue;
                }
                const filename = ret[i].getFilename();
                if (excludeHelper_1.ExcludeHelper.isExcluded(filename, ruleExcludePatterns)) {
                    ret.splice(i, 1);
                }
            }
        }
        return ret;
    }
}
exports.RulesRunner = RulesRunner;
//# sourceMappingURL=rules_runner.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/severity.js":
/*!***********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/severity.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Severity = void 0;
var Severity;
(function (Severity) {
    Severity["Error"] = "Error";
    Severity["Warning"] = "Warning";
    Severity["Info"] = "Info";
})(Severity || (exports.Severity = Severity = {}));
//# sourceMappingURL=severity.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/skip_logic.js":
/*!*************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/skip_logic.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SkipLogic = void 0;
const objects_1 = __webpack_require__(/*! ./objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const include_graph_1 = __webpack_require__(/*! ./utils/include_graph */ "./node_modules/@abaplint/core/build/src/utils/include_graph.js");
class SkipLogic {
    constructor(reg) {
        this.reg = reg;
        this.tobj = undefined;
    }
    skip(obj) {
        const global = this.reg.getConfig().getGlobal();
        if (global.skipGeneratedGatewayClasses === true
            && obj instanceof objects_1.Class
            && this.isGeneratedGatewayClass(obj)) {
            return true;
        }
        else if (global.skipIncludesWithoutMain === true
            && obj instanceof objects_1.Program
            && obj.isInclude() === true) {
            const ig = new include_graph_1.IncludeGraph(this.reg);
            const file = obj.getMainABAPFile();
            if (file && ig.listMainForInclude(file.getFilename()).length === 0) {
                return true;
            }
        }
        else if (global.skipGeneratedPersistentClasses === true
            && obj instanceof objects_1.Class
            && this.isGeneratedPersistentClass(obj)) {
            return true;
        }
        else if (global.skipGeneratedFunctionGroups === true
            && obj instanceof objects_1.FunctionGroup
            && this.isGeneratedFunctionGroup(obj)) {
            return true;
        }
        else if (global.skipGeneratedProxyClasses === true
            && obj instanceof objects_1.Class
            && this.isGeneratedProxyClass(obj)) {
            return true;
        }
        else if (global.skipGeneratedProxyInterfaces === true
            && obj instanceof objects_1.Interface
            && this.isGeneratedProxyInterface(obj)) {
            return true;
        }
        else if (global.skipGeneratedBOPFInterfaces === true
            && obj instanceof objects_1.Interface
            && this.isGeneratedBOPFInterface(obj)) {
            return true;
        }
        return false;
    }
    ///////////////////////////
    isGeneratedBOPFInterface(obj) {
        var _a;
        const implementing = (_a = obj.getDefinition()) === null || _a === void 0 ? void 0 : _a.getImplementing();
        if (implementing === undefined) {
            return false;
        }
        for (const i of implementing) {
            if (i.name.toUpperCase() === "/BOBF/IF_LIB_CONSTANTS") {
                return true;
            }
        }
        return false;
    }
    isGeneratedProxyInterface(obj) {
        const xml = obj.getXML();
        if (!xml) {
            return false;
        }
        const result = xml.match(/<CLSPROXY>(.)<\/CLSPROXY>/);
        if (result) {
            return true;
        }
        else {
            return false;
        }
    }
    isGeneratedProxyClass(obj) {
        const xml = obj.getXML();
        if (!xml) {
            return false;
        }
        const result = xml.match(/<CLSPROXY>(.)<\/CLSPROXY>/);
        if (result) {
            return true;
        }
        else {
            return false;
        }
    }
    isGeneratedFunctionGroup(group) {
        var _a;
        if (this.tobj === undefined) {
            this.tobj = {};
            for (const obj of this.reg.getObjects()) {
                if (obj.getType() !== "TOBJ") {
                    continue;
                }
                const tobj = obj;
                const area = (_a = tobj.getArea()) === null || _a === void 0 ? void 0 : _a.toUpperCase();
                if (area) {
                    this.tobj[area] = true;
                }
            }
        }
        return this.tobj[group.getName().toUpperCase()];
    }
    isGeneratedGatewayClass(obj) {
        var _a;
        let sup = undefined;
        const definition = obj.getClassDefinition();
        if (definition) {
            sup = (_a = definition.superClassName) === null || _a === void 0 ? void 0 : _a.toUpperCase();
        }
        if (obj.getName().match(/_MPC$/i) && sup === "/IWBEP/CL_MGW_PUSH_ABS_MODEL") {
            return true;
        }
        else if (obj.getName().match(/_DPC$/i) && sup === "/IWBEP/CL_MGW_PUSH_ABS_DATA") {
            return true;
        }
        else if (sup === "CL_SADL_GTK_EXPOSURE_MPC") {
            return true;
        }
        return false;
    }
    isGeneratedPersistentClass(obj) {
        if (obj.getCategory() === objects_1.ClassCategory.Persistent) {
            return true;
        }
        else if (obj.getCategory() === objects_1.ClassCategory.PersistentFactory) {
            return true;
        }
        const main = obj.getClassDefinition();
        if (main) {
            const sup = main.superClassName;
            if (sup) {
                const sclass = this.reg.getObject("CLAS", sup.toUpperCase());
                if (sclass && sclass.getCategory() === objects_1.ClassCategory.PersistentFactory) {
                    return true;
                }
            }
        }
        return false;
    }
}
exports.SkipLogic = SkipLogic;
//# sourceMappingURL=skip_logic.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/cyclomatic_complexity_stats.js":
/*!************************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/cyclomatic_complexity_stats.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CyclomaticComplexityStats = void 0;
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Structures = __webpack_require__(/*! ../abap/3_structures/structures */ "./node_modules/@abaplint/core/build/src/abap/3_structures/structures/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
class CyclomaticComplexityStats {
    static run(obj) {
        var _a, _b, _c;
        const res = [];
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            for (const m of ((_a = file.getStructure()) === null || _a === void 0 ? void 0 : _a.findAllStructures(Structures.Method)) || []) {
                let count = 0;
                for (const s of m.findAllStatementNodes()) {
                    const type = s.get();
                    if (type instanceof Statements.Assert
                        || type instanceof Statements.Check
                        || type instanceof Statements.ElseIf
                        || type instanceof Statements.If
                        || type instanceof Statements.While
                        || type instanceof Statements.Case
                        || type instanceof Statements.SelectLoop
                        || type instanceof Statements.Catch
                        || type instanceof Statements.Cleanup
                        || type instanceof Statements.EndAt
                        || type instanceof Statements.Loop) {
                        count += 1;
                    }
                }
                const name = (_c = (_b = m.findDirectStatement(Statements.MethodImplementation)) === null || _b === void 0 ? void 0 : _b.findDirectExpression(Expressions.MethodName)) === null || _c === void 0 ? void 0 : _c.getFirstToken().getStr();
                res.push({
                    file,
                    pos: m.getFirstToken().getStart(),
                    name: name ? name : "Error!",
                    count,
                });
            }
        }
        return res;
    }
}
exports.CyclomaticComplexityStats = CyclomaticComplexityStats;
//# sourceMappingURL=cyclomatic_complexity_stats.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/excludeHelper.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/excludeHelper.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ExcludeHelper = void 0;
class ExcludeHelper {
    static isExcluded(filename, excludePatterns) {
        for (const exclude of excludePatterns) {
            if (exclude.exec(filename)) {
                return true;
            }
        }
        return false;
    }
}
exports.ExcludeHelper = ExcludeHelper;
//# sourceMappingURL=excludeHelper.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/form_length_stats.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/form_length_stats.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.FormLengthStats = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class FormLengthStats {
    static run(obj) {
        const res = [];
        let pos = undefined;
        let name = "";
        let count = 0;
        let form = false;
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            for (const stat of file.getStatements()) {
                const type = stat.get();
                if (type instanceof Statements.Form) {
                    pos = stat.getFirstToken().getStart();
                    name = this.findName(stat);
                    form = true;
                    count = 0;
                }
                else if (type instanceof Statements.EndForm) {
                    if (pos) {
                        res.push({ name: name, className: "", count, file, pos });
                    }
                    else {
                        continue;
                    }
                    form = false;
                }
                else if (form === true
                    && !(type instanceof _statement_1.Comment)
                    && !(type instanceof _statement_1.Empty)) {
                    count = count + 1;
                }
            }
        }
        return res;
    }
    static findName(stat) {
        let name = "";
        const nameExpr = stat.findFirstExpression(expressions_1.FormName);
        if (nameExpr) {
            name = nameExpr.getFirstToken().getStr();
        }
        else {
            throw new Error("FormLength, findName, expected FormName");
        }
        return name;
    }
}
exports.FormLengthStats = FormLengthStats;
//# sourceMappingURL=form_length_stats.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/include_graph.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/include_graph.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.IncludeGraph = void 0;
const statements_1 = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const objects_1 = __webpack_require__(/*! ../objects */ "./node_modules/@abaplint/core/build/src/objects/index.js");
const check_include_1 = __webpack_require__(/*! ../rules/check_include */ "./node_modules/@abaplint/core/build/src/rules/check_include.js");
const position_1 = __webpack_require__(/*! ../position */ "./node_modules/@abaplint/core/build/src/position.js");
const issue_1 = __webpack_require__(/*! ../issue */ "./node_modules/@abaplint/core/build/src/issue.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const severity_1 = __webpack_require__(/*! ../severity */ "./node_modules/@abaplint/core/build/src/severity.js");
// todo, check for cycles/circular dependencies, method findTop
// todo, add configurable error for multiple use includes
function getABAPObjects(reg) {
    const ret = [];
    for (const o of reg.getObjects()) {
        if (o instanceof _abap_object_1.ABAPObject) {
            ret.push(o);
        }
    }
    return ret;
}
class Graph {
    constructor() {
        this.vertices = [];
        this.edges = [];
    }
    addVertex(vertex) {
        this.vertices.push(vertex);
    }
    findInclude(includeName) {
        for (const v of this.vertices) {
            if (v.includeName.toUpperCase() === includeName.toUpperCase()) {
                return v;
            }
        }
        return undefined;
    }
    findVertex(filename) {
        for (const v of this.vertices) {
            if (v.filename.toUpperCase() === filename.toUpperCase()) {
                return v;
            }
        }
        return undefined;
    }
    addEdge(from, toFilename) {
        this.edges.push({ from: from.filename, to: toFilename });
    }
    findTop(filename) {
        const ret = [];
        for (const e of this.edges) {
            if (e.from === filename) {
                ret.push(...this.findTop(e.to));
            }
        }
        if (ret.length === 0) {
            const found = this.findVertex(filename);
            if (found !== undefined) {
                ret.push(found);
            }
        }
        return ret;
    }
}
class IncludeGraph {
    constructor(reg) {
        this.reg = reg;
        this.issues = [];
        this.graph = new Graph();
        this.build();
    }
    getIssues() {
        return this.issues;
    }
    listMainForInclude(filename) {
        const ret = [];
        if (filename === undefined) {
            return [];
        }
        for (const f of this.graph.findTop(filename)) {
            if (f.include === false) {
                ret.push(f.filename);
            }
        }
        return ret;
    }
    getIssuesFile(file) {
        const ret = [];
        for (const i of this.issues) {
            if (i.getFilename() === file.getFilename()) {
                ret.push(i);
            }
        }
        return ret;
    }
    ///////////////////////////////
    build() {
        this.addVertices();
        for (const o of getABAPObjects(this.reg)) {
            for (const f of o.getABAPFiles()) {
                for (const s of f.getStatements()) {
                    if (s.get() instanceof statements_1.Include) {
                        const ifFound = s.concatTokens().toUpperCase().includes("IF FOUND");
                        const iexp = s.findFirstExpression(expressions_1.IncludeName);
                        if (iexp === undefined) {
                            throw new Error("unexpected Include node");
                        }
                        const name = iexp.getFirstToken().getStr().toUpperCase();
                        if (name.match(/^(\/\w+\/)?L.+XX$/)) { // function module XX includes, possibily namespaced
                            continue;
                        }
                        const found = this.graph.findInclude(name);
                        if (found === undefined) {
                            if (ifFound === false) {
                                const issue = issue_1.Issue.atStatement(f, s, "Include " + name + " not found", new check_include_1.CheckInclude().getMetadata().key, severity_1.Severity.Error);
                                this.issues.push(issue);
                            }
                        }
                        else if (found.include === false) {
                            const issue = issue_1.Issue.atStatement(f, s, "Not possible to INCLUDE a main program", new check_include_1.CheckInclude().getMetadata().key, severity_1.Severity.Error);
                            this.issues.push(issue);
                        }
                        else {
                            this.graph.addEdge(found, f.getFilename());
                        }
                    }
                }
            }
        }
        this.findUnusedIncludes();
    }
    findUnusedIncludes() {
        for (const v of this.graph.vertices) {
            if (v.include === true) {
                if (this.listMainForInclude(v.filename).length === 0) {
                    const f = this.reg.getFileByName(v.filename);
                    if (f === undefined) {
                        throw new Error("findUnusedIncludes internal error");
                    }
                    const issue = issue_1.Issue.atPosition(f, new position_1.Position(1, 1), "INCLUDE not used anywhere", new check_include_1.CheckInclude().getMetadata().key, severity_1.Severity.Error);
                    this.issues.push(issue);
                }
            }
        }
    }
    addVertices() {
        for (const o of getABAPObjects(this.reg)) {
            if (o instanceof objects_1.Program) {
                const file = o.getMainABAPFile();
                if (file) {
                    this.graph.addVertex({
                        filename: file.getFilename(),
                        includeName: o.getName(),
                        include: o.isInclude()
                    });
                }
            }
            else if (o instanceof objects_1.TypePool) {
                const file = o.getMainABAPFile();
                if (file) {
                    this.graph.addVertex({
                        filename: file.getFilename(),
                        includeName: o.getName(),
                        include: false
                    });
                }
            }
            else if (o instanceof objects_1.Class) {
                for (const f of o.getSequencedFiles()) {
                    this.graph.addVertex({
                        filename: f.getFilename(),
                        includeName: o.getName(),
                        include: false
                    });
                }
            }
            else if (o instanceof objects_1.FunctionGroup) {
                for (const i of o.getIncludeFiles()) {
                    this.graph.addVertex({
                        filename: i.file.getFilename(),
                        includeName: i.name,
                        include: true
                    });
                }
                const file = o.getMainABAPFile();
                if (file) {
                    this.graph.addVertex({
                        filename: file.getFilename(),
                        includeName: o.getName(),
                        include: false
                    });
                }
            }
        }
    }
}
exports.IncludeGraph = IncludeGraph;
//# sourceMappingURL=include_graph.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/method_length_stats.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/method_length_stats.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.MethodLengthStats = void 0;
const Statements = __webpack_require__(/*! ../abap/2_statements/statements */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/index.js");
const Expressions = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const expressions_1 = __webpack_require__(/*! ../abap/2_statements/expressions */ "./node_modules/@abaplint/core/build/src/abap/2_statements/expressions/index.js");
const _abap_object_1 = __webpack_require__(/*! ../objects/_abap_object */ "./node_modules/@abaplint/core/build/src/objects/_abap_object.js");
const _statement_1 = __webpack_require__(/*! ../abap/2_statements/statements/_statement */ "./node_modules/@abaplint/core/build/src/abap/2_statements/statements/_statement.js");
class MethodLengthStats {
    static run(obj) {
        var _a;
        const res = [];
        let pos = undefined;
        let methodName = "";
        let count = 0;
        let method = false;
        if (!(obj instanceof _abap_object_1.ABAPObject)) {
            return [];
        }
        for (const file of obj.getABAPFiles()) {
            let className = "";
            for (const stat of file.getStatements()) {
                const type = stat.get();
                if (type instanceof Statements.MethodImplementation) {
                    pos = stat.getFirstToken().getStart();
                    methodName = this.findName(stat);
                    method = true;
                    count = 0;
                }
                else if (type instanceof Statements.ClassImplementation) {
                    className = ((_a = stat.findFirstExpression(Expressions.ClassName)) === null || _a === void 0 ? void 0 : _a.concatTokens()) || "INTERNAL_ERROR";
                }
                else if (type instanceof Statements.EndMethod) {
                    if (pos) {
                        res.push({ name: methodName, className, count, file, pos });
                    }
                    else {
                        continue;
                    }
                    method = false;
                }
                else if (method === true
                    && !(type instanceof _statement_1.Comment)
                    && !(type instanceof _statement_1.Empty)) {
                    count = count + 1;
                }
            }
        }
        return res;
    }
    static findName(stat) {
        let name = "";
        const nameExpr = stat.findFirstExpression(expressions_1.MethodName);
        if (nameExpr) {
            name = nameExpr.getFirstToken().getStr();
        }
        else {
            throw new Error("MethodLength, findName, expected MethodName");
        }
        return name;
    }
}
exports.MethodLengthStats = MethodLengthStats;
//# sourceMappingURL=method_length_stats.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/utils/name_validator.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/utils/name_validator.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.NameValidator = void 0;
class NameValidator {
    static violatesRule(name, pattern, params) {
        if (params.ignoreNames && params.ignoreNames.indexOf(name.toUpperCase()) >= 0) {
            return false;
        }
        for (const ignored of params.ignorePatterns || []) {
            if (new RegExp(ignored, "i").test(name)) {
                return false;
            }
        }
        return !params.patternKind || params.patternKind === "required" ?
            pattern.test(name) === false :
            pattern.test(name) === true;
    }
}
exports.NameValidator = NameValidator;
//# sourceMappingURL=name_validator.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/version.js":
/*!**********************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/version.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.defaultVersion = exports.Version = void 0;
exports.getPreviousVersion = getPreviousVersion;
var Version;
(function (Version) {
    Version["OpenABAP"] = "open-abap";
    Version["v700"] = "v700";
    Version["v702"] = "v702";
    Version["v740sp02"] = "v740sp02";
    Version["v740sp05"] = "v740sp05";
    Version["v740sp08"] = "v740sp08";
    Version["v750"] = "v750";
    Version["v751"] = "v751";
    Version["v752"] = "v752";
    Version["v753"] = "v753";
    Version["v754"] = "v754";
    Version["v755"] = "v755";
    Version["v756"] = "v756";
    Version["v757"] = "v757";
    Version["v758"] = "v758";
    Version["Cloud"] = "Cloud";
})(Version || (exports.Version = Version = {}));
exports.defaultVersion = Version.v758;
function getPreviousVersion(v) {
    if (v === Version.OpenABAP) {
        return Version.v702;
    }
    const all = Object.values(Version);
    const found = all.indexOf(v);
    if (found < 0) {
        throw "Unknown version: " + v;
    }
    else if (found === 0) {
        throw "Nothing lower: " + v;
    }
    return all[found - 1];
}
//# sourceMappingURL=version.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/virtual_position.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/virtual_position.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.VirtualPosition = void 0;
const position_1 = __webpack_require__(/*! ./position */ "./node_modules/@abaplint/core/build/src/position.js");
/** used for macro calls */
class VirtualPosition extends position_1.Position {
    constructor(virtual, row, col) {
        super(virtual.getRow(), virtual.getCol());
        this.vrow = row;
        this.vcol = col;
    }
    equals(p) {
        if (!(p instanceof VirtualPosition)) {
            return false;
        }
        const casted = p;
        return super.equals(this) && this.vrow === casted.vrow && this.vcol === casted.vcol;
    }
}
exports.VirtualPosition = VirtualPosition;
//# sourceMappingURL=virtual_position.js.map

/***/ }),

/***/ "./node_modules/@abaplint/core/build/src/xml_utils.js":
/*!************************************************************!*\
  !*** ./node_modules/@abaplint/core/build/src/xml_utils.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.xmlToArray = xmlToArray;
exports.unescape = unescape;
function xmlToArray(data) {
    if (data === undefined) {
        return [];
    }
    else if (Array.isArray(data)) {
        return data;
    }
    else {
        return [data];
    }
}
function unescape(str) {
    if (str === undefined) {
        return "";
    }
    str = str.replace(/&amp;/g, "&");
    str = str.replace(/&gt;/g, ">");
    str = str.replace(/&lt;/g, "<");
    str = str.replace(/&quot;/g, "\"");
    str = str.replace(/&apos;/g, "'");
    return str;
}
//# sourceMappingURL=xml_utils.js.map

/***/ }),

/***/ "./node_modules/balanced-match/index.js":
/*!**********************************************!*\
  !*** ./node_modules/balanced-match/index.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";

module.exports = balanced;
function balanced(a, b, str) {
  if (a instanceof RegExp) a = maybeMatch(a, str);
  if (b instanceof RegExp) b = maybeMatch(b, str);

  var r = range(a, b, str);

  return r && {
    start: r[0],
    end: r[1],
    pre: str.slice(0, r[0]),
    body: str.slice(r[0] + a.length, r[1]),
    post: str.slice(r[1] + b.length)
  };
}

function maybeMatch(reg, str) {
  var m = str.match(reg);
  return m ? m[0] : null;
}

balanced.range = range;
function range(a, b, str) {
  var begs, beg, left, right, result;
  var ai = str.indexOf(a);
  var bi = str.indexOf(b, ai + 1);
  var i = ai;

  if (ai >= 0 && bi > 0) {
    begs = [];
    left = str.length;

    while (i >= 0 && !result) {
      if (i == ai) {
        begs.push(i);
        ai = str.indexOf(a, i + 1);
      } else if (begs.length == 1) {
        result = [ begs.pop(), bi ];
      } else {
        beg = begs.pop();
        if (beg < left) {
          left = beg;
          right = bi;
        }

        bi = str.indexOf(b, i + 1);
      }

      i = ai < bi && ai >= 0 ? ai : bi;
    }

    if (begs.length) {
      result = [ left, right ];
    }
  }

  return result;
}


/***/ }),

/***/ "./node_modules/brace-expansion/index.js":
/*!***********************************************!*\
  !*** ./node_modules/brace-expansion/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var concatMap = __webpack_require__(/*! concat-map */ "./node_modules/concat-map/index.js");
var balanced = __webpack_require__(/*! balanced-match */ "./node_modules/balanced-match/index.js");

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  // I don't know why Bash 4.3 does this, but it does.
  // Anything starting with {} will have the first two bytes preserved
  // but *only* at the top level, so {},a}b will not expand to anything,
  // but a{},b}c will be expanded to [a}c,abc].
  // One could argue that this is a bug in Bash, but since the goal of
  // this module is to match Bash's rules, we escape a leading {}
  if (str.substr(0, 2) === '{}') {
    str = '\\{\\}' + str.substr(2);
  }

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = m.body.indexOf(',') >= 0;
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*\}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}



/***/ }),

/***/ "./node_modules/concat-map/index.js":
/*!******************************************!*\
  !*** ./node_modules/concat-map/index.js ***!
  \******************************************/
/***/ ((module) => {

module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/fxp.js":
/*!*************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/fxp.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


const validator = __webpack_require__(/*! ./validator */ "./node_modules/fast-xml-parser/src/validator.js");
const XMLParser = __webpack_require__(/*! ./xmlparser/XMLParser */ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js");
const XMLBuilder = __webpack_require__(/*! ./xmlbuilder/json2xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js");

module.exports = {
  XMLParser: XMLParser,
  XMLValidator: validator,
  XMLBuilder: XMLBuilder
}

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/ignoreAttributes.js":
/*!**************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/ignoreAttributes.js ***!
  \**************************************************************/
/***/ ((module) => {

function getIgnoreAttributesFn(ignoreAttributes) {
    if (typeof ignoreAttributes === 'function') {
        return ignoreAttributes
    }
    if (Array.isArray(ignoreAttributes)) {
        return (attrName) => {
            for (const pattern of ignoreAttributes) {
                if (typeof pattern === 'string' && attrName === pattern) {
                    return true
                }
                if (pattern instanceof RegExp && pattern.test(attrName)) {
                    return true
                }
            }
        }
    }
    return () => false
}

module.exports = getIgnoreAttributesFn

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/util.js":
/*!**************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/util.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


const nameStartChar = ':A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD';
const nameChar = nameStartChar + '\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040';
const nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'
const regexName = new RegExp('^' + nameRegexp + '$');

const getAllMatches = function(string, regex) {
  const matches = [];
  let match = regex.exec(string);
  while (match) {
    const allmatches = [];
    allmatches.startIndex = regex.lastIndex - match[0].length;
    const len = match.length;
    for (let index = 0; index < len; index++) {
      allmatches.push(match[index]);
    }
    matches.push(allmatches);
    match = regex.exec(string);
  }
  return matches;
};

const isName = function(string) {
  const match = regexName.exec(string);
  return !(match === null || typeof match === 'undefined');
};

exports.isExist = function(v) {
  return typeof v !== 'undefined';
};

exports.isEmptyObject = function(obj) {
  return Object.keys(obj).length === 0;
};

/**
 * Copy all the properties of a into b.
 * @param {*} target
 * @param {*} a
 */
exports.merge = function(target, a, arrayMode) {
  if (a) {
    const keys = Object.keys(a); // will return an array of own properties
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      if (arrayMode === 'strict') {
        target[keys[i]] = [ a[keys[i]] ];
      } else {
        target[keys[i]] = a[keys[i]];
      }
    }
  }
};
/* exports.merge =function (b,a){
  return Object.assign(b,a);
} */

exports.getValue = function(v) {
  if (exports.isExist(v)) {
    return v;
  } else {
    return '';
  }
};

// const fakeCall = function(a) {return a;};
// const fakeCallNoReturn = function() {};

exports.isName = isName;
exports.getAllMatches = getAllMatches;
exports.nameRegexp = nameRegexp;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/validator.js":
/*!*******************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/validator.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";


const util = __webpack_require__(/*! ./util */ "./node_modules/fast-xml-parser/src/util.js");

const defaultOptions = {
  allowBooleanAttributes: false, //A tag can have attributes without any value
  unpairedTags: []
};

//const tagsPattern = new RegExp("<\\/?([\\w:\\-_\.]+)\\s*\/?>","g");
exports.validate = function (xmlData, options) {
  options = Object.assign({}, defaultOptions, options);

  //xmlData = xmlData.replace(/(\r\n|\n|\r)/gm,"");//make it single line
  //xmlData = xmlData.replace(/(^\s*<\?xml.*?\?>)/g,"");//Remove XML starting tag
  //xmlData = xmlData.replace(/(<!DOCTYPE[\s\w\"\.\/\-\:]+(\[.*\])*\s*>)/g,"");//Remove DOCTYPE
  const tags = [];
  let tagFound = false;

  //indicates that the root tag has been closed (aka. depth 0 has been reached)
  let reachedRoot = false;

  if (xmlData[0] === '\ufeff') {
    // check for byte order mark (BOM)
    xmlData = xmlData.substr(1);
  }
  
  for (let i = 0; i < xmlData.length; i++) {

    if (xmlData[i] === '<' && xmlData[i+1] === '?') {
      i+=2;
      i = readPI(xmlData,i);
      if (i.err) return i;
    }else if (xmlData[i] === '<') {
      //starting of tag
      //read until you reach to '>' avoiding any '>' in attribute value
      let tagStartPos = i;
      i++;
      
      if (xmlData[i] === '!') {
        i = readCommentAndCDATA(xmlData, i);
        continue;
      } else {
        let closingTag = false;
        if (xmlData[i] === '/') {
          //closing tag
          closingTag = true;
          i++;
        }
        //read tagname
        let tagName = '';
        for (; i < xmlData.length &&
          xmlData[i] !== '>' &&
          xmlData[i] !== ' ' &&
          xmlData[i] !== '\t' &&
          xmlData[i] !== '\n' &&
          xmlData[i] !== '\r'; i++
        ) {
          tagName += xmlData[i];
        }
        tagName = tagName.trim();
        //console.log(tagName);

        if (tagName[tagName.length - 1] === '/') {
          //self closing tag without attributes
          tagName = tagName.substring(0, tagName.length - 1);
          //continue;
          i--;
        }
        if (!validateTagName(tagName)) {
          let msg;
          if (tagName.trim().length === 0) {
            msg = "Invalid space after '<'.";
          } else {
            msg = "Tag '"+tagName+"' is an invalid name.";
          }
          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));
        }

        const result = readAttributeStr(xmlData, i);
        if (result === false) {
          return getErrorObject('InvalidAttr', "Attributes for '"+tagName+"' have open quote.", getLineNumberForPosition(xmlData, i));
        }
        let attrStr = result.value;
        i = result.index;

        if (attrStr[attrStr.length - 1] === '/') {
          //self closing tag
          const attrStrStart = i - attrStr.length;
          attrStr = attrStr.substring(0, attrStr.length - 1);
          const isValid = validateAttributeString(attrStr, options);
          if (isValid === true) {
            tagFound = true;
            //continue; //text may presents after self closing tag
          } else {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));
          }
        } else if (closingTag) {
          if (!result.tagClosed) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' doesn't have proper closing.", getLineNumberForPosition(xmlData, i));
          } else if (attrStr.trim().length > 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' can't have attributes or invalid starting.", getLineNumberForPosition(xmlData, tagStartPos));
          } else if (tags.length === 0) {
            return getErrorObject('InvalidTag', "Closing tag '"+tagName+"' has not been opened.", getLineNumberForPosition(xmlData, tagStartPos));
          } else {
            const otg = tags.pop();
            if (tagName !== otg.tagName) {
              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);
              return getErrorObject('InvalidTag',
                "Expected closing tag '"+otg.tagName+"' (opened in line "+openPos.line+", col "+openPos.col+") instead of closing tag '"+tagName+"'.",
                getLineNumberForPosition(xmlData, tagStartPos));
            }

            //when there are no more tags, we reached the root level.
            if (tags.length == 0) {
              reachedRoot = true;
            }
          }
        } else {
          const isValid = validateAttributeString(attrStr, options);
          if (isValid !== true) {
            //the result from the nested function returns the position of the error within the attribute
            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute
            //this gives us the absolute index in the entire xml, which we can use to find the line at last
            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));
          }

          //if the root level has been reached before ...
          if (reachedRoot === true) {
            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));
          } else if(options.unpairedTags.indexOf(tagName) !== -1){
            //don't push into stack
          } else {
            tags.push({tagName, tagStartPos});
          }
          tagFound = true;
        }

        //skip tag text value
        //It may include comments and CDATA value
        for (i++; i < xmlData.length; i++) {
          if (xmlData[i] === '<') {
            if (xmlData[i + 1] === '!') {
              //comment or CADATA
              i++;
              i = readCommentAndCDATA(xmlData, i);
              continue;
            } else if (xmlData[i+1] === '?') {
              i = readPI(xmlData, ++i);
              if (i.err) return i;
            } else{
              break;
            }
          } else if (xmlData[i] === '&') {
            const afterAmp = validateAmpersand(xmlData, i);
            if (afterAmp == -1)
              return getErrorObject('InvalidChar', "char '&' is not expected.", getLineNumberForPosition(xmlData, i));
            i = afterAmp;
          }else{
            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {
              return getErrorObject('InvalidXml', "Extra text at the end", getLineNumberForPosition(xmlData, i));
            }
          }
        } //end of reading tag text value
        if (xmlData[i] === '<') {
          i--;
        }
      }
    } else {
      if ( isWhiteSpace(xmlData[i])) {
        continue;
      }
      return getErrorObject('InvalidChar', "char '"+xmlData[i]+"' is not expected.", getLineNumberForPosition(xmlData, i));
    }
  }

  if (!tagFound) {
    return getErrorObject('InvalidXml', 'Start tag expected.', 1);
  }else if (tags.length == 1) {
      return getErrorObject('InvalidTag', "Unclosed tag '"+tags[0].tagName+"'.", getLineNumberForPosition(xmlData, tags[0].tagStartPos));
  }else if (tags.length > 0) {
      return getErrorObject('InvalidXml', "Invalid '"+
          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\r?\n/g, '')+
          "' found.", {line: 1, col: 1});
  }

  return true;
};

function isWhiteSpace(char){
  return char === ' ' || char === '\t' || char === '\n'  || char === '\r';
}
/**
 * Read Processing insstructions and skip
 * @param {*} xmlData
 * @param {*} i
 */
function readPI(xmlData, i) {
  const start = i;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] == '?' || xmlData[i] == ' ') {
      //tagname
      const tagname = xmlData.substr(start, i - start);
      if (i > 5 && tagname === 'xml') {
        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));
      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {
        //check if valid attribut string
        i++;
        break;
      } else {
        continue;
      }
    }
  }
  return i;
}

function readCommentAndCDATA(xmlData, i) {
  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {
    //comment
    for (i += 3; i < xmlData.length; i++) {
      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  } else if (
    xmlData.length > i + 8 &&
    xmlData[i + 1] === 'D' &&
    xmlData[i + 2] === 'O' &&
    xmlData[i + 3] === 'C' &&
    xmlData[i + 4] === 'T' &&
    xmlData[i + 5] === 'Y' &&
    xmlData[i + 6] === 'P' &&
    xmlData[i + 7] === 'E'
  ) {
    let angleBracketsCount = 1;
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === '<') {
        angleBracketsCount++;
      } else if (xmlData[i] === '>') {
        angleBracketsCount--;
        if (angleBracketsCount === 0) {
          break;
        }
      }
    }
  } else if (
    xmlData.length > i + 9 &&
    xmlData[i + 1] === '[' &&
    xmlData[i + 2] === 'C' &&
    xmlData[i + 3] === 'D' &&
    xmlData[i + 4] === 'A' &&
    xmlData[i + 5] === 'T' &&
    xmlData[i + 6] === 'A' &&
    xmlData[i + 7] === '['
  ) {
    for (i += 8; i < xmlData.length; i++) {
      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {
        i += 2;
        break;
      }
    }
  }

  return i;
}

const doubleQuote = '"';
const singleQuote = "'";

/**
 * Keep reading xmlData until '<' is found outside the attribute value.
 * @param {string} xmlData
 * @param {number} i
 */
function readAttributeStr(xmlData, i) {
  let attrStr = '';
  let startChar = '';
  let tagClosed = false;
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {
      if (startChar === '') {
        startChar = xmlData[i];
      } else if (startChar !== xmlData[i]) {
        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa
      } else {
        startChar = '';
      }
    } else if (xmlData[i] === '>') {
      if (startChar === '') {
        tagClosed = true;
        break;
      }
    }
    attrStr += xmlData[i];
  }
  if (startChar !== '') {
    return false;
  }

  return {
    value: attrStr,
    index: i,
    tagClosed: tagClosed
  };
}

/**
 * Select all the attributes whether valid or invalid.
 */
const validAttrStrRegxp = new RegExp('(\\s*)([^\\s=]+)(\\s*=)?(\\s*([\'"])(([\\s\\S])*?)\\5)?', 'g');

//attr, ="sd", a="amit's", a="sd"b="saf", ab  cd=""

function validateAttributeString(attrStr, options) {
  //console.log("start:"+attrStr+":end");

  //if(attrStr.trim().length === 0) return true; //empty string

  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);
  const attrNames = {};

  for (let i = 0; i < matches.length; i++) {
    if (matches[i][1].length === 0) {
      //nospace before attribute name: a="sd"b="saf"
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' has no space in starting.", getPositionFromMatch(matches[i]))
    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {
      return getErrorObject('InvalidAttr', "Attribute '"+matches[i][2]+"' is without value.", getPositionFromMatch(matches[i]));
    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {
      //independent attribute: ab
      return getErrorObject('InvalidAttr', "boolean attribute '"+matches[i][2]+"' is not allowed.", getPositionFromMatch(matches[i]));
    }
    /* else if(matches[i][6] === undefined){//attribute without value: ab=
                    return { err: { code:"InvalidAttr",msg:"attribute " + matches[i][2] + " has no value assigned."}};
                } */
    const attrName = matches[i][2];
    if (!validateAttrName(attrName)) {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is an invalid name.", getPositionFromMatch(matches[i]));
    }
    if (!attrNames.hasOwnProperty(attrName)) {
      //check for duplicate attribute.
      attrNames[attrName] = 1;
    } else {
      return getErrorObject('InvalidAttr', "Attribute '"+attrName+"' is repeated.", getPositionFromMatch(matches[i]));
    }
  }

  return true;
}

function validateNumberAmpersand(xmlData, i) {
  let re = /\d/;
  if (xmlData[i] === 'x') {
    i++;
    re = /[\da-fA-F]/;
  }
  for (; i < xmlData.length; i++) {
    if (xmlData[i] === ';')
      return i;
    if (!xmlData[i].match(re))
      break;
  }
  return -1;
}

function validateAmpersand(xmlData, i) {
  // https://www.w3.org/TR/xml/#dt-charref
  i++;
  if (xmlData[i] === ';')
    return -1;
  if (xmlData[i] === '#') {
    i++;
    return validateNumberAmpersand(xmlData, i);
  }
  let count = 0;
  for (; i < xmlData.length; i++, count++) {
    if (xmlData[i].match(/\w/) && count < 20)
      continue;
    if (xmlData[i] === ';')
      break;
    return -1;
  }
  return i;
}

function getErrorObject(code, message, lineNumber) {
  return {
    err: {
      code: code,
      msg: message,
      line: lineNumber.line || lineNumber,
      col: lineNumber.col,
    },
  };
}

function validateAttrName(attrName) {
  return util.isName(attrName);
}

// const startsWithXML = /^xml/i;

function validateTagName(tagname) {
  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;
}

//this function returns the line number for the character at the given index
function getLineNumberForPosition(xmlData, index) {
  const lines = xmlData.substring(0, index).split(/\r?\n/);
  return {
    line: lines.length,

    // column number is last line's length + 1, because column numbering starts at 1:
    col: lines[lines.length - 1].length + 1
  };
}

//this function returns the position of the first character of match within attrStr
function getPositionFromMatch(match) {
  return match.startIndex + match[1].length;
}


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

//parse Empty Node as self closing node
const buildFromOrderedJs = __webpack_require__(/*! ./orderedJs2Xml */ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js");
const getIgnoreAttributesFn = __webpack_require__(/*! ../ignoreAttributes */ "./node_modules/fast-xml-parser/src/ignoreAttributes.js")

const defaultOptions = {
  attributeNamePrefix: '@_',
  attributesGroupName: false,
  textNodeName: '#text',
  ignoreAttributes: true,
  cdataPropName: false,
  format: false,
  indentBy: '  ',
  suppressEmptyNode: false,
  suppressUnpairedNode: true,
  suppressBooleanAttributes: true,
  tagValueProcessor: function(key, a) {
    return a;
  },
  attributeValueProcessor: function(attrName, a) {
    return a;
  },
  preserveOrder: false,
  commentPropName: false,
  unpairedTags: [],
  entities: [
    { regex: new RegExp("&", "g"), val: "&amp;" },//it must be on top
    { regex: new RegExp(">", "g"), val: "&gt;" },
    { regex: new RegExp("<", "g"), val: "&lt;" },
    { regex: new RegExp("\'", "g"), val: "&apos;" },
    { regex: new RegExp("\"", "g"), val: "&quot;" }
  ],
  processEntities: true,
  stopNodes: [],
  // transformTagName: false,
  // transformAttributeName: false,
  oneListGroup: false
};

function Builder(options) {
  this.options = Object.assign({}, defaultOptions, options);
  if (this.options.ignoreAttributes === true || this.options.attributesGroupName) {
    this.isAttribute = function(/*a*/) {
      return false;
    };
  } else {
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)
    this.attrPrefixLen = this.options.attributeNamePrefix.length;
    this.isAttribute = isAttribute;
  }

  this.processTextOrObjNode = processTextOrObjNode

  if (this.options.format) {
    this.indentate = indentate;
    this.tagEndChar = '>\n';
    this.newLine = '\n';
  } else {
    this.indentate = function() {
      return '';
    };
    this.tagEndChar = '>';
    this.newLine = '';
  }
}

Builder.prototype.build = function(jObj) {
  if(this.options.preserveOrder){
    return buildFromOrderedJs(jObj, this.options);
  }else {
    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){
      jObj = {
        [this.options.arrayNodeName] : jObj
      }
    }
    return this.j2x(jObj, 0, []).val;
  }
};

Builder.prototype.j2x = function(jObj, level, ajPath) {
  let attrStr = '';
  let val = '';
  const jPath = ajPath.join('.')
  for (let key in jObj) {
    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;
    if (typeof jObj[key] === 'undefined') {
      // supress undefined node only if it is not an attribute
      if (this.isAttribute(key)) {
        val += '';
      }
    } else if (jObj[key] === null) {
      // null attribute should be ignored by the attribute list, but should not cause the tag closing
      if (this.isAttribute(key)) {
        val += '';
      } else if (key[0] === '?') {
        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
      } else {
        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
      }
      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
    } else if (jObj[key] instanceof Date) {
      val += this.buildTextValNode(jObj[key], key, '', level);
    } else if (typeof jObj[key] !== 'object') {
      //premitive type
      const attr = this.isAttribute(key);
      if (attr && !this.ignoreAttributesFn(attr, jPath)) {
        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);
      } else if (!attr) {
        //tag value
        if (key === this.options.textNodeName) {
          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);
          val += this.replaceEntitiesValue(newval);
        } else {
          val += this.buildTextValNode(jObj[key], key, '', level);
        }
      }
    } else if (Array.isArray(jObj[key])) {
      //repeated nodes
      const arrLen = jObj[key].length;
      let listTagVal = "";
      let listTagAttr = "";
      for (let j = 0; j < arrLen; j++) {
        const item = jObj[key][j];
        if (typeof item === 'undefined') {
          // supress undefined node
        } else if (item === null) {
          if(key[0] === "?") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;
          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;
        } else if (typeof item === 'object') {
          if(this.options.oneListGroup){
            const result = this.j2x(item, level + 1, ajPath.concat(key));
            listTagVal += result.val;
            if (this.options.attributesGroupName && item.hasOwnProperty(this.options.attributesGroupName)) {
              listTagAttr += result.attrStr
            }
          }else{
            listTagVal += this.processTextOrObjNode(item, key, level, ajPath)
          }
        } else {
          if (this.options.oneListGroup) {
            let textValue = this.options.tagValueProcessor(key, item);
            textValue = this.replaceEntitiesValue(textValue);
            listTagVal += textValue;
          } else {
            listTagVal += this.buildTextValNode(item, key, '', level);
          }
        }
      }
      if(this.options.oneListGroup){
        listTagVal = this.buildObjectNode(listTagVal, key, listTagAttr, level);
      }
      val += listTagVal;
    } else {
      //nested node
      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {
        const Ks = Object.keys(jObj[key]);
        const L = Ks.length;
        for (let j = 0; j < L; j++) {
          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);
        }
      } else {
        val += this.processTextOrObjNode(jObj[key], key, level, ajPath)
      }
    }
  }
  return {attrStr: attrStr, val: val};
};

Builder.prototype.buildAttrPairStr = function(attrName, val){
  val = this.options.attributeValueProcessor(attrName, '' + val);
  val = this.replaceEntitiesValue(val);
  if (this.options.suppressBooleanAttributes && val === "true") {
    return ' ' + attrName;
  } else return ' ' + attrName + '="' + val + '"';
}

function processTextOrObjNode (object, key, level, ajPath) {
  const result = this.j2x(object, level + 1, ajPath.concat(key));
  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {
    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);
  } else {
    return this.buildObjectNode(result.val, key, result.attrStr, level);
  }
}

Builder.prototype.buildObjectNode = function(val, key, attrStr, level) {
  if(val === ""){
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }
  }else{

    let tagEndExp = '</' + key + this.tagEndChar;
    let piClosingChar = "";
    
    if(key[0] === "?") {
      piClosingChar = "?";
      tagEndExp = "";
    }
  
    // attrStr is an empty string in case the attribute came as undefined or null
    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {
      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );
    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {
      return this.indentate(level) + `<!--${val}-->` + this.newLine;
    }else {
      return (
        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +
        val +
        this.indentate(level) + tagEndExp    );
    }
  }
}

Builder.prototype.closeTag = function(key){
  let closeTag = "";
  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired
    if(!this.options.suppressUnpairedNode) closeTag = "/"
  }else if(this.options.suppressEmptyNode){ //empty
    closeTag = "/";
  }else{
    closeTag = `></${key}`
  }
  return closeTag;
}

function buildEmptyObjNode(val, key, attrStr, level) {
  if (val !== '') {
    return this.buildObjectNode(val, key, attrStr, level);
  } else {
    if(key[0] === "?") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;
    else {
      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;
      // return this.buildTagStr(level,key, attrStr);
    }
  }
}

Builder.prototype.buildTextValNode = function(val, key, attrStr, level) {
  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {
    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;
  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {
    return this.indentate(level) + `<!--${val}-->` +  this.newLine;
  }else if(key[0] === "?") {//PI tag
    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; 
  }else{
    let textValue = this.options.tagValueProcessor(key, val);
    textValue = this.replaceEntitiesValue(textValue);
  
    if( textValue === ''){
      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;
    }else{
      return this.indentate(level) + '<' + key + attrStr + '>' +
         textValue +
        '</' + key + this.tagEndChar;
    }
  }
}

Builder.prototype.replaceEntitiesValue = function(textValue){
  if(textValue && textValue.length > 0 && this.options.processEntities){
    for (let i=0; i<this.options.entities.length; i++) {
      const entity = this.options.entities[i];
      textValue = textValue.replace(entity.regex, entity.val);
    }
  }
  return textValue;
}

function indentate(level) {
  return this.options.indentBy.repeat(level);
}

function isAttribute(name /*, options*/) {
  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {
    return name.substr(this.attrPrefixLen);
  } else {
    return false;
  }
}

module.exports = Builder;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js ***!
  \**********************************************************************/
/***/ ((module) => {

const EOL = "\n";

/**
 * 
 * @param {array} jArray 
 * @param {any} options 
 * @returns 
 */
function toXml(jArray, options) {
    let indentation = "";
    if (options.format && options.indentBy.length > 0) {
        indentation = EOL;
    }
    return arrToStr(jArray, options, "", indentation);
}

function arrToStr(arr, options, jPath, indentation) {
    let xmlStr = "";
    let isPreviousElementTag = false;

    for (let i = 0; i < arr.length; i++) {
        const tagObj = arr[i];
        const tagName = propName(tagObj);
        if(tagName === undefined) continue;

        let newJPath = "";
        if (jPath.length === 0) newJPath = tagName
        else newJPath = `${jPath}.${tagName}`;

        if (tagName === options.textNodeName) {
            let tagText = tagObj[tagName];
            if (!isStopNode(newJPath, options)) {
                tagText = options.tagValueProcessor(tagName, tagText);
                tagText = replaceEntitiesValue(tagText, options);
            }
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += tagText;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.cdataPropName) {
            if (isPreviousElementTag) {
                xmlStr += indentation;
            }
            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;
            isPreviousElementTag = false;
            continue;
        } else if (tagName === options.commentPropName) {
            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;
            isPreviousElementTag = true;
            continue;
        } else if (tagName[0] === "?") {
            const attStr = attr_to_str(tagObj[":@"], options);
            const tempInd = tagName === "?xml" ? "" : indentation;
            let piTextNodeName = tagObj[tagName][0][options.textNodeName];
            piTextNodeName = piTextNodeName.length !== 0 ? " " + piTextNodeName : ""; //remove extra spacing
            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;
            isPreviousElementTag = true;
            continue;
        }
        let newIdentation = indentation;
        if (newIdentation !== "") {
            newIdentation += options.indentBy;
        }
        const attStr = attr_to_str(tagObj[":@"], options);
        const tagStart = indentation + `<${tagName}${attStr}`;
        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);
        if (options.unpairedTags.indexOf(tagName) !== -1) {
            if (options.suppressUnpairedNode) xmlStr += tagStart + ">";
            else xmlStr += tagStart + "/>";
        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {
            xmlStr += tagStart + "/>";
        } else if (tagValue && tagValue.endsWith(">")) {
            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;
        } else {
            xmlStr += tagStart + ">";
            if (tagValue && indentation !== "" && (tagValue.includes("/>") || tagValue.includes("</"))) {
                xmlStr += indentation + options.indentBy + tagValue + indentation;
            } else {
                xmlStr += tagValue;
            }
            xmlStr += `</${tagName}>`;
        }
        isPreviousElementTag = true;
    }

    return xmlStr;
}

function propName(obj) {
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        if(!obj.hasOwnProperty(key)) continue;
        if (key !== ":@") return key;
    }
}

function attr_to_str(attrMap, options) {
    let attrStr = "";
    if (attrMap && !options.ignoreAttributes) {
        for (let attr in attrMap) {
            if(!attrMap.hasOwnProperty(attr)) continue;
            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);
            attrVal = replaceEntitiesValue(attrVal, options);
            if (attrVal === true && options.suppressBooleanAttributes) {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;
            } else {
                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}="${attrVal}"`;
            }
        }
    }
    return attrStr;
}

function isStopNode(jPath, options) {
    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);
    let tagName = jPath.substr(jPath.lastIndexOf(".") + 1);
    for (let index in options.stopNodes) {
        if (options.stopNodes[index] === jPath || options.stopNodes[index] === "*." + tagName) return true;
    }
    return false;
}

function replaceEntitiesValue(textValue, options) {
    if (textValue && textValue.length > 0 && options.processEntities) {
        for (let i = 0; i < options.entities.length; i++) {
            const entity = options.entities[i];
            textValue = textValue.replace(entity.regex, entity.val);
        }
    }
    return textValue;
}
module.exports = toXml;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js":
/*!*********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const util = __webpack_require__(/*! ../util */ "./node_modules/fast-xml-parser/src/util.js");

//TODO: handle comments
function readDocType(xmlData, i){
    
    const entities = {};
    if( xmlData[i + 3] === 'O' &&
         xmlData[i + 4] === 'C' &&
         xmlData[i + 5] === 'T' &&
         xmlData[i + 6] === 'Y' &&
         xmlData[i + 7] === 'P' &&
         xmlData[i + 8] === 'E')
    {    
        i = i+9;
        let angleBracketsCount = 1;
        let hasBody = false, comment = false;
        let exp = "";
        for(;i<xmlData.length;i++){
            if (xmlData[i] === '<' && !comment) { //Determine the tag type
                if( hasBody && isEntity(xmlData, i)){
                    i += 7; 
                    [entityName, val,i] = readEntityExp(xmlData,i+1);
                    if(val.indexOf("&") === -1) //Parameter entities are not supported
                        entities[ validateEntityName(entityName) ] = {
                            regx : RegExp( `&${entityName};`,"g"),
                            val: val
                        };
                }
                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported
                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported
                else if( isComment)                         comment = true;
                else                                        throw new Error("Invalid DOCTYPE");

                angleBracketsCount++;
                exp = "";
            } else if (xmlData[i] === '>') { //Read tag content
                if(comment){
                    if( xmlData[i - 1] === "-" && xmlData[i - 2] === "-"){
                        comment = false;
                        angleBracketsCount--;
                    }
                }else{
                    angleBracketsCount--;
                }
                if (angleBracketsCount === 0) {
                  break;
                }
            }else if( xmlData[i] === '['){
                hasBody = true;
            }else{
                exp += xmlData[i];
            }
        }
        if(angleBracketsCount !== 0){
            throw new Error(`Unclosed DOCTYPE`);
        }
    }else{
        throw new Error(`Invalid Tag instead of DOCTYPE`);
    }
    return {entities, i};
}

function readEntityExp(xmlData,i){
    //External entities are not supported
    //    <!ENTITY ext SYSTEM "http://normal-website.com" >

    //Parameter entities are not supported
    //    <!ENTITY entityname "&anotherElement;">

    //Internal entities are supported
    //    <!ENTITY entityname "replacement text">
    
    //read EntityName
    let entityName = "";
    for (; i < xmlData.length && (xmlData[i] !== "'" && xmlData[i] !== '"' ); i++) {
        // if(xmlData[i] === " ") continue;
        // else 
        entityName += xmlData[i];
    }
    entityName = entityName.trim();
    if(entityName.indexOf(" ") !== -1) throw new Error("External entites are not supported");

    //read Entity Value
    const startChar = xmlData[i++];
    let val = ""
    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {
        val += xmlData[i];
    }
    return [entityName, val, i];
}

function isComment(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === '-' &&
    xmlData[i+3] === '-') return true
    return false
}
function isEntity(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'N' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'I' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'Y') return true
    return false
}
function isElement(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'E' &&
    xmlData[i+3] === 'L' &&
    xmlData[i+4] === 'E' &&
    xmlData[i+5] === 'M' &&
    xmlData[i+6] === 'E' &&
    xmlData[i+7] === 'N' &&
    xmlData[i+8] === 'T') return true
    return false
}

function isAttlist(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'A' &&
    xmlData[i+3] === 'T' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'L' &&
    xmlData[i+6] === 'I' &&
    xmlData[i+7] === 'S' &&
    xmlData[i+8] === 'T') return true
    return false
}
function isNotation(xmlData, i){
    if(xmlData[i+1] === '!' &&
    xmlData[i+2] === 'N' &&
    xmlData[i+3] === 'O' &&
    xmlData[i+4] === 'T' &&
    xmlData[i+5] === 'A' &&
    xmlData[i+6] === 'T' &&
    xmlData[i+7] === 'I' &&
    xmlData[i+8] === 'O' &&
    xmlData[i+9] === 'N') return true
    return false
}

function validateEntityName(name){
    if (util.isName(name))
	return name;
    else
        throw new Error(`Invalid entity name ${name}`);
}

module.exports = readDocType;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports) => {


const defaultOptions = {
    preserveOrder: false,
    attributeNamePrefix: '@_',
    attributesGroupName: false,
    textNodeName: '#text',
    ignoreAttributes: true,
    removeNSPrefix: false, // remove NS from tag name or attribute name if true
    allowBooleanAttributes: false, //a tag can have attributes without any value
    //ignoreRootElement : false,
    parseTagValue: true,
    parseAttributeValue: false,
    trimValues: true, //Trim string values of tag and attributes
    cdataPropName: false,
    numberParseOptions: {
      hex: true,
      leadingZeros: true,
      eNotation: true
    },
    tagValueProcessor: function(tagName, val) {
      return val;
    },
    attributeValueProcessor: function(attrName, val) {
      return val;
    },
    stopNodes: [], //nested tags will not be parsed even for errors
    alwaysCreateTextNode: false,
    isArray: () => false,
    commentPropName: false,
    unpairedTags: [],
    processEntities: true,
    htmlEntities: false,
    ignoreDeclaration: false,
    ignorePiTags: false,
    transformTagName: false,
    transformAttributeName: false,
    updateTag: function(tagName, jPath, attrs){
      return tagName
    },
    // skipEmptyListItem: false
};
   
const buildOptions = function(options) {
    return Object.assign({}, defaultOptions, options);
};

exports.buildOptions = buildOptions;
exports.defaultOptions = defaultOptions;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js":
/*!************************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

///@ts-check

const util = __webpack_require__(/*! ../util */ "./node_modules/fast-xml-parser/src/util.js");
const xmlNode = __webpack_require__(/*! ./xmlNode */ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js");
const readDocType = __webpack_require__(/*! ./DocTypeReader */ "./node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js");
const toNumber = __webpack_require__(/*! strnum */ "./node_modules/strnum/strnum.js");
const getIgnoreAttributesFn = __webpack_require__(/*! ../ignoreAttributes */ "./node_modules/fast-xml-parser/src/ignoreAttributes.js")

// const regx =
//   '<((!\\[CDATA\\[([\\s\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\/)(NAME)\\s*>))([^<]*)'
//   .replace(/NAME/g, util.nameRegexp);

//const tagsRegx = new RegExp("<(\\/?[\\w:\\-\._]+)([^>]*)>(\\s*"+cdataRegx+")*([^<]+)?","g");
//const tagsRegx = new RegExp("<(\\/?)((\\w*:)?([\\w:\\-\._]+))([^>]*)>([^<]*)("+cdataRegx+"([^<]*))*([^<]+)?","g");

class OrderedObjParser{
  constructor(options){
    this.options = options;
    this.currentNode = null;
    this.tagsNodeStack = [];
    this.docTypeEntities = {};
    this.lastEntities = {
      "apos" : { regex: /&(apos|#39|#x27);/g, val : "'"},
      "gt" : { regex: /&(gt|#62|#x3E);/g, val : ">"},
      "lt" : { regex: /&(lt|#60|#x3C);/g, val : "<"},
      "quot" : { regex: /&(quot|#34|#x22);/g, val : "\""},
    };
    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : "&"};
    this.htmlEntities = {
      "space": { regex: /&(nbsp|#160);/g, val: " " },
      // "lt" : { regex: /&(lt|#60);/g, val: "<" },
      // "gt" : { regex: /&(gt|#62);/g, val: ">" },
      // "amp" : { regex: /&(amp|#38);/g, val: "&" },
      // "quot" : { regex: /&(quot|#34);/g, val: "\"" },
      // "apos" : { regex: /&(apos|#39);/g, val: "'" },
      "cent" : { regex: /&(cent|#162);/g, val: "¢" },
      "pound" : { regex: /&(pound|#163);/g, val: "£" },
      "yen" : { regex: /&(yen|#165);/g, val: "¥" },
      "euro" : { regex: /&(euro|#8364);/g, val: "€" },
      "copyright" : { regex: /&(copy|#169);/g, val: "©" },
      "reg" : { regex: /&(reg|#174);/g, val: "®" },
      "inr" : { regex: /&(inr|#8377);/g, val: "₹" },
      "num_dec": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },
      "num_hex": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },
    };
    this.addExternalEntities = addExternalEntities;
    this.parseXml = parseXml;
    this.parseTextData = parseTextData;
    this.resolveNameSpace = resolveNameSpace;
    this.buildAttributesMap = buildAttributesMap;
    this.isItStopNode = isItStopNode;
    this.replaceEntitiesValue = replaceEntitiesValue;
    this.readStopNodeData = readStopNodeData;
    this.saveTextToParentTag = saveTextToParentTag;
    this.addChild = addChild;
    this.ignoreAttributesFn = getIgnoreAttributesFn(this.options.ignoreAttributes)
  }

}

function addExternalEntities(externalEntities){
  const entKeys = Object.keys(externalEntities);
  for (let i = 0; i < entKeys.length; i++) {
    const ent = entKeys[i];
    this.lastEntities[ent] = {
       regex: new RegExp("&"+ent+";","g"),
       val : externalEntities[ent]
    }
  }
}

/**
 * @param {string} val
 * @param {string} tagName
 * @param {string} jPath
 * @param {boolean} dontTrim
 * @param {boolean} hasAttributes
 * @param {boolean} isLeafNode
 * @param {boolean} escapeEntities
 */
function parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {
  if (val !== undefined) {
    if (this.options.trimValues && !dontTrim) {
      val = val.trim();
    }
    if(val.length > 0){
      if(!escapeEntities) val = this.replaceEntitiesValue(val);
      
      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);
      if(newval === null || newval === undefined){
        //don't parse
        return val;
      }else if(typeof newval !== typeof val || newval !== val){
        //overwrite
        return newval;
      }else if(this.options.trimValues){
        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
      }else{
        const trimmedVal = val.trim();
        if(trimmedVal === val){
          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);
        }else{
          return val;
        }
      }
    }
  }
}

function resolveNameSpace(tagname) {
  if (this.options.removeNSPrefix) {
    const tags = tagname.split(':');
    const prefix = tagname.charAt(0) === '/' ? '/' : '';
    if (tags[0] === 'xmlns') {
      return '';
    }
    if (tags.length === 2) {
      tagname = prefix + tags[1];
    }
  }
  return tagname;
}

//TODO: change regex to capture NS
//const attrsRegx = new RegExp("([\\w\\-\\.\\:]+)\\s*=\\s*(['\"])((.|\n)*?)\\2","gm");
const attrsRegx = new RegExp('([^\\s=]+)\\s*(=\\s*([\'"])([\\s\\S]*?)\\3)?', 'gm');

function buildAttributesMap(attrStr, jPath, tagName) {
  if (this.options.ignoreAttributes !== true && typeof attrStr === 'string') {
    // attrStr = attrStr.replace(/\r?\n/g, ' ');
    //attrStr = attrStr || attrStr.trim();

    const matches = util.getAllMatches(attrStr, attrsRegx);
    const len = matches.length; //don't make it inline
    const attrs = {};
    for (let i = 0; i < len; i++) {
      const attrName = this.resolveNameSpace(matches[i][1]);
      if (this.ignoreAttributesFn(attrName, jPath)) {
        continue
      }
      let oldVal = matches[i][4];
      let aName = this.options.attributeNamePrefix + attrName;
      if (attrName.length) {
        if (this.options.transformAttributeName) {
          aName = this.options.transformAttributeName(aName);
        }
        if(aName === "__proto__") aName  = "#__proto__";
        if (oldVal !== undefined) {
          if (this.options.trimValues) {
            oldVal = oldVal.trim();
          }
          oldVal = this.replaceEntitiesValue(oldVal);
          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);
          if(newVal === null || newVal === undefined){
            //don't parse
            attrs[aName] = oldVal;
          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){
            //overwrite
            attrs[aName] = newVal;
          }else{
            //parse
            attrs[aName] = parseValue(
              oldVal,
              this.options.parseAttributeValue,
              this.options.numberParseOptions
            );
          }
        } else if (this.options.allowBooleanAttributes) {
          attrs[aName] = true;
        }
      }
    }
    if (!Object.keys(attrs).length) {
      return;
    }
    if (this.options.attributesGroupName) {
      const attrCollection = {};
      attrCollection[this.options.attributesGroupName] = attrs;
      return attrCollection;
    }
    return attrs
  }
}

const parseXml = function(xmlData) {
  xmlData = xmlData.replace(/\r\n?/g, "\n"); //TODO: remove this line
  const xmlObj = new xmlNode('!xml');
  let currentNode = xmlObj;
  let textData = "";
  let jPath = "";
  for(let i=0; i< xmlData.length; i++){//for each char in XML data
    const ch = xmlData[i];
    if(ch === '<'){
      // const nextIndex = i+1;
      // const _2ndChar = xmlData[nextIndex];
      if( xmlData[i+1] === '/') {//Closing Tag
        const closeIndex = findClosingIndex(xmlData, ">", i, "Closing Tag is not closed.")
        let tagName = xmlData.substring(i+2,closeIndex).trim();

        if(this.options.removeNSPrefix){
          const colonIndex = tagName.indexOf(":");
          if(colonIndex !== -1){
            tagName = tagName.substr(colonIndex+1);
          }
        }

        if(this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }

        if(currentNode){
          textData = this.saveTextToParentTag(textData, currentNode, jPath);
        }

        //check if last tag of nested tag was unpaired tag
        const lastTagName = jPath.substring(jPath.lastIndexOf(".")+1);
        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){
          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);
        }
        let propIndex = 0
        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){
          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)
          this.tagsNodeStack.pop();
        }else{
          propIndex = jPath.lastIndexOf(".");
        }
        jPath = jPath.substring(0, propIndex);

        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope
        textData = "";
        i = closeIndex;
      } else if( xmlData[i+1] === '?') {

        let tagData = readTagExp(xmlData,i, false, "?>");
        if(!tagData) throw new Error("Pi Tag is not closed.");

        textData = this.saveTextToParentTag(textData, currentNode, jPath);
        if( (this.options.ignoreDeclaration && tagData.tagName === "?xml") || this.options.ignorePiTags){

        }else{
  
          const childNode = new xmlNode(tagData.tagName);
          childNode.add(this.options.textNodeName, "");
          
          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);
          }
          this.addChild(currentNode, childNode, jPath)

        }


        i = tagData.closeIndex + 1;
      } else if(xmlData.substr(i + 1, 3) === '!--') {
        const endIndex = findClosingIndex(xmlData, "-->", i+4, "Comment is not closed.")
        if(this.options.commentPropName){
          const comment = xmlData.substring(i + 4, endIndex - 2);

          textData = this.saveTextToParentTag(textData, currentNode, jPath);

          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);
        }
        i = endIndex;
      } else if( xmlData.substr(i + 1, 2) === '!D') {
        const result = readDocType(xmlData, i);
        this.docTypeEntities = result.entities;
        i = result.i;
      }else if(xmlData.substr(i + 1, 2) === '![') {
        const closeIndex = findClosingIndex(xmlData, "]]>", i, "CDATA is not closed.") - 2;
        const tagExp = xmlData.substring(i + 9,closeIndex);

        textData = this.saveTextToParentTag(textData, currentNode, jPath);

        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);
        if(val == undefined) val = "";

        //cdata should be set even if it is 0 length string
        if(this.options.cdataPropName){
          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);
        }else{
          currentNode.add(this.options.textNodeName, val);
        }
        
        i = closeIndex + 2;
      }else {//Opening tag
        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);
        let tagName= result.tagName;
        const rawTagName = result.rawTagName;
        let tagExp = result.tagExp;
        let attrExpPresent = result.attrExpPresent;
        let closeIndex = result.closeIndex;

        if (this.options.transformTagName) {
          tagName = this.options.transformTagName(tagName);
        }
        
        //save text as child node
        if (currentNode && textData) {
          if(currentNode.tagname !== '!xml'){
            //when nested tag is found
            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);
          }
        }

        //check if last tag was unpaired tag
        const lastTag = currentNode;
        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){
          currentNode = this.tagsNodeStack.pop();
          jPath = jPath.substring(0, jPath.lastIndexOf("."));
        }
        if(tagName !== xmlObj.tagname){
          jPath += jPath ? "." + tagName : tagName;
        }
        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {
          let tagContent = "";
          //self-closing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            i = result.closeIndex;
          }
          //unpaired tag
          else if(this.options.unpairedTags.indexOf(tagName) !== -1){
            
            i = result.closeIndex;
          }
          //normal tag
          else{
            //read until closing tag is found
            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);
            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);
            i = result.i;
            tagContent = result.tagContent;
          }

          const childNode = new xmlNode(tagName);
          if(tagName !== tagExp && attrExpPresent){
            childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
          }
          if(tagContent) {
            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);
          }
          
          jPath = jPath.substr(0, jPath.lastIndexOf("."));
          childNode.add(this.options.textNodeName, tagContent);
          
          this.addChild(currentNode, childNode, jPath)
        }else{
  //selfClosing tag
          if(tagExp.length > 0 && tagExp.lastIndexOf("/") === tagExp.length - 1){
            if(tagName[tagName.length - 1] === "/"){ //remove trailing '/'
              tagName = tagName.substr(0, tagName.length - 1);
              jPath = jPath.substr(0, jPath.length - 1);
              tagExp = tagName;
            }else{
              tagExp = tagExp.substr(0, tagExp.length - 1);
            }
            
            if(this.options.transformTagName) {
              tagName = this.options.transformTagName(tagName);
            }

            const childNode = new xmlNode(tagName);
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            jPath = jPath.substr(0, jPath.lastIndexOf("."));
          }
    //opening tag
          else{
            const childNode = new xmlNode( tagName);
            this.tagsNodeStack.push(currentNode);
            
            if(tagName !== tagExp && attrExpPresent){
              childNode[":@"] = this.buildAttributesMap(tagExp, jPath, tagName);
            }
            this.addChild(currentNode, childNode, jPath)
            currentNode = childNode;
          }
          textData = "";
          i = closeIndex;
        }
      }
    }else{
      textData += xmlData[i];
    }
  }
  return xmlObj.child;
}

function addChild(currentNode, childNode, jPath){
  const result = this.options.updateTag(childNode.tagname, jPath, childNode[":@"])
  if(result === false){
  }else if(typeof result === "string"){
    childNode.tagname = result
    currentNode.addChild(childNode);
  }else{
    currentNode.addChild(childNode);
  }
}

const replaceEntitiesValue = function(val){

  if(this.options.processEntities){
    for(let entityName in this.docTypeEntities){
      const entity = this.docTypeEntities[entityName];
      val = val.replace( entity.regx, entity.val);
    }
    for(let entityName in this.lastEntities){
      const entity = this.lastEntities[entityName];
      val = val.replace( entity.regex, entity.val);
    }
    if(this.options.htmlEntities){
      for(let entityName in this.htmlEntities){
        const entity = this.htmlEntities[entityName];
        val = val.replace( entity.regex, entity.val);
      }
    }
    val = val.replace( this.ampEntity.regex, this.ampEntity.val);
  }
  return val;
}
function saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {
  if (textData) { //store previously collected data as textNode
    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0
    
    textData = this.parseTextData(textData,
      currentNode.tagname,
      jPath,
      false,
      currentNode[":@"] ? Object.keys(currentNode[":@"]).length !== 0 : false,
      isLeafNode);

    if (textData !== undefined && textData !== "")
      currentNode.add(this.options.textNodeName, textData);
    textData = "";
  }
  return textData;
}

//TODO: use jPath to simplify the logic
/**
 * 
 * @param {string[]} stopNodes 
 * @param {string} jPath
 * @param {string} currentTagName 
 */
function isItStopNode(stopNodes, jPath, currentTagName){
  const allNodesExp = "*." + currentTagName;
  for (const stopNodePath in stopNodes) {
    const stopNodeExp = stopNodes[stopNodePath];
    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;
  }
  return false;
}

/**
 * Returns the tag Expression and where it is ending handling single-double quotes situation
 * @param {string} xmlData 
 * @param {number} i starting index
 * @returns 
 */
function tagExpWithClosingIndex(xmlData, i, closingChar = ">"){
  let attrBoundary;
  let tagExp = "";
  for (let index = i; index < xmlData.length; index++) {
    let ch = xmlData[index];
    if (attrBoundary) {
        if (ch === attrBoundary) attrBoundary = "";//reset
    } else if (ch === '"' || ch === "'") {
        attrBoundary = ch;
    } else if (ch === closingChar[0]) {
      if(closingChar[1]){
        if(xmlData[index + 1] === closingChar[1]){
          return {
            data: tagExp,
            index: index
          }
        }
      }else{
        return {
          data: tagExp,
          index: index
        }
      }
    } else if (ch === '\t') {
      ch = " "
    }
    tagExp += ch;
  }
}

function findClosingIndex(xmlData, str, i, errMsg){
  const closingIndex = xmlData.indexOf(str, i);
  if(closingIndex === -1){
    throw new Error(errMsg)
  }else{
    return closingIndex + str.length - 1;
  }
}

function readTagExp(xmlData,i, removeNSPrefix, closingChar = ">"){
  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);
  if(!result) return;
  let tagExp = result.data;
  const closeIndex = result.index;
  const separatorIndex = tagExp.search(/\s/);
  let tagName = tagExp;
  let attrExpPresent = true;
  if(separatorIndex !== -1){//separate tag name and attributes expression
    tagName = tagExp.substring(0, separatorIndex);
    tagExp = tagExp.substring(separatorIndex + 1).trimStart();
  }

  const rawTagName = tagName;
  if(removeNSPrefix){
    const colonIndex = tagName.indexOf(":");
    if(colonIndex !== -1){
      tagName = tagName.substr(colonIndex+1);
      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);
    }
  }

  return {
    tagName: tagName,
    tagExp: tagExp,
    closeIndex: closeIndex,
    attrExpPresent: attrExpPresent,
    rawTagName: rawTagName,
  }
}
/**
 * find paired tag for a stop node
 * @param {string} xmlData 
 * @param {string} tagName 
 * @param {number} i 
 */
function readStopNodeData(xmlData, tagName, i){
  const startIndex = i;
  // Starting at 1 since we already have an open tag
  let openTagCount = 1;

  for (; i < xmlData.length; i++) {
    if( xmlData[i] === "<"){ 
      if (xmlData[i+1] === "/") {//close tag
          const closeIndex = findClosingIndex(xmlData, ">", i, `${tagName} is not closed`);
          let closeTagName = xmlData.substring(i+2,closeIndex).trim();
          if(closeTagName === tagName){
            openTagCount--;
            if (openTagCount === 0) {
              return {
                tagContent: xmlData.substring(startIndex, i),
                i : closeIndex
              }
            }
          }
          i=closeIndex;
        } else if(xmlData[i+1] === '?') { 
          const closeIndex = findClosingIndex(xmlData, "?>", i+1, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 3) === '!--') { 
          const closeIndex = findClosingIndex(xmlData, "-->", i+3, "StopNode is not closed.")
          i=closeIndex;
        } else if(xmlData.substr(i + 1, 2) === '![') { 
          const closeIndex = findClosingIndex(xmlData, "]]>", i, "StopNode is not closed.") - 2;
          i=closeIndex;
        } else {
          const tagData = readTagExp(xmlData, i, '>')

          if (tagData) {
            const openTagName = tagData && tagData.tagName;
            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== "/") {
              openTagCount++;
            }
            i=tagData.closeIndex;
          }
        }
      }
  }//end for loop
}

function parseValue(val, shouldParse, options) {
  if (shouldParse && typeof val === 'string') {
    //console.log(options)
    const newval = val.trim();
    if(newval === 'true' ) return true;
    else if(newval === 'false' ) return false;
    else return toNumber(val, options);
  } else {
    if (util.isExist(val)) {
      return val;
    } else {
      return '';
    }
  }
}


module.exports = OrderedObjParser;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/XMLParser.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const { buildOptions} = __webpack_require__(/*! ./OptionsBuilder */ "./node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js");
const OrderedObjParser = __webpack_require__(/*! ./OrderedObjParser */ "./node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js");
const { prettify} = __webpack_require__(/*! ./node2json */ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js");
const validator = __webpack_require__(/*! ../validator */ "./node_modules/fast-xml-parser/src/validator.js");

class XMLParser{
    
    constructor(options){
        this.externalEntities = {};
        this.options = buildOptions(options);
        
    }
    /**
     * Parse XML dats to JS object 
     * @param {string|Buffer} xmlData 
     * @param {boolean|Object} validationOption 
     */
    parse(xmlData,validationOption){
        if(typeof xmlData === "string"){
        }else if( xmlData.toString){
            xmlData = xmlData.toString();
        }else{
            throw new Error("XML data is accepted in String or Bytes[] form.")
        }
        if( validationOption){
            if(validationOption === true) validationOption = {}; //validate with default options
            
            const result = validator.validate(xmlData, validationOption);
            if (result !== true) {
              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )
            }
          }
        const orderedObjParser = new OrderedObjParser(this.options);
        orderedObjParser.addExternalEntities(this.externalEntities);
        const orderedResult = orderedObjParser.parseXml(xmlData);
        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;
        else return prettify(orderedResult, this.options);
    }

    /**
     * Add Entity which is not by default supported by this library
     * @param {string} key 
     * @param {string} value 
     */
    addEntity(key, value){
        if(value.indexOf("&") !== -1){
            throw new Error("Entity value can't have '&'")
        }else if(key.indexOf("&") !== -1 || key.indexOf(";") !== -1){
            throw new Error("An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'")
        }else if(value === "&"){
            throw new Error("An entity with value '&' is not permitted");
        }else{
            this.externalEntities[key] = value;
        }
    }
}

module.exports = XMLParser;

/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/node2json.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/node2json.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";


/**
 * 
 * @param {array} node 
 * @param {any} options 
 * @returns 
 */
function prettify(node, options){
  return compress( node, options);
}

/**
 * 
 * @param {array} arr 
 * @param {object} options 
 * @param {string} jPath 
 * @returns object
 */
function compress(arr, options, jPath){
  let text;
  const compressedObj = {};
  for (let i = 0; i < arr.length; i++) {
    const tagObj = arr[i];
    const property = propName(tagObj);
    let newJpath = "";
    if(jPath === undefined) newJpath = property;
    else newJpath = jPath + "." + property;

    if(property === options.textNodeName){
      if(text === undefined) text = tagObj[property];
      else text += "" + tagObj[property];
    }else if(property === undefined){
      continue;
    }else if(tagObj[property]){
      
      let val = compress(tagObj[property], options, newJpath);
      const isLeaf = isLeafTag(val, options);

      if(tagObj[":@"]){
        assignAttributes( val, tagObj[":@"], newJpath, options);
      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){
        val = val[options.textNodeName];
      }else if(Object.keys(val).length === 0){
        if(options.alwaysCreateTextNode) val[options.textNodeName] = "";
        else val = "";
      }

      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {
        if(!Array.isArray(compressedObj[property])) {
            compressedObj[property] = [ compressedObj[property] ];
        }
        compressedObj[property].push(val);
      }else{
        //TODO: if a node is not an array, then check if it should be an array
        //also determine if it is a leaf node
        if (options.isArray(property, newJpath, isLeaf )) {
          compressedObj[property] = [val];
        }else{
          compressedObj[property] = val;
        }
      }
    }
    
  }
  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;
  if(typeof text === "string"){
    if(text.length > 0) compressedObj[options.textNodeName] = text;
  }else if(text !== undefined) compressedObj[options.textNodeName] = text;
  return compressedObj;
}

function propName(obj){
  const keys = Object.keys(obj);
  for (let i = 0; i < keys.length; i++) {
    const key = keys[i];
    if(key !== ":@") return key;
  }
}

function assignAttributes(obj, attrMap, jpath, options){
  if (attrMap) {
    const keys = Object.keys(attrMap);
    const len = keys.length; //don't make it inline
    for (let i = 0; i < len; i++) {
      const atrrName = keys[i];
      if (options.isArray(atrrName, jpath + "." + atrrName, true, true)) {
        obj[atrrName] = [ attrMap[atrrName] ];
      } else {
        obj[atrrName] = attrMap[atrrName];
      }
    }
  }
}

function isLeafTag(obj, options){
  const { textNodeName } = options;
  const propCount = Object.keys(obj).length;
  
  if (propCount === 0) {
    return true;
  }

  if (
    propCount === 1 &&
    (obj[textNodeName] || typeof obj[textNodeName] === "boolean" || obj[textNodeName] === 0)
  ) {
    return true;
  }

  return false;
}
exports.prettify = prettify;


/***/ }),

/***/ "./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js":
/*!***************************************************************!*\
  !*** ./node_modules/fast-xml-parser/src/xmlparser/xmlNode.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


class XmlNode{
  constructor(tagname) {
    this.tagname = tagname;
    this.child = []; //nested tags, text, cdata, comments in order
    this[":@"] = {}; //attributes map
  }
  add(key,val){
    // this.child.push( {name : key, val: val, isCdata: isCdata });
    if(key === "__proto__") key = "#__proto__";
    this.child.push( {[key]: val });
  }
  addChild(node) {
    if(node.tagname === "__proto__") node.tagname = "#__proto__";
    if(node[":@"] && Object.keys(node[":@"]).length > 0){
      this.child.push( { [node.tagname]: node.child, [":@"]: node[":@"] });
    }else{
      this.child.push( { [node.tagname]: node.child });
    }
  };
};


module.exports = XmlNode;

/***/ }),

/***/ "./node_modules/fs.realpath/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs.realpath/index.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = realpath
realpath.realpath = realpath
realpath.sync = realpathSync
realpath.realpathSync = realpathSync
realpath.monkeypatch = monkeypatch
realpath.unmonkeypatch = unmonkeypatch

var fs = __webpack_require__(/*! fs */ "fs")
var origRealpath = fs.realpath
var origRealpathSync = fs.realpathSync

var version = process.version
var ok = /^v[0-5]\./.test(version)
var old = __webpack_require__(/*! ./old.js */ "./node_modules/fs.realpath/old.js")

function newError (er) {
  return er && er.syscall === 'realpath' && (
    er.code === 'ELOOP' ||
    er.code === 'ENOMEM' ||
    er.code === 'ENAMETOOLONG'
  )
}

function realpath (p, cache, cb) {
  if (ok) {
    return origRealpath(p, cache, cb)
  }

  if (typeof cache === 'function') {
    cb = cache
    cache = null
  }
  origRealpath(p, cache, function (er, result) {
    if (newError(er)) {
      old.realpath(p, cache, cb)
    } else {
      cb(er, result)
    }
  })
}

function realpathSync (p, cache) {
  if (ok) {
    return origRealpathSync(p, cache)
  }

  try {
    return origRealpathSync(p, cache)
  } catch (er) {
    if (newError(er)) {
      return old.realpathSync(p, cache)
    } else {
      throw er
    }
  }
}

function monkeypatch () {
  fs.realpath = realpath
  fs.realpathSync = realpathSync
}

function unmonkeypatch () {
  fs.realpath = origRealpath
  fs.realpathSync = origRealpathSync
}


/***/ }),

/***/ "./node_modules/fs.realpath/old.js":
/*!*****************************************!*\
  !*** ./node_modules/fs.realpath/old.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var pathModule = __webpack_require__(/*! path */ "path");
var isWindows = process.platform === 'win32';
var fs = __webpack_require__(/*! fs */ "fs");

// JavaScript implementation of realpath, ported from node pre-v6

var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);

function rethrow() {
  // Only enable in debug mode. A backtrace uses ~1000 bytes of heap space and
  // is fairly slow to generate.
  var callback;
  if (DEBUG) {
    var backtrace = new Error;
    callback = debugCallback;
  } else
    callback = missingCallback;

  return callback;

  function debugCallback(err) {
    if (err) {
      backtrace.message = err.message;
      err = backtrace;
      missingCallback(err);
    }
  }

  function missingCallback(err) {
    if (err) {
      if (process.throwDeprecation)
        throw err;  // Forgot a callback but don't know where? Use NODE_DEBUG=fs
      else if (!process.noDeprecation) {
        var msg = 'fs: missing callback ' + (err.stack || err.message);
        if (process.traceDeprecation)
          console.trace(msg);
        else
          console.error(msg);
      }
    }
  }
}

function maybeCallback(cb) {
  return typeof cb === 'function' ? cb : rethrow();
}

var normalize = pathModule.normalize;

// Regexp that finds the next partion of a (partial) path
// result is [base_with_slash, base], e.g. ['somedir/', 'somedir']
if (isWindows) {
  var nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
} else {
  var nextPartRe = /(.*?)(?:[\/]+|$)/g;
}

// Regex to find the device root, including trailing slash. E.g. 'c:\\'.
if (isWindows) {
  var splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
} else {
  var splitRootRe = /^[\/]*/;
}

exports.realpathSync = function realpathSync(p, cache) {
  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return cache[p];
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstatSync(base);
      knownHard[base] = true;
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  // NB: p.length changes.
  while (pos < p.length) {
    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      continue;
    }

    var resolvedLink;
    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // some known symbolic link.  no need to stat again.
      resolvedLink = cache[base];
    } else {
      var stat = fs.lstatSync(base);
      if (!stat.isSymbolicLink()) {
        knownHard[base] = true;
        if (cache) cache[base] = base;
        continue;
      }

      // read the link if it wasn't read before
      // dev/ino always return 0 on windows, so skip the check.
      var linkTarget = null;
      if (!isWindows) {
        var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
        if (seenLinks.hasOwnProperty(id)) {
          linkTarget = seenLinks[id];
        }
      }
      if (linkTarget === null) {
        fs.statSync(base);
        linkTarget = fs.readlinkSync(base);
      }
      resolvedLink = pathModule.resolve(previous, linkTarget);
      // track this, if given a cache.
      if (cache) cache[base] = resolvedLink;
      if (!isWindows) seenLinks[id] = linkTarget;
    }

    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }

  if (cache) cache[original] = p;

  return p;
};


exports.realpath = function realpath(p, cache, cb) {
  if (typeof cb !== 'function') {
    cb = maybeCallback(cache);
    cache = null;
  }

  // make p is absolute
  p = pathModule.resolve(p);

  if (cache && Object.prototype.hasOwnProperty.call(cache, p)) {
    return process.nextTick(cb.bind(null, null, cache[p]));
  }

  var original = p,
      seenLinks = {},
      knownHard = {};

  // current character position in p
  var pos;
  // the partial path so far, including a trailing slash if any
  var current;
  // the partial path without a trailing slash (except when pointing at a root)
  var base;
  // the partial path scanned in the previous round, with slash
  var previous;

  start();

  function start() {
    // Skip over roots
    var m = splitRootRe.exec(p);
    pos = m[0].length;
    current = m[0];
    base = m[0];
    previous = '';

    // On windows, check that the root exists. On unix there is no need.
    if (isWindows && !knownHard[base]) {
      fs.lstat(base, function(err) {
        if (err) return cb(err);
        knownHard[base] = true;
        LOOP();
      });
    } else {
      process.nextTick(LOOP);
    }
  }

  // walk down the path, swapping out linked pathparts for their real
  // values
  function LOOP() {
    // stop if scanned past end of path
    if (pos >= p.length) {
      if (cache) cache[original] = p;
      return cb(null, p);
    }

    // find the next part
    nextPartRe.lastIndex = pos;
    var result = nextPartRe.exec(p);
    previous = current;
    current += result[0];
    base = previous + result[1];
    pos = nextPartRe.lastIndex;

    // continue if not a symlink
    if (knownHard[base] || (cache && cache[base] === base)) {
      return process.nextTick(LOOP);
    }

    if (cache && Object.prototype.hasOwnProperty.call(cache, base)) {
      // known symbolic link.  no need to stat again.
      return gotResolvedLink(cache[base]);
    }

    return fs.lstat(base, gotStat);
  }

  function gotStat(err, stat) {
    if (err) return cb(err);

    // if not a symlink, skip to the next path part
    if (!stat.isSymbolicLink()) {
      knownHard[base] = true;
      if (cache) cache[base] = base;
      return process.nextTick(LOOP);
    }

    // stat & read the link if not read before
    // call gotTarget as soon as the link target is known
    // dev/ino always return 0 on windows, so skip the check.
    if (!isWindows) {
      var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
      if (seenLinks.hasOwnProperty(id)) {
        return gotTarget(null, seenLinks[id], base);
      }
    }
    fs.stat(base, function(err) {
      if (err) return cb(err);

      fs.readlink(base, function(err, target) {
        if (!isWindows) seenLinks[id] = target;
        gotTarget(err, target);
      });
    });
  }

  function gotTarget(err, target, base) {
    if (err) return cb(err);

    var resolvedLink = pathModule.resolve(previous, target);
    if (cache) cache[base] = resolvedLink;
    gotResolvedLink(resolvedLink);
  }

  function gotResolvedLink(resolvedLink) {
    // resolve the link, then start over
    p = pathModule.resolve(resolvedLink, p.slice(pos));
    start();
  }
};


/***/ }),

/***/ "./node_modules/glob/common.js":
/*!*************************************!*\
  !*** ./node_modules/glob/common.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.setopts = setopts
exports.ownProp = ownProp
exports.makeAbs = makeAbs
exports.finish = finish
exports.mark = mark
exports.isIgnored = isIgnored
exports.childrenIgnored = childrenIgnored

function ownProp (obj, field) {
  return Object.prototype.hasOwnProperty.call(obj, field)
}

var fs = __webpack_require__(/*! fs */ "fs")
var path = __webpack_require__(/*! path */ "path")
var minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./node_modules/path-is-absolute/index.js")
var Minimatch = minimatch.Minimatch

function alphasort (a, b) {
  return a.localeCompare(b, 'en')
}

function setupIgnores (self, options) {
  self.ignore = options.ignore || []

  if (!Array.isArray(self.ignore))
    self.ignore = [self.ignore]

  if (self.ignore.length) {
    self.ignore = self.ignore.map(ignoreMap)
  }
}

// ignore patterns are always in dot:true mode.
function ignoreMap (pattern) {
  var gmatcher = null
  if (pattern.slice(-3) === '/**') {
    var gpattern = pattern.replace(/(\/\*\*)+$/, '')
    gmatcher = new Minimatch(gpattern, { dot: true })
  }

  return {
    matcher: new Minimatch(pattern, { dot: true }),
    gmatcher: gmatcher
  }
}

function setopts (self, pattern, options) {
  if (!options)
    options = {}

  // base-matching: just use globstar for that.
  if (options.matchBase && -1 === pattern.indexOf("/")) {
    if (options.noglobstar) {
      throw new Error("base matching requires globstar")
    }
    pattern = "**/" + pattern
  }

  self.silent = !!options.silent
  self.pattern = pattern
  self.strict = options.strict !== false
  self.realpath = !!options.realpath
  self.realpathCache = options.realpathCache || Object.create(null)
  self.follow = !!options.follow
  self.dot = !!options.dot
  self.mark = !!options.mark
  self.nodir = !!options.nodir
  if (self.nodir)
    self.mark = true
  self.sync = !!options.sync
  self.nounique = !!options.nounique
  self.nonull = !!options.nonull
  self.nosort = !!options.nosort
  self.nocase = !!options.nocase
  self.stat = !!options.stat
  self.noprocess = !!options.noprocess
  self.absolute = !!options.absolute
  self.fs = options.fs || fs

  self.maxLength = options.maxLength || Infinity
  self.cache = options.cache || Object.create(null)
  self.statCache = options.statCache || Object.create(null)
  self.symlinks = options.symlinks || Object.create(null)

  setupIgnores(self, options)

  self.changedCwd = false
  var cwd = process.cwd()
  if (!ownProp(options, "cwd"))
    self.cwd = cwd
  else {
    self.cwd = path.resolve(options.cwd)
    self.changedCwd = self.cwd !== cwd
  }

  self.root = options.root || path.resolve(self.cwd, "/")
  self.root = path.resolve(self.root)
  if (process.platform === "win32")
    self.root = self.root.replace(/\\/g, "/")

  // TODO: is an absolute `cwd` supposed to be resolved against `root`?
  // e.g. { cwd: '/test', root: __dirname } === path.join(__dirname, '/test')
  self.cwdAbs = isAbsolute(self.cwd) ? self.cwd : makeAbs(self, self.cwd)
  if (process.platform === "win32")
    self.cwdAbs = self.cwdAbs.replace(/\\/g, "/")
  self.nomount = !!options.nomount

  // disable comments and negation in Minimatch.
  // Note that they are not supported in Glob itself anyway.
  options.nonegate = true
  options.nocomment = true
  // always treat \ in patterns as escapes, not path separators
  options.allowWindowsEscape = false

  self.minimatch = new Minimatch(pattern, options)
  self.options = self.minimatch.options
}

function finish (self) {
  var nou = self.nounique
  var all = nou ? [] : Object.create(null)

  for (var i = 0, l = self.matches.length; i < l; i ++) {
    var matches = self.matches[i]
    if (!matches || Object.keys(matches).length === 0) {
      if (self.nonull) {
        // do like the shell, and spit out the literal glob
        var literal = self.minimatch.globSet[i]
        if (nou)
          all.push(literal)
        else
          all[literal] = true
      }
    } else {
      // had matches
      var m = Object.keys(matches)
      if (nou)
        all.push.apply(all, m)
      else
        m.forEach(function (m) {
          all[m] = true
        })
    }
  }

  if (!nou)
    all = Object.keys(all)

  if (!self.nosort)
    all = all.sort(alphasort)

  // at *some* point we statted all of these
  if (self.mark) {
    for (var i = 0; i < all.length; i++) {
      all[i] = self._mark(all[i])
    }
    if (self.nodir) {
      all = all.filter(function (e) {
        var notDir = !(/\/$/.test(e))
        var c = self.cache[e] || self.cache[makeAbs(self, e)]
        if (notDir && c)
          notDir = c !== 'DIR' && !Array.isArray(c)
        return notDir
      })
    }
  }

  if (self.ignore.length)
    all = all.filter(function(m) {
      return !isIgnored(self, m)
    })

  self.found = all
}

function mark (self, p) {
  var abs = makeAbs(self, p)
  var c = self.cache[abs]
  var m = p
  if (c) {
    var isDir = c === 'DIR' || Array.isArray(c)
    var slash = p.slice(-1) === '/'

    if (isDir && !slash)
      m += '/'
    else if (!isDir && slash)
      m = m.slice(0, -1)

    if (m !== p) {
      var mabs = makeAbs(self, m)
      self.statCache[mabs] = self.statCache[abs]
      self.cache[mabs] = self.cache[abs]
    }
  }

  return m
}

// lotta situps...
function makeAbs (self, f) {
  var abs = f
  if (f.charAt(0) === '/') {
    abs = path.join(self.root, f)
  } else if (isAbsolute(f) || f === '') {
    abs = f
  } else if (self.changedCwd) {
    abs = path.resolve(self.cwd, f)
  } else {
    abs = path.resolve(f)
  }

  if (process.platform === 'win32')
    abs = abs.replace(/\\/g, '/')

  return abs
}


// Return true, if pattern ends with globstar '**', for the accompanying parent directory.
// Ex:- If node_modules/** is the pattern, add 'node_modules' to ignore list along with it's contents
function isIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return item.matcher.match(path) || !!(item.gmatcher && item.gmatcher.match(path))
  })
}

function childrenIgnored (self, path) {
  if (!self.ignore.length)
    return false

  return self.ignore.some(function(item) {
    return !!(item.gmatcher && item.gmatcher.match(path))
  })
}


/***/ }),

/***/ "./node_modules/glob/glob.js":
/*!***********************************!*\
  !*** ./node_modules/glob/glob.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Approach:
//
// 1. Get the minimatch set
// 2. For each pattern in the set, PROCESS(pattern, false)
// 3. Store matches per-set, then uniq them
//
// PROCESS(pattern, inGlobStar)
// Get the first [n] items from pattern that are all strings
// Join these together.  This is PREFIX.
//   If there is no more remaining, then stat(PREFIX) and
//   add to matches if it succeeds.  END.
//
// If inGlobStar and PREFIX is symlink and points to dir
//   set ENTRIES = []
// else readdir(PREFIX) as ENTRIES
//   If fail, END
//
// with ENTRIES
//   If pattern[n] is GLOBSTAR
//     // handle the case where the globstar match is empty
//     // by pruning it out, and testing the resulting pattern
//     PROCESS(pattern[0..n] + pattern[n+1 .. $], false)
//     // handle other cases.
//     for ENTRY in ENTRIES (not dotfiles)
//       // attach globstar + tail onto the entry
//       // Mark that this entry is a globstar match
//       PROCESS(pattern[0..n] + ENTRY + pattern[n .. $], true)
//
//   else // not globstar
//     for ENTRY in ENTRIES (not dotfiles, unless pattern[n] is dot)
//       Test ENTRY against pattern[n]
//       If fails, continue
//       If passes, PROCESS(pattern[0..n] + item + pattern[n+1 .. $])
//
// Caveat:
//   Cache all stats and readdirs results to minimize syscall.  Since all
//   we ever care about is existence and directory-ness, we can just keep
//   `true` for files, and [children,...] for directories, or `false` for
//   things that don't exist.

module.exports = glob

var rp = __webpack_require__(/*! fs.realpath */ "./node_modules/fs.realpath/index.js")
var minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js")
var Minimatch = minimatch.Minimatch
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits.js")
var EE = (__webpack_require__(/*! events */ "events").EventEmitter)
var path = __webpack_require__(/*! path */ "path")
var assert = __webpack_require__(/*! assert */ "assert")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./node_modules/path-is-absolute/index.js")
var globSync = __webpack_require__(/*! ./sync.js */ "./node_modules/glob/sync.js")
var common = __webpack_require__(/*! ./common.js */ "./node_modules/glob/common.js")
var setopts = common.setopts
var ownProp = common.ownProp
var inflight = __webpack_require__(/*! inflight */ "./node_modules/inflight/inflight.js")
var util = __webpack_require__(/*! util */ "util")
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

var once = __webpack_require__(/*! once */ "./node_modules/once/once.js")

function glob (pattern, options, cb) {
  if (typeof options === 'function') cb = options, options = {}
  if (!options) options = {}

  if (options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return globSync(pattern, options)
  }

  return new Glob(pattern, options, cb)
}

glob.sync = globSync
var GlobSync = glob.GlobSync = globSync.GlobSync

// old api surface
glob.glob = glob

function extend (origin, add) {
  if (add === null || typeof add !== 'object') {
    return origin
  }

  var keys = Object.keys(add)
  var i = keys.length
  while (i--) {
    origin[keys[i]] = add[keys[i]]
  }
  return origin
}

glob.hasMagic = function (pattern, options_) {
  var options = extend({}, options_)
  options.noprocess = true

  var g = new Glob(pattern, options)
  var set = g.minimatch.set

  if (!pattern)
    return false

  if (set.length > 1)
    return true

  for (var j = 0; j < set[0].length; j++) {
    if (typeof set[0][j] !== 'string')
      return true
  }

  return false
}

glob.Glob = Glob
inherits(Glob, EE)
function Glob (pattern, options, cb) {
  if (typeof options === 'function') {
    cb = options
    options = null
  }

  if (options && options.sync) {
    if (cb)
      throw new TypeError('callback provided to sync glob')
    return new GlobSync(pattern, options)
  }

  if (!(this instanceof Glob))
    return new Glob(pattern, options, cb)

  setopts(this, pattern, options)
  this._didRealPath = false

  // process each pattern in the minimatch set
  var n = this.minimatch.set.length

  // The matches are stored as {<filename>: true,...} so that
  // duplicates are automagically pruned.
  // Later, we do an Object.keys() on these.
  // Keep them as a list so we can fill in when nonull is set.
  this.matches = new Array(n)

  if (typeof cb === 'function') {
    cb = once(cb)
    this.on('error', cb)
    this.on('end', function (matches) {
      cb(null, matches)
    })
  }

  var self = this
  this._processing = 0

  this._emitQueue = []
  this._processQueue = []
  this.paused = false

  if (this.noprocess)
    return this

  if (n === 0)
    return done()

  var sync = true
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false, done)
  }
  sync = false

  function done () {
    --self._processing
    if (self._processing <= 0) {
      if (sync) {
        process.nextTick(function () {
          self._finish()
        })
      } else {
        self._finish()
      }
    }
  }
}

Glob.prototype._finish = function () {
  assert(this instanceof Glob)
  if (this.aborted)
    return

  if (this.realpath && !this._didRealpath)
    return this._realpath()

  common.finish(this)
  this.emit('end', this.found)
}

Glob.prototype._realpath = function () {
  if (this._didRealpath)
    return

  this._didRealpath = true

  var n = this.matches.length
  if (n === 0)
    return this._finish()

  var self = this
  for (var i = 0; i < this.matches.length; i++)
    this._realpathSet(i, next)

  function next () {
    if (--n === 0)
      self._finish()
  }
}

Glob.prototype._realpathSet = function (index, cb) {
  var matchset = this.matches[index]
  if (!matchset)
    return cb()

  var found = Object.keys(matchset)
  var self = this
  var n = found.length

  if (n === 0)
    return cb()

  var set = this.matches[index] = Object.create(null)
  found.forEach(function (p, i) {
    // If there's a problem with the stat, then it means that
    // one or more of the links in the realpath couldn't be
    // resolved.  just return the abs value in that case.
    p = self._makeAbs(p)
    rp.realpath(p, self.realpathCache, function (er, real) {
      if (!er)
        set[real] = true
      else if (er.syscall === 'stat')
        set[p] = true
      else
        self.emit('error', er) // srsly wtf right here

      if (--n === 0) {
        self.matches[index] = set
        cb()
      }
    })
  })
}

Glob.prototype._mark = function (p) {
  return common.mark(this, p)
}

Glob.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}

Glob.prototype.abort = function () {
  this.aborted = true
  this.emit('abort')
}

Glob.prototype.pause = function () {
  if (!this.paused) {
    this.paused = true
    this.emit('pause')
  }
}

Glob.prototype.resume = function () {
  if (this.paused) {
    this.emit('resume')
    this.paused = false
    if (this._emitQueue.length) {
      var eq = this._emitQueue.slice(0)
      this._emitQueue.length = 0
      for (var i = 0; i < eq.length; i ++) {
        var e = eq[i]
        this._emitMatch(e[0], e[1])
      }
    }
    if (this._processQueue.length) {
      var pq = this._processQueue.slice(0)
      this._processQueue.length = 0
      for (var i = 0; i < pq.length; i ++) {
        var p = pq[i]
        this._processing--
        this._process(p[0], p[1], p[2], p[3])
      }
    }
  }
}

Glob.prototype._process = function (pattern, index, inGlobStar, cb) {
  assert(this instanceof Glob)
  assert(typeof cb === 'function')

  if (this.aborted)
    return

  this._processing++
  if (this.paused) {
    this._processQueue.push([pattern, index, inGlobStar, cb])
    return
  }

  //console.error('PROCESS %d', this._processing, pattern)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // see if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index, cb)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) ||
      isAbsolute(pattern.map(function (p) {
        return typeof p === 'string' ? p : '[*]'
      }).join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip _processing
  if (childrenIgnored(this, read))
    return cb()

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar, cb)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar, cb)
}

Glob.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    return self._processReaddir2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}

Glob.prototype._processReaddir2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return cb()

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  //console.error('prd2', prefix, entries, remain[0]._glob, matchedEntries)

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return cb()

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return cb()
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix) {
      if (prefix !== '/')
        e = prefix + '/' + e
      else
        e = prefix + e
    }
    this._process([e].concat(remain), index, inGlobStar, cb)
  }
  cb()
}

Glob.prototype._emitMatch = function (index, e) {
  if (this.aborted)
    return

  if (isIgnored(this, e))
    return

  if (this.paused) {
    this._emitQueue.push([index, e])
    return
  }

  var abs = isAbsolute(e) ? e : this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute)
    e = abs

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  var st = this.statCache[abs]
  if (st)
    this.emit('stat', e, st)

  this.emit('match', e)
}

Glob.prototype._readdirInGlobStar = function (abs, cb) {
  if (this.aborted)
    return

  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false, cb)

  var lstatkey = 'lstat\0' + abs
  var self = this
  var lstatcb = inflight(lstatkey, lstatcb_)

  if (lstatcb)
    self.fs.lstat(abs, lstatcb)

  function lstatcb_ (er, lstat) {
    if (er && er.code === 'ENOENT')
      return cb()

    var isSym = lstat && lstat.isSymbolicLink()
    self.symlinks[abs] = isSym

    // If it's not a symlink or a dir, then it's definitely a regular file.
    // don't bother doing a readdir in that case.
    if (!isSym && lstat && !lstat.isDirectory()) {
      self.cache[abs] = 'FILE'
      cb()
    } else
      self._readdir(abs, false, cb)
  }
}

Glob.prototype._readdir = function (abs, inGlobStar, cb) {
  if (this.aborted)
    return

  cb = inflight('readdir\0'+abs+'\0'+inGlobStar, cb)
  if (!cb)
    return

  //console.error('RD %j %j', +inGlobStar, abs)
  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs, cb)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return cb()

    if (Array.isArray(c))
      return cb(null, c)
  }

  var self = this
  self.fs.readdir(abs, readdirCb(this, abs, cb))
}

function readdirCb (self, abs, cb) {
  return function (er, entries) {
    if (er)
      self._readdirError(abs, er, cb)
    else
      self._readdirEntries(abs, entries, cb)
  }
}

Glob.prototype._readdirEntries = function (abs, entries, cb) {
  if (this.aborted)
    return

  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries
  return cb(null, entries)
}

Glob.prototype._readdirError = function (f, er, cb) {
  if (this.aborted)
    return

  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        this.emit('error', error)
        this.abort()
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict) {
        this.emit('error', er)
        // If the error is handled, then we abort
        // if not, we threw out of here
        this.abort()
      }
      if (!this.silent)
        console.error('glob error', er)
      break
  }

  return cb()
}

Glob.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar, cb) {
  var self = this
  this._readdir(abs, inGlobStar, function (er, entries) {
    self._processGlobStar2(prefix, read, abs, remain, index, inGlobStar, entries, cb)
  })
}


Glob.prototype._processGlobStar2 = function (prefix, read, abs, remain, index, inGlobStar, entries, cb) {
  //console.error('pgs2', prefix, remain[0], entries)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return cb()

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false, cb)

  var isSym = this.symlinks[abs]
  var len = entries.length

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return cb()

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true, cb)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true, cb)
  }

  cb()
}

Glob.prototype._processSimple = function (prefix, index, cb) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var self = this
  this._stat(prefix, function (er, exists) {
    self._processSimple2(prefix, index, er, exists, cb)
  })
}
Glob.prototype._processSimple2 = function (prefix, index, er, exists, cb) {

  //console.error('ps2', prefix, exists)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return cb()

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
  cb()
}

// Returns either 'DIR', 'FILE', or false
Glob.prototype._stat = function (f, cb) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return cb()

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return cb(null, c)

    if (needDir && c === 'FILE')
      return cb()

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (stat !== undefined) {
    if (stat === false)
      return cb(null, stat)
    else {
      var type = stat.isDirectory() ? 'DIR' : 'FILE'
      if (needDir && type === 'FILE')
        return cb()
      else
        return cb(null, type, stat)
    }
  }

  var self = this
  var statcb = inflight('stat\0' + abs, lstatcb_)
  if (statcb)
    self.fs.lstat(abs, statcb)

  function lstatcb_ (er, lstat) {
    if (lstat && lstat.isSymbolicLink()) {
      // If it's a symlink, then treat it as the target, unless
      // the target does not exist, then treat it as a file.
      return self.fs.stat(abs, function (er, stat) {
        if (er)
          self._stat2(f, abs, null, lstat, cb)
        else
          self._stat2(f, abs, er, stat, cb)
      })
    } else {
      self._stat2(f, abs, er, lstat, cb)
    }
  }
}

Glob.prototype._stat2 = function (f, abs, er, stat, cb) {
  if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
    this.statCache[abs] = false
    return cb()
  }

  var needDir = f.slice(-1) === '/'
  this.statCache[abs] = stat

  if (abs.slice(-1) === '/' && stat && !stat.isDirectory())
    return cb(null, false, stat)

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'
  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return cb()

  return cb(null, c, stat)
}


/***/ }),

/***/ "./node_modules/glob/sync.js":
/*!***********************************!*\
  !*** ./node_modules/glob/sync.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = globSync
globSync.GlobSync = GlobSync

var rp = __webpack_require__(/*! fs.realpath */ "./node_modules/fs.realpath/index.js")
var minimatch = __webpack_require__(/*! minimatch */ "./node_modules/minimatch/minimatch.js")
var Minimatch = minimatch.Minimatch
var Glob = (__webpack_require__(/*! ./glob.js */ "./node_modules/glob/glob.js").Glob)
var util = __webpack_require__(/*! util */ "util")
var path = __webpack_require__(/*! path */ "path")
var assert = __webpack_require__(/*! assert */ "assert")
var isAbsolute = __webpack_require__(/*! path-is-absolute */ "./node_modules/path-is-absolute/index.js")
var common = __webpack_require__(/*! ./common.js */ "./node_modules/glob/common.js")
var setopts = common.setopts
var ownProp = common.ownProp
var childrenIgnored = common.childrenIgnored
var isIgnored = common.isIgnored

function globSync (pattern, options) {
  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  return new GlobSync(pattern, options).found
}

function GlobSync (pattern, options) {
  if (!pattern)
    throw new Error('must provide pattern')

  if (typeof options === 'function' || arguments.length === 3)
    throw new TypeError('callback provided to sync glob\n'+
                        'See: https://github.com/isaacs/node-glob/issues/167')

  if (!(this instanceof GlobSync))
    return new GlobSync(pattern, options)

  setopts(this, pattern, options)

  if (this.noprocess)
    return this

  var n = this.minimatch.set.length
  this.matches = new Array(n)
  for (var i = 0; i < n; i ++) {
    this._process(this.minimatch.set[i], i, false)
  }
  this._finish()
}

GlobSync.prototype._finish = function () {
  assert.ok(this instanceof GlobSync)
  if (this.realpath) {
    var self = this
    this.matches.forEach(function (matchset, index) {
      var set = self.matches[index] = Object.create(null)
      for (var p in matchset) {
        try {
          p = self._makeAbs(p)
          var real = rp.realpathSync(p, self.realpathCache)
          set[real] = true
        } catch (er) {
          if (er.syscall === 'stat')
            set[self._makeAbs(p)] = true
          else
            throw er
        }
      }
    })
  }
  common.finish(this)
}


GlobSync.prototype._process = function (pattern, index, inGlobStar) {
  assert.ok(this instanceof GlobSync)

  // Get the first [n] parts of pattern that are all strings.
  var n = 0
  while (typeof pattern[n] === 'string') {
    n ++
  }
  // now n is the index of the first one that is *not* a string.

  // See if there's anything else
  var prefix
  switch (n) {
    // if not, then this is rather simple
    case pattern.length:
      this._processSimple(pattern.join('/'), index)
      return

    case 0:
      // pattern *starts* with some non-trivial item.
      // going to readdir(cwd), but not include the prefix in matches.
      prefix = null
      break

    default:
      // pattern has some string bits in the front.
      // whatever it starts with, whether that's 'absolute' like /foo/bar,
      // or 'relative' like '../baz'
      prefix = pattern.slice(0, n).join('/')
      break
  }

  var remain = pattern.slice(n)

  // get the list of entries.
  var read
  if (prefix === null)
    read = '.'
  else if (isAbsolute(prefix) ||
      isAbsolute(pattern.map(function (p) {
        return typeof p === 'string' ? p : '[*]'
      }).join('/'))) {
    if (!prefix || !isAbsolute(prefix))
      prefix = '/' + prefix
    read = prefix
  } else
    read = prefix

  var abs = this._makeAbs(read)

  //if ignored, skip processing
  if (childrenIgnored(this, read))
    return

  var isGlobStar = remain[0] === minimatch.GLOBSTAR
  if (isGlobStar)
    this._processGlobStar(prefix, read, abs, remain, index, inGlobStar)
  else
    this._processReaddir(prefix, read, abs, remain, index, inGlobStar)
}


GlobSync.prototype._processReaddir = function (prefix, read, abs, remain, index, inGlobStar) {
  var entries = this._readdir(abs, inGlobStar)

  // if the abs isn't a dir, then nothing can match!
  if (!entries)
    return

  // It will only match dot entries if it starts with a dot, or if
  // dot is set.  Stuff like @(.foo|.bar) isn't allowed.
  var pn = remain[0]
  var negate = !!this.minimatch.negate
  var rawGlob = pn._glob
  var dotOk = this.dot || rawGlob.charAt(0) === '.'

  var matchedEntries = []
  for (var i = 0; i < entries.length; i++) {
    var e = entries[i]
    if (e.charAt(0) !== '.' || dotOk) {
      var m
      if (negate && !prefix) {
        m = !e.match(pn)
      } else {
        m = e.match(pn)
      }
      if (m)
        matchedEntries.push(e)
    }
  }

  var len = matchedEntries.length
  // If there are no matched entries, then nothing matches.
  if (len === 0)
    return

  // if this is the last remaining pattern bit, then no need for
  // an additional stat *unless* the user has specified mark or
  // stat explicitly.  We know they exist, since readdir returned
  // them.

  if (remain.length === 1 && !this.mark && !this.stat) {
    if (!this.matches[index])
      this.matches[index] = Object.create(null)

    for (var i = 0; i < len; i ++) {
      var e = matchedEntries[i]
      if (prefix) {
        if (prefix.slice(-1) !== '/')
          e = prefix + '/' + e
        else
          e = prefix + e
      }

      if (e.charAt(0) === '/' && !this.nomount) {
        e = path.join(this.root, e)
      }
      this._emitMatch(index, e)
    }
    // This was the last one, and no stats were needed
    return
  }

  // now test all matched entries as stand-ins for that part
  // of the pattern.
  remain.shift()
  for (var i = 0; i < len; i ++) {
    var e = matchedEntries[i]
    var newPattern
    if (prefix)
      newPattern = [prefix, e]
    else
      newPattern = [e]
    this._process(newPattern.concat(remain), index, inGlobStar)
  }
}


GlobSync.prototype._emitMatch = function (index, e) {
  if (isIgnored(this, e))
    return

  var abs = this._makeAbs(e)

  if (this.mark)
    e = this._mark(e)

  if (this.absolute) {
    e = abs
  }

  if (this.matches[index][e])
    return

  if (this.nodir) {
    var c = this.cache[abs]
    if (c === 'DIR' || Array.isArray(c))
      return
  }

  this.matches[index][e] = true

  if (this.stat)
    this._stat(e)
}


GlobSync.prototype._readdirInGlobStar = function (abs) {
  // follow all symlinked directories forever
  // just proceed as if this is a non-globstar situation
  if (this.follow)
    return this._readdir(abs, false)

  var entries
  var lstat
  var stat
  try {
    lstat = this.fs.lstatSync(abs)
  } catch (er) {
    if (er.code === 'ENOENT') {
      // lstat failed, doesn't exist
      return null
    }
  }

  var isSym = lstat && lstat.isSymbolicLink()
  this.symlinks[abs] = isSym

  // If it's not a symlink or a dir, then it's definitely a regular file.
  // don't bother doing a readdir in that case.
  if (!isSym && lstat && !lstat.isDirectory())
    this.cache[abs] = 'FILE'
  else
    entries = this._readdir(abs, false)

  return entries
}

GlobSync.prototype._readdir = function (abs, inGlobStar) {
  var entries

  if (inGlobStar && !ownProp(this.symlinks, abs))
    return this._readdirInGlobStar(abs)

  if (ownProp(this.cache, abs)) {
    var c = this.cache[abs]
    if (!c || c === 'FILE')
      return null

    if (Array.isArray(c))
      return c
  }

  try {
    return this._readdirEntries(abs, this.fs.readdirSync(abs))
  } catch (er) {
    this._readdirError(abs, er)
    return null
  }
}

GlobSync.prototype._readdirEntries = function (abs, entries) {
  // if we haven't asked to stat everything, then just
  // assume that everything in there exists, so we can avoid
  // having to stat it a second time.
  if (!this.mark && !this.stat) {
    for (var i = 0; i < entries.length; i ++) {
      var e = entries[i]
      if (abs === '/')
        e = abs + e
      else
        e = abs + '/' + e
      this.cache[e] = true
    }
  }

  this.cache[abs] = entries

  // mark and cache dir-ness
  return entries
}

GlobSync.prototype._readdirError = function (f, er) {
  // handle errors, and cache the information
  switch (er.code) {
    case 'ENOTSUP': // https://github.com/isaacs/node-glob/issues/205
    case 'ENOTDIR': // totally normal. means it *does* exist.
      var abs = this._makeAbs(f)
      this.cache[abs] = 'FILE'
      if (abs === this.cwdAbs) {
        var error = new Error(er.code + ' invalid cwd ' + this.cwd)
        error.path = this.cwd
        error.code = er.code
        throw error
      }
      break

    case 'ENOENT': // not terribly unusual
    case 'ELOOP':
    case 'ENAMETOOLONG':
    case 'UNKNOWN':
      this.cache[this._makeAbs(f)] = false
      break

    default: // some unusual error.  Treat as failure.
      this.cache[this._makeAbs(f)] = false
      if (this.strict)
        throw er
      if (!this.silent)
        console.error('glob error', er)
      break
  }
}

GlobSync.prototype._processGlobStar = function (prefix, read, abs, remain, index, inGlobStar) {

  var entries = this._readdir(abs, inGlobStar)

  // no entries means not a dir, so it can never have matches
  // foo.txt/** doesn't match foo.txt
  if (!entries)
    return

  // test without the globstar, and with every child both below
  // and replacing the globstar.
  var remainWithoutGlobStar = remain.slice(1)
  var gspref = prefix ? [ prefix ] : []
  var noGlobStar = gspref.concat(remainWithoutGlobStar)

  // the noGlobStar pattern exits the inGlobStar state
  this._process(noGlobStar, index, false)

  var len = entries.length
  var isSym = this.symlinks[abs]

  // If it's a symlink, and we're in a globstar, then stop
  if (isSym && inGlobStar)
    return

  for (var i = 0; i < len; i++) {
    var e = entries[i]
    if (e.charAt(0) === '.' && !this.dot)
      continue

    // these two cases enter the inGlobStar state
    var instead = gspref.concat(entries[i], remainWithoutGlobStar)
    this._process(instead, index, true)

    var below = gspref.concat(entries[i], remain)
    this._process(below, index, true)
  }
}

GlobSync.prototype._processSimple = function (prefix, index) {
  // XXX review this.  Shouldn't it be doing the mounting etc
  // before doing stat?  kinda weird?
  var exists = this._stat(prefix)

  if (!this.matches[index])
    this.matches[index] = Object.create(null)

  // If it doesn't exist, then just mark the lack of results
  if (!exists)
    return

  if (prefix && isAbsolute(prefix) && !this.nomount) {
    var trail = /[\/\\]$/.test(prefix)
    if (prefix.charAt(0) === '/') {
      prefix = path.join(this.root, prefix)
    } else {
      prefix = path.resolve(this.root, prefix)
      if (trail)
        prefix += '/'
    }
  }

  if (process.platform === 'win32')
    prefix = prefix.replace(/\\/g, '/')

  // Mark this as a match
  this._emitMatch(index, prefix)
}

// Returns either 'DIR', 'FILE', or false
GlobSync.prototype._stat = function (f) {
  var abs = this._makeAbs(f)
  var needDir = f.slice(-1) === '/'

  if (f.length > this.maxLength)
    return false

  if (!this.stat && ownProp(this.cache, abs)) {
    var c = this.cache[abs]

    if (Array.isArray(c))
      c = 'DIR'

    // It exists, but maybe not how we need it
    if (!needDir || c === 'DIR')
      return c

    if (needDir && c === 'FILE')
      return false

    // otherwise we have to stat, because maybe c=true
    // if we know it exists, but not what it is.
  }

  var exists
  var stat = this.statCache[abs]
  if (!stat) {
    var lstat
    try {
      lstat = this.fs.lstatSync(abs)
    } catch (er) {
      if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
        this.statCache[abs] = false
        return false
      }
    }

    if (lstat && lstat.isSymbolicLink()) {
      try {
        stat = this.fs.statSync(abs)
      } catch (er) {
        stat = lstat
      }
    } else {
      stat = lstat
    }
  }

  this.statCache[abs] = stat

  var c = true
  if (stat)
    c = stat.isDirectory() ? 'DIR' : 'FILE'

  this.cache[abs] = this.cache[abs] || c

  if (needDir && c === 'FILE')
    return false

  return c
}

GlobSync.prototype._mark = function (p) {
  return common.mark(this, p)
}

GlobSync.prototype._makeAbs = function (f) {
  return common.makeAbs(this, f)
}


/***/ }),

/***/ "./node_modules/inflight/inflight.js":
/*!*******************************************!*\
  !*** ./node_modules/inflight/inflight.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
var reqs = Object.create(null)
var once = __webpack_require__(/*! once */ "./node_modules/once/once.js")

module.exports = wrappy(inflight)

function inflight (key, cb) {
  if (reqs[key]) {
    reqs[key].push(cb)
    return null
  } else {
    reqs[key] = [cb]
    return makeres(key)
  }
}

function makeres (key) {
  return once(function RES () {
    var cbs = reqs[key]
    var len = cbs.length
    var args = slice(arguments)

    // XXX It's somewhat ambiguous whether a new callback added in this
    // pass should be queued for later execution if something in the
    // list of callbacks throws, or if it should just be discarded.
    // However, it's such an edge case that it hardly matters, and either
    // choice is likely as surprising as the other.
    // As it happens, we do go ahead and schedule it for later execution.
    try {
      for (var i = 0; i < len; i++) {
        cbs[i].apply(null, args)
      }
    } finally {
      if (cbs.length > len) {
        // added more in the interim.
        // de-zalgo, just in case, but don't call again.
        cbs.splice(0, len)
        process.nextTick(function () {
          RES.apply(null, args)
        })
      } else {
        delete reqs[key]
      }
    }
  })
}

function slice (args) {
  var length = args.length
  var array = []

  for (var i = 0; i < length; i++) array[i] = args[i]
  return array
}


/***/ }),

/***/ "./node_modules/inherits/inherits.js":
/*!*******************************************!*\
  !*** ./node_modules/inherits/inherits.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

try {
  var util = __webpack_require__(/*! util */ "util");
  /* istanbul ignore next */
  if (typeof util.inherits !== 'function') throw '';
  module.exports = util.inherits;
} catch (e) {
  /* istanbul ignore next */
  module.exports = __webpack_require__(/*! ./inherits_browser.js */ "./node_modules/inherits/inherits_browser.js");
}


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/minimatch/minimatch.js":
/*!*********************************************!*\
  !*** ./node_modules/minimatch/minimatch.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = (function () { try { return __webpack_require__(/*! path */ "path") } catch (e) {}}()) || {
  sep: '/'
}
minimatch.sep = path.sep

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = __webpack_require__(/*! brace-expansion */ "./node_modules/brace-expansion/index.js")

var plTypes = {
  '!': { open: '(?:(?!(?:', close: '))[^/]*?)'},
  '?': { open: '(?:', close: ')?' },
  '+': { open: '(?:', close: ')+' },
  '*': { open: '(?:', close: ')*' },
  '@': { open: '(?:', close: ')' }
}

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  b = b || {}
  var t = {}
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || typeof def !== 'object' || !Object.keys(def).length) {
    return minimatch
  }

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }
  m.Minimatch.defaults = function defaults (options) {
    return orig.defaults(ext(def, options)).Minimatch
  }

  m.filter = function filter (pattern, options) {
    return orig.filter(pattern, ext(def, options))
  }

  m.defaults = function defaults (options) {
    return orig.defaults(ext(def, options))
  }

  m.makeRe = function makeRe (pattern, options) {
    return orig.makeRe(pattern, ext(def, options))
  }

  m.braceExpand = function braceExpand (pattern, options) {
    return orig.braceExpand(pattern, ext(def, options))
  }

  m.match = function (list, pattern, options) {
    return orig.match(list, pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  assertValidPattern(pattern)

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  assertValidPattern(pattern)

  if (!options) options = {}

  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (!options.allowWindowsEscape && path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false
  this.partial = !!options.partial

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = function debug() { console.error.apply(console, arguments) }

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  assertValidPattern(pattern)

  // Thanks to Yeting Li <https://github.com/yetingli> for
  // improving this regexp to avoid a ReDOS vulnerability.
  if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

var MAX_PATTERN_LENGTH = 1024 * 64
var assertValidPattern = function (pattern) {
  if (typeof pattern !== 'string') {
    throw new TypeError('invalid pattern')
  }

  if (pattern.length > MAX_PATTERN_LENGTH) {
    throw new TypeError('pattern is too long')
  }
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  assertValidPattern(pattern)

  var options = this.options

  // shortcuts
  if (pattern === '**') {
    if (!options.noglobstar)
      return GLOBSTAR
    else
      pattern = '*'
  }
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var negativeLists = []
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      /* istanbul ignore next */
      case '/': {
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false
      }

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        patternListStack.push({
          type: stateChar,
          start: i - 1,
          reStart: re.length,
          open: plTypes[stateChar].open,
          close: plTypes[stateChar].close
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!(?:' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        var pl = patternListStack.pop()
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        re += pl.close
        if (pl.type === '!') {
          negativeLists.push(pl)
        }
        pl.reEnd = re.length
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        // split where the last [ was, make sure we don't have
        // an invalid re. if so, re-walk the contents of the
        // would-be class to re-translate any characters that
        // were passed through as-is
        // TODO: It would probably be faster to determine this
        // without a try/catch and a new RegExp, but it's tricky
        // to do safely.  For now, this is safe and works.
        var cs = pattern.substring(classStart + 1, i)
        try {
          RegExp('[' + cs + ']')
        } catch (er) {
          // not a valid class!
          var sp = this.parse(cs, SUBPARSE)
          re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
          hasMagic = hasMagic || sp[1]
          inClass = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + pl.open.length)
    this.debug('setting tail', re, pl)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail, pl, re)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '[': case '.': case '(': addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like 'a.xyz.yz' doesn't match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n > -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // "after" the negated section.
    var openParensBefore = nlBefore.split('(').length - 1
    var cleanAfter = nlAfter
    for (i = 0; i < openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, '')
    }
    nlAfter = cleanAfter

    var dollar = ''
    if (nlAfter === '' && isSub !== SUBPARSE) {
      dollar = '$'
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) {
    re = '(?=.)' + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  try {
    var regExp = new RegExp('^' + re + '$', flags)
  } catch (er) /* istanbul ignore next - should be impossible */ {
    // If it was an invalid regular expression, then it can't match
    // anything.  This trick looks for a character after the end of
    // the string, which is of course impossible, except in multi-line
    // mode, but it's not a /m regex.
    return new RegExp('$.')
  }

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) /* istanbul ignore next - should be impossible */ {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = function match (f, partial) {
  if (typeof partial === 'undefined') partial = this.partial
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    /* istanbul ignore if */
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      /* istanbul ignore if */
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      hit = f === p
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else /* istanbul ignore else */ if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    return (fi === fl - 1) && (file[fi] === '')
  }

  // should be unreachable.
  /* istanbul ignore next */
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}


/***/ }),

/***/ "./node_modules/minimist/index.js":
/*!****************************************!*\
  !*** ./node_modules/minimist/index.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";


function hasKey(obj, keys) {
	var o = obj;
	keys.slice(0, -1).forEach(function (key) {
		o = o[key] || {};
	});

	var key = keys[keys.length - 1];
	return key in o;
}

function isNumber(x) {
	if (typeof x === 'number') { return true; }
	if ((/^0x[0-9a-f]+$/i).test(x)) { return true; }
	return (/^[-+]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/).test(x);
}

function isConstructorOrProto(obj, key) {
	return (key === 'constructor' && typeof obj[key] === 'function') || key === '__proto__';
}

module.exports = function (args, opts) {
	if (!opts) { opts = {}; }

	var flags = {
		bools: {},
		strings: {},
		unknownFn: null,
	};

	if (typeof opts.unknown === 'function') {
		flags.unknownFn = opts.unknown;
	}

	if (typeof opts.boolean === 'boolean' && opts.boolean) {
		flags.allBools = true;
	} else {
		[].concat(opts.boolean).filter(Boolean).forEach(function (key) {
			flags.bools[key] = true;
		});
	}

	var aliases = {};

	function aliasIsBoolean(key) {
		return aliases[key].some(function (x) {
			return flags.bools[x];
		});
	}

	Object.keys(opts.alias || {}).forEach(function (key) {
		aliases[key] = [].concat(opts.alias[key]);
		aliases[key].forEach(function (x) {
			aliases[x] = [key].concat(aliases[key].filter(function (y) {
				return x !== y;
			}));
		});
	});

	[].concat(opts.string).filter(Boolean).forEach(function (key) {
		flags.strings[key] = true;
		if (aliases[key]) {
			[].concat(aliases[key]).forEach(function (k) {
				flags.strings[k] = true;
			});
		}
	});

	var defaults = opts.default || {};

	var argv = { _: [] };

	function argDefined(key, arg) {
		return (flags.allBools && (/^--[^=]+$/).test(arg))
			|| flags.strings[key]
			|| flags.bools[key]
			|| aliases[key];
	}

	function setKey(obj, keys, value) {
		var o = obj;
		for (var i = 0; i < keys.length - 1; i++) {
			var key = keys[i];
			if (isConstructorOrProto(o, key)) { return; }
			if (o[key] === undefined) { o[key] = {}; }
			if (
				o[key] === Object.prototype
				|| o[key] === Number.prototype
				|| o[key] === String.prototype
			) {
				o[key] = {};
			}
			if (o[key] === Array.prototype) { o[key] = []; }
			o = o[key];
		}

		var lastKey = keys[keys.length - 1];
		if (isConstructorOrProto(o, lastKey)) { return; }
		if (
			o === Object.prototype
			|| o === Number.prototype
			|| o === String.prototype
		) {
			o = {};
		}
		if (o === Array.prototype) { o = []; }
		if (o[lastKey] === undefined || flags.bools[lastKey] || typeof o[lastKey] === 'boolean') {
			o[lastKey] = value;
		} else if (Array.isArray(o[lastKey])) {
			o[lastKey].push(value);
		} else {
			o[lastKey] = [o[lastKey], value];
		}
	}

	function setArg(key, val, arg) {
		if (arg && flags.unknownFn && !argDefined(key, arg)) {
			if (flags.unknownFn(arg) === false) { return; }
		}

		var value = !flags.strings[key] && isNumber(val)
			? Number(val)
			: val;
		setKey(argv, key.split('.'), value);

		(aliases[key] || []).forEach(function (x) {
			setKey(argv, x.split('.'), value);
		});
	}

	Object.keys(flags.bools).forEach(function (key) {
		setArg(key, defaults[key] === undefined ? false : defaults[key]);
	});

	var notFlags = [];

	if (args.indexOf('--') !== -1) {
		notFlags = args.slice(args.indexOf('--') + 1);
		args = args.slice(0, args.indexOf('--'));
	}

	for (var i = 0; i < args.length; i++) {
		var arg = args[i];
		var key;
		var next;

		if ((/^--.+=/).test(arg)) {
			// Using [\s\S] instead of . because js doesn't support the
			// 'dotall' regex modifier. See:
			// http://stackoverflow.com/a/1068308/13216
			var m = arg.match(/^--([^=]+)=([\s\S]*)$/);
			key = m[1];
			var value = m[2];
			if (flags.bools[key]) {
				value = value !== 'false';
			}
			setArg(key, value, arg);
		} else if ((/^--no-.+/).test(arg)) {
			key = arg.match(/^--no-(.+)/)[1];
			setArg(key, false, arg);
		} else if ((/^--.+/).test(arg)) {
			key = arg.match(/^--(.+)/)[1];
			next = args[i + 1];
			if (
				next !== undefined
				&& !(/^(-|--)[^-]/).test(next)
				&& !flags.bools[key]
				&& !flags.allBools
				&& (aliases[key] ? !aliasIsBoolean(key) : true)
			) {
				setArg(key, next, arg);
				i += 1;
			} else if ((/^(true|false)$/).test(next)) {
				setArg(key, next === 'true', arg);
				i += 1;
			} else {
				setArg(key, flags.strings[key] ? '' : true, arg);
			}
		} else if ((/^-[^-]+/).test(arg)) {
			var letters = arg.slice(1, -1).split('');

			var broken = false;
			for (var j = 0; j < letters.length; j++) {
				next = arg.slice(j + 2);

				if (next === '-') {
					setArg(letters[j], next, arg);
					continue;
				}

				if ((/[A-Za-z]/).test(letters[j]) && next[0] === '=') {
					setArg(letters[j], next.slice(1), arg);
					broken = true;
					break;
				}

				if (
					(/[A-Za-z]/).test(letters[j])
					&& (/-?\d+(\.\d*)?(e-?\d+)?$/).test(next)
				) {
					setArg(letters[j], next, arg);
					broken = true;
					break;
				}

				if (letters[j + 1] && letters[j + 1].match(/\W/)) {
					setArg(letters[j], arg.slice(j + 2), arg);
					broken = true;
					break;
				} else {
					setArg(letters[j], flags.strings[letters[j]] ? '' : true, arg);
				}
			}

			key = arg.slice(-1)[0];
			if (!broken && key !== '-') {
				if (
					args[i + 1]
					&& !(/^(-|--)[^-]/).test(args[i + 1])
					&& !flags.bools[key]
					&& (aliases[key] ? !aliasIsBoolean(key) : true)
				) {
					setArg(key, args[i + 1], arg);
					i += 1;
				} else if (args[i + 1] && (/^(true|false)$/).test(args[i + 1])) {
					setArg(key, args[i + 1] === 'true', arg);
					i += 1;
				} else {
					setArg(key, flags.strings[key] ? '' : true, arg);
				}
			}
		} else {
			if (!flags.unknownFn || flags.unknownFn(arg) !== false) {
				argv._.push(flags.strings._ || !isNumber(arg) ? arg : Number(arg));
			}
			if (opts.stopEarly) {
				argv._.push.apply(argv._, args.slice(i + 1));
				break;
			}
		}
	}

	Object.keys(defaults).forEach(function (k) {
		if (!hasKey(argv, k.split('.'))) {
			setKey(argv, k.split('.'), defaults[k]);

			(aliases[k] || []).forEach(function (x) {
				setKey(argv, x.split('.'), defaults[k]);
			});
		}
	});

	if (opts['--']) {
		argv['--'] = notFlags.slice();
	} else {
		notFlags.forEach(function (k) {
			argv._.push(k);
		});
	}

	return argv;
};


/***/ }),

/***/ "./node_modules/once/once.js":
/*!***********************************!*\
  !*** ./node_modules/once/once.js ***!
  \***********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var wrappy = __webpack_require__(/*! wrappy */ "./node_modules/wrappy/wrappy.js")
module.exports = wrappy(once)
module.exports.strict = wrappy(onceStrict)

once.proto = once(function () {
  Object.defineProperty(Function.prototype, 'once', {
    value: function () {
      return once(this)
    },
    configurable: true
  })

  Object.defineProperty(Function.prototype, 'onceStrict', {
    value: function () {
      return onceStrict(this)
    },
    configurable: true
  })
})

function once (fn) {
  var f = function () {
    if (f.called) return f.value
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  f.called = false
  return f
}

function onceStrict (fn) {
  var f = function () {
    if (f.called)
      throw new Error(f.onceError)
    f.called = true
    return f.value = fn.apply(this, arguments)
  }
  var name = fn.name || 'Function wrapped with `once`'
  f.onceError = name + " shouldn't be called more than once"
  f.called = false
  return f
}


/***/ }),

/***/ "./node_modules/path-is-absolute/index.js":
/*!************************************************!*\
  !*** ./node_modules/path-is-absolute/index.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";


function posix(path) {
	return path.charAt(0) === '/';
}

function win32(path) {
	// https://github.com/nodejs/node/blob/b3fcc245fb25539909ef1d5eaa01dbf92e168633/lib/path.js#L56
	var splitDeviceRe = /^([a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?([\\\/])?([\s\S]*?)$/;
	var result = splitDeviceRe.exec(path);
	var device = result[1] || '';
	var isUnc = Boolean(device && device.charAt(1) !== ':');

	// UNC paths are always absolute
	return Boolean(result[2] || isUnc);
}

module.exports = process.platform === 'win32' ? win32 : posix;
module.exports.posix = posix;
module.exports.win32 = win32;


/***/ }),

/***/ "./node_modules/progress/index.js":
/*!****************************************!*\
  !*** ./node_modules/progress/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/node-progress */ "./node_modules/progress/lib/node-progress.js");


/***/ }),

/***/ "./node_modules/progress/lib/node-progress.js":
/*!****************************************************!*\
  !*** ./node_modules/progress/lib/node-progress.js ***!
  \****************************************************/
/***/ ((module, exports) => {

/*!
 * node-progress
 * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>
 * MIT Licensed
 */

/**
 * Expose `ProgressBar`.
 */

exports = module.exports = ProgressBar;

/**
 * Initialize a `ProgressBar` with the given `fmt` string and `options` or
 * `total`.
 *
 * Options:
 *
 *   - `curr` current completed index
 *   - `total` total number of ticks to complete
 *   - `width` the displayed width of the progress bar defaulting to total
 *   - `stream` the output stream defaulting to stderr
 *   - `head` head character defaulting to complete character
 *   - `complete` completion character defaulting to "="
 *   - `incomplete` incomplete character defaulting to "-"
 *   - `renderThrottle` minimum time between updates in milliseconds defaulting to 16
 *   - `callback` optional function to call when the progress bar completes
 *   - `clear` will clear the progress bar upon termination
 *
 * Tokens:
 *
 *   - `:bar` the progress bar itself
 *   - `:current` current tick number
 *   - `:total` total ticks
 *   - `:elapsed` time elapsed in seconds
 *   - `:percent` completion percentage
 *   - `:eta` eta in seconds
 *   - `:rate` rate of ticks per second
 *
 * @param {string} fmt
 * @param {object|number} options or total
 * @api public
 */

function ProgressBar(fmt, options) {
  this.stream = options.stream || process.stderr;

  if (typeof(options) == 'number') {
    var total = options;
    options = {};
    options.total = total;
  } else {
    options = options || {};
    if ('string' != typeof fmt) throw new Error('format required');
    if ('number' != typeof options.total) throw new Error('total required');
  }

  this.fmt = fmt;
  this.curr = options.curr || 0;
  this.total = options.total;
  this.width = options.width || this.total;
  this.clear = options.clear
  this.chars = {
    complete   : options.complete || '=',
    incomplete : options.incomplete || '-',
    head       : options.head || (options.complete || '=')
  };
  this.renderThrottle = options.renderThrottle !== 0 ? (options.renderThrottle || 16) : 0;
  this.lastRender = -Infinity;
  this.callback = options.callback || function () {};
  this.tokens = {};
  this.lastDraw = '';
}

/**
 * "tick" the progress bar with optional `len` and optional `tokens`.
 *
 * @param {number|object} len or tokens
 * @param {object} tokens
 * @api public
 */

ProgressBar.prototype.tick = function(len, tokens){
  if (len !== 0)
    len = len || 1;

  // swap tokens
  if ('object' == typeof len) tokens = len, len = 1;
  if (tokens) this.tokens = tokens;

  // start time for eta
  if (0 == this.curr) this.start = new Date;

  this.curr += len

  // try to render
  this.render();

  // progress complete
  if (this.curr >= this.total) {
    this.render(undefined, true);
    this.complete = true;
    this.terminate();
    this.callback(this);
    return;
  }
};

/**
 * Method to render the progress bar with optional `tokens` to place in the
 * progress bar's `fmt` field.
 *
 * @param {object} tokens
 * @api public
 */

ProgressBar.prototype.render = function (tokens, force) {
  force = force !== undefined ? force : false;
  if (tokens) this.tokens = tokens;

  if (!this.stream.isTTY) return;

  var now = Date.now();
  var delta = now - this.lastRender;
  if (!force && (delta < this.renderThrottle)) {
    return;
  } else {
    this.lastRender = now;
  }

  var ratio = this.curr / this.total;
  ratio = Math.min(Math.max(ratio, 0), 1);

  var percent = Math.floor(ratio * 100);
  var incomplete, complete, completeLength;
  var elapsed = new Date - this.start;
  var eta = (percent == 100) ? 0 : elapsed * (this.total / this.curr - 1);
  var rate = this.curr / (elapsed / 1000);

  /* populate the bar template with percentages and timestamps */
  var str = this.fmt
    .replace(':current', this.curr)
    .replace(':total', this.total)
    .replace(':elapsed', isNaN(elapsed) ? '0.0' : (elapsed / 1000).toFixed(1))
    .replace(':eta', (isNaN(eta) || !isFinite(eta)) ? '0.0' : (eta / 1000)
      .toFixed(1))
    .replace(':percent', percent.toFixed(0) + '%')
    .replace(':rate', Math.round(rate));

  /* compute the available space (non-zero) for the bar */
  var availableSpace = Math.max(0, this.stream.columns - str.replace(':bar', '').length);
  if(availableSpace && process.platform === 'win32'){
    availableSpace = availableSpace - 1;
  }

  var width = Math.min(this.width, availableSpace);

  /* TODO: the following assumes the user has one ':bar' token */
  completeLength = Math.round(width * ratio);
  complete = Array(Math.max(0, completeLength + 1)).join(this.chars.complete);
  incomplete = Array(Math.max(0, width - completeLength + 1)).join(this.chars.incomplete);

  /* add head to the complete string */
  if(completeLength > 0)
    complete = complete.slice(0, -1) + this.chars.head;

  /* fill in the actual progress bar */
  str = str.replace(':bar', complete + incomplete);

  /* replace the extra tokens */
  if (this.tokens) for (var key in this.tokens) str = str.replace(':' + key, this.tokens[key]);

  if (this.lastDraw !== str) {
    this.stream.cursorTo(0);
    this.stream.write(str);
    this.stream.clearLine(1);
    this.lastDraw = str;
  }
};

/**
 * "update" the progress bar to represent an exact percentage.
 * The ratio (between 0 and 1) specified will be multiplied by `total` and
 * floored, representing the closest available "tick." For example, if a
 * progress bar has a length of 3 and `update(0.5)` is called, the progress
 * will be set to 1.
 *
 * A ratio of 0.5 will attempt to set the progress to halfway.
 *
 * @param {number} ratio The ratio (between 0 and 1 inclusive) to set the
 *   overall completion to.
 * @api public
 */

ProgressBar.prototype.update = function (ratio, tokens) {
  var goal = Math.floor(ratio * this.total);
  var delta = goal - this.curr;

  this.tick(delta, tokens);
};

/**
 * "interrupt" the progress bar and write a message above it.
 * @param {string} message The message to write.
 * @api public
 */

ProgressBar.prototype.interrupt = function (message) {
  // clear the current line
  this.stream.clearLine();
  // move the cursor to the start of the line
  this.stream.cursorTo(0);
  // write the message text
  this.stream.write(message);
  // terminate the line after writing the message
  this.stream.write('\n');
  // re-display the progress bar with its lastDraw
  this.stream.write(this.lastDraw);
};

/**
 * Terminates a progress bar.
 *
 * @api public
 */

ProgressBar.prototype.terminate = function () {
  if (this.clear) {
    if (this.stream.clearLine) {
      this.stream.clearLine();
      this.stream.cursorTo(0);
    }
  } else {
    this.stream.write('\n');
  }
};


/***/ }),

/***/ "./node_modules/sax/lib/sax.js":
/*!*************************************!*\
  !*** ./node_modules/sax/lib/sax.js ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

;(function (sax) { // wrapper for non-node envs
  sax.parser = function (strict, opt) { return new SAXParser(strict, opt) }
  sax.SAXParser = SAXParser
  sax.SAXStream = SAXStream
  sax.createStream = createStream

  // When we pass the MAX_BUFFER_LENGTH position, start checking for buffer overruns.
  // When we check, schedule the next check for MAX_BUFFER_LENGTH - (max(buffer lengths)),
  // since that's the earliest that a buffer overrun could occur.  This way, checks are
  // as rare as required, but as often as necessary to ensure never crossing this bound.
  // Furthermore, buffers are only tested at most once per write(), so passing a very
  // large string into write() might have undesirable effects, but this is manageable by
  // the caller, so it is assumed to be safe.  Thus, a call to write() may, in the extreme
  // edge case, result in creating at most one complete copy of the string passed in.
  // Set to Infinity to have unlimited buffers.
  sax.MAX_BUFFER_LENGTH = 64 * 1024

  var buffers = [
    'comment', 'sgmlDecl', 'textNode', 'tagName', 'doctype',
    'procInstName', 'procInstBody', 'entity', 'attribName',
    'attribValue', 'cdata', 'script'
  ]

  sax.EVENTS = [
    'text',
    'processinginstruction',
    'sgmldeclaration',
    'doctype',
    'comment',
    'opentagstart',
    'attribute',
    'opentag',
    'closetag',
    'opencdata',
    'cdata',
    'closecdata',
    'error',
    'end',
    'ready',
    'script',
    'opennamespace',
    'closenamespace'
  ]

  function SAXParser (strict, opt) {
    if (!(this instanceof SAXParser)) {
      return new SAXParser(strict, opt)
    }

    var parser = this
    clearBuffers(parser)
    parser.q = parser.c = ''
    parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH
    parser.opt = opt || {}
    parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags
    parser.looseCase = parser.opt.lowercase ? 'toLowerCase' : 'toUpperCase'
    parser.tags = []
    parser.closed = parser.closedRoot = parser.sawRoot = false
    parser.tag = parser.error = null
    parser.strict = !!strict
    parser.noscript = !!(strict || parser.opt.noscript)
    parser.state = S.BEGIN
    parser.strictEntities = parser.opt.strictEntities
    parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES)
    parser.attribList = []

    // namespaces form a prototype chain.
    // it always points at the current tag,
    // which protos to its parent tag.
    if (parser.opt.xmlns) {
      parser.ns = Object.create(rootNS)
    }

    // mostly just for error reporting
    parser.trackPosition = parser.opt.position !== false
    if (parser.trackPosition) {
      parser.position = parser.line = parser.column = 0
    }
    emit(parser, 'onready')
  }

  if (!Object.create) {
    Object.create = function (o) {
      function F () {}
      F.prototype = o
      var newf = new F()
      return newf
    }
  }

  if (!Object.keys) {
    Object.keys = function (o) {
      var a = []
      for (var i in o) if (o.hasOwnProperty(i)) a.push(i)
      return a
    }
  }

  function checkBufferLength (parser) {
    var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10)
    var maxActual = 0
    for (var i = 0, l = buffers.length; i < l; i++) {
      var len = parser[buffers[i]].length
      if (len > maxAllowed) {
        // Text/cdata nodes can get big, and since they're buffered,
        // we can get here under normal conditions.
        // Avoid issues by emitting the text node now,
        // so at least it won't get any bigger.
        switch (buffers[i]) {
          case 'textNode':
            closeText(parser)
            break

          case 'cdata':
            emitNode(parser, 'oncdata', parser.cdata)
            parser.cdata = ''
            break

          case 'script':
            emitNode(parser, 'onscript', parser.script)
            parser.script = ''
            break

          default:
            error(parser, 'Max buffer length exceeded: ' + buffers[i])
        }
      }
      maxActual = Math.max(maxActual, len)
    }
    // schedule the next check for the earliest possible buffer overrun.
    var m = sax.MAX_BUFFER_LENGTH - maxActual
    parser.bufferCheckPosition = m + parser.position
  }

  function clearBuffers (parser) {
    for (var i = 0, l = buffers.length; i < l; i++) {
      parser[buffers[i]] = ''
    }
  }

  function flushBuffers (parser) {
    closeText(parser)
    if (parser.cdata !== '') {
      emitNode(parser, 'oncdata', parser.cdata)
      parser.cdata = ''
    }
    if (parser.script !== '') {
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }
  }

  SAXParser.prototype = {
    end: function () { end(this) },
    write: write,
    resume: function () { this.error = null; return this },
    close: function () { return this.write(null) },
    flush: function () { flushBuffers(this) }
  }

  var Stream
  try {
    Stream = (__webpack_require__(/*! stream */ "stream").Stream)
  } catch (ex) {
    Stream = function () {}
  }

  var streamWraps = sax.EVENTS.filter(function (ev) {
    return ev !== 'error' && ev !== 'end'
  })

  function createStream (strict, opt) {
    return new SAXStream(strict, opt)
  }

  function SAXStream (strict, opt) {
    if (!(this instanceof SAXStream)) {
      return new SAXStream(strict, opt)
    }

    Stream.apply(this)

    this._parser = new SAXParser(strict, opt)
    this.writable = true
    this.readable = true

    var me = this

    this._parser.onend = function () {
      me.emit('end')
    }

    this._parser.onerror = function (er) {
      me.emit('error', er)

      // if didn't throw, then means error was handled.
      // go ahead and clear error, so we can write again.
      me._parser.error = null
    }

    this._decoder = null

    streamWraps.forEach(function (ev) {
      Object.defineProperty(me, 'on' + ev, {
        get: function () {
          return me._parser['on' + ev]
        },
        set: function (h) {
          if (!h) {
            me.removeAllListeners(ev)
            me._parser['on' + ev] = h
            return h
          }
          me.on(ev, h)
        },
        enumerable: true,
        configurable: false
      })
    })
  }

  SAXStream.prototype = Object.create(Stream.prototype, {
    constructor: {
      value: SAXStream
    }
  })

  SAXStream.prototype.write = function (data) {
    if (typeof Buffer === 'function' &&
      typeof Buffer.isBuffer === 'function' &&
      Buffer.isBuffer(data)) {
      if (!this._decoder) {
        var SD = (__webpack_require__(/*! string_decoder */ "string_decoder").StringDecoder)
        this._decoder = new SD('utf8')
      }
      data = this._decoder.write(data)
    }

    this._parser.write(data.toString())
    this.emit('data', data)
    return true
  }

  SAXStream.prototype.end = function (chunk) {
    if (chunk && chunk.length) {
      this.write(chunk)
    }
    this._parser.end()
    return true
  }

  SAXStream.prototype.on = function (ev, handler) {
    var me = this
    if (!me._parser['on' + ev] && streamWraps.indexOf(ev) !== -1) {
      me._parser['on' + ev] = function () {
        var args = arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments)
        args.splice(0, 0, ev)
        me.emit.apply(me, args)
      }
    }

    return Stream.prototype.on.call(me, ev, handler)
  }

  // this really needs to be replaced with character classes.
  // XML allows all manner of ridiculous numbers and digits.
  var CDATA = '[CDATA['
  var DOCTYPE = 'DOCTYPE'
  var XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  var XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/'
  var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE }

  // http://www.w3.org/TR/REC-xml/#NT-NameStartChar
  // This implementation works on strings, a single character at a time
  // as such, it cannot ever support astral-plane characters (10000-EFFFF)
  // without a significant breaking change to either this  parser, or the
  // JavaScript language.  Implementation of an emoji-capable xml parser
  // is left as an exercise for the reader.
  var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/

  var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/
  var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/

  function isWhitespace (c) {
    return c === ' ' || c === '\n' || c === '\r' || c === '\t'
  }

  function isQuote (c) {
    return c === '"' || c === '\''
  }

  function isAttribEnd (c) {
    return c === '>' || isWhitespace(c)
  }

  function isMatch (regex, c) {
    return regex.test(c)
  }

  function notMatch (regex, c) {
    return !isMatch(regex, c)
  }

  var S = 0
  sax.STATE = {
    BEGIN: S++, // leading byte order mark or whitespace
    BEGIN_WHITESPACE: S++, // leading whitespace
    TEXT: S++, // general stuff
    TEXT_ENTITY: S++, // &amp and such.
    OPEN_WAKA: S++, // <
    SGML_DECL: S++, // <!BLARG
    SGML_DECL_QUOTED: S++, // <!BLARG foo "bar
    DOCTYPE: S++, // <!DOCTYPE
    DOCTYPE_QUOTED: S++, // <!DOCTYPE "//blah
    DOCTYPE_DTD: S++, // <!DOCTYPE "//blah" [ ...
    DOCTYPE_DTD_QUOTED: S++, // <!DOCTYPE "//blah" [ "foo
    COMMENT_STARTING: S++, // <!-
    COMMENT: S++, // <!--
    COMMENT_ENDING: S++, // <!-- blah -
    COMMENT_ENDED: S++, // <!-- blah --
    CDATA: S++, // <![CDATA[ something
    CDATA_ENDING: S++, // ]
    CDATA_ENDING_2: S++, // ]]
    PROC_INST: S++, // <?hi
    PROC_INST_BODY: S++, // <?hi there
    PROC_INST_ENDING: S++, // <?hi "there" ?
    OPEN_TAG: S++, // <strong
    OPEN_TAG_SLASH: S++, // <strong /
    ATTRIB: S++, // <a
    ATTRIB_NAME: S++, // <a foo
    ATTRIB_NAME_SAW_WHITE: S++, // <a foo _
    ATTRIB_VALUE: S++, // <a foo=
    ATTRIB_VALUE_QUOTED: S++, // <a foo="bar
    ATTRIB_VALUE_CLOSED: S++, // <a foo="bar"
    ATTRIB_VALUE_UNQUOTED: S++, // <a foo=bar
    ATTRIB_VALUE_ENTITY_Q: S++, // <foo bar="&quot;"
    ATTRIB_VALUE_ENTITY_U: S++, // <foo bar=&quot
    CLOSE_TAG: S++, // </a
    CLOSE_TAG_SAW_WHITE: S++, // </a   >
    SCRIPT: S++, // <script> ...
    SCRIPT_ENDING: S++ // <script> ... <
  }

  sax.XML_ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'"
  }

  sax.ENTITIES = {
    'amp': '&',
    'gt': '>',
    'lt': '<',
    'quot': '"',
    'apos': "'",
    'AElig': 198,
    'Aacute': 193,
    'Acirc': 194,
    'Agrave': 192,
    'Aring': 197,
    'Atilde': 195,
    'Auml': 196,
    'Ccedil': 199,
    'ETH': 208,
    'Eacute': 201,
    'Ecirc': 202,
    'Egrave': 200,
    'Euml': 203,
    'Iacute': 205,
    'Icirc': 206,
    'Igrave': 204,
    'Iuml': 207,
    'Ntilde': 209,
    'Oacute': 211,
    'Ocirc': 212,
    'Ograve': 210,
    'Oslash': 216,
    'Otilde': 213,
    'Ouml': 214,
    'THORN': 222,
    'Uacute': 218,
    'Ucirc': 219,
    'Ugrave': 217,
    'Uuml': 220,
    'Yacute': 221,
    'aacute': 225,
    'acirc': 226,
    'aelig': 230,
    'agrave': 224,
    'aring': 229,
    'atilde': 227,
    'auml': 228,
    'ccedil': 231,
    'eacute': 233,
    'ecirc': 234,
    'egrave': 232,
    'eth': 240,
    'euml': 235,
    'iacute': 237,
    'icirc': 238,
    'igrave': 236,
    'iuml': 239,
    'ntilde': 241,
    'oacute': 243,
    'ocirc': 244,
    'ograve': 242,
    'oslash': 248,
    'otilde': 245,
    'ouml': 246,
    'szlig': 223,
    'thorn': 254,
    'uacute': 250,
    'ucirc': 251,
    'ugrave': 249,
    'uuml': 252,
    'yacute': 253,
    'yuml': 255,
    'copy': 169,
    'reg': 174,
    'nbsp': 160,
    'iexcl': 161,
    'cent': 162,
    'pound': 163,
    'curren': 164,
    'yen': 165,
    'brvbar': 166,
    'sect': 167,
    'uml': 168,
    'ordf': 170,
    'laquo': 171,
    'not': 172,
    'shy': 173,
    'macr': 175,
    'deg': 176,
    'plusmn': 177,
    'sup1': 185,
    'sup2': 178,
    'sup3': 179,
    'acute': 180,
    'micro': 181,
    'para': 182,
    'middot': 183,
    'cedil': 184,
    'ordm': 186,
    'raquo': 187,
    'frac14': 188,
    'frac12': 189,
    'frac34': 190,
    'iquest': 191,
    'times': 215,
    'divide': 247,
    'OElig': 338,
    'oelig': 339,
    'Scaron': 352,
    'scaron': 353,
    'Yuml': 376,
    'fnof': 402,
    'circ': 710,
    'tilde': 732,
    'Alpha': 913,
    'Beta': 914,
    'Gamma': 915,
    'Delta': 916,
    'Epsilon': 917,
    'Zeta': 918,
    'Eta': 919,
    'Theta': 920,
    'Iota': 921,
    'Kappa': 922,
    'Lambda': 923,
    'Mu': 924,
    'Nu': 925,
    'Xi': 926,
    'Omicron': 927,
    'Pi': 928,
    'Rho': 929,
    'Sigma': 931,
    'Tau': 932,
    'Upsilon': 933,
    'Phi': 934,
    'Chi': 935,
    'Psi': 936,
    'Omega': 937,
    'alpha': 945,
    'beta': 946,
    'gamma': 947,
    'delta': 948,
    'epsilon': 949,
    'zeta': 950,
    'eta': 951,
    'theta': 952,
    'iota': 953,
    'kappa': 954,
    'lambda': 955,
    'mu': 956,
    'nu': 957,
    'xi': 958,
    'omicron': 959,
    'pi': 960,
    'rho': 961,
    'sigmaf': 962,
    'sigma': 963,
    'tau': 964,
    'upsilon': 965,
    'phi': 966,
    'chi': 967,
    'psi': 968,
    'omega': 969,
    'thetasym': 977,
    'upsih': 978,
    'piv': 982,
    'ensp': 8194,
    'emsp': 8195,
    'thinsp': 8201,
    'zwnj': 8204,
    'zwj': 8205,
    'lrm': 8206,
    'rlm': 8207,
    'ndash': 8211,
    'mdash': 8212,
    'lsquo': 8216,
    'rsquo': 8217,
    'sbquo': 8218,
    'ldquo': 8220,
    'rdquo': 8221,
    'bdquo': 8222,
    'dagger': 8224,
    'Dagger': 8225,
    'bull': 8226,
    'hellip': 8230,
    'permil': 8240,
    'prime': 8242,
    'Prime': 8243,
    'lsaquo': 8249,
    'rsaquo': 8250,
    'oline': 8254,
    'frasl': 8260,
    'euro': 8364,
    'image': 8465,
    'weierp': 8472,
    'real': 8476,
    'trade': 8482,
    'alefsym': 8501,
    'larr': 8592,
    'uarr': 8593,
    'rarr': 8594,
    'darr': 8595,
    'harr': 8596,
    'crarr': 8629,
    'lArr': 8656,
    'uArr': 8657,
    'rArr': 8658,
    'dArr': 8659,
    'hArr': 8660,
    'forall': 8704,
    'part': 8706,
    'exist': 8707,
    'empty': 8709,
    'nabla': 8711,
    'isin': 8712,
    'notin': 8713,
    'ni': 8715,
    'prod': 8719,
    'sum': 8721,
    'minus': 8722,
    'lowast': 8727,
    'radic': 8730,
    'prop': 8733,
    'infin': 8734,
    'ang': 8736,
    'and': 8743,
    'or': 8744,
    'cap': 8745,
    'cup': 8746,
    'int': 8747,
    'there4': 8756,
    'sim': 8764,
    'cong': 8773,
    'asymp': 8776,
    'ne': 8800,
    'equiv': 8801,
    'le': 8804,
    'ge': 8805,
    'sub': 8834,
    'sup': 8835,
    'nsub': 8836,
    'sube': 8838,
    'supe': 8839,
    'oplus': 8853,
    'otimes': 8855,
    'perp': 8869,
    'sdot': 8901,
    'lceil': 8968,
    'rceil': 8969,
    'lfloor': 8970,
    'rfloor': 8971,
    'lang': 9001,
    'rang': 9002,
    'loz': 9674,
    'spades': 9824,
    'clubs': 9827,
    'hearts': 9829,
    'diams': 9830
  }

  Object.keys(sax.ENTITIES).forEach(function (key) {
    var e = sax.ENTITIES[key]
    var s = typeof e === 'number' ? String.fromCharCode(e) : e
    sax.ENTITIES[key] = s
  })

  for (var s in sax.STATE) {
    sax.STATE[sax.STATE[s]] = s
  }

  // shorthand
  S = sax.STATE

  function emit (parser, event, data) {
    parser[event] && parser[event](data)
  }

  function emitNode (parser, nodeType, data) {
    if (parser.textNode) closeText(parser)
    emit(parser, nodeType, data)
  }

  function closeText (parser) {
    parser.textNode = textopts(parser.opt, parser.textNode)
    if (parser.textNode) emit(parser, 'ontext', parser.textNode)
    parser.textNode = ''
  }

  function textopts (opt, text) {
    if (opt.trim) text = text.trim()
    if (opt.normalize) text = text.replace(/\s+/g, ' ')
    return text
  }

  function error (parser, er) {
    closeText(parser)
    if (parser.trackPosition) {
      er += '\nLine: ' + parser.line +
        '\nColumn: ' + parser.column +
        '\nChar: ' + parser.c
    }
    er = new Error(er)
    parser.error = er
    emit(parser, 'onerror', er)
    return parser
  }

  function end (parser) {
    if (parser.sawRoot && !parser.closedRoot) strictFail(parser, 'Unclosed root tag')
    if ((parser.state !== S.BEGIN) &&
      (parser.state !== S.BEGIN_WHITESPACE) &&
      (parser.state !== S.TEXT)) {
      error(parser, 'Unexpected end')
    }
    closeText(parser)
    parser.c = ''
    parser.closed = true
    emit(parser, 'onend')
    SAXParser.call(parser, parser.strict, parser.opt)
    return parser
  }

  function strictFail (parser, message) {
    if (typeof parser !== 'object' || !(parser instanceof SAXParser)) {
      throw new Error('bad call to strictFail')
    }
    if (parser.strict) {
      error(parser, message)
    }
  }

  function newTag (parser) {
    if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]()
    var parent = parser.tags[parser.tags.length - 1] || parser
    var tag = parser.tag = { name: parser.tagName, attributes: {} }

    // will be overridden if tag contails an xmlns="foo" or xmlns:foo="bar"
    if (parser.opt.xmlns) {
      tag.ns = parent.ns
    }
    parser.attribList.length = 0
    emitNode(parser, 'onopentagstart', tag)
  }

  function qname (name, attribute) {
    var i = name.indexOf(':')
    var qualName = i < 0 ? [ '', name ] : name.split(':')
    var prefix = qualName[0]
    var local = qualName[1]

    // <x "xmlns"="http://foo">
    if (attribute && name === 'xmlns') {
      prefix = 'xmlns'
      local = ''
    }

    return { prefix: prefix, local: local }
  }

  function attrib (parser) {
    if (!parser.strict) {
      parser.attribName = parser.attribName[parser.looseCase]()
    }

    if (parser.attribList.indexOf(parser.attribName) !== -1 ||
      parser.tag.attributes.hasOwnProperty(parser.attribName)) {
      parser.attribName = parser.attribValue = ''
      return
    }

    if (parser.opt.xmlns) {
      var qn = qname(parser.attribName, true)
      var prefix = qn.prefix
      var local = qn.local

      if (prefix === 'xmlns') {
        // namespace binding attribute. push the binding into scope
        if (local === 'xml' && parser.attribValue !== XML_NAMESPACE) {
          strictFail(parser,
            'xml: prefix must be bound to ' + XML_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else if (local === 'xmlns' && parser.attribValue !== XMLNS_NAMESPACE) {
          strictFail(parser,
            'xmlns: prefix must be bound to ' + XMLNS_NAMESPACE + '\n' +
            'Actual: ' + parser.attribValue)
        } else {
          var tag = parser.tag
          var parent = parser.tags[parser.tags.length - 1] || parser
          if (tag.ns === parent.ns) {
            tag.ns = Object.create(parent.ns)
          }
          tag.ns[local] = parser.attribValue
        }
      }

      // defer onattribute events until all attributes have been seen
      // so any new bindings can take effect. preserve attribute order
      // so deferred events can be emitted in document order
      parser.attribList.push([parser.attribName, parser.attribValue])
    } else {
      // in non-xmlns mode, we can emit the event right away
      parser.tag.attributes[parser.attribName] = parser.attribValue
      emitNode(parser, 'onattribute', {
        name: parser.attribName,
        value: parser.attribValue
      })
    }

    parser.attribName = parser.attribValue = ''
  }

  function openTag (parser, selfClosing) {
    if (parser.opt.xmlns) {
      // emit namespace binding events
      var tag = parser.tag

      // add namespace info to tag
      var qn = qname(parser.tagName)
      tag.prefix = qn.prefix
      tag.local = qn.local
      tag.uri = tag.ns[qn.prefix] || ''

      if (tag.prefix && !tag.uri) {
        strictFail(parser, 'Unbound namespace prefix: ' +
          JSON.stringify(parser.tagName))
        tag.uri = qn.prefix
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (tag.ns && parent.ns !== tag.ns) {
        Object.keys(tag.ns).forEach(function (p) {
          emitNode(parser, 'onopennamespace', {
            prefix: p,
            uri: tag.ns[p]
          })
        })
      }

      // handle deferred onattribute events
      // Note: do not apply default ns to attributes:
      //   http://www.w3.org/TR/REC-xml-names/#defaulting
      for (var i = 0, l = parser.attribList.length; i < l; i++) {
        var nv = parser.attribList[i]
        var name = nv[0]
        var value = nv[1]
        var qualName = qname(name, true)
        var prefix = qualName.prefix
        var local = qualName.local
        var uri = prefix === '' ? '' : (tag.ns[prefix] || '')
        var a = {
          name: name,
          value: value,
          prefix: prefix,
          local: local,
          uri: uri
        }

        // if there's any attributes with an undefined namespace,
        // then fail on them now.
        if (prefix && prefix !== 'xmlns' && !uri) {
          strictFail(parser, 'Unbound namespace prefix: ' +
            JSON.stringify(prefix))
          a.uri = prefix
        }
        parser.tag.attributes[name] = a
        emitNode(parser, 'onattribute', a)
      }
      parser.attribList.length = 0
    }

    parser.tag.isSelfClosing = !!selfClosing

    // process the tag
    parser.sawRoot = true
    parser.tags.push(parser.tag)
    emitNode(parser, 'onopentag', parser.tag)
    if (!selfClosing) {
      // special case for <script> in non-strict mode.
      if (!parser.noscript && parser.tagName.toLowerCase() === 'script') {
        parser.state = S.SCRIPT
      } else {
        parser.state = S.TEXT
      }
      parser.tag = null
      parser.tagName = ''
    }
    parser.attribName = parser.attribValue = ''
    parser.attribList.length = 0
  }

  function closeTag (parser) {
    if (!parser.tagName) {
      strictFail(parser, 'Weird empty close tag.')
      parser.textNode += '</>'
      parser.state = S.TEXT
      return
    }

    if (parser.script) {
      if (parser.tagName !== 'script') {
        parser.script += '</' + parser.tagName + '>'
        parser.tagName = ''
        parser.state = S.SCRIPT
        return
      }
      emitNode(parser, 'onscript', parser.script)
      parser.script = ''
    }

    // first make sure that the closing tag actually exists.
    // <a><b></c></b></a> will close everything, otherwise.
    var t = parser.tags.length
    var tagName = parser.tagName
    if (!parser.strict) {
      tagName = tagName[parser.looseCase]()
    }
    var closeTo = tagName
    while (t--) {
      var close = parser.tags[t]
      if (close.name !== closeTo) {
        // fail the first time in strict mode
        strictFail(parser, 'Unexpected close tag')
      } else {
        break
      }
    }

    // didn't find it.  we already failed for strict, so just abort.
    if (t < 0) {
      strictFail(parser, 'Unmatched closing tag: ' + parser.tagName)
      parser.textNode += '</' + parser.tagName + '>'
      parser.state = S.TEXT
      return
    }
    parser.tagName = tagName
    var s = parser.tags.length
    while (s-- > t) {
      var tag = parser.tag = parser.tags.pop()
      parser.tagName = parser.tag.name
      emitNode(parser, 'onclosetag', parser.tagName)

      var x = {}
      for (var i in tag.ns) {
        x[i] = tag.ns[i]
      }

      var parent = parser.tags[parser.tags.length - 1] || parser
      if (parser.opt.xmlns && tag.ns !== parent.ns) {
        // remove namespace bindings introduced by tag
        Object.keys(tag.ns).forEach(function (p) {
          var n = tag.ns[p]
          emitNode(parser, 'onclosenamespace', { prefix: p, uri: n })
        })
      }
    }
    if (t === 0) parser.closedRoot = true
    parser.tagName = parser.attribValue = parser.attribName = ''
    parser.attribList.length = 0
    parser.state = S.TEXT
  }

  function parseEntity (parser) {
    var entity = parser.entity
    var entityLC = entity.toLowerCase()
    var num
    var numStr = ''

    if (parser.ENTITIES[entity]) {
      return parser.ENTITIES[entity]
    }
    if (parser.ENTITIES[entityLC]) {
      return parser.ENTITIES[entityLC]
    }
    entity = entityLC
    if (entity.charAt(0) === '#') {
      if (entity.charAt(1) === 'x') {
        entity = entity.slice(2)
        num = parseInt(entity, 16)
        numStr = num.toString(16)
      } else {
        entity = entity.slice(1)
        num = parseInt(entity, 10)
        numStr = num.toString(10)
      }
    }
    entity = entity.replace(/^0+/, '')
    if (isNaN(num) || numStr.toLowerCase() !== entity) {
      strictFail(parser, 'Invalid character entity')
      return '&' + parser.entity + ';'
    }

    return String.fromCodePoint(num)
  }

  function beginWhiteSpace (parser, c) {
    if (c === '<') {
      parser.state = S.OPEN_WAKA
      parser.startTagPosition = parser.position
    } else if (!isWhitespace(c)) {
      // have to process this as a text node.
      // weird, but happens.
      strictFail(parser, 'Non-whitespace before first tag.')
      parser.textNode = c
      parser.state = S.TEXT
    }
  }

  function charAt (chunk, i) {
    var result = ''
    if (i < chunk.length) {
      result = chunk.charAt(i)
    }
    return result
  }

  function write (chunk) {
    var parser = this
    if (this.error) {
      throw this.error
    }
    if (parser.closed) {
      return error(parser,
        'Cannot write after close. Assign an onready handler.')
    }
    if (chunk === null) {
      return end(parser)
    }
    if (typeof chunk === 'object') {
      chunk = chunk.toString()
    }
    var i = 0
    var c = ''
    while (true) {
      c = charAt(chunk, i++)
      parser.c = c

      if (!c) {
        break
      }

      if (parser.trackPosition) {
        parser.position++
        if (c === '\n') {
          parser.line++
          parser.column = 0
        } else {
          parser.column++
        }
      }

      switch (parser.state) {
        case S.BEGIN:
          parser.state = S.BEGIN_WHITESPACE
          if (c === '\uFEFF') {
            continue
          }
          beginWhiteSpace(parser, c)
          continue

        case S.BEGIN_WHITESPACE:
          beginWhiteSpace(parser, c)
          continue

        case S.TEXT:
          if (parser.sawRoot && !parser.closedRoot) {
            var starti = i - 1
            while (c && c !== '<' && c !== '&') {
              c = charAt(chunk, i++)
              if (c && parser.trackPosition) {
                parser.position++
                if (c === '\n') {
                  parser.line++
                  parser.column = 0
                } else {
                  parser.column++
                }
              }
            }
            parser.textNode += chunk.substring(starti, i - 1)
          }
          if (c === '<' && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
            parser.state = S.OPEN_WAKA
            parser.startTagPosition = parser.position
          } else {
            if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
              strictFail(parser, 'Text data outside of root node.')
            }
            if (c === '&') {
              parser.state = S.TEXT_ENTITY
            } else {
              parser.textNode += c
            }
          }
          continue

        case S.SCRIPT:
          // only non-strict
          if (c === '<') {
            parser.state = S.SCRIPT_ENDING
          } else {
            parser.script += c
          }
          continue

        case S.SCRIPT_ENDING:
          if (c === '/') {
            parser.state = S.CLOSE_TAG
          } else {
            parser.script += '<' + c
            parser.state = S.SCRIPT
          }
          continue

        case S.OPEN_WAKA:
          // either a /, ?, !, or text is coming next.
          if (c === '!') {
            parser.state = S.SGML_DECL
            parser.sgmlDecl = ''
          } else if (isWhitespace(c)) {
            // wait for it...
          } else if (isMatch(nameStart, c)) {
            parser.state = S.OPEN_TAG
            parser.tagName = c
          } else if (c === '/') {
            parser.state = S.CLOSE_TAG
            parser.tagName = ''
          } else if (c === '?') {
            parser.state = S.PROC_INST
            parser.procInstName = parser.procInstBody = ''
          } else {
            strictFail(parser, 'Unencoded <')
            // if there was some whitespace, then add that in.
            if (parser.startTagPosition + 1 < parser.position) {
              var pad = parser.position - parser.startTagPosition
              c = new Array(pad).join(' ') + c
            }
            parser.textNode += '<' + c
            parser.state = S.TEXT
          }
          continue

        case S.SGML_DECL:
          if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
            emitNode(parser, 'onopencdata')
            parser.state = S.CDATA
            parser.sgmlDecl = ''
            parser.cdata = ''
          } else if (parser.sgmlDecl + c === '--') {
            parser.state = S.COMMENT
            parser.comment = ''
            parser.sgmlDecl = ''
          } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
            parser.state = S.DOCTYPE
            if (parser.doctype || parser.sawRoot) {
              strictFail(parser,
                'Inappropriately located doctype declaration')
            }
            parser.doctype = ''
            parser.sgmlDecl = ''
          } else if (c === '>') {
            emitNode(parser, 'onsgmldeclaration', parser.sgmlDecl)
            parser.sgmlDecl = ''
            parser.state = S.TEXT
          } else if (isQuote(c)) {
            parser.state = S.SGML_DECL_QUOTED
            parser.sgmlDecl += c
          } else {
            parser.sgmlDecl += c
          }
          continue

        case S.SGML_DECL_QUOTED:
          if (c === parser.q) {
            parser.state = S.SGML_DECL
            parser.q = ''
          }
          parser.sgmlDecl += c
          continue

        case S.DOCTYPE:
          if (c === '>') {
            parser.state = S.TEXT
            emitNode(parser, 'ondoctype', parser.doctype)
            parser.doctype = true // just remember that we saw it.
          } else {
            parser.doctype += c
            if (c === '[') {
              parser.state = S.DOCTYPE_DTD
            } else if (isQuote(c)) {
              parser.state = S.DOCTYPE_QUOTED
              parser.q = c
            }
          }
          continue

        case S.DOCTYPE_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.q = ''
            parser.state = S.DOCTYPE
          }
          continue

        case S.DOCTYPE_DTD:
          parser.doctype += c
          if (c === ']') {
            parser.state = S.DOCTYPE
          } else if (isQuote(c)) {
            parser.state = S.DOCTYPE_DTD_QUOTED
            parser.q = c
          }
          continue

        case S.DOCTYPE_DTD_QUOTED:
          parser.doctype += c
          if (c === parser.q) {
            parser.state = S.DOCTYPE_DTD
            parser.q = ''
          }
          continue

        case S.COMMENT:
          if (c === '-') {
            parser.state = S.COMMENT_ENDING
          } else {
            parser.comment += c
          }
          continue

        case S.COMMENT_ENDING:
          if (c === '-') {
            parser.state = S.COMMENT_ENDED
            parser.comment = textopts(parser.opt, parser.comment)
            if (parser.comment) {
              emitNode(parser, 'oncomment', parser.comment)
            }
            parser.comment = ''
          } else {
            parser.comment += '-' + c
            parser.state = S.COMMENT
          }
          continue

        case S.COMMENT_ENDED:
          if (c !== '>') {
            strictFail(parser, 'Malformed comment')
            // allow <!-- blah -- bloo --> in non-strict mode,
            // which is a comment of " blah -- bloo "
            parser.comment += '--' + c
            parser.state = S.COMMENT
          } else {
            parser.state = S.TEXT
          }
          continue

        case S.CDATA:
          if (c === ']') {
            parser.state = S.CDATA_ENDING
          } else {
            parser.cdata += c
          }
          continue

        case S.CDATA_ENDING:
          if (c === ']') {
            parser.state = S.CDATA_ENDING_2
          } else {
            parser.cdata += ']' + c
            parser.state = S.CDATA
          }
          continue

        case S.CDATA_ENDING_2:
          if (c === '>') {
            if (parser.cdata) {
              emitNode(parser, 'oncdata', parser.cdata)
            }
            emitNode(parser, 'onclosecdata')
            parser.cdata = ''
            parser.state = S.TEXT
          } else if (c === ']') {
            parser.cdata += ']'
          } else {
            parser.cdata += ']]' + c
            parser.state = S.CDATA
          }
          continue

        case S.PROC_INST:
          if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else if (isWhitespace(c)) {
            parser.state = S.PROC_INST_BODY
          } else {
            parser.procInstName += c
          }
          continue

        case S.PROC_INST_BODY:
          if (!parser.procInstBody && isWhitespace(c)) {
            continue
          } else if (c === '?') {
            parser.state = S.PROC_INST_ENDING
          } else {
            parser.procInstBody += c
          }
          continue

        case S.PROC_INST_ENDING:
          if (c === '>') {
            emitNode(parser, 'onprocessinginstruction', {
              name: parser.procInstName,
              body: parser.procInstBody
            })
            parser.procInstName = parser.procInstBody = ''
            parser.state = S.TEXT
          } else {
            parser.procInstBody += '?' + c
            parser.state = S.PROC_INST_BODY
          }
          continue

        case S.OPEN_TAG:
          if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else {
            newTag(parser)
            if (c === '>') {
              openTag(parser)
            } else if (c === '/') {
              parser.state = S.OPEN_TAG_SLASH
            } else {
              if (!isWhitespace(c)) {
                strictFail(parser, 'Invalid character in tag name')
              }
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.OPEN_TAG_SLASH:
          if (c === '>') {
            openTag(parser, true)
            closeTag(parser)
          } else {
            strictFail(parser, 'Forward-slash in opening tag not followed by >')
            parser.state = S.ATTRIB
          }
          continue

        case S.ATTRIB:
          // haven't read the attribute name yet.
          if (isWhitespace(c)) {
            continue
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (c === '>') {
            strictFail(parser, 'Attribute without value')
            parser.attribValue = parser.attribName
            attrib(parser)
            openTag(parser)
          } else if (isWhitespace(c)) {
            parser.state = S.ATTRIB_NAME_SAW_WHITE
          } else if (isMatch(nameBody, c)) {
            parser.attribName += c
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_NAME_SAW_WHITE:
          if (c === '=') {
            parser.state = S.ATTRIB_VALUE
          } else if (isWhitespace(c)) {
            continue
          } else {
            strictFail(parser, 'Attribute without value')
            parser.tag.attributes[parser.attribName] = ''
            parser.attribValue = ''
            emitNode(parser, 'onattribute', {
              name: parser.attribName,
              value: ''
            })
            parser.attribName = ''
            if (c === '>') {
              openTag(parser)
            } else if (isMatch(nameStart, c)) {
              parser.attribName = c
              parser.state = S.ATTRIB_NAME
            } else {
              strictFail(parser, 'Invalid attribute name')
              parser.state = S.ATTRIB
            }
          }
          continue

        case S.ATTRIB_VALUE:
          if (isWhitespace(c)) {
            continue
          } else if (isQuote(c)) {
            parser.q = c
            parser.state = S.ATTRIB_VALUE_QUOTED
          } else {
            strictFail(parser, 'Unquoted attribute value')
            parser.state = S.ATTRIB_VALUE_UNQUOTED
            parser.attribValue = c
          }
          continue

        case S.ATTRIB_VALUE_QUOTED:
          if (c !== parser.q) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_Q
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          parser.q = ''
          parser.state = S.ATTRIB_VALUE_CLOSED
          continue

        case S.ATTRIB_VALUE_CLOSED:
          if (isWhitespace(c)) {
            parser.state = S.ATTRIB
          } else if (c === '>') {
            openTag(parser)
          } else if (c === '/') {
            parser.state = S.OPEN_TAG_SLASH
          } else if (isMatch(nameStart, c)) {
            strictFail(parser, 'No whitespace between attributes')
            parser.attribName = c
            parser.attribValue = ''
            parser.state = S.ATTRIB_NAME
          } else {
            strictFail(parser, 'Invalid attribute name')
          }
          continue

        case S.ATTRIB_VALUE_UNQUOTED:
          if (!isAttribEnd(c)) {
            if (c === '&') {
              parser.state = S.ATTRIB_VALUE_ENTITY_U
            } else {
              parser.attribValue += c
            }
            continue
          }
          attrib(parser)
          if (c === '>') {
            openTag(parser)
          } else {
            parser.state = S.ATTRIB
          }
          continue

        case S.CLOSE_TAG:
          if (!parser.tagName) {
            if (isWhitespace(c)) {
              continue
            } else if (notMatch(nameStart, c)) {
              if (parser.script) {
                parser.script += '</' + c
                parser.state = S.SCRIPT
              } else {
                strictFail(parser, 'Invalid tagname in closing tag.')
              }
            } else {
              parser.tagName = c
            }
          } else if (c === '>') {
            closeTag(parser)
          } else if (isMatch(nameBody, c)) {
            parser.tagName += c
          } else if (parser.script) {
            parser.script += '</' + parser.tagName
            parser.tagName = ''
            parser.state = S.SCRIPT
          } else {
            if (!isWhitespace(c)) {
              strictFail(parser, 'Invalid tagname in closing tag')
            }
            parser.state = S.CLOSE_TAG_SAW_WHITE
          }
          continue

        case S.CLOSE_TAG_SAW_WHITE:
          if (isWhitespace(c)) {
            continue
          }
          if (c === '>') {
            closeTag(parser)
          } else {
            strictFail(parser, 'Invalid characters in closing tag')
          }
          continue

        case S.TEXT_ENTITY:
        case S.ATTRIB_VALUE_ENTITY_Q:
        case S.ATTRIB_VALUE_ENTITY_U:
          var returnState
          var buffer
          switch (parser.state) {
            case S.TEXT_ENTITY:
              returnState = S.TEXT
              buffer = 'textNode'
              break

            case S.ATTRIB_VALUE_ENTITY_Q:
              returnState = S.ATTRIB_VALUE_QUOTED
              buffer = 'attribValue'
              break

            case S.ATTRIB_VALUE_ENTITY_U:
              returnState = S.ATTRIB_VALUE_UNQUOTED
              buffer = 'attribValue'
              break
          }

          if (c === ';') {
            parser[buffer] += parseEntity(parser)
            parser.entity = ''
            parser.state = returnState
          } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
            parser.entity += c
          } else {
            strictFail(parser, 'Invalid character in entity name')
            parser[buffer] += '&' + parser.entity + c
            parser.entity = ''
            parser.state = returnState
          }

          continue

        default:
          throw new Error(parser, 'Unknown state: ' + parser.state)
      }
    } // while

    if (parser.position >= parser.bufferCheckPosition) {
      checkBufferLength(parser)
    }
    return parser
  }

  /*! http://mths.be/fromcodepoint v0.1.0 by @mathias */
  /* istanbul ignore next */
  if (!String.fromCodePoint) {
    (function () {
      var stringFromCharCode = String.fromCharCode
      var floor = Math.floor
      var fromCodePoint = function () {
        var MAX_SIZE = 0x4000
        var codeUnits = []
        var highSurrogate
        var lowSurrogate
        var index = -1
        var length = arguments.length
        if (!length) {
          return ''
        }
        var result = ''
        while (++index < length) {
          var codePoint = Number(arguments[index])
          if (
            !isFinite(codePoint) || // `NaN`, `+Infinity`, or `-Infinity`
            codePoint < 0 || // not a valid Unicode code point
            codePoint > 0x10FFFF || // not a valid Unicode code point
            floor(codePoint) !== codePoint // not an integer
          ) {
            throw RangeError('Invalid code point: ' + codePoint)
          }
          if (codePoint <= 0xFFFF) { // BMP code point
            codeUnits.push(codePoint)
          } else { // Astral code point; split in surrogate halves
            // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000
            highSurrogate = (codePoint >> 10) + 0xD800
            lowSurrogate = (codePoint % 0x400) + 0xDC00
            codeUnits.push(highSurrogate, lowSurrogate)
          }
          if (index + 1 === length || codeUnits.length > MAX_SIZE) {
            result += stringFromCharCode.apply(null, codeUnits)
            codeUnits.length = 0
          }
        }
        return result
      }
      /* istanbul ignore next */
      if (Object.defineProperty) {
        Object.defineProperty(String, 'fromCodePoint', {
          value: fromCodePoint,
          configurable: true,
          writable: true
        })
      } else {
        String.fromCodePoint = fromCodePoint
      }
    }())
  }
})( false ? 0 : exports)


/***/ }),

/***/ "./node_modules/strnum/strnum.js":
/*!***************************************!*\
  !*** ./node_modules/strnum/strnum.js ***!
  \***************************************/
/***/ ((module) => {

const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;
const numRegex = /^([\-\+])?(0*)(\.[0-9]+([eE]\-?[0-9]+)?|[0-9]+(\.[0-9]+([eE]\-?[0-9]+)?)?)$/;
// const octRegex = /0x[a-z0-9]+/;
// const binRegex = /0x[a-z0-9]+/;


//polyfill
if (!Number.parseInt && window.parseInt) {
    Number.parseInt = window.parseInt;
}
if (!Number.parseFloat && window.parseFloat) {
    Number.parseFloat = window.parseFloat;
}

  
const consider = {
    hex :  true,
    leadingZeros: true,
    decimalPoint: "\.",
    eNotation: true
    //skipLike: /regex/
};

function toNumber(str, options = {}){
    // const options = Object.assign({}, consider);
    // if(opt.leadingZeros === false){
    //     options.leadingZeros = false;
    // }else if(opt.hex === false){
    //     options.hex = false;
    // }

    options = Object.assign({}, consider, options );
    if(!str || typeof str !== "string" ) return str;
    
    let trimmedStr  = str.trim();
    // if(trimmedStr === "0.0") return 0;
    // else if(trimmedStr === "+0.0") return 0;
    // else if(trimmedStr === "-0.0") return -0;

    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;
    else if (options.hex && hexRegex.test(trimmedStr)) {
        return Number.parseInt(trimmedStr, 16);
    // } else if (options.parseOct && octRegex.test(str)) {
    //     return Number.parseInt(val, 8);
    // }else if (options.parseBin && binRegex.test(str)) {
    //     return Number.parseInt(val, 2);
    }else{
        //separate negative sign, leading zeros, and rest number
        const match = numRegex.exec(trimmedStr);
        if(match){
            const sign = match[1];
            const leadingZeros = match[2];
            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros
            //trim ending zeros for floating number
            
            const eNotation = match[4] || match[6];
            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== ".") return str; //-0123
            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== ".") return str; //0123
            else{//no leading zeros or leading zeros are allowed
                const num = Number(trimmedStr);
                const numStr = "" + num;
                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(eNotation){ //given number has enotation
                    if(options.eNotation) return num;
                    else return str;
                }else if(trimmedStr.indexOf(".") !== -1){ //floating number
                    // const decimalPart = match[5].substr(1);
                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf("."));

                    
                    // const p = numStr.indexOf(".");
                    // const givenIntPart = numStr.substr(0,p);
                    // const givenDecPart = numStr.substr(p+1);
                    if(numStr === "0" && (numTrimmedByZeros === "") ) return num; //0.0
                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000
                    else if( sign && numStr === "-"+numTrimmedByZeros) return num;
                    else return str;
                }
                
                if(leadingZeros){
                    // if(numTrimmedByZeros === numStr){
                    //     if(options.leadingZeros) return num;
                    //     else return str;
                    // }else return str;
                    if(numTrimmedByZeros === numStr) return num;
                    else if(sign+numTrimmedByZeros === numStr) return num;
                    else return str;
                }

                if(trimmedStr === numStr) return num;
                else if(trimmedStr === sign+numStr) return num;
                // else{
                //     //number with +/- sign
                //     trimmedStr.test(/[-+][0-9]);

                // }
                return str;
            }
            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;
            
        }else{ //non-numeric string
            return str;
        }
    }
}

/**
 * 
 * @param {string} numStr without leading zeros
 * @returns 
 */
function trimZeros(numStr){
    if(numStr && numStr.indexOf(".") !== -1){//float
        numStr = numStr.replace(/0+$/, ""); //remove ending zeros
        if(numStr === ".")  numStr = "0";
        else if(numStr[0] === ".")  numStr = "0"+numStr;
        else if(numStr[numStr.length-1] === ".")  numStr = numStr.substr(0,numStr.length-1);
        return numStr;
    }
    return numStr;
}
module.exports = toNumber


/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/umd/main.js":
/*!******************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/umd/main.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function (factory) {
    if ( true && typeof module.exports === "object") {
        var v = factory(__webpack_require__("./node_modules/vscode-languageserver-types/lib/umd sync recursive"), exports);
        if (v !== undefined) module.exports = v;
    }
    else if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__, exports], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
})(function (require, exports) {
    /* --------------------------------------------------------------------------------------------
     * Copyright (c) Microsoft Corporation. All rights reserved.
     * Licensed under the MIT License. See License.txt in the project root for license information.
     * ------------------------------------------------------------------------------------------ */
    'use strict';
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TextDocument = exports.EOL = exports.WorkspaceFolder = exports.InlineCompletionContext = exports.SelectedCompletionInfo = exports.InlineCompletionTriggerKind = exports.InlineCompletionList = exports.InlineCompletionItem = exports.StringValue = exports.InlayHint = exports.InlayHintLabelPart = exports.InlayHintKind = exports.InlineValueContext = exports.InlineValueEvaluatableExpression = exports.InlineValueVariableLookup = exports.InlineValueText = exports.SemanticTokens = exports.SemanticTokenModifiers = exports.SemanticTokenTypes = exports.SelectionRange = exports.DocumentLink = exports.FormattingOptions = exports.CodeLens = exports.CodeAction = exports.CodeActionContext = exports.CodeActionTriggerKind = exports.CodeActionKind = exports.DocumentSymbol = exports.WorkspaceSymbol = exports.SymbolInformation = exports.SymbolTag = exports.SymbolKind = exports.DocumentHighlight = exports.DocumentHighlightKind = exports.SignatureInformation = exports.ParameterInformation = exports.Hover = exports.MarkedString = exports.CompletionList = exports.CompletionItem = exports.CompletionItemLabelDetails = exports.InsertTextMode = exports.InsertReplaceEdit = exports.CompletionItemTag = exports.InsertTextFormat = exports.CompletionItemKind = exports.MarkupContent = exports.MarkupKind = exports.TextDocumentItem = exports.OptionalVersionedTextDocumentIdentifier = exports.VersionedTextDocumentIdentifier = exports.TextDocumentIdentifier = exports.WorkspaceChange = exports.WorkspaceEdit = exports.DeleteFile = exports.RenameFile = exports.CreateFile = exports.TextDocumentEdit = exports.AnnotatedTextEdit = exports.ChangeAnnotationIdentifier = exports.ChangeAnnotation = exports.TextEdit = exports.Command = exports.Diagnostic = exports.CodeDescription = exports.DiagnosticTag = exports.DiagnosticSeverity = exports.DiagnosticRelatedInformation = exports.FoldingRange = exports.FoldingRangeKind = exports.ColorPresentation = exports.ColorInformation = exports.Color = exports.LocationLink = exports.Location = exports.Range = exports.Position = exports.uinteger = exports.integer = exports.URI = exports.DocumentUri = void 0;
    var DocumentUri;
    (function (DocumentUri) {
        function is(value) {
            return typeof value === 'string';
        }
        DocumentUri.is = is;
    })(DocumentUri || (exports.DocumentUri = DocumentUri = {}));
    var URI;
    (function (URI) {
        function is(value) {
            return typeof value === 'string';
        }
        URI.is = is;
    })(URI || (exports.URI = URI = {}));
    var integer;
    (function (integer) {
        integer.MIN_VALUE = -2147483648;
        integer.MAX_VALUE = 2147483647;
        function is(value) {
            return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
        }
        integer.is = is;
    })(integer || (exports.integer = integer = {}));
    var uinteger;
    (function (uinteger) {
        uinteger.MIN_VALUE = 0;
        uinteger.MAX_VALUE = 2147483647;
        function is(value) {
            return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
        }
        uinteger.is = is;
    })(uinteger || (exports.uinteger = uinteger = {}));
    /**
     * The Position namespace provides helper functions to work with
     * {@link Position} literals.
     */
    var Position;
    (function (Position) {
        /**
         * Creates a new Position literal from the given line and character.
         * @param line The position's line.
         * @param character The position's character.
         */
        function create(line, character) {
            if (line === Number.MAX_VALUE) {
                line = uinteger.MAX_VALUE;
            }
            if (character === Number.MAX_VALUE) {
                character = uinteger.MAX_VALUE;
            }
            return { line: line, character: character };
        }
        Position.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Position} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
        }
        Position.is = is;
    })(Position || (exports.Position = Position = {}));
    /**
     * The Range namespace provides helper functions to work with
     * {@link Range} literals.
     */
    var Range;
    (function (Range) {
        function create(one, two, three, four) {
            if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
                return { start: Position.create(one, two), end: Position.create(three, four) };
            }
            else if (Position.is(one) && Position.is(two)) {
                return { start: one, end: two };
            }
            else {
                throw new Error("Range#create called with invalid arguments[".concat(one, ", ").concat(two, ", ").concat(three, ", ").concat(four, "]"));
            }
        }
        Range.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Range} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
        }
        Range.is = is;
    })(Range || (exports.Range = Range = {}));
    /**
     * The Location namespace provides helper functions to work with
     * {@link Location} literals.
     */
    var Location;
    (function (Location) {
        /**
         * Creates a Location literal.
         * @param uri The location's uri.
         * @param range The location's range.
         */
        function create(uri, range) {
            return { uri: uri, range: range };
        }
        Location.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Location} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
        }
        Location.is = is;
    })(Location || (exports.Location = Location = {}));
    /**
     * The LocationLink namespace provides helper functions to work with
     * {@link LocationLink} literals.
     */
    var LocationLink;
    (function (LocationLink) {
        /**
         * Creates a LocationLink literal.
         * @param targetUri The definition's uri.
         * @param targetRange The full range of the definition.
         * @param targetSelectionRange The span of the symbol definition at the target.
         * @param originSelectionRange The span of the symbol being defined in the originating source file.
         */
        function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
            return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
        }
        LocationLink.create = create;
        /**
         * Checks whether the given literal conforms to the {@link LocationLink} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri)
                && Range.is(candidate.targetSelectionRange)
                && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
        }
        LocationLink.is = is;
    })(LocationLink || (exports.LocationLink = LocationLink = {}));
    /**
     * The Color namespace provides helper functions to work with
     * {@link Color} literals.
     */
    var Color;
    (function (Color) {
        /**
         * Creates a new Color literal.
         */
        function create(red, green, blue, alpha) {
            return {
                red: red,
                green: green,
                blue: blue,
                alpha: alpha,
            };
        }
        Color.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Color} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1)
                && Is.numberRange(candidate.green, 0, 1)
                && Is.numberRange(candidate.blue, 0, 1)
                && Is.numberRange(candidate.alpha, 0, 1);
        }
        Color.is = is;
    })(Color || (exports.Color = Color = {}));
    /**
     * The ColorInformation namespace provides helper functions to work with
     * {@link ColorInformation} literals.
     */
    var ColorInformation;
    (function (ColorInformation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(range, color) {
            return {
                range: range,
                color: color,
            };
        }
        ColorInformation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
        }
        ColorInformation.is = is;
    })(ColorInformation || (exports.ColorInformation = ColorInformation = {}));
    /**
     * The Color namespace provides helper functions to work with
     * {@link ColorPresentation} literals.
     */
    var ColorPresentation;
    (function (ColorPresentation) {
        /**
         * Creates a new ColorInformation literal.
         */
        function create(label, textEdit, additionalTextEdits) {
            return {
                label: label,
                textEdit: textEdit,
                additionalTextEdits: additionalTextEdits,
            };
        }
        ColorPresentation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ColorInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label)
                && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
                && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
        }
        ColorPresentation.is = is;
    })(ColorPresentation || (exports.ColorPresentation = ColorPresentation = {}));
    /**
     * A set of predefined range kinds.
     */
    var FoldingRangeKind;
    (function (FoldingRangeKind) {
        /**
         * Folding range for a comment
         */
        FoldingRangeKind.Comment = 'comment';
        /**
         * Folding range for an import or include
         */
        FoldingRangeKind.Imports = 'imports';
        /**
         * Folding range for a region (e.g. `#region`)
         */
        FoldingRangeKind.Region = 'region';
    })(FoldingRangeKind || (exports.FoldingRangeKind = FoldingRangeKind = {}));
    /**
     * The folding range namespace provides helper functions to work with
     * {@link FoldingRange} literals.
     */
    var FoldingRange;
    (function (FoldingRange) {
        /**
         * Creates a new FoldingRange literal.
         */
        function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
            var result = {
                startLine: startLine,
                endLine: endLine
            };
            if (Is.defined(startCharacter)) {
                result.startCharacter = startCharacter;
            }
            if (Is.defined(endCharacter)) {
                result.endCharacter = endCharacter;
            }
            if (Is.defined(kind)) {
                result.kind = kind;
            }
            if (Is.defined(collapsedText)) {
                result.collapsedText = collapsedText;
            }
            return result;
        }
        FoldingRange.create = create;
        /**
         * Checks whether the given literal conforms to the {@link FoldingRange} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine)
                && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter))
                && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter))
                && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
        }
        FoldingRange.is = is;
    })(FoldingRange || (exports.FoldingRange = FoldingRange = {}));
    /**
     * The DiagnosticRelatedInformation namespace provides helper functions to work with
     * {@link DiagnosticRelatedInformation} literals.
     */
    var DiagnosticRelatedInformation;
    (function (DiagnosticRelatedInformation) {
        /**
         * Creates a new DiagnosticRelatedInformation literal.
         */
        function create(location, message) {
            return {
                location: location,
                message: message
            };
        }
        DiagnosticRelatedInformation.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
        }
        DiagnosticRelatedInformation.is = is;
    })(DiagnosticRelatedInformation || (exports.DiagnosticRelatedInformation = DiagnosticRelatedInformation = {}));
    /**
     * The diagnostic's severity.
     */
    var DiagnosticSeverity;
    (function (DiagnosticSeverity) {
        /**
         * Reports an error.
         */
        DiagnosticSeverity.Error = 1;
        /**
         * Reports a warning.
         */
        DiagnosticSeverity.Warning = 2;
        /**
         * Reports an information.
         */
        DiagnosticSeverity.Information = 3;
        /**
         * Reports a hint.
         */
        DiagnosticSeverity.Hint = 4;
    })(DiagnosticSeverity || (exports.DiagnosticSeverity = DiagnosticSeverity = {}));
    /**
     * The diagnostic tags.
     *
     * @since 3.15.0
     */
    var DiagnosticTag;
    (function (DiagnosticTag) {
        /**
         * Unused or unnecessary code.
         *
         * Clients are allowed to render diagnostics with this tag faded out instead of having
         * an error squiggle.
         */
        DiagnosticTag.Unnecessary = 1;
        /**
         * Deprecated or obsolete code.
         *
         * Clients are allowed to rendered diagnostics with this tag strike through.
         */
        DiagnosticTag.Deprecated = 2;
    })(DiagnosticTag || (exports.DiagnosticTag = DiagnosticTag = {}));
    /**
     * The CodeDescription namespace provides functions to deal with descriptions for diagnostic codes.
     *
     * @since 3.16.0
     */
    var CodeDescription;
    (function (CodeDescription) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.href);
        }
        CodeDescription.is = is;
    })(CodeDescription || (exports.CodeDescription = CodeDescription = {}));
    /**
     * The Diagnostic namespace provides helper functions to work with
     * {@link Diagnostic} literals.
     */
    var Diagnostic;
    (function (Diagnostic) {
        /**
         * Creates a new Diagnostic literal.
         */
        function create(range, message, severity, code, source, relatedInformation) {
            var result = { range: range, message: message };
            if (Is.defined(severity)) {
                result.severity = severity;
            }
            if (Is.defined(code)) {
                result.code = code;
            }
            if (Is.defined(source)) {
                result.source = source;
            }
            if (Is.defined(relatedInformation)) {
                result.relatedInformation = relatedInformation;
            }
            return result;
        }
        Diagnostic.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Diagnostic} interface.
         */
        function is(value) {
            var _a;
            var candidate = value;
            return Is.defined(candidate)
                && Range.is(candidate.range)
                && Is.string(candidate.message)
                && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
                && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
                && (Is.undefined(candidate.codeDescription) || (Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)))
                && (Is.string(candidate.source) || Is.undefined(candidate.source))
                && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
        }
        Diagnostic.is = is;
    })(Diagnostic || (exports.Diagnostic = Diagnostic = {}));
    /**
     * The Command namespace provides helper functions to work with
     * {@link Command} literals.
     */
    var Command;
    (function (Command) {
        /**
         * Creates a new Command literal.
         */
        function create(title, command) {
            var args = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                args[_i - 2] = arguments[_i];
            }
            var result = { title: title, command: command };
            if (Is.defined(args) && args.length > 0) {
                result.arguments = args;
            }
            return result;
        }
        Command.create = create;
        /**
         * Checks whether the given literal conforms to the {@link Command} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
        }
        Command.is = is;
    })(Command || (exports.Command = Command = {}));
    /**
     * The TextEdit namespace provides helper function to create replace,
     * insert and delete edits more easily.
     */
    var TextEdit;
    (function (TextEdit) {
        /**
         * Creates a replace text edit.
         * @param range The range of text to be replaced.
         * @param newText The new text.
         */
        function replace(range, newText) {
            return { range: range, newText: newText };
        }
        TextEdit.replace = replace;
        /**
         * Creates an insert text edit.
         * @param position The position to insert the text at.
         * @param newText The text to be inserted.
         */
        function insert(position, newText) {
            return { range: { start: position, end: position }, newText: newText };
        }
        TextEdit.insert = insert;
        /**
         * Creates a delete text edit.
         * @param range The range of text to be deleted.
         */
        function del(range) {
            return { range: range, newText: '' };
        }
        TextEdit.del = del;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate)
                && Is.string(candidate.newText)
                && Range.is(candidate.range);
        }
        TextEdit.is = is;
    })(TextEdit || (exports.TextEdit = TextEdit = {}));
    var ChangeAnnotation;
    (function (ChangeAnnotation) {
        function create(label, needsConfirmation, description) {
            var result = { label: label };
            if (needsConfirmation !== undefined) {
                result.needsConfirmation = needsConfirmation;
            }
            if (description !== undefined) {
                result.description = description;
            }
            return result;
        }
        ChangeAnnotation.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Is.string(candidate.label) &&
                (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) &&
                (Is.string(candidate.description) || candidate.description === undefined);
        }
        ChangeAnnotation.is = is;
    })(ChangeAnnotation || (exports.ChangeAnnotation = ChangeAnnotation = {}));
    var ChangeAnnotationIdentifier;
    (function (ChangeAnnotationIdentifier) {
        function is(value) {
            var candidate = value;
            return Is.string(candidate);
        }
        ChangeAnnotationIdentifier.is = is;
    })(ChangeAnnotationIdentifier || (exports.ChangeAnnotationIdentifier = ChangeAnnotationIdentifier = {}));
    var AnnotatedTextEdit;
    (function (AnnotatedTextEdit) {
        /**
         * Creates an annotated replace text edit.
         *
         * @param range The range of text to be replaced.
         * @param newText The new text.
         * @param annotation The annotation.
         */
        function replace(range, newText, annotation) {
            return { range: range, newText: newText, annotationId: annotation };
        }
        AnnotatedTextEdit.replace = replace;
        /**
         * Creates an annotated insert text edit.
         *
         * @param position The position to insert the text at.
         * @param newText The text to be inserted.
         * @param annotation The annotation.
         */
        function insert(position, newText, annotation) {
            return { range: { start: position, end: position }, newText: newText, annotationId: annotation };
        }
        AnnotatedTextEdit.insert = insert;
        /**
         * Creates an annotated delete text edit.
         *
         * @param range The range of text to be deleted.
         * @param annotation The annotation.
         */
        function del(range, annotation) {
            return { range: range, newText: '', annotationId: annotation };
        }
        AnnotatedTextEdit.del = del;
        function is(value) {
            var candidate = value;
            return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        AnnotatedTextEdit.is = is;
    })(AnnotatedTextEdit || (exports.AnnotatedTextEdit = AnnotatedTextEdit = {}));
    /**
     * The TextDocumentEdit namespace provides helper function to create
     * an edit that manipulates a text document.
     */
    var TextDocumentEdit;
    (function (TextDocumentEdit) {
        /**
         * Creates a new `TextDocumentEdit`
         */
        function create(textDocument, edits) {
            return { textDocument: textDocument, edits: edits };
        }
        TextDocumentEdit.create = create;
        function is(value) {
            var candidate = value;
            return Is.defined(candidate)
                && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument)
                && Array.isArray(candidate.edits);
        }
        TextDocumentEdit.is = is;
    })(TextDocumentEdit || (exports.TextDocumentEdit = TextDocumentEdit = {}));
    var CreateFile;
    (function (CreateFile) {
        function create(uri, options, annotation) {
            var result = {
                kind: 'create',
                uri: uri
            };
            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        CreateFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined ||
                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        CreateFile.is = is;
    })(CreateFile || (exports.CreateFile = CreateFile = {}));
    var RenameFile;
    (function (RenameFile) {
        function create(oldUri, newUri, options, annotation) {
            var result = {
                kind: 'rename',
                oldUri: oldUri,
                newUri: newUri
            };
            if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        RenameFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined ||
                ((candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        RenameFile.is = is;
    })(RenameFile || (exports.RenameFile = RenameFile = {}));
    var DeleteFile;
    (function (DeleteFile) {
        function create(uri, options, annotation) {
            var result = {
                kind: 'delete',
                uri: uri
            };
            if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
                result.options = options;
            }
            if (annotation !== undefined) {
                result.annotationId = annotation;
            }
            return result;
        }
        DeleteFile.create = create;
        function is(value) {
            var candidate = value;
            return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined ||
                ((candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists)))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
        }
        DeleteFile.is = is;
    })(DeleteFile || (exports.DeleteFile = DeleteFile = {}));
    var WorkspaceEdit;
    (function (WorkspaceEdit) {
        function is(value) {
            var candidate = value;
            return candidate &&
                (candidate.changes !== undefined || candidate.documentChanges !== undefined) &&
                (candidate.documentChanges === undefined || candidate.documentChanges.every(function (change) {
                    if (Is.string(change.kind)) {
                        return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                    }
                    else {
                        return TextDocumentEdit.is(change);
                    }
                }));
        }
        WorkspaceEdit.is = is;
    })(WorkspaceEdit || (exports.WorkspaceEdit = WorkspaceEdit = {}));
    var TextEditChangeImpl = /** @class */ (function () {
        function TextEditChangeImpl(edits, changeAnnotations) {
            this.edits = edits;
            this.changeAnnotations = changeAnnotations;
        }
        TextEditChangeImpl.prototype.insert = function (position, newText, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.insert(position, newText);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.insert(position, newText, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.insert(position, newText, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.replace = function (range, newText, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.replace(range, newText);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.replace(range, newText, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.replace(range, newText, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.delete = function (range, annotation) {
            var edit;
            var id;
            if (annotation === undefined) {
                edit = TextEdit.del(range);
            }
            else if (ChangeAnnotationIdentifier.is(annotation)) {
                id = annotation;
                edit = AnnotatedTextEdit.del(range, annotation);
            }
            else {
                this.assertChangeAnnotations(this.changeAnnotations);
                id = this.changeAnnotations.manage(annotation);
                edit = AnnotatedTextEdit.del(range, id);
            }
            this.edits.push(edit);
            if (id !== undefined) {
                return id;
            }
        };
        TextEditChangeImpl.prototype.add = function (edit) {
            this.edits.push(edit);
        };
        TextEditChangeImpl.prototype.all = function () {
            return this.edits;
        };
        TextEditChangeImpl.prototype.clear = function () {
            this.edits.splice(0, this.edits.length);
        };
        TextEditChangeImpl.prototype.assertChangeAnnotations = function (value) {
            if (value === undefined) {
                throw new Error("Text edit change is not configured to manage change annotations.");
            }
        };
        return TextEditChangeImpl;
    }());
    /**
     * A helper class
     */
    var ChangeAnnotations = /** @class */ (function () {
        function ChangeAnnotations(annotations) {
            this._annotations = annotations === undefined ? Object.create(null) : annotations;
            this._counter = 0;
            this._size = 0;
        }
        ChangeAnnotations.prototype.all = function () {
            return this._annotations;
        };
        Object.defineProperty(ChangeAnnotations.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: false,
            configurable: true
        });
        ChangeAnnotations.prototype.manage = function (idOrAnnotation, annotation) {
            var id;
            if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
                id = idOrAnnotation;
            }
            else {
                id = this.nextId();
                annotation = idOrAnnotation;
            }
            if (this._annotations[id] !== undefined) {
                throw new Error("Id ".concat(id, " is already in use."));
            }
            if (annotation === undefined) {
                throw new Error("No annotation provided for id ".concat(id));
            }
            this._annotations[id] = annotation;
            this._size++;
            return id;
        };
        ChangeAnnotations.prototype.nextId = function () {
            this._counter++;
            return this._counter.toString();
        };
        return ChangeAnnotations;
    }());
    /**
     * A workspace change helps constructing changes to a workspace.
     */
    var WorkspaceChange = /** @class */ (function () {
        function WorkspaceChange(workspaceEdit) {
            var _this = this;
            this._textEditChanges = Object.create(null);
            if (workspaceEdit !== undefined) {
                this._workspaceEdit = workspaceEdit;
                if (workspaceEdit.documentChanges) {
                    this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                    workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                    workspaceEdit.documentChanges.forEach(function (change) {
                        if (TextDocumentEdit.is(change)) {
                            var textEditChange = new TextEditChangeImpl(change.edits, _this._changeAnnotations);
                            _this._textEditChanges[change.textDocument.uri] = textEditChange;
                        }
                    });
                }
                else if (workspaceEdit.changes) {
                    Object.keys(workspaceEdit.changes).forEach(function (key) {
                        var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                        _this._textEditChanges[key] = textEditChange;
                    });
                }
            }
            else {
                this._workspaceEdit = {};
            }
        }
        Object.defineProperty(WorkspaceChange.prototype, "edit", {
            /**
             * Returns the underlying {@link WorkspaceEdit} literal
             * use to be returned from a workspace edit operation like rename.
             */
            get: function () {
                this.initDocumentChanges();
                if (this._changeAnnotations !== undefined) {
                    if (this._changeAnnotations.size === 0) {
                        this._workspaceEdit.changeAnnotations = undefined;
                    }
                    else {
                        this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                    }
                }
                return this._workspaceEdit;
            },
            enumerable: false,
            configurable: true
        });
        WorkspaceChange.prototype.getTextEditChange = function (key) {
            if (OptionalVersionedTextDocumentIdentifier.is(key)) {
                this.initDocumentChanges();
                if (this._workspaceEdit.documentChanges === undefined) {
                    throw new Error('Workspace edit is not configured for document changes.');
                }
                var textDocument = { uri: key.uri, version: key.version };
                var result = this._textEditChanges[textDocument.uri];
                if (!result) {
                    var edits = [];
                    var textDocumentEdit = {
                        textDocument: textDocument,
                        edits: edits
                    };
                    this._workspaceEdit.documentChanges.push(textDocumentEdit);
                    result = new TextEditChangeImpl(edits, this._changeAnnotations);
                    this._textEditChanges[textDocument.uri] = result;
                }
                return result;
            }
            else {
                this.initChanges();
                if (this._workspaceEdit.changes === undefined) {
                    throw new Error('Workspace edit is not configured for normal text edit changes.');
                }
                var result = this._textEditChanges[key];
                if (!result) {
                    var edits = [];
                    this._workspaceEdit.changes[key] = edits;
                    result = new TextEditChangeImpl(edits);
                    this._textEditChanges[key] = result;
                }
                return result;
            }
        };
        WorkspaceChange.prototype.initDocumentChanges = function () {
            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                this._changeAnnotations = new ChangeAnnotations();
                this._workspaceEdit.documentChanges = [];
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
        };
        WorkspaceChange.prototype.initChanges = function () {
            if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
                this._workspaceEdit.changes = Object.create(null);
            }
        };
        WorkspaceChange.prototype.createFile = function (uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = CreateFile.create(uri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = CreateFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        WorkspaceChange.prototype.renameFile = function (oldUri, newUri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = RenameFile.create(oldUri, newUri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = RenameFile.create(oldUri, newUri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        WorkspaceChange.prototype.deleteFile = function (uri, optionsOrAnnotation, options) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var annotation;
            if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
                annotation = optionsOrAnnotation;
            }
            else {
                options = optionsOrAnnotation;
            }
            var operation;
            var id;
            if (annotation === undefined) {
                operation = DeleteFile.create(uri, options);
            }
            else {
                id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
                operation = DeleteFile.create(uri, options, id);
            }
            this._workspaceEdit.documentChanges.push(operation);
            if (id !== undefined) {
                return id;
            }
        };
        return WorkspaceChange;
    }());
    exports.WorkspaceChange = WorkspaceChange;
    /**
     * The TextDocumentIdentifier namespace provides helper functions to work with
     * {@link TextDocumentIdentifier} literals.
     */
    var TextDocumentIdentifier;
    (function (TextDocumentIdentifier) {
        /**
         * Creates a new TextDocumentIdentifier literal.
         * @param uri The document's uri.
         */
        function create(uri) {
            return { uri: uri };
        }
        TextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri);
        }
        TextDocumentIdentifier.is = is;
    })(TextDocumentIdentifier || (exports.TextDocumentIdentifier = TextDocumentIdentifier = {}));
    /**
     * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
     * {@link VersionedTextDocumentIdentifier} literals.
     */
    var VersionedTextDocumentIdentifier;
    (function (VersionedTextDocumentIdentifier) {
        /**
         * Creates a new VersionedTextDocumentIdentifier literal.
         * @param uri The document's uri.
         * @param version The document's version.
         */
        function create(uri, version) {
            return { uri: uri, version: version };
        }
        VersionedTextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
        }
        VersionedTextDocumentIdentifier.is = is;
    })(VersionedTextDocumentIdentifier || (exports.VersionedTextDocumentIdentifier = VersionedTextDocumentIdentifier = {}));
    /**
     * The OptionalVersionedTextDocumentIdentifier namespace provides helper functions to work with
     * {@link OptionalVersionedTextDocumentIdentifier} literals.
     */
    var OptionalVersionedTextDocumentIdentifier;
    (function (OptionalVersionedTextDocumentIdentifier) {
        /**
         * Creates a new OptionalVersionedTextDocumentIdentifier literal.
         * @param uri The document's uri.
         * @param version The document's version.
         */
        function create(uri, version) {
            return { uri: uri, version: version };
        }
        OptionalVersionedTextDocumentIdentifier.create = create;
        /**
         * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
        }
        OptionalVersionedTextDocumentIdentifier.is = is;
    })(OptionalVersionedTextDocumentIdentifier || (exports.OptionalVersionedTextDocumentIdentifier = OptionalVersionedTextDocumentIdentifier = {}));
    /**
     * The TextDocumentItem namespace provides helper functions to work with
     * {@link TextDocumentItem} literals.
     */
    var TextDocumentItem;
    (function (TextDocumentItem) {
        /**
         * Creates a new TextDocumentItem literal.
         * @param uri The document's uri.
         * @param languageId The document's language identifier.
         * @param version The document's version number.
         * @param text The document's text.
         */
        function create(uri, languageId, version, text) {
            return { uri: uri, languageId: languageId, version: version, text: text };
        }
        TextDocumentItem.create = create;
        /**
         * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
        }
        TextDocumentItem.is = is;
    })(TextDocumentItem || (exports.TextDocumentItem = TextDocumentItem = {}));
    /**
     * Describes the content type that a client supports in various
     * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
     *
     * Please note that `MarkupKinds` must not start with a `$`. This kinds
     * are reserved for internal usage.
     */
    var MarkupKind;
    (function (MarkupKind) {
        /**
         * Plain text is supported as a content format
         */
        MarkupKind.PlainText = 'plaintext';
        /**
         * Markdown is supported as a content format
         */
        MarkupKind.Markdown = 'markdown';
        /**
         * Checks whether the given value is a value of the {@link MarkupKind} type.
         */
        function is(value) {
            var candidate = value;
            return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
        }
        MarkupKind.is = is;
    })(MarkupKind || (exports.MarkupKind = MarkupKind = {}));
    var MarkupContent;
    (function (MarkupContent) {
        /**
         * Checks whether the given value conforms to the {@link MarkupContent} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
        }
        MarkupContent.is = is;
    })(MarkupContent || (exports.MarkupContent = MarkupContent = {}));
    /**
     * The kind of a completion entry.
     */
    var CompletionItemKind;
    (function (CompletionItemKind) {
        CompletionItemKind.Text = 1;
        CompletionItemKind.Method = 2;
        CompletionItemKind.Function = 3;
        CompletionItemKind.Constructor = 4;
        CompletionItemKind.Field = 5;
        CompletionItemKind.Variable = 6;
        CompletionItemKind.Class = 7;
        CompletionItemKind.Interface = 8;
        CompletionItemKind.Module = 9;
        CompletionItemKind.Property = 10;
        CompletionItemKind.Unit = 11;
        CompletionItemKind.Value = 12;
        CompletionItemKind.Enum = 13;
        CompletionItemKind.Keyword = 14;
        CompletionItemKind.Snippet = 15;
        CompletionItemKind.Color = 16;
        CompletionItemKind.File = 17;
        CompletionItemKind.Reference = 18;
        CompletionItemKind.Folder = 19;
        CompletionItemKind.EnumMember = 20;
        CompletionItemKind.Constant = 21;
        CompletionItemKind.Struct = 22;
        CompletionItemKind.Event = 23;
        CompletionItemKind.Operator = 24;
        CompletionItemKind.TypeParameter = 25;
    })(CompletionItemKind || (exports.CompletionItemKind = CompletionItemKind = {}));
    /**
     * Defines whether the insert text in a completion item should be interpreted as
     * plain text or a snippet.
     */
    var InsertTextFormat;
    (function (InsertTextFormat) {
        /**
         * The primary text to be inserted is treated as a plain string.
         */
        InsertTextFormat.PlainText = 1;
        /**
         * The primary text to be inserted is treated as a snippet.
         *
         * A snippet can define tab stops and placeholders with `$1`, `$2`
         * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
         * the end of the snippet. Placeholders with equal identifiers are linked,
         * that is typing in one will update others too.
         *
         * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
         */
        InsertTextFormat.Snippet = 2;
    })(InsertTextFormat || (exports.InsertTextFormat = InsertTextFormat = {}));
    /**
     * Completion item tags are extra annotations that tweak the rendering of a completion
     * item.
     *
     * @since 3.15.0
     */
    var CompletionItemTag;
    (function (CompletionItemTag) {
        /**
         * Render a completion as obsolete, usually using a strike-out.
         */
        CompletionItemTag.Deprecated = 1;
    })(CompletionItemTag || (exports.CompletionItemTag = CompletionItemTag = {}));
    /**
     * The InsertReplaceEdit namespace provides functions to deal with insert / replace edits.
     *
     * @since 3.16.0
     */
    var InsertReplaceEdit;
    (function (InsertReplaceEdit) {
        /**
         * Creates a new insert / replace edit
         */
        function create(newText, insert, replace) {
            return { newText: newText, insert: insert, replace: replace };
        }
        InsertReplaceEdit.create = create;
        /**
         * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
         */
        function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
        }
        InsertReplaceEdit.is = is;
    })(InsertReplaceEdit || (exports.InsertReplaceEdit = InsertReplaceEdit = {}));
    /**
     * How whitespace and indentation is handled during completion
     * item insertion.
     *
     * @since 3.16.0
     */
    var InsertTextMode;
    (function (InsertTextMode) {
        /**
         * The insertion or replace strings is taken as it is. If the
         * value is multi line the lines below the cursor will be
         * inserted using the indentation defined in the string value.
         * The client will not apply any kind of adjustments to the
         * string.
         */
        InsertTextMode.asIs = 1;
        /**
         * The editor adjusts leading whitespace of new lines so that
         * they match the indentation up to the cursor of the line for
         * which the item is accepted.
         *
         * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
         * multi line completion item is indented using 2 tabs and all
         * following lines inserted will be indented using 2 tabs as well.
         */
        InsertTextMode.adjustIndentation = 2;
    })(InsertTextMode || (exports.InsertTextMode = InsertTextMode = {}));
    var CompletionItemLabelDetails;
    (function (CompletionItemLabelDetails) {
        function is(value) {
            var candidate = value;
            return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) &&
                (Is.string(candidate.description) || candidate.description === undefined);
        }
        CompletionItemLabelDetails.is = is;
    })(CompletionItemLabelDetails || (exports.CompletionItemLabelDetails = CompletionItemLabelDetails = {}));
    /**
     * The CompletionItem namespace provides functions to deal with
     * completion items.
     */
    var CompletionItem;
    (function (CompletionItem) {
        /**
         * Create a completion item and seed it with a label.
         * @param label The completion item's label
         */
        function create(label) {
            return { label: label };
        }
        CompletionItem.create = create;
    })(CompletionItem || (exports.CompletionItem = CompletionItem = {}));
    /**
     * The CompletionList namespace provides functions to deal with
     * completion lists.
     */
    var CompletionList;
    (function (CompletionList) {
        /**
         * Creates a new completion list.
         *
         * @param items The completion items.
         * @param isIncomplete The list is not complete.
         */
        function create(items, isIncomplete) {
            return { items: items ? items : [], isIncomplete: !!isIncomplete };
        }
        CompletionList.create = create;
    })(CompletionList || (exports.CompletionList = CompletionList = {}));
    var MarkedString;
    (function (MarkedString) {
        /**
         * Creates a marked string from plain text.
         *
         * @param plainText The plain text.
         */
        function fromPlainText(plainText) {
            return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
        }
        MarkedString.fromPlainText = fromPlainText;
        /**
         * Checks whether the given value conforms to the {@link MarkedString} type.
         */
        function is(value) {
            var candidate = value;
            return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
        }
        MarkedString.is = is;
    })(MarkedString || (exports.MarkedString = MarkedString = {}));
    var Hover;
    (function (Hover) {
        /**
         * Checks whether the given value conforms to the {@link Hover} interface.
         */
        function is(value) {
            var candidate = value;
            return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
                MarkedString.is(candidate.contents) ||
                Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
        }
        Hover.is = is;
    })(Hover || (exports.Hover = Hover = {}));
    /**
     * The ParameterInformation namespace provides helper functions to work with
     * {@link ParameterInformation} literals.
     */
    var ParameterInformation;
    (function (ParameterInformation) {
        /**
         * Creates a new parameter information literal.
         *
         * @param label A label string.
         * @param documentation A doc string.
         */
        function create(label, documentation) {
            return documentation ? { label: label, documentation: documentation } : { label: label };
        }
        ParameterInformation.create = create;
    })(ParameterInformation || (exports.ParameterInformation = ParameterInformation = {}));
    /**
     * The SignatureInformation namespace provides helper functions to work with
     * {@link SignatureInformation} literals.
     */
    var SignatureInformation;
    (function (SignatureInformation) {
        function create(label, documentation) {
            var parameters = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                parameters[_i - 2] = arguments[_i];
            }
            var result = { label: label };
            if (Is.defined(documentation)) {
                result.documentation = documentation;
            }
            if (Is.defined(parameters)) {
                result.parameters = parameters;
            }
            else {
                result.parameters = [];
            }
            return result;
        }
        SignatureInformation.create = create;
    })(SignatureInformation || (exports.SignatureInformation = SignatureInformation = {}));
    /**
     * A document highlight kind.
     */
    var DocumentHighlightKind;
    (function (DocumentHighlightKind) {
        /**
         * A textual occurrence.
         */
        DocumentHighlightKind.Text = 1;
        /**
         * Read-access of a symbol, like reading a variable.
         */
        DocumentHighlightKind.Read = 2;
        /**
         * Write-access of a symbol, like writing to a variable.
         */
        DocumentHighlightKind.Write = 3;
    })(DocumentHighlightKind || (exports.DocumentHighlightKind = DocumentHighlightKind = {}));
    /**
     * DocumentHighlight namespace to provide helper functions to work with
     * {@link DocumentHighlight} literals.
     */
    var DocumentHighlight;
    (function (DocumentHighlight) {
        /**
         * Create a DocumentHighlight object.
         * @param range The range the highlight applies to.
         * @param kind The highlight kind
         */
        function create(range, kind) {
            var result = { range: range };
            if (Is.number(kind)) {
                result.kind = kind;
            }
            return result;
        }
        DocumentHighlight.create = create;
    })(DocumentHighlight || (exports.DocumentHighlight = DocumentHighlight = {}));
    /**
     * A symbol kind.
     */
    var SymbolKind;
    (function (SymbolKind) {
        SymbolKind.File = 1;
        SymbolKind.Module = 2;
        SymbolKind.Namespace = 3;
        SymbolKind.Package = 4;
        SymbolKind.Class = 5;
        SymbolKind.Method = 6;
        SymbolKind.Property = 7;
        SymbolKind.Field = 8;
        SymbolKind.Constructor = 9;
        SymbolKind.Enum = 10;
        SymbolKind.Interface = 11;
        SymbolKind.Function = 12;
        SymbolKind.Variable = 13;
        SymbolKind.Constant = 14;
        SymbolKind.String = 15;
        SymbolKind.Number = 16;
        SymbolKind.Boolean = 17;
        SymbolKind.Array = 18;
        SymbolKind.Object = 19;
        SymbolKind.Key = 20;
        SymbolKind.Null = 21;
        SymbolKind.EnumMember = 22;
        SymbolKind.Struct = 23;
        SymbolKind.Event = 24;
        SymbolKind.Operator = 25;
        SymbolKind.TypeParameter = 26;
    })(SymbolKind || (exports.SymbolKind = SymbolKind = {}));
    /**
     * Symbol tags are extra annotations that tweak the rendering of a symbol.
     *
     * @since 3.16
     */
    var SymbolTag;
    (function (SymbolTag) {
        /**
         * Render a symbol as obsolete, usually using a strike-out.
         */
        SymbolTag.Deprecated = 1;
    })(SymbolTag || (exports.SymbolTag = SymbolTag = {}));
    var SymbolInformation;
    (function (SymbolInformation) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the location of the symbol.
         * @param uri The resource of the location of symbol.
         * @param containerName The name of the symbol containing the symbol.
         */
        function create(name, kind, range, uri, containerName) {
            var result = {
                name: name,
                kind: kind,
                location: { uri: uri, range: range }
            };
            if (containerName) {
                result.containerName = containerName;
            }
            return result;
        }
        SymbolInformation.create = create;
    })(SymbolInformation || (exports.SymbolInformation = SymbolInformation = {}));
    var WorkspaceSymbol;
    (function (WorkspaceSymbol) {
        /**
         * Create a new workspace symbol.
         *
         * @param name The name of the symbol.
         * @param kind The kind of the symbol.
         * @param uri The resource of the location of the symbol.
         * @param range An options range of the location.
         * @returns A WorkspaceSymbol.
         */
        function create(name, kind, uri, range) {
            return range !== undefined
                ? { name: name, kind: kind, location: { uri: uri, range: range } }
                : { name: name, kind: kind, location: { uri: uri } };
        }
        WorkspaceSymbol.create = create;
    })(WorkspaceSymbol || (exports.WorkspaceSymbol = WorkspaceSymbol = {}));
    var DocumentSymbol;
    (function (DocumentSymbol) {
        /**
         * Creates a new symbol information literal.
         *
         * @param name The name of the symbol.
         * @param detail The detail of the symbol.
         * @param kind The kind of the symbol.
         * @param range The range of the symbol.
         * @param selectionRange The selectionRange of the symbol.
         * @param children Children of the symbol.
         */
        function create(name, detail, kind, range, selectionRange, children) {
            var result = {
                name: name,
                detail: detail,
                kind: kind,
                range: range,
                selectionRange: selectionRange
            };
            if (children !== undefined) {
                result.children = children;
            }
            return result;
        }
        DocumentSymbol.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
         */
        function is(value) {
            var candidate = value;
            return candidate &&
                Is.string(candidate.name) && Is.number(candidate.kind) &&
                Range.is(candidate.range) && Range.is(candidate.selectionRange) &&
                (candidate.detail === undefined || Is.string(candidate.detail)) &&
                (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) &&
                (candidate.children === undefined || Array.isArray(candidate.children)) &&
                (candidate.tags === undefined || Array.isArray(candidate.tags));
        }
        DocumentSymbol.is = is;
    })(DocumentSymbol || (exports.DocumentSymbol = DocumentSymbol = {}));
    /**
     * A set of predefined code action kinds
     */
    var CodeActionKind;
    (function (CodeActionKind) {
        /**
         * Empty kind.
         */
        CodeActionKind.Empty = '';
        /**
         * Base kind for quickfix actions: 'quickfix'
         */
        CodeActionKind.QuickFix = 'quickfix';
        /**
         * Base kind for refactoring actions: 'refactor'
         */
        CodeActionKind.Refactor = 'refactor';
        /**
         * Base kind for refactoring extraction actions: 'refactor.extract'
         *
         * Example extract actions:
         *
         * - Extract method
         * - Extract function
         * - Extract variable
         * - Extract interface from class
         * - ...
         */
        CodeActionKind.RefactorExtract = 'refactor.extract';
        /**
         * Base kind for refactoring inline actions: 'refactor.inline'
         *
         * Example inline actions:
         *
         * - Inline function
         * - Inline variable
         * - Inline constant
         * - ...
         */
        CodeActionKind.RefactorInline = 'refactor.inline';
        /**
         * Base kind for refactoring rewrite actions: 'refactor.rewrite'
         *
         * Example rewrite actions:
         *
         * - Convert JavaScript function to class
         * - Add or remove parameter
         * - Encapsulate field
         * - Make method static
         * - Move method to base class
         * - ...
         */
        CodeActionKind.RefactorRewrite = 'refactor.rewrite';
        /**
         * Base kind for source actions: `source`
         *
         * Source code actions apply to the entire file.
         */
        CodeActionKind.Source = 'source';
        /**
         * Base kind for an organize imports source action: `source.organizeImports`
         */
        CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
        /**
         * Base kind for auto-fix source actions: `source.fixAll`.
         *
         * Fix all actions automatically fix errors that have a clear fix that do not require user input.
         * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
         *
         * @since 3.15.0
         */
        CodeActionKind.SourceFixAll = 'source.fixAll';
    })(CodeActionKind || (exports.CodeActionKind = CodeActionKind = {}));
    /**
     * The reason why code actions were requested.
     *
     * @since 3.17.0
     */
    var CodeActionTriggerKind;
    (function (CodeActionTriggerKind) {
        /**
         * Code actions were explicitly requested by the user or by an extension.
         */
        CodeActionTriggerKind.Invoked = 1;
        /**
         * Code actions were requested automatically.
         *
         * This typically happens when current selection in a file changes, but can
         * also be triggered when file content changes.
         */
        CodeActionTriggerKind.Automatic = 2;
    })(CodeActionTriggerKind || (exports.CodeActionTriggerKind = CodeActionTriggerKind = {}));
    /**
     * The CodeActionContext namespace provides helper functions to work with
     * {@link CodeActionContext} literals.
     */
    var CodeActionContext;
    (function (CodeActionContext) {
        /**
         * Creates a new CodeActionContext literal.
         */
        function create(diagnostics, only, triggerKind) {
            var result = { diagnostics: diagnostics };
            if (only !== undefined && only !== null) {
                result.only = only;
            }
            if (triggerKind !== undefined && triggerKind !== null) {
                result.triggerKind = triggerKind;
            }
            return result;
        }
        CodeActionContext.create = create;
        /**
         * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is)
                && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string))
                && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
        }
        CodeActionContext.is = is;
    })(CodeActionContext || (exports.CodeActionContext = CodeActionContext = {}));
    var CodeAction;
    (function (CodeAction) {
        function create(title, kindOrCommandOrEdit, kind) {
            var result = { title: title };
            var checkKind = true;
            if (typeof kindOrCommandOrEdit === 'string') {
                checkKind = false;
                result.kind = kindOrCommandOrEdit;
            }
            else if (Command.is(kindOrCommandOrEdit)) {
                result.command = kindOrCommandOrEdit;
            }
            else {
                result.edit = kindOrCommandOrEdit;
            }
            if (checkKind && kind !== undefined) {
                result.kind = kind;
            }
            return result;
        }
        CodeAction.create = create;
        function is(value) {
            var candidate = value;
            return candidate && Is.string(candidate.title) &&
                (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
                (candidate.kind === undefined || Is.string(candidate.kind)) &&
                (candidate.edit !== undefined || candidate.command !== undefined) &&
                (candidate.command === undefined || Command.is(candidate.command)) &&
                (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) &&
                (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
        }
        CodeAction.is = is;
    })(CodeAction || (exports.CodeAction = CodeAction = {}));
    /**
     * The CodeLens namespace provides helper functions to work with
     * {@link CodeLens} literals.
     */
    var CodeLens;
    (function (CodeLens) {
        /**
         * Creates a new CodeLens literal.
         */
        function create(range, data) {
            var result = { range: range };
            if (Is.defined(data)) {
                result.data = data;
            }
            return result;
        }
        CodeLens.create = create;
        /**
         * Checks whether the given literal conforms to the {@link CodeLens} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
        }
        CodeLens.is = is;
    })(CodeLens || (exports.CodeLens = CodeLens = {}));
    /**
     * The FormattingOptions namespace provides helper functions to work with
     * {@link FormattingOptions} literals.
     */
    var FormattingOptions;
    (function (FormattingOptions) {
        /**
         * Creates a new FormattingOptions literal.
         */
        function create(tabSize, insertSpaces) {
            return { tabSize: tabSize, insertSpaces: insertSpaces };
        }
        FormattingOptions.create = create;
        /**
         * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
        }
        FormattingOptions.is = is;
    })(FormattingOptions || (exports.FormattingOptions = FormattingOptions = {}));
    /**
     * The DocumentLink namespace provides helper functions to work with
     * {@link DocumentLink} literals.
     */
    var DocumentLink;
    (function (DocumentLink) {
        /**
         * Creates a new DocumentLink literal.
         */
        function create(range, target, data) {
            return { range: range, target: target, data: data };
        }
        DocumentLink.create = create;
        /**
         * Checks whether the given literal conforms to the {@link DocumentLink} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
        }
        DocumentLink.is = is;
    })(DocumentLink || (exports.DocumentLink = DocumentLink = {}));
    /**
     * The SelectionRange namespace provides helper function to work with
     * SelectionRange literals.
     */
    var SelectionRange;
    (function (SelectionRange) {
        /**
         * Creates a new SelectionRange
         * @param range the range.
         * @param parent an optional parent.
         */
        function create(range, parent) {
            return { range: range, parent: parent };
        }
        SelectionRange.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
        }
        SelectionRange.is = is;
    })(SelectionRange || (exports.SelectionRange = SelectionRange = {}));
    /**
     * A set of predefined token types. This set is not fixed
     * an clients can specify additional token types via the
     * corresponding client capabilities.
     *
     * @since 3.16.0
     */
    var SemanticTokenTypes;
    (function (SemanticTokenTypes) {
        SemanticTokenTypes["namespace"] = "namespace";
        /**
         * Represents a generic type. Acts as a fallback for types which can't be mapped to
         * a specific type like class or enum.
         */
        SemanticTokenTypes["type"] = "type";
        SemanticTokenTypes["class"] = "class";
        SemanticTokenTypes["enum"] = "enum";
        SemanticTokenTypes["interface"] = "interface";
        SemanticTokenTypes["struct"] = "struct";
        SemanticTokenTypes["typeParameter"] = "typeParameter";
        SemanticTokenTypes["parameter"] = "parameter";
        SemanticTokenTypes["variable"] = "variable";
        SemanticTokenTypes["property"] = "property";
        SemanticTokenTypes["enumMember"] = "enumMember";
        SemanticTokenTypes["event"] = "event";
        SemanticTokenTypes["function"] = "function";
        SemanticTokenTypes["method"] = "method";
        SemanticTokenTypes["macro"] = "macro";
        SemanticTokenTypes["keyword"] = "keyword";
        SemanticTokenTypes["modifier"] = "modifier";
        SemanticTokenTypes["comment"] = "comment";
        SemanticTokenTypes["string"] = "string";
        SemanticTokenTypes["number"] = "number";
        SemanticTokenTypes["regexp"] = "regexp";
        SemanticTokenTypes["operator"] = "operator";
        /**
         * @since 3.17.0
         */
        SemanticTokenTypes["decorator"] = "decorator";
    })(SemanticTokenTypes || (exports.SemanticTokenTypes = SemanticTokenTypes = {}));
    /**
     * A set of predefined token modifiers. This set is not fixed
     * an clients can specify additional token types via the
     * corresponding client capabilities.
     *
     * @since 3.16.0
     */
    var SemanticTokenModifiers;
    (function (SemanticTokenModifiers) {
        SemanticTokenModifiers["declaration"] = "declaration";
        SemanticTokenModifiers["definition"] = "definition";
        SemanticTokenModifiers["readonly"] = "readonly";
        SemanticTokenModifiers["static"] = "static";
        SemanticTokenModifiers["deprecated"] = "deprecated";
        SemanticTokenModifiers["abstract"] = "abstract";
        SemanticTokenModifiers["async"] = "async";
        SemanticTokenModifiers["modification"] = "modification";
        SemanticTokenModifiers["documentation"] = "documentation";
        SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
    })(SemanticTokenModifiers || (exports.SemanticTokenModifiers = SemanticTokenModifiers = {}));
    /**
     * @since 3.16.0
     */
    var SemanticTokens;
    (function (SemanticTokens) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') &&
                Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
        }
        SemanticTokens.is = is;
    })(SemanticTokens || (exports.SemanticTokens = SemanticTokens = {}));
    /**
     * The InlineValueText namespace provides functions to deal with InlineValueTexts.
     *
     * @since 3.17.0
     */
    var InlineValueText;
    (function (InlineValueText) {
        /**
         * Creates a new InlineValueText literal.
         */
        function create(range, text) {
            return { range: range, text: text };
        }
        InlineValueText.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
        }
        InlineValueText.is = is;
    })(InlineValueText || (exports.InlineValueText = InlineValueText = {}));
    /**
     * The InlineValueVariableLookup namespace provides functions to deal with InlineValueVariableLookups.
     *
     * @since 3.17.0
     */
    var InlineValueVariableLookup;
    (function (InlineValueVariableLookup) {
        /**
         * Creates a new InlineValueText literal.
         */
        function create(range, variableName, caseSensitiveLookup) {
            return { range: range, variableName: variableName, caseSensitiveLookup: caseSensitiveLookup };
        }
        InlineValueVariableLookup.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup)
                && (Is.string(candidate.variableName) || candidate.variableName === undefined);
        }
        InlineValueVariableLookup.is = is;
    })(InlineValueVariableLookup || (exports.InlineValueVariableLookup = InlineValueVariableLookup = {}));
    /**
     * The InlineValueEvaluatableExpression namespace provides functions to deal with InlineValueEvaluatableExpression.
     *
     * @since 3.17.0
     */
    var InlineValueEvaluatableExpression;
    (function (InlineValueEvaluatableExpression) {
        /**
         * Creates a new InlineValueEvaluatableExpression literal.
         */
        function create(range, expression) {
            return { range: range, expression: expression };
        }
        InlineValueEvaluatableExpression.create = create;
        function is(value) {
            var candidate = value;
            return candidate !== undefined && candidate !== null && Range.is(candidate.range)
                && (Is.string(candidate.expression) || candidate.expression === undefined);
        }
        InlineValueEvaluatableExpression.is = is;
    })(InlineValueEvaluatableExpression || (exports.InlineValueEvaluatableExpression = InlineValueEvaluatableExpression = {}));
    /**
     * The InlineValueContext namespace provides helper functions to work with
     * {@link InlineValueContext} literals.
     *
     * @since 3.17.0
     */
    var InlineValueContext;
    (function (InlineValueContext) {
        /**
         * Creates a new InlineValueContext literal.
         */
        function create(frameId, stoppedLocation) {
            return { frameId: frameId, stoppedLocation: stoppedLocation };
        }
        InlineValueContext.create = create;
        /**
         * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Range.is(value.stoppedLocation);
        }
        InlineValueContext.is = is;
    })(InlineValueContext || (exports.InlineValueContext = InlineValueContext = {}));
    /**
     * Inlay hint kinds.
     *
     * @since 3.17.0
     */
    var InlayHintKind;
    (function (InlayHintKind) {
        /**
         * An inlay hint that for a type annotation.
         */
        InlayHintKind.Type = 1;
        /**
         * An inlay hint that is for a parameter.
         */
        InlayHintKind.Parameter = 2;
        function is(value) {
            return value === 1 || value === 2;
        }
        InlayHintKind.is = is;
    })(InlayHintKind || (exports.InlayHintKind = InlayHintKind = {}));
    var InlayHintLabelPart;
    (function (InlayHintLabelPart) {
        function create(value) {
            return { value: value };
        }
        InlayHintLabelPart.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate)
                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
                && (candidate.location === undefined || Location.is(candidate.location))
                && (candidate.command === undefined || Command.is(candidate.command));
        }
        InlayHintLabelPart.is = is;
    })(InlayHintLabelPart || (exports.InlayHintLabelPart = InlayHintLabelPart = {}));
    var InlayHint;
    (function (InlayHint) {
        function create(position, label, kind) {
            var result = { position: position, label: label };
            if (kind !== undefined) {
                result.kind = kind;
            }
            return result;
        }
        InlayHint.create = create;
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && Position.is(candidate.position)
                && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is))
                && (candidate.kind === undefined || InlayHintKind.is(candidate.kind))
                && (candidate.textEdits === undefined) || Is.typedArray(candidate.textEdits, TextEdit.is)
                && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip))
                && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft))
                && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
        }
        InlayHint.is = is;
    })(InlayHint || (exports.InlayHint = InlayHint = {}));
    var StringValue;
    (function (StringValue) {
        function createSnippet(value) {
            return { kind: 'snippet', value: value };
        }
        StringValue.createSnippet = createSnippet;
    })(StringValue || (exports.StringValue = StringValue = {}));
    var InlineCompletionItem;
    (function (InlineCompletionItem) {
        function create(insertText, filterText, range, command) {
            return { insertText: insertText, filterText: filterText, range: range, command: command };
        }
        InlineCompletionItem.create = create;
    })(InlineCompletionItem || (exports.InlineCompletionItem = InlineCompletionItem = {}));
    var InlineCompletionList;
    (function (InlineCompletionList) {
        function create(items) {
            return { items: items };
        }
        InlineCompletionList.create = create;
    })(InlineCompletionList || (exports.InlineCompletionList = InlineCompletionList = {}));
    /**
     * Describes how an {@link InlineCompletionItemProvider inline completion provider} was triggered.
     *
     * @since 3.18.0
     * @proposed
     */
    var InlineCompletionTriggerKind;
    (function (InlineCompletionTriggerKind) {
        /**
         * Completion was triggered explicitly by a user gesture.
         */
        InlineCompletionTriggerKind.Invoked = 0;
        /**
         * Completion was triggered automatically while editing.
         */
        InlineCompletionTriggerKind.Automatic = 1;
    })(InlineCompletionTriggerKind || (exports.InlineCompletionTriggerKind = InlineCompletionTriggerKind = {}));
    var SelectedCompletionInfo;
    (function (SelectedCompletionInfo) {
        function create(range, text) {
            return { range: range, text: text };
        }
        SelectedCompletionInfo.create = create;
    })(SelectedCompletionInfo || (exports.SelectedCompletionInfo = SelectedCompletionInfo = {}));
    var InlineCompletionContext;
    (function (InlineCompletionContext) {
        function create(triggerKind, selectedCompletionInfo) {
            return { triggerKind: triggerKind, selectedCompletionInfo: selectedCompletionInfo };
        }
        InlineCompletionContext.create = create;
    })(InlineCompletionContext || (exports.InlineCompletionContext = InlineCompletionContext = {}));
    var WorkspaceFolder;
    (function (WorkspaceFolder) {
        function is(value) {
            var candidate = value;
            return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
        }
        WorkspaceFolder.is = is;
    })(WorkspaceFolder || (exports.WorkspaceFolder = WorkspaceFolder = {}));
    exports.EOL = ['\n', '\r\n', '\r'];
    /**
     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
     */
    var TextDocument;
    (function (TextDocument) {
        /**
         * Creates a new ITextDocument literal from the given uri and content.
         * @param uri The document's uri.
         * @param languageId The document's language Id.
         * @param version The document's version.
         * @param content The document's content.
         */
        function create(uri, languageId, version, content) {
            return new FullTextDocument(uri, languageId, version, content);
        }
        TextDocument.create = create;
        /**
         * Checks whether the given literal conforms to the {@link ITextDocument} interface.
         */
        function is(value) {
            var candidate = value;
            return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount)
                && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
        }
        TextDocument.is = is;
        function applyEdits(document, edits) {
            var text = document.getText();
            var sortedEdits = mergeSort(edits, function (a, b) {
                var diff = a.range.start.line - b.range.start.line;
                if (diff === 0) {
                    return a.range.start.character - b.range.start.character;
                }
                return diff;
            });
            var lastModifiedOffset = text.length;
            for (var i = sortedEdits.length - 1; i >= 0; i--) {
                var e = sortedEdits[i];
                var startOffset = document.offsetAt(e.range.start);
                var endOffset = document.offsetAt(e.range.end);
                if (endOffset <= lastModifiedOffset) {
                    text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
                }
                else {
                    throw new Error('Overlapping edit');
                }
                lastModifiedOffset = startOffset;
            }
            return text;
        }
        TextDocument.applyEdits = applyEdits;
        function mergeSort(data, compare) {
            if (data.length <= 1) {
                // sorted
                return data;
            }
            var p = (data.length / 2) | 0;
            var left = data.slice(0, p);
            var right = data.slice(p);
            mergeSort(left, compare);
            mergeSort(right, compare);
            var leftIdx = 0;
            var rightIdx = 0;
            var i = 0;
            while (leftIdx < left.length && rightIdx < right.length) {
                var ret = compare(left[leftIdx], right[rightIdx]);
                if (ret <= 0) {
                    // smaller_equal -> take left to preserve order
                    data[i++] = left[leftIdx++];
                }
                else {
                    // greater -> take right
                    data[i++] = right[rightIdx++];
                }
            }
            while (leftIdx < left.length) {
                data[i++] = left[leftIdx++];
            }
            while (rightIdx < right.length) {
                data[i++] = right[rightIdx++];
            }
            return data;
        }
    })(TextDocument || (exports.TextDocument = TextDocument = {}));
    /**
     * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
     */
    var FullTextDocument = /** @class */ (function () {
        function FullTextDocument(uri, languageId, version, content) {
            this._uri = uri;
            this._languageId = languageId;
            this._version = version;
            this._content = content;
            this._lineOffsets = undefined;
        }
        Object.defineProperty(FullTextDocument.prototype, "uri", {
            get: function () {
                return this._uri;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "languageId", {
            get: function () {
                return this._languageId;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(FullTextDocument.prototype, "version", {
            get: function () {
                return this._version;
            },
            enumerable: false,
            configurable: true
        });
        FullTextDocument.prototype.getText = function (range) {
            if (range) {
                var start = this.offsetAt(range.start);
                var end = this.offsetAt(range.end);
                return this._content.substring(start, end);
            }
            return this._content;
        };
        FullTextDocument.prototype.update = function (event, version) {
            this._content = event.text;
            this._version = version;
            this._lineOffsets = undefined;
        };
        FullTextDocument.prototype.getLineOffsets = function () {
            if (this._lineOffsets === undefined) {
                var lineOffsets = [];
                var text = this._content;
                var isLineStart = true;
                for (var i = 0; i < text.length; i++) {
                    if (isLineStart) {
                        lineOffsets.push(i);
                        isLineStart = false;
                    }
                    var ch = text.charAt(i);
                    isLineStart = (ch === '\r' || ch === '\n');
                    if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                        i++;
                    }
                }
                if (isLineStart && text.length > 0) {
                    lineOffsets.push(text.length);
                }
                this._lineOffsets = lineOffsets;
            }
            return this._lineOffsets;
        };
        FullTextDocument.prototype.positionAt = function (offset) {
            offset = Math.max(Math.min(offset, this._content.length), 0);
            var lineOffsets = this.getLineOffsets();
            var low = 0, high = lineOffsets.length;
            if (high === 0) {
                return Position.create(0, offset);
            }
            while (low < high) {
                var mid = Math.floor((low + high) / 2);
                if (lineOffsets[mid] > offset) {
                    high = mid;
                }
                else {
                    low = mid + 1;
                }
            }
            // low is the least x for which the line offset is larger than the current offset
            // or array.length if no line offset is larger than the current offset
            var line = low - 1;
            return Position.create(line, offset - lineOffsets[line]);
        };
        FullTextDocument.prototype.offsetAt = function (position) {
            var lineOffsets = this.getLineOffsets();
            if (position.line >= lineOffsets.length) {
                return this._content.length;
            }
            else if (position.line < 0) {
                return 0;
            }
            var lineOffset = lineOffsets[position.line];
            var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
            return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
        };
        Object.defineProperty(FullTextDocument.prototype, "lineCount", {
            get: function () {
                return this.getLineOffsets().length;
            },
            enumerable: false,
            configurable: true
        });
        return FullTextDocument;
    }());
    var Is;
    (function (Is) {
        var toString = Object.prototype.toString;
        function defined(value) {
            return typeof value !== 'undefined';
        }
        Is.defined = defined;
        function undefined(value) {
            return typeof value === 'undefined';
        }
        Is.undefined = undefined;
        function boolean(value) {
            return value === true || value === false;
        }
        Is.boolean = boolean;
        function string(value) {
            return toString.call(value) === '[object String]';
        }
        Is.string = string;
        function number(value) {
            return toString.call(value) === '[object Number]';
        }
        Is.number = number;
        function numberRange(value, min, max) {
            return toString.call(value) === '[object Number]' && min <= value && value <= max;
        }
        Is.numberRange = numberRange;
        function integer(value) {
            return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
        }
        Is.integer = integer;
        function uinteger(value) {
            return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
        }
        Is.uinteger = uinteger;
        function func(value) {
            return toString.call(value) === '[object Function]';
        }
        Is.func = func;
        function objectLiteral(value) {
            // Strictly speaking class instances pass this check as well. Since the LSP
            // doesn't use classes we ignore this for now. If we do we need to add something
            // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
            return value !== null && typeof value === 'object';
        }
        Is.objectLiteral = objectLiteral;
        function typedArray(value, check) {
            return Array.isArray(value) && value.every(check);
        }
        Is.typedArray = typedArray;
    })(Is || (Is = {}));
});


/***/ }),

/***/ "./node_modules/vscode-languageserver-types/lib/umd sync recursive":
/*!****************************************************************!*\
  !*** ./node_modules/vscode-languageserver-types/lib/umd/ sync ***!
  \****************************************************************/
/***/ ((module) => {

function webpackEmptyContext(req) {
	var e = new Error("Cannot find module '" + req + "'");
	e.code = 'MODULE_NOT_FOUND';
	throw e;
}
webpackEmptyContext.keys = () => ([]);
webpackEmptyContext.resolve = webpackEmptyContext;
webpackEmptyContext.id = "./node_modules/vscode-languageserver-types/lib/umd sync recursive";
module.exports = webpackEmptyContext;

/***/ }),

/***/ "./node_modules/wrappy/wrappy.js":
/*!***************************************!*\
  !*** ./node_modules/wrappy/wrappy.js ***!
  \***************************************/
/***/ ((module) => {

// Returns a wrapper function that returns a wrapped callback
// The wrapper function should do some stuff, and return a
// presumably different callback function.
// This makes sure that own properties are retained, so that
// decorations and such are not lost along the way.
module.exports = wrappy
function wrappy (fn, cb) {
  if (fn && cb) return wrappy(fn)(cb)

  if (typeof fn !== 'function')
    throw new TypeError('need wrapper function')

  Object.keys(fn).forEach(function (k) {
    wrapper[k] = fn[k]
  })

  return wrapper

  function wrapper() {
    var args = new Array(arguments.length)
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i]
    }
    var ret = fn.apply(this, args)
    var cb = args[args.length-1]
    if (typeof ret === 'function' && ret !== cb) {
      Object.keys(cb).forEach(function (k) {
        ret[k] = cb[k]
      })
    }
    return ret
  }
}


/***/ }),

/***/ "./node_modules/xml-js/lib/array-helper.js":
/*!*************************************************!*\
  !*** ./node_modules/xml-js/lib/array-helper.js ***!
  \*************************************************/
/***/ ((module) => {

module.exports = {

  isArray: function(value) {
    if (Array.isArray) {
      return Array.isArray(value);
    }
    // fallback for older browsers like  IE 8
    return Object.prototype.toString.call( value ) === '[object Array]';
  }

};


/***/ }),

/***/ "./node_modules/xml-js/lib/index.js":
/*!******************************************!*\
  !*** ./node_modules/xml-js/lib/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*jslint node:true */

var xml2js = __webpack_require__(/*! ./xml2js */ "./node_modules/xml-js/lib/xml2js.js");
var xml2json = __webpack_require__(/*! ./xml2json */ "./node_modules/xml-js/lib/xml2json.js");
var js2xml = __webpack_require__(/*! ./js2xml */ "./node_modules/xml-js/lib/js2xml.js");
var json2xml = __webpack_require__(/*! ./json2xml */ "./node_modules/xml-js/lib/json2xml.js");

module.exports = {
  xml2js: xml2js,
  xml2json: xml2json,
  js2xml: js2xml,
  json2xml: json2xml
};


/***/ }),

/***/ "./node_modules/xml-js/lib/js2xml.js":
/*!*******************************************!*\
  !*** ./node_modules/xml-js/lib/js2xml.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var helper = __webpack_require__(/*! ./options-helper */ "./node_modules/xml-js/lib/options-helper.js");
var isArray = (__webpack_require__(/*! ./array-helper */ "./node_modules/xml-js/lib/array-helper.js").isArray);

var currentElement, currentElementName;

function validateOptions(userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('indentText', options);
  helper.ensureFlagExists('indentCdata', options);
  helper.ensureFlagExists('indentAttributes', options);
  helper.ensureFlagExists('indentInstruction', options);
  helper.ensureFlagExists('fullTagEmptyElement', options);
  helper.ensureFlagExists('noQuotesForNativeAttributes', options);
  helper.ensureSpacesExists(options);
  if (typeof options.spaces === 'number') {
    options.spaces = Array(options.spaces + 1).join(' ');
  }
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  helper.checkFnExists('fullTagEmptyElement', options);
  return options;
}

function writeIndentation(options, depth, firstLine) {
  return (!firstLine && options.spaces ? '\n' : '') + Array(depth + 1).join(options.spaces);
}

function writeAttributes(attributes, options, depth) {
  if (options.ignoreAttributes) {
    return '';
  }
  if ('attributesFn' in options) {
    attributes = options.attributesFn(attributes, currentElementName, currentElement);
  }
  var key, attr, attrName, quote, result = [];
  for (key in attributes) {
    if (attributes.hasOwnProperty(key) && attributes[key] !== null && attributes[key] !== undefined) {
      quote = options.noQuotesForNativeAttributes && typeof attributes[key] !== 'string' ? '' : '"';
      attr = '' + attributes[key]; // ensure number and boolean are converted to String
      attr = attr.replace(/"/g, '&quot;');
      attrName = 'attributeNameFn' in options ? options.attributeNameFn(key, attr, currentElementName, currentElement) : key;
      result.push((options.spaces && options.indentAttributes? writeIndentation(options, depth+1, false) : ' '));
      result.push(attrName + '=' + quote + ('attributeValueFn' in options ? options.attributeValueFn(attr, key, currentElementName, currentElement) : attr) + quote);
    }
  }
  if (attributes && Object.keys(attributes).length && options.spaces && options.indentAttributes) {
    result.push(writeIndentation(options, depth, false));
  }
  return result.join('');
}

function writeDeclaration(declaration, options, depth) {
  currentElement = declaration;
  currentElementName = 'xml';
  return options.ignoreDeclaration ? '' :  '<?' + 'xml' + writeAttributes(declaration[options.attributesKey], options, depth) + '?>';
}

function writeInstruction(instruction, options, depth) {
  if (options.ignoreInstruction) {
    return '';
  }
  var key;
  for (key in instruction) {
    if (instruction.hasOwnProperty(key)) {
      break;
    }
  }
  var instructionName = 'instructionNameFn' in options ? options.instructionNameFn(key, instruction[key], currentElementName, currentElement) : key;
  if (typeof instruction[key] === 'object') {
    currentElement = instruction;
    currentElementName = instructionName;
    return '<?' + instructionName + writeAttributes(instruction[key][options.attributesKey], options, depth) + '?>';
  } else {
    var instructionValue = instruction[key] ? instruction[key] : '';
    if ('instructionFn' in options) instructionValue = options.instructionFn(instructionValue, key, currentElementName, currentElement);
    return '<?' + instructionName + (instructionValue ? ' ' + instructionValue : '') + '?>';
  }
}

function writeComment(comment, options) {
  return options.ignoreComment ? '' : '<!--' + ('commentFn' in options ? options.commentFn(comment, currentElementName, currentElement) : comment) + '-->';
}

function writeCdata(cdata, options) {
  return options.ignoreCdata ? '' : '<![CDATA[' + ('cdataFn' in options ? options.cdataFn(cdata, currentElementName, currentElement) : cdata.replace(']]>', ']]]]><![CDATA[>')) + ']]>';
}

function writeDoctype(doctype, options) {
  return options.ignoreDoctype ? '' : '<!DOCTYPE ' + ('doctypeFn' in options ? options.doctypeFn(doctype, currentElementName, currentElement) : doctype) + '>';
}

function writeText(text, options) {
  if (options.ignoreText) return '';
  text = '' + text; // ensure Number and Boolean are converted to String
  text = text.replace(/&amp;/g, '&'); // desanitize to avoid double sanitization
  text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  return 'textFn' in options ? options.textFn(text, currentElementName, currentElement) : text;
}

function hasContent(element, options) {
  var i;
  if (element.elements && element.elements.length) {
    for (i = 0; i < element.elements.length; ++i) {
      switch (element.elements[i][options.typeKey]) {
      case 'text':
        if (options.indentText) {
          return true;
        }
        break; // skip to next key
      case 'cdata':
        if (options.indentCdata) {
          return true;
        }
        break; // skip to next key
      case 'instruction':
        if (options.indentInstruction) {
          return true;
        }
        break; // skip to next key
      case 'doctype':
      case 'comment':
      case 'element':
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElement(element, options, depth) {
  currentElement = element;
  currentElementName = element.name;
  var xml = [], elementName = 'elementNameFn' in options ? options.elementNameFn(element.name, element) : element.name;
  xml.push('<' + elementName);
  if (element[options.attributesKey]) {
    xml.push(writeAttributes(element[options.attributesKey], options, depth));
  }
  var withClosingTag = element[options.elementsKey] && element[options.elementsKey].length || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
  if (!withClosingTag) {
    if ('fullTagEmptyElementFn' in options) {
      withClosingTag = options.fullTagEmptyElementFn(element.name, element);
    } else {
      withClosingTag = options.fullTagEmptyElement;
    }
  }
  if (withClosingTag) {
    xml.push('>');
    if (element[options.elementsKey] && element[options.elementsKey].length) {
      xml.push(writeElements(element[options.elementsKey], options, depth + 1));
      currentElement = element;
      currentElementName = element.name;
    }
    xml.push(options.spaces && hasContent(element, options) ? '\n' + Array(depth + 1).join(options.spaces) : '');
    xml.push('</' + elementName + '>');
  } else {
    xml.push('/>');
  }
  return xml.join('');
}

function writeElements(elements, options, depth, firstLine) {
  return elements.reduce(function (xml, element) {
    var indent = writeIndentation(options, depth, firstLine && !xml);
    switch (element.type) {
    case 'element': return xml + indent + writeElement(element, options, depth);
    case 'comment': return xml + indent + writeComment(element[options.commentKey], options);
    case 'doctype': return xml + indent + writeDoctype(element[options.doctypeKey], options);
    case 'cdata': return xml + (options.indentCdata ? indent : '') + writeCdata(element[options.cdataKey], options);
    case 'text': return xml + (options.indentText ? indent : '') + writeText(element[options.textKey], options);
    case 'instruction':
      var instruction = {};
      instruction[element[options.nameKey]] = element[options.attributesKey] ? element : element[options.instructionKey];
      return xml + (options.indentInstruction ? indent : '') + writeInstruction(instruction, options, depth);
    }
  }, '');
}

function hasContentCompact(element, options, anyContent) {
  var key;
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      switch (key) {
      case options.parentKey:
      case options.attributesKey:
        break; // skip to next key
      case options.textKey:
        if (options.indentText || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.cdataKey:
        if (options.indentCdata || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.instructionKey:
        if (options.indentInstruction || anyContent) {
          return true;
        }
        break; // skip to next key
      case options.doctypeKey:
      case options.commentKey:
        return true;
      default:
        return true;
      }
    }
  }
  return false;
}

function writeElementCompact(element, name, options, depth, indent) {
  currentElement = element;
  currentElementName = name;
  var elementName = 'elementNameFn' in options ? options.elementNameFn(name, element) : name;
  if (typeof element === 'undefined' || element === null || element === '') {
    return 'fullTagEmptyElementFn' in options && options.fullTagEmptyElementFn(name, element) || options.fullTagEmptyElement ? '<' + elementName + '></' + elementName + '>' : '<' + elementName + '/>';
  }
  var xml = [];
  if (name) {
    xml.push('<' + elementName);
    if (typeof element !== 'object') {
      xml.push('>' + writeText(element,options) + '</' + elementName + '>');
      return xml.join('');
    }
    if (element[options.attributesKey]) {
      xml.push(writeAttributes(element[options.attributesKey], options, depth));
    }
    var withClosingTag = hasContentCompact(element, options, true) || element[options.attributesKey] && element[options.attributesKey]['xml:space'] === 'preserve';
    if (!withClosingTag) {
      if ('fullTagEmptyElementFn' in options) {
        withClosingTag = options.fullTagEmptyElementFn(name, element);
      } else {
        withClosingTag = options.fullTagEmptyElement;
      }
    }
    if (withClosingTag) {
      xml.push('>');
    } else {
      xml.push('/>');
      return xml.join('');
    }
  }
  xml.push(writeElementsCompact(element, options, depth + 1, false));
  currentElement = element;
  currentElementName = name;
  if (name) {
    xml.push((indent ? writeIndentation(options, depth, false) : '') + '</' + elementName + '>');
  }
  return xml.join('');
}

function writeElementsCompact(element, options, depth, firstLine) {
  var i, key, nodes, xml = [];
  for (key in element) {
    if (element.hasOwnProperty(key)) {
      nodes = isArray(element[key]) ? element[key] : [element[key]];
      for (i = 0; i < nodes.length; ++i) {
        switch (key) {
        case options.declarationKey: xml.push(writeDeclaration(nodes[i], options, depth)); break;
        case options.instructionKey: xml.push((options.indentInstruction ? writeIndentation(options, depth, firstLine) : '') + writeInstruction(nodes[i], options, depth)); break;
        case options.attributesKey: case options.parentKey: break; // skip
        case options.textKey: xml.push((options.indentText ? writeIndentation(options, depth, firstLine) : '') + writeText(nodes[i], options)); break;
        case options.cdataKey: xml.push((options.indentCdata ? writeIndentation(options, depth, firstLine) : '') + writeCdata(nodes[i], options)); break;
        case options.doctypeKey: xml.push(writeIndentation(options, depth, firstLine) + writeDoctype(nodes[i], options)); break;
        case options.commentKey: xml.push(writeIndentation(options, depth, firstLine) + writeComment(nodes[i], options)); break;
        default: xml.push(writeIndentation(options, depth, firstLine) + writeElementCompact(nodes[i], key, options, depth, hasContentCompact(nodes[i], options)));
        }
        firstLine = firstLine && !xml.length;
      }
    }
  }
  return xml.join('');
}

module.exports = function (js, options) {
  options = validateOptions(options);
  var xml = [];
  currentElement = js;
  currentElementName = '_root_';
  if (options.compact) {
    xml.push(writeElementsCompact(js, options, 0, true));
  } else {
    if (js[options.declarationKey]) {
      xml.push(writeDeclaration(js[options.declarationKey], options, 0));
    }
    if (js[options.elementsKey] && js[options.elementsKey].length) {
      xml.push(writeElements(js[options.elementsKey], options, 0, !xml.length));
    }
  }
  return xml.join('');
};


/***/ }),

/***/ "./node_modules/xml-js/lib/json2xml.js":
/*!*********************************************!*\
  !*** ./node_modules/xml-js/lib/json2xml.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var js2xml = __webpack_require__(/*! ./js2xml.js */ "./node_modules/xml-js/lib/js2xml.js");

module.exports = function (json, options) {
  if (json instanceof Buffer) {
    json = json.toString();
  }
  var js = null;
  if (typeof (json) === 'string') {
    try {
      js = JSON.parse(json);
    } catch (e) {
      throw new Error('The JSON structure is invalid');
    }
  } else {
    js = json;
  }
  return js2xml(js, options);
};


/***/ }),

/***/ "./node_modules/xml-js/lib/options-helper.js":
/*!***************************************************!*\
  !*** ./node_modules/xml-js/lib/options-helper.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isArray = (__webpack_require__(/*! ./array-helper */ "./node_modules/xml-js/lib/array-helper.js").isArray);

module.exports = {

  copyOptions: function (options) {
    var key, copy = {};
    for (key in options) {
      if (options.hasOwnProperty(key)) {
        copy[key] = options[key];
      }
    }
    return copy;
  },

  ensureFlagExists: function (item, options) {
    if (!(item in options) || typeof options[item] !== 'boolean') {
      options[item] = false;
    }
  },

  ensureSpacesExists: function (options) {
    if (!('spaces' in options) || (typeof options.spaces !== 'number' && typeof options.spaces !== 'string')) {
      options.spaces = 0;
    }
  },

  ensureAlwaysArrayExists: function (options) {
    if (!('alwaysArray' in options) || (typeof options.alwaysArray !== 'boolean' && !isArray(options.alwaysArray))) {
      options.alwaysArray = false;
    }
  },

  ensureKeyExists: function (key, options) {
    if (!(key + 'Key' in options) || typeof options[key + 'Key'] !== 'string') {
      options[key + 'Key'] = options.compact ? '_' + key : key;
    }
  },

  checkFnExists: function (key, options) {
    return key + 'Fn' in options;
  }

};


/***/ }),

/***/ "./node_modules/xml-js/lib/xml2js.js":
/*!*******************************************!*\
  !*** ./node_modules/xml-js/lib/xml2js.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var sax = __webpack_require__(/*! sax */ "./node_modules/sax/lib/sax.js");
var expat /*= require('node-expat');*/ = { on: function () { }, parse: function () { } };
var helper = __webpack_require__(/*! ./options-helper */ "./node_modules/xml-js/lib/options-helper.js");
var isArray = (__webpack_require__(/*! ./array-helper */ "./node_modules/xml-js/lib/array-helper.js").isArray);

var options;
var pureJsParser = true;
var currentElement;

function validateOptions(userOptions) {
  options = helper.copyOptions(userOptions);
  helper.ensureFlagExists('ignoreDeclaration', options);
  helper.ensureFlagExists('ignoreInstruction', options);
  helper.ensureFlagExists('ignoreAttributes', options);
  helper.ensureFlagExists('ignoreText', options);
  helper.ensureFlagExists('ignoreComment', options);
  helper.ensureFlagExists('ignoreCdata', options);
  helper.ensureFlagExists('ignoreDoctype', options);
  helper.ensureFlagExists('compact', options);
  helper.ensureFlagExists('alwaysChildren', options);
  helper.ensureFlagExists('addParent', options);
  helper.ensureFlagExists('trim', options);
  helper.ensureFlagExists('nativeType', options);
  helper.ensureFlagExists('nativeTypeAttributes', options);
  helper.ensureFlagExists('sanitize', options);
  helper.ensureFlagExists('instructionHasAttributes', options);
  helper.ensureFlagExists('captureSpacesBetweenElements', options);
  helper.ensureAlwaysArrayExists(options);
  helper.ensureKeyExists('declaration', options);
  helper.ensureKeyExists('instruction', options);
  helper.ensureKeyExists('attributes', options);
  helper.ensureKeyExists('text', options);
  helper.ensureKeyExists('comment', options);
  helper.ensureKeyExists('cdata', options);
  helper.ensureKeyExists('doctype', options);
  helper.ensureKeyExists('type', options);
  helper.ensureKeyExists('name', options);
  helper.ensureKeyExists('elements', options);
  helper.ensureKeyExists('parent', options);
  helper.checkFnExists('doctype', options);
  helper.checkFnExists('instruction', options);
  helper.checkFnExists('cdata', options);
  helper.checkFnExists('comment', options);
  helper.checkFnExists('text', options);
  helper.checkFnExists('instructionName', options);
  helper.checkFnExists('elementName', options);
  helper.checkFnExists('attributeName', options);
  helper.checkFnExists('attributeValue', options);
  helper.checkFnExists('attributes', options);
  return options;
}

function nativeType(value) {
  var nValue = Number(value);
  if (!isNaN(nValue)) {
    return nValue;
  }
  var bValue = value.toLowerCase();
  if (bValue === 'true') {
    return true;
  } else if (bValue === 'false') {
    return false;
  }
  return value;
}

function addField(type, value) {
  var key;
  if (options.compact) {
    if (
      !currentElement[options[type + 'Key']] &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(options[type + 'Key']) !== -1 : options.alwaysArray)
    ) {
      currentElement[options[type + 'Key']] = [];
    }
    if (currentElement[options[type + 'Key']] && !isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']] = [currentElement[options[type + 'Key']]];
    }
    if (type + 'Fn' in options && typeof value === 'string') {
      value = options[type + 'Fn'](value, currentElement);
    }
    if (type === 'instruction' && ('instructionFn' in options || 'instructionNameFn' in options)) {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          if ('instructionFn' in options) {
            value[key] = options.instructionFn(value[key], key, currentElement);
          } else {
            var temp = value[key];
            delete value[key];
            value[options.instructionNameFn(key, temp, currentElement)] = temp;
          }
        }
      }
    }
    if (isArray(currentElement[options[type + 'Key']])) {
      currentElement[options[type + 'Key']].push(value);
    } else {
      currentElement[options[type + 'Key']] = value;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    var element = {};
    element[options.typeKey] = type;
    if (type === 'instruction') {
      for (key in value) {
        if (value.hasOwnProperty(key)) {
          break;
        }
      }
      element[options.nameKey] = 'instructionNameFn' in options ? options.instructionNameFn(key, value, currentElement) : key;
      if (options.instructionHasAttributes) {
        element[options.attributesKey] = value[key][options.attributesKey];
        if ('instructionFn' in options) {
          element[options.attributesKey] = options.instructionFn(element[options.attributesKey], key, currentElement);
        }
      } else {
        if ('instructionFn' in options) {
          value[key] = options.instructionFn(value[key], key, currentElement);
        }
        element[options.instructionKey] = value[key];
      }
    } else {
      if (type + 'Fn' in options) {
        value = options[type + 'Fn'](value, currentElement);
      }
      element[options[type + 'Key']] = value;
    }
    if (options.addParent) {
      element[options.parentKey] = currentElement;
    }
    currentElement[options.elementsKey].push(element);
  }
}

function manipulateAttributes(attributes) {
  if ('attributesFn' in options && attributes) {
    attributes = options.attributesFn(attributes, currentElement);
  }
  if ((options.trim || 'attributeValueFn' in options || 'attributeNameFn' in options || options.nativeTypeAttributes) && attributes) {
    var key;
    for (key in attributes) {
      if (attributes.hasOwnProperty(key)) {
        if (options.trim) attributes[key] = attributes[key].trim();
        if (options.nativeTypeAttributes) {
          attributes[key] = nativeType(attributes[key]);
        }
        if ('attributeValueFn' in options) attributes[key] = options.attributeValueFn(attributes[key], key, currentElement);
        if ('attributeNameFn' in options) {
          var temp = attributes[key];
          delete attributes[key];
          attributes[options.attributeNameFn(key, attributes[key], currentElement)] = temp;
        }
      }
    }
  }
  return attributes;
}

function onInstruction(instruction) {
  var attributes = {};
  if (instruction.body && (instruction.name.toLowerCase() === 'xml' || options.instructionHasAttributes)) {
    var attrsRegExp = /([\w:-]+)\s*=\s*(?:"([^"]*)"|'([^']*)'|(\w+))\s*/g;
    var match;
    while ((match = attrsRegExp.exec(instruction.body)) !== null) {
      attributes[match[1]] = match[2] || match[3] || match[4];
    }
    attributes = manipulateAttributes(attributes);
  }
  if (instruction.name.toLowerCase() === 'xml') {
    if (options.ignoreDeclaration) {
      return;
    }
    currentElement[options.declarationKey] = {};
    if (Object.keys(attributes).length) {
      currentElement[options.declarationKey][options.attributesKey] = attributes;
    }
    if (options.addParent) {
      currentElement[options.declarationKey][options.parentKey] = currentElement;
    }
  } else {
    if (options.ignoreInstruction) {
      return;
    }
    if (options.trim) {
      instruction.body = instruction.body.trim();
    }
    var value = {};
    if (options.instructionHasAttributes && Object.keys(attributes).length) {
      value[instruction.name] = {};
      value[instruction.name][options.attributesKey] = attributes;
    } else {
      value[instruction.name] = instruction.body;
    }
    addField('instruction', value);
  }
}

function onStartElement(name, attributes) {
  var element;
  if (typeof name === 'object') {
    attributes = name.attributes;
    name = name.name;
  }
  attributes = manipulateAttributes(attributes);
  if ('elementNameFn' in options) {
    name = options.elementNameFn(name, currentElement);
  }
  if (options.compact) {
    element = {};
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = {};
      var key;
      for (key in attributes) {
        if (attributes.hasOwnProperty(key)) {
          element[options.attributesKey][key] = attributes[key];
        }
      }
    }
    if (
      !(name in currentElement) &&
      (isArray(options.alwaysArray) ? options.alwaysArray.indexOf(name) !== -1 : options.alwaysArray)
    ) {
      currentElement[name] = [];
    }
    if (currentElement[name] && !isArray(currentElement[name])) {
      currentElement[name] = [currentElement[name]];
    }
    if (isArray(currentElement[name])) {
      currentElement[name].push(element);
    } else {
      currentElement[name] = element;
    }
  } else {
    if (!currentElement[options.elementsKey]) {
      currentElement[options.elementsKey] = [];
    }
    element = {};
    element[options.typeKey] = 'element';
    element[options.nameKey] = name;
    if (!options.ignoreAttributes && attributes && Object.keys(attributes).length) {
      element[options.attributesKey] = attributes;
    }
    if (options.alwaysChildren) {
      element[options.elementsKey] = [];
    }
    currentElement[options.elementsKey].push(element);
  }
  element[options.parentKey] = currentElement; // will be deleted in onEndElement() if !options.addParent
  currentElement = element;
}

function onText(text) {
  if (options.ignoreText) {
    return;
  }
  if (!text.trim() && !options.captureSpacesBetweenElements) {
    return;
  }
  if (options.trim) {
    text = text.trim();
  }
  if (options.nativeType) {
    text = nativeType(text);
  }
  if (options.sanitize) {
    text = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
  }
  addField('text', text);
}

function onComment(comment) {
  if (options.ignoreComment) {
    return;
  }
  if (options.trim) {
    comment = comment.trim();
  }
  addField('comment', comment);
}

function onEndElement(name) {
  var parentElement = currentElement[options.parentKey];
  if (!options.addParent) {
    delete currentElement[options.parentKey];
  }
  currentElement = parentElement;
}

function onCdata(cdata) {
  if (options.ignoreCdata) {
    return;
  }
  if (options.trim) {
    cdata = cdata.trim();
  }
  addField('cdata', cdata);
}

function onDoctype(doctype) {
  if (options.ignoreDoctype) {
    return;
  }
  doctype = doctype.replace(/^ /, '');
  if (options.trim) {
    doctype = doctype.trim();
  }
  addField('doctype', doctype);
}

function onError(error) {
  error.note = error; //console.error(error);
}

module.exports = function (xml, userOptions) {

  var parser = pureJsParser ? sax.parser(true, {}) : parser = new expat.Parser('UTF-8');
  var result = {};
  currentElement = result;

  options = validateOptions(userOptions);

  if (pureJsParser) {
    parser.opt = {strictEntities: true};
    parser.onopentag = onStartElement;
    parser.ontext = onText;
    parser.oncomment = onComment;
    parser.onclosetag = onEndElement;
    parser.onerror = onError;
    parser.oncdata = onCdata;
    parser.ondoctype = onDoctype;
    parser.onprocessinginstruction = onInstruction;
  } else {
    parser.on('startElement', onStartElement);
    parser.on('text', onText);
    parser.on('comment', onComment);
    parser.on('endElement', onEndElement);
    parser.on('error', onError);
    //parser.on('startCdata', onStartCdata);
    //parser.on('endCdata', onEndCdata);
    //parser.on('entityDecl', onEntityDecl);
  }

  if (pureJsParser) {
    parser.write(xml).close();
  } else {
    if (!parser.parse(xml)) {
      throw new Error('XML parsing error: ' + parser.getError());
    }
  }

  if (result[options.elementsKey]) {
    var temp = result[options.elementsKey];
    delete result[options.elementsKey];
    result[options.elementsKey] = temp;
    delete result.text;
  }

  return result;

};


/***/ }),

/***/ "./node_modules/xml-js/lib/xml2json.js":
/*!*********************************************!*\
  !*** ./node_modules/xml-js/lib/xml2json.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var helper = __webpack_require__(/*! ./options-helper */ "./node_modules/xml-js/lib/options-helper.js");
var xml2js = __webpack_require__(/*! ./xml2js */ "./node_modules/xml-js/lib/xml2js.js");

function validateOptions (userOptions) {
  var options = helper.copyOptions(userOptions);
  helper.ensureSpacesExists(options);
  return options;
}

module.exports = function(xml, userOptions) {
  var options, js, json, parentKey;
  options = validateOptions(userOptions);
  js = xml2js(xml, options);
  parentKey = 'compact' in options && options.compact ? '_parent' : 'parent';
  // parentKey = ptions.compact ? '_parent' : 'parent'; // consider this
  if ('addParent' in options && options.addParent) {
    json = JSON.stringify(js, function (k, v) { return k === parentKey? '_' : v; }, options.spaces);
  } else {
    json = JSON.stringify(js, null, options.spaces);
  }
  return json.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
};


/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "node:crypto":
/*!******************************!*\
  !*** external "node:crypto" ***!
  \******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:crypto");

/***/ }),

/***/ "node:os":
/*!**************************!*\
  !*** external "node:os" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:os");

/***/ }),

/***/ "node:process":
/*!*******************************!*\
  !*** external "node:process" ***!
  \*******************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:process");

/***/ }),

/***/ "node:tty":
/*!***************************!*\
  !*** external "node:tty" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("node:tty");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ }),

/***/ "./node_modules/chalk/source/index.js":
/*!********************************************!*\
  !*** ./node_modules/chalk/source/index.js ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   Chalk: () => (/* binding */ Chalk),
/* harmony export */   backgroundColorNames: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.backgroundColorNames),
/* harmony export */   backgroundColors: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.backgroundColorNames),
/* harmony export */   chalkStderr: () => (/* binding */ chalkStderr),
/* harmony export */   colorNames: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.colorNames),
/* harmony export */   colors: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.colorNames),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   foregroundColorNames: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.foregroundColorNames),
/* harmony export */   foregroundColors: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.foregroundColorNames),
/* harmony export */   modifierNames: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.modifierNames),
/* harmony export */   modifiers: () => (/* reexport safe */ _ansi_styles__WEBPACK_IMPORTED_MODULE_1__.modifierNames),
/* harmony export */   supportsColor: () => (/* binding */ stdoutColor),
/* harmony export */   supportsColorStderr: () => (/* binding */ stderrColor)
/* harmony export */ });
/* harmony import */ var _ansi_styles__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vendor/ansi-styles/index.js */ "./node_modules/chalk/source/vendor/ansi-styles/index.js");
/* harmony import */ var _supports_color__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! #supports-color */ "./node_modules/chalk/source/vendor/supports-color/index.js");
/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utilities.js */ "./node_modules/chalk/source/utilities.js");




const {stdout: stdoutColor, stderr: stderrColor} = _supports_color__WEBPACK_IMPORTED_MODULE_0__["default"];

const GENERATOR = Symbol('GENERATOR');
const STYLER = Symbol('STYLER');
const IS_EMPTY = Symbol('IS_EMPTY');

// `supportsColor.level` → `ansiStyles.color[name]` mapping
const levelMapping = [
	'ansi',
	'ansi',
	'ansi256',
	'ansi16m',
];

const styles = Object.create(null);

const applyOptions = (object, options = {}) => {
	if (options.level && !(Number.isInteger(options.level) && options.level >= 0 && options.level <= 3)) {
		throw new Error('The `level` option should be an integer from 0 to 3');
	}

	// Detect level if not set manually
	const colorLevel = stdoutColor ? stdoutColor.level : 0;
	object.level = options.level === undefined ? colorLevel : options.level;
};

class Chalk {
	constructor(options) {
		// eslint-disable-next-line no-constructor-return
		return chalkFactory(options);
	}
}

const chalkFactory = options => {
	const chalk = (...strings) => strings.join(' ');
	applyOptions(chalk, options);

	Object.setPrototypeOf(chalk, createChalk.prototype);

	return chalk;
};

function createChalk(options) {
	return chalkFactory(options);
}

Object.setPrototypeOf(createChalk.prototype, Function.prototype);

for (const [styleName, style] of Object.entries(_ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"])) {
	styles[styleName] = {
		get() {
			const builder = createBuilder(this, createStyler(style.open, style.close, this[STYLER]), this[IS_EMPTY]);
			Object.defineProperty(this, styleName, {value: builder});
			return builder;
		},
	};
}

styles.visible = {
	get() {
		const builder = createBuilder(this, this[STYLER], true);
		Object.defineProperty(this, 'visible', {value: builder});
		return builder;
	},
};

const getModelAnsi = (model, level, type, ...arguments_) => {
	if (model === 'rgb') {
		if (level === 'ansi16m') {
			return _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"][type].ansi16m(...arguments_);
		}

		if (level === 'ansi256') {
			return _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"][type].ansi256(_ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"].rgbToAnsi256(...arguments_));
		}

		return _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"][type].ansi(_ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"].rgbToAnsi(...arguments_));
	}

	if (model === 'hex') {
		return getModelAnsi('rgb', level, type, ..._ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"].hexToRgb(...arguments_));
	}

	return _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"][type][model](...arguments_);
};

const usedModels = ['rgb', 'hex', 'ansi256'];

for (const model of usedModels) {
	styles[model] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'color', ...arguments_), _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"].color.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};

	const bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
	styles[bgModel] = {
		get() {
			const {level} = this;
			return function (...arguments_) {
				const styler = createStyler(getModelAnsi(model, levelMapping[level], 'bgColor', ...arguments_), _ansi_styles__WEBPACK_IMPORTED_MODULE_1__["default"].bgColor.close, this[STYLER]);
				return createBuilder(this, styler, this[IS_EMPTY]);
			};
		},
	};
}

const proto = Object.defineProperties(() => {}, {
	...styles,
	level: {
		enumerable: true,
		get() {
			return this[GENERATOR].level;
		},
		set(level) {
			this[GENERATOR].level = level;
		},
	},
});

const createStyler = (open, close, parent) => {
	let openAll;
	let closeAll;
	if (parent === undefined) {
		openAll = open;
		closeAll = close;
	} else {
		openAll = parent.openAll + open;
		closeAll = close + parent.closeAll;
	}

	return {
		open,
		close,
		openAll,
		closeAll,
		parent,
	};
};

const createBuilder = (self, _styler, _isEmpty) => {
	// Single argument is hot path, implicit coercion is faster than anything
	// eslint-disable-next-line no-implicit-coercion
	const builder = (...arguments_) => applyStyle(builder, (arguments_.length === 1) ? ('' + arguments_[0]) : arguments_.join(' '));

	// We alter the prototype because we must return a function, but there is
	// no way to create a function with a different prototype
	Object.setPrototypeOf(builder, proto);

	builder[GENERATOR] = self;
	builder[STYLER] = _styler;
	builder[IS_EMPTY] = _isEmpty;

	return builder;
};

const applyStyle = (self, string) => {
	if (self.level <= 0 || !string) {
		return self[IS_EMPTY] ? '' : string;
	}

	let styler = self[STYLER];

	if (styler === undefined) {
		return string;
	}

	const {openAll, closeAll} = styler;
	if (string.includes('\u001B')) {
		while (styler !== undefined) {
			// Replace any instances already present with a re-opening code
			// otherwise only the part of the string until said closing code
			// will be colored, and the rest will simply be 'plain'.
			string = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.stringReplaceAll)(string, styler.close, styler.open);

			styler = styler.parent;
		}
	}

	// We can move both next actions out of loop, because remaining actions in loop won't have
	// any/visible effect on parts we add here. Close the styling before a linebreak and reopen
	// after next line to fix a bleed issue on macOS: https://github.com/chalk/chalk/pull/92
	const lfIndex = string.indexOf('\n');
	if (lfIndex !== -1) {
		string = (0,_utilities_js__WEBPACK_IMPORTED_MODULE_2__.stringEncaseCRLFWithFirstIndex)(string, closeAll, openAll, lfIndex);
	}

	return openAll + string + closeAll;
};

Object.defineProperties(createChalk.prototype, styles);

const chalk = createChalk();
const chalkStderr = createChalk({level: stderrColor ? stderrColor.level : 0});





/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (chalk);


/***/ }),

/***/ "./node_modules/chalk/source/utilities.js":
/*!************************************************!*\
  !*** ./node_modules/chalk/source/utilities.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   stringEncaseCRLFWithFirstIndex: () => (/* binding */ stringEncaseCRLFWithFirstIndex),
/* harmony export */   stringReplaceAll: () => (/* binding */ stringReplaceAll)
/* harmony export */ });
// TODO: When targeting Node.js 16, use `String.prototype.replaceAll`.
function stringReplaceAll(string, substring, replacer) {
	let index = string.indexOf(substring);
	if (index === -1) {
		return string;
	}

	const substringLength = substring.length;
	let endIndex = 0;
	let returnValue = '';
	do {
		returnValue += string.slice(endIndex, index) + substring + replacer;
		endIndex = index + substringLength;
		index = string.indexOf(substring, endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}

function stringEncaseCRLFWithFirstIndex(string, prefix, postfix, index) {
	let endIndex = 0;
	let returnValue = '';
	do {
		const gotCR = string[index - 1] === '\r';
		returnValue += string.slice(endIndex, (gotCR ? index - 1 : index)) + prefix + (gotCR ? '\r\n' : '\n') + postfix;
		endIndex = index + 1;
		index = string.indexOf('\n', endIndex);
	} while (index !== -1);

	returnValue += string.slice(endIndex);
	return returnValue;
}


/***/ }),

/***/ "./node_modules/chalk/source/vendor/ansi-styles/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/chalk/source/vendor/ansi-styles/index.js ***!
  \***************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   backgroundColorNames: () => (/* binding */ backgroundColorNames),
/* harmony export */   colorNames: () => (/* binding */ colorNames),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   foregroundColorNames: () => (/* binding */ foregroundColorNames),
/* harmony export */   modifierNames: () => (/* binding */ modifierNames)
/* harmony export */ });
const ANSI_BACKGROUND_OFFSET = 10;

const wrapAnsi16 = (offset = 0) => code => `\u001B[${code + offset}m`;

const wrapAnsi256 = (offset = 0) => code => `\u001B[${38 + offset};5;${code}m`;

const wrapAnsi16m = (offset = 0) => (red, green, blue) => `\u001B[${38 + offset};2;${red};${green};${blue}m`;

const styles = {
	modifier: {
		reset: [0, 0],
		// 21 isn't widely supported and 22 does the same thing
		bold: [1, 22],
		dim: [2, 22],
		italic: [3, 23],
		underline: [4, 24],
		overline: [53, 55],
		inverse: [7, 27],
		hidden: [8, 28],
		strikethrough: [9, 29],
	},
	color: {
		black: [30, 39],
		red: [31, 39],
		green: [32, 39],
		yellow: [33, 39],
		blue: [34, 39],
		magenta: [35, 39],
		cyan: [36, 39],
		white: [37, 39],

		// Bright color
		blackBright: [90, 39],
		gray: [90, 39], // Alias of `blackBright`
		grey: [90, 39], // Alias of `blackBright`
		redBright: [91, 39],
		greenBright: [92, 39],
		yellowBright: [93, 39],
		blueBright: [94, 39],
		magentaBright: [95, 39],
		cyanBright: [96, 39],
		whiteBright: [97, 39],
	},
	bgColor: {
		bgBlack: [40, 49],
		bgRed: [41, 49],
		bgGreen: [42, 49],
		bgYellow: [43, 49],
		bgBlue: [44, 49],
		bgMagenta: [45, 49],
		bgCyan: [46, 49],
		bgWhite: [47, 49],

		// Bright color
		bgBlackBright: [100, 49],
		bgGray: [100, 49], // Alias of `bgBlackBright`
		bgGrey: [100, 49], // Alias of `bgBlackBright`
		bgRedBright: [101, 49],
		bgGreenBright: [102, 49],
		bgYellowBright: [103, 49],
		bgBlueBright: [104, 49],
		bgMagentaBright: [105, 49],
		bgCyanBright: [106, 49],
		bgWhiteBright: [107, 49],
	},
};

const modifierNames = Object.keys(styles.modifier);
const foregroundColorNames = Object.keys(styles.color);
const backgroundColorNames = Object.keys(styles.bgColor);
const colorNames = [...foregroundColorNames, ...backgroundColorNames];

function assembleStyles() {
	const codes = new Map();

	for (const [groupName, group] of Object.entries(styles)) {
		for (const [styleName, style] of Object.entries(group)) {
			styles[styleName] = {
				open: `\u001B[${style[0]}m`,
				close: `\u001B[${style[1]}m`,
			};

			group[styleName] = styles[styleName];

			codes.set(style[0], style[1]);
		}

		Object.defineProperty(styles, groupName, {
			value: group,
			enumerable: false,
		});
	}

	Object.defineProperty(styles, 'codes', {
		value: codes,
		enumerable: false,
	});

	styles.color.close = '\u001B[39m';
	styles.bgColor.close = '\u001B[49m';

	styles.color.ansi = wrapAnsi16();
	styles.color.ansi256 = wrapAnsi256();
	styles.color.ansi16m = wrapAnsi16m();
	styles.bgColor.ansi = wrapAnsi16(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi256 = wrapAnsi256(ANSI_BACKGROUND_OFFSET);
	styles.bgColor.ansi16m = wrapAnsi16m(ANSI_BACKGROUND_OFFSET);

	// From https://github.com/Qix-/color-convert/blob/3f0e0d4e92e235796ccb17f6e85c72094a651f49/conversions.js
	Object.defineProperties(styles, {
		rgbToAnsi256: {
			value(red, green, blue) {
				// We use the extended greyscale palette here, with the exception of
				// black and white. normal palette only has 4 greyscale shades.
				if (red === green && green === blue) {
					if (red < 8) {
						return 16;
					}

					if (red > 248) {
						return 231;
					}

					return Math.round(((red - 8) / 247) * 24) + 232;
				}

				return 16
					+ (36 * Math.round(red / 255 * 5))
					+ (6 * Math.round(green / 255 * 5))
					+ Math.round(blue / 255 * 5);
			},
			enumerable: false,
		},
		hexToRgb: {
			value(hex) {
				const matches = /[a-f\d]{6}|[a-f\d]{3}/i.exec(hex.toString(16));
				if (!matches) {
					return [0, 0, 0];
				}

				let [colorString] = matches;

				if (colorString.length === 3) {
					colorString = [...colorString].map(character => character + character).join('');
				}

				const integer = Number.parseInt(colorString, 16);

				return [
					/* eslint-disable no-bitwise */
					(integer >> 16) & 0xFF,
					(integer >> 8) & 0xFF,
					integer & 0xFF,
					/* eslint-enable no-bitwise */
				];
			},
			enumerable: false,
		},
		hexToAnsi256: {
			value: hex => styles.rgbToAnsi256(...styles.hexToRgb(hex)),
			enumerable: false,
		},
		ansi256ToAnsi: {
			value(code) {
				if (code < 8) {
					return 30 + code;
				}

				if (code < 16) {
					return 90 + (code - 8);
				}

				let red;
				let green;
				let blue;

				if (code >= 232) {
					red = (((code - 232) * 10) + 8) / 255;
					green = red;
					blue = red;
				} else {
					code -= 16;

					const remainder = code % 36;

					red = Math.floor(code / 36) / 5;
					green = Math.floor(remainder / 6) / 5;
					blue = (remainder % 6) / 5;
				}

				const value = Math.max(red, green, blue) * 2;

				if (value === 0) {
					return 30;
				}

				// eslint-disable-next-line no-bitwise
				let result = 30 + ((Math.round(blue) << 2) | (Math.round(green) << 1) | Math.round(red));

				if (value === 2) {
					result += 60;
				}

				return result;
			},
			enumerable: false,
		},
		rgbToAnsi: {
			value: (red, green, blue) => styles.ansi256ToAnsi(styles.rgbToAnsi256(red, green, blue)),
			enumerable: false,
		},
		hexToAnsi: {
			value: hex => styles.ansi256ToAnsi(styles.hexToAnsi256(hex)),
			enumerable: false,
		},
	});

	return styles;
}

const ansiStyles = assembleStyles();

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (ansiStyles);


/***/ }),

/***/ "./node_modules/chalk/source/vendor/supports-color/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/chalk/source/vendor/supports-color/index.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   createSupportsColor: () => (/* binding */ createSupportsColor),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var node_process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! node:process */ "node:process");
/* harmony import */ var node_os__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! node:os */ "node:os");
/* harmony import */ var node_tty__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:tty */ "node:tty");




// From: https://github.com/sindresorhus/has-flag/blob/main/index.js
/// function hasFlag(flag, argv = globalThis.Deno?.args ?? process.argv) {
function hasFlag(flag, argv = globalThis.Deno ? globalThis.Deno.args : node_process__WEBPACK_IMPORTED_MODULE_0__.argv) {
	const prefix = flag.startsWith('-') ? '' : (flag.length === 1 ? '-' : '--');
	const position = argv.indexOf(prefix + flag);
	const terminatorPosition = argv.indexOf('--');
	return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
}

const {env} = node_process__WEBPACK_IMPORTED_MODULE_0__;

let flagForceColor;
if (
	hasFlag('no-color')
	|| hasFlag('no-colors')
	|| hasFlag('color=false')
	|| hasFlag('color=never')
) {
	flagForceColor = 0;
} else if (
	hasFlag('color')
	|| hasFlag('colors')
	|| hasFlag('color=true')
	|| hasFlag('color=always')
) {
	flagForceColor = 1;
}

function envForceColor() {
	if ('FORCE_COLOR' in env) {
		if (env.FORCE_COLOR === 'true') {
			return 1;
		}

		if (env.FORCE_COLOR === 'false') {
			return 0;
		}

		return env.FORCE_COLOR.length === 0 ? 1 : Math.min(Number.parseInt(env.FORCE_COLOR, 10), 3);
	}
}

function translateLevel(level) {
	if (level === 0) {
		return false;
	}

	return {
		level,
		hasBasic: true,
		has256: level >= 2,
		has16m: level >= 3,
	};
}

function _supportsColor(haveStream, {streamIsTTY, sniffFlags = true} = {}) {
	const noFlagForceColor = envForceColor();
	if (noFlagForceColor !== undefined) {
		flagForceColor = noFlagForceColor;
	}

	const forceColor = sniffFlags ? flagForceColor : noFlagForceColor;

	if (forceColor === 0) {
		return 0;
	}

	if (sniffFlags) {
		if (hasFlag('color=16m')
			|| hasFlag('color=full')
			|| hasFlag('color=truecolor')) {
			return 3;
		}

		if (hasFlag('color=256')) {
			return 2;
		}
	}

	// Check for Azure DevOps pipelines.
	// Has to be above the `!streamIsTTY` check.
	if ('TF_BUILD' in env && 'AGENT_NAME' in env) {
		return 1;
	}

	if (haveStream && !streamIsTTY && forceColor === undefined) {
		return 0;
	}

	const min = forceColor || 0;

	if (env.TERM === 'dumb') {
		return min;
	}

	if (node_process__WEBPACK_IMPORTED_MODULE_0__.platform === 'win32') {
		// Windows 10 build 10586 is the first Windows release that supports 256 colors.
		// Windows 10 build 14931 is the first release that supports 16m/TrueColor.
		const osRelease = node_os__WEBPACK_IMPORTED_MODULE_1__.release().split('.');
		if (
			Number(osRelease[0]) >= 10
			&& Number(osRelease[2]) >= 10_586
		) {
			return Number(osRelease[2]) >= 14_931 ? 3 : 2;
		}

		return 1;
	}

	if ('CI' in env) {
		if ('GITHUB_ACTIONS' in env || 'GITEA_ACTIONS' in env) {
			return 3;
		}

		if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI', 'BUILDKITE', 'DRONE'].some(sign => sign in env) || env.CI_NAME === 'codeship') {
			return 1;
		}

		return min;
	}

	if ('TEAMCITY_VERSION' in env) {
		return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
	}

	if (env.COLORTERM === 'truecolor') {
		return 3;
	}

	if (env.TERM === 'xterm-kitty') {
		return 3;
	}

	if ('TERM_PROGRAM' in env) {
		const version = Number.parseInt((env.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

		switch (env.TERM_PROGRAM) {
			case 'iTerm.app': {
				return version >= 3 ? 3 : 2;
			}

			case 'Apple_Terminal': {
				return 2;
			}
			// No default
		}
	}

	if (/-256(color)?$/i.test(env.TERM)) {
		return 2;
	}

	if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
		return 1;
	}

	if ('COLORTERM' in env) {
		return 1;
	}

	return min;
}

function createSupportsColor(stream, options = {}) {
	const level = _supportsColor(stream, {
		streamIsTTY: stream && stream.isTTY,
		...options,
	});

	return translateLevel(level);
}

const supportsColor = {
	stdout: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(1)}),
	stderr: createSupportsColor({isTTY: node_tty__WEBPACK_IMPORTED_MODULE_2__.isatty(2)}),
};

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (supportsColor);


/***/ }),

/***/ "./node_modules/json5/dist/index.mjs":
/*!*******************************************!*\
  !*** ./node_modules/json5/dist/index.mjs ***!
  \*******************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// This is a generated file. Do not edit.
var Space_Separator = /[\u1680\u2000-\u200A\u202F\u205F\u3000]/;
var ID_Start = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]/;
var ID_Continue = /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u09FC\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9-\u0AFF\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D00-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF9\u1D00-\u1DF9\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF2D-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDE00-\uDE3E\uDE47\uDE50-\uDE83\uDE86-\uDE99\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD47\uDD50-\uDD59]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/;

var unicode = {
	Space_Separator: Space_Separator,
	ID_Start: ID_Start,
	ID_Continue: ID_Continue
};

var util = {
    isSpaceSeparator (c) {
        return typeof c === 'string' && unicode.Space_Separator.test(c)
    },

    isIdStartChar (c) {
        return typeof c === 'string' && (
            (c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c === '$') || (c === '_') ||
        unicode.ID_Start.test(c)
        )
    },

    isIdContinueChar (c) {
        return typeof c === 'string' && (
            (c >= 'a' && c <= 'z') ||
        (c >= 'A' && c <= 'Z') ||
        (c >= '0' && c <= '9') ||
        (c === '$') || (c === '_') ||
        (c === '\u200C') || (c === '\u200D') ||
        unicode.ID_Continue.test(c)
        )
    },

    isDigit (c) {
        return typeof c === 'string' && /[0-9]/.test(c)
    },

    isHexDigit (c) {
        return typeof c === 'string' && /[0-9A-Fa-f]/.test(c)
    },
};

let source;
let parseState;
let stack;
let pos;
let line;
let column;
let token;
let key;
let root;

var parse = function parse (text, reviver) {
    source = String(text);
    parseState = 'start';
    stack = [];
    pos = 0;
    line = 1;
    column = 0;
    token = undefined;
    key = undefined;
    root = undefined;

    do {
        token = lex();

        // This code is unreachable.
        // if (!parseStates[parseState]) {
        //     throw invalidParseState()
        // }

        parseStates[parseState]();
    } while (token.type !== 'eof')

    if (typeof reviver === 'function') {
        return internalize({'': root}, '', reviver)
    }

    return root
};

function internalize (holder, name, reviver) {
    const value = holder[name];
    if (value != null && typeof value === 'object') {
        if (Array.isArray(value)) {
            for (let i = 0; i < value.length; i++) {
                const key = String(i);
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    });
                }
            }
        } else {
            for (const key in value) {
                const replacement = internalize(value, key, reviver);
                if (replacement === undefined) {
                    delete value[key];
                } else {
                    Object.defineProperty(value, key, {
                        value: replacement,
                        writable: true,
                        enumerable: true,
                        configurable: true,
                    });
                }
            }
        }
    }

    return reviver.call(holder, name, value)
}

let lexState;
let buffer;
let doubleQuote;
let sign;
let c;

function lex () {
    lexState = 'default';
    buffer = '';
    doubleQuote = false;
    sign = 1;

    for (;;) {
        c = peek();

        // This code is unreachable.
        // if (!lexStates[lexState]) {
        //     throw invalidLexState(lexState)
        // }

        const token = lexStates[lexState]();
        if (token) {
            return token
        }
    }
}

function peek () {
    if (source[pos]) {
        return String.fromCodePoint(source.codePointAt(pos))
    }
}

function read () {
    const c = peek();

    if (c === '\n') {
        line++;
        column = 0;
    } else if (c) {
        column += c.length;
    } else {
        column++;
    }

    if (c) {
        pos += c.length;
    }

    return c
}

const lexStates = {
    default () {
        switch (c) {
        case '\t':
        case '\v':
        case '\f':
        case ' ':
        case '\u00A0':
        case '\uFEFF':
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
            read();
            return

        case '/':
            read();
            lexState = 'comment';
            return

        case undefined:
            read();
            return newToken('eof')
        }

        if (util.isSpaceSeparator(c)) {
            read();
            return
        }

        // This code is unreachable.
        // if (!lexStates[parseState]) {
        //     throw invalidLexState(parseState)
        // }

        return lexStates[parseState]()
    },

    comment () {
        switch (c) {
        case '*':
            read();
            lexState = 'multiLineComment';
            return

        case '/':
            read();
            lexState = 'singleLineComment';
            return
        }

        throw invalidChar(read())
    },

    multiLineComment () {
        switch (c) {
        case '*':
            read();
            lexState = 'multiLineCommentAsterisk';
            return

        case undefined:
            throw invalidChar(read())
        }

        read();
    },

    multiLineCommentAsterisk () {
        switch (c) {
        case '*':
            read();
            return

        case '/':
            read();
            lexState = 'default';
            return

        case undefined:
            throw invalidChar(read())
        }

        read();
        lexState = 'multiLineComment';
    },

    singleLineComment () {
        switch (c) {
        case '\n':
        case '\r':
        case '\u2028':
        case '\u2029':
            read();
            lexState = 'default';
            return

        case undefined:
            read();
            return newToken('eof')
        }

        read();
    },

    value () {
        switch (c) {
        case '{':
        case '[':
            return newToken('punctuator', read())

        case 'n':
            read();
            literal('ull');
            return newToken('null', null)

        case 't':
            read();
            literal('rue');
            return newToken('boolean', true)

        case 'f':
            read();
            literal('alse');
            return newToken('boolean', false)

        case '-':
        case '+':
            if (read() === '-') {
                sign = -1;
            }

            lexState = 'sign';
            return

        case '.':
            buffer = read();
            lexState = 'decimalPointLeading';
            return

        case '0':
            buffer = read();
            lexState = 'zero';
            return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            buffer = read();
            lexState = 'decimalInteger';
            return

        case 'I':
            read();
            literal('nfinity');
            return newToken('numeric', Infinity)

        case 'N':
            read();
            literal('aN');
            return newToken('numeric', NaN)

        case '"':
        case "'":
            doubleQuote = (read() === '"');
            buffer = '';
            lexState = 'string';
            return
        }

        throw invalidChar(read())
    },

    identifierNameStartEscape () {
        if (c !== 'u') {
            throw invalidChar(read())
        }

        read();
        const u = unicodeEscape();
        switch (u) {
        case '$':
        case '_':
            break

        default:
            if (!util.isIdStartChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u;
        lexState = 'identifierName';
    },

    identifierName () {
        switch (c) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
            buffer += read();
            return

        case '\\':
            read();
            lexState = 'identifierNameEscape';
            return
        }

        if (util.isIdContinueChar(c)) {
            buffer += read();
            return
        }

        return newToken('identifier', buffer)
    },

    identifierNameEscape () {
        if (c !== 'u') {
            throw invalidChar(read())
        }

        read();
        const u = unicodeEscape();
        switch (u) {
        case '$':
        case '_':
        case '\u200C':
        case '\u200D':
            break

        default:
            if (!util.isIdContinueChar(u)) {
                throw invalidIdentifier()
            }

            break
        }

        buffer += u;
        lexState = 'identifierName';
    },

    sign () {
        switch (c) {
        case '.':
            buffer = read();
            lexState = 'decimalPointLeading';
            return

        case '0':
            buffer = read();
            lexState = 'zero';
            return

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            buffer = read();
            lexState = 'decimalInteger';
            return

        case 'I':
            read();
            literal('nfinity');
            return newToken('numeric', sign * Infinity)

        case 'N':
            read();
            literal('aN');
            return newToken('numeric', NaN)
        }

        throw invalidChar(read())
    },

    zero () {
        switch (c) {
        case '.':
            buffer += read();
            lexState = 'decimalPoint';
            return

        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return

        case 'x':
        case 'X':
            buffer += read();
            lexState = 'hexadecimal';
            return
        }

        return newToken('numeric', sign * 0)
    },

    decimalInteger () {
        switch (c) {
        case '.':
            buffer += read();
            lexState = 'decimalPoint';
            return

        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalPointLeading () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return
        }

        throw invalidChar(read())
    },

    decimalPoint () {
        switch (c) {
        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalFraction';
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalFraction () {
        switch (c) {
        case 'e':
        case 'E':
            buffer += read();
            lexState = 'decimalExponent';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    decimalExponent () {
        switch (c) {
        case '+':
        case '-':
            buffer += read();
            lexState = 'decimalExponentSign';
            return
        }

        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return
        }

        throw invalidChar(read())
    },

    decimalExponentSign () {
        if (util.isDigit(c)) {
            buffer += read();
            lexState = 'decimalExponentInteger';
            return
        }

        throw invalidChar(read())
    },

    decimalExponentInteger () {
        if (util.isDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    hexadecimal () {
        if (util.isHexDigit(c)) {
            buffer += read();
            lexState = 'hexadecimalInteger';
            return
        }

        throw invalidChar(read())
    },

    hexadecimalInteger () {
        if (util.isHexDigit(c)) {
            buffer += read();
            return
        }

        return newToken('numeric', sign * Number(buffer))
    },

    string () {
        switch (c) {
        case '\\':
            read();
            buffer += escape();
            return

        case '"':
            if (doubleQuote) {
                read();
                return newToken('string', buffer)
            }

            buffer += read();
            return

        case "'":
            if (!doubleQuote) {
                read();
                return newToken('string', buffer)
            }

            buffer += read();
            return

        case '\n':
        case '\r':
            throw invalidChar(read())

        case '\u2028':
        case '\u2029':
            separatorChar(c);
            break

        case undefined:
            throw invalidChar(read())
        }

        buffer += read();
    },

    start () {
        switch (c) {
        case '{':
        case '[':
            return newToken('punctuator', read())

        // This code is unreachable since the default lexState handles eof.
        // case undefined:
        //     return newToken('eof')
        }

        lexState = 'value';
    },

    beforePropertyName () {
        switch (c) {
        case '$':
        case '_':
            buffer = read();
            lexState = 'identifierName';
            return

        case '\\':
            read();
            lexState = 'identifierNameStartEscape';
            return

        case '}':
            return newToken('punctuator', read())

        case '"':
        case "'":
            doubleQuote = (read() === '"');
            lexState = 'string';
            return
        }

        if (util.isIdStartChar(c)) {
            buffer += read();
            lexState = 'identifierName';
            return
        }

        throw invalidChar(read())
    },

    afterPropertyName () {
        if (c === ':') {
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    beforePropertyValue () {
        lexState = 'value';
    },

    afterPropertyValue () {
        switch (c) {
        case ',':
        case '}':
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    beforeArrayValue () {
        if (c === ']') {
            return newToken('punctuator', read())
        }

        lexState = 'value';
    },

    afterArrayValue () {
        switch (c) {
        case ',':
        case ']':
            return newToken('punctuator', read())
        }

        throw invalidChar(read())
    },

    end () {
        // This code is unreachable since it's handled by the default lexState.
        // if (c === undefined) {
        //     read()
        //     return newToken('eof')
        // }

        throw invalidChar(read())
    },
};

function newToken (type, value) {
    return {
        type,
        value,
        line,
        column,
    }
}

function literal (s) {
    for (const c of s) {
        const p = peek();

        if (p !== c) {
            throw invalidChar(read())
        }

        read();
    }
}

function escape () {
    const c = peek();
    switch (c) {
    case 'b':
        read();
        return '\b'

    case 'f':
        read();
        return '\f'

    case 'n':
        read();
        return '\n'

    case 'r':
        read();
        return '\r'

    case 't':
        read();
        return '\t'

    case 'v':
        read();
        return '\v'

    case '0':
        read();
        if (util.isDigit(peek())) {
            throw invalidChar(read())
        }

        return '\0'

    case 'x':
        read();
        return hexEscape()

    case 'u':
        read();
        return unicodeEscape()

    case '\n':
    case '\u2028':
    case '\u2029':
        read();
        return ''

    case '\r':
        read();
        if (peek() === '\n') {
            read();
        }

        return ''

    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
        throw invalidChar(read())

    case undefined:
        throw invalidChar(read())
    }

    return read()
}

function hexEscape () {
    let buffer = '';
    let c = peek();

    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read();

    c = peek();
    if (!util.isHexDigit(c)) {
        throw invalidChar(read())
    }

    buffer += read();

    return String.fromCodePoint(parseInt(buffer, 16))
}

function unicodeEscape () {
    let buffer = '';
    let count = 4;

    while (count-- > 0) {
        const c = peek();
        if (!util.isHexDigit(c)) {
            throw invalidChar(read())
        }

        buffer += read();
    }

    return String.fromCodePoint(parseInt(buffer, 16))
}

const parseStates = {
    start () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        push();
    },

    beforePropertyName () {
        switch (token.type) {
        case 'identifier':
        case 'string':
            key = token.value;
            parseState = 'afterPropertyName';
            return

        case 'punctuator':
            // This code is unreachable since it's handled by the lexState.
            // if (token.value !== '}') {
            //     throw invalidToken()
            // }

            pop();
            return

        case 'eof':
            throw invalidEOF()
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    afterPropertyName () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator' || token.value !== ':') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        parseState = 'beforePropertyValue';
    },

    beforePropertyValue () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        push();
    },

    beforeArrayValue () {
        if (token.type === 'eof') {
            throw invalidEOF()
        }

        if (token.type === 'punctuator' && token.value === ']') {
            pop();
            return
        }

        push();
    },

    afterPropertyValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        switch (token.value) {
        case ',':
            parseState = 'beforePropertyName';
            return

        case '}':
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    afterArrayValue () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'punctuator') {
        //     throw invalidToken()
        // }

        if (token.type === 'eof') {
            throw invalidEOF()
        }

        switch (token.value) {
        case ',':
            parseState = 'beforeArrayValue';
            return

        case ']':
            pop();
        }

        // This code is unreachable since it's handled by the lexState.
        // throw invalidToken()
    },

    end () {
        // This code is unreachable since it's handled by the lexState.
        // if (token.type !== 'eof') {
        //     throw invalidToken()
        // }
    },
};

function push () {
    let value;

    switch (token.type) {
    case 'punctuator':
        switch (token.value) {
        case '{':
            value = {};
            break

        case '[':
            value = [];
            break
        }

        break

    case 'null':
    case 'boolean':
    case 'numeric':
    case 'string':
        value = token.value;
        break

    // This code is unreachable.
    // default:
    //     throw invalidToken()
    }

    if (root === undefined) {
        root = value;
    } else {
        const parent = stack[stack.length - 1];
        if (Array.isArray(parent)) {
            parent.push(value);
        } else {
            Object.defineProperty(parent, key, {
                value,
                writable: true,
                enumerable: true,
                configurable: true,
            });
        }
    }

    if (value !== null && typeof value === 'object') {
        stack.push(value);

        if (Array.isArray(value)) {
            parseState = 'beforeArrayValue';
        } else {
            parseState = 'beforePropertyName';
        }
    } else {
        const current = stack[stack.length - 1];
        if (current == null) {
            parseState = 'end';
        } else if (Array.isArray(current)) {
            parseState = 'afterArrayValue';
        } else {
            parseState = 'afterPropertyValue';
        }
    }
}

function pop () {
    stack.pop();

    const current = stack[stack.length - 1];
    if (current == null) {
        parseState = 'end';
    } else if (Array.isArray(current)) {
        parseState = 'afterArrayValue';
    } else {
        parseState = 'afterPropertyValue';
    }
}

// This code is unreachable.
// function invalidParseState () {
//     return new Error(`JSON5: invalid parse state '${parseState}'`)
// }

// This code is unreachable.
// function invalidLexState (state) {
//     return new Error(`JSON5: invalid lex state '${state}'`)
// }

function invalidChar (c) {
    if (c === undefined) {
        return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
    }

    return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
}

function invalidEOF () {
    return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
}

// This code is unreachable.
// function invalidToken () {
//     if (token.type === 'eof') {
//         return syntaxError(`JSON5: invalid end of input at ${line}:${column}`)
//     }

//     const c = String.fromCodePoint(token.value.codePointAt(0))
//     return syntaxError(`JSON5: invalid character '${formatChar(c)}' at ${line}:${column}`)
// }

function invalidIdentifier () {
    column -= 5;
    return syntaxError(`JSON5: invalid identifier character at ${line}:${column}`)
}

function separatorChar (c) {
    console.warn(`JSON5: '${formatChar(c)}' in strings is not valid ECMAScript; consider escaping`);
}

function formatChar (c) {
    const replacements = {
        "'": "\\'",
        '"': '\\"',
        '\\': '\\\\',
        '\b': '\\b',
        '\f': '\\f',
        '\n': '\\n',
        '\r': '\\r',
        '\t': '\\t',
        '\v': '\\v',
        '\0': '\\0',
        '\u2028': '\\u2028',
        '\u2029': '\\u2029',
    };

    if (replacements[c]) {
        return replacements[c]
    }

    if (c < ' ') {
        const hexString = c.charCodeAt(0).toString(16);
        return '\\x' + ('00' + hexString).substring(hexString.length)
    }

    return c
}

function syntaxError (message) {
    const err = new SyntaxError(message);
    err.lineNumber = line;
    err.columnNumber = column;
    return err
}

var stringify = function stringify (value, replacer, space) {
    const stack = [];
    let indent = '';
    let propertyList;
    let replacerFunc;
    let gap = '';
    let quote;

    if (
        replacer != null &&
        typeof replacer === 'object' &&
        !Array.isArray(replacer)
    ) {
        space = replacer.space;
        quote = replacer.quote;
        replacer = replacer.replacer;
    }

    if (typeof replacer === 'function') {
        replacerFunc = replacer;
    } else if (Array.isArray(replacer)) {
        propertyList = [];
        for (const v of replacer) {
            let item;

            if (typeof v === 'string') {
                item = v;
            } else if (
                typeof v === 'number' ||
                v instanceof String ||
                v instanceof Number
            ) {
                item = String(v);
            }

            if (item !== undefined && propertyList.indexOf(item) < 0) {
                propertyList.push(item);
            }
        }
    }

    if (space instanceof Number) {
        space = Number(space);
    } else if (space instanceof String) {
        space = String(space);
    }

    if (typeof space === 'number') {
        if (space > 0) {
            space = Math.min(10, Math.floor(space));
            gap = '          '.substr(0, space);
        }
    } else if (typeof space === 'string') {
        gap = space.substr(0, 10);
    }

    return serializeProperty('', {'': value})

    function serializeProperty (key, holder) {
        let value = holder[key];
        if (value != null) {
            if (typeof value.toJSON5 === 'function') {
                value = value.toJSON5(key);
            } else if (typeof value.toJSON === 'function') {
                value = value.toJSON(key);
            }
        }

        if (replacerFunc) {
            value = replacerFunc.call(holder, key, value);
        }

        if (value instanceof Number) {
            value = Number(value);
        } else if (value instanceof String) {
            value = String(value);
        } else if (value instanceof Boolean) {
            value = value.valueOf();
        }

        switch (value) {
        case null: return 'null'
        case true: return 'true'
        case false: return 'false'
        }

        if (typeof value === 'string') {
            return quoteString(value, false)
        }

        if (typeof value === 'number') {
            return String(value)
        }

        if (typeof value === 'object') {
            return Array.isArray(value) ? serializeArray(value) : serializeObject(value)
        }

        return undefined
    }

    function quoteString (value) {
        const quotes = {
            "'": 0.1,
            '"': 0.2,
        };

        const replacements = {
            "'": "\\'",
            '"': '\\"',
            '\\': '\\\\',
            '\b': '\\b',
            '\f': '\\f',
            '\n': '\\n',
            '\r': '\\r',
            '\t': '\\t',
            '\v': '\\v',
            '\0': '\\0',
            '\u2028': '\\u2028',
            '\u2029': '\\u2029',
        };

        let product = '';

        for (let i = 0; i < value.length; i++) {
            const c = value[i];
            switch (c) {
            case "'":
            case '"':
                quotes[c]++;
                product += c;
                continue

            case '\0':
                if (util.isDigit(value[i + 1])) {
                    product += '\\x00';
                    continue
                }
            }

            if (replacements[c]) {
                product += replacements[c];
                continue
            }

            if (c < ' ') {
                let hexString = c.charCodeAt(0).toString(16);
                product += '\\x' + ('00' + hexString).substring(hexString.length);
                continue
            }

            product += c;
        }

        const quoteChar = quote || Object.keys(quotes).reduce((a, b) => (quotes[a] < quotes[b]) ? a : b);

        product = product.replace(new RegExp(quoteChar, 'g'), replacements[quoteChar]);

        return quoteChar + product + quoteChar
    }

    function serializeObject (value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5')
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let keys = propertyList || Object.keys(value);
        let partial = [];
        for (const key of keys) {
            const propertyString = serializeProperty(key, value);
            if (propertyString !== undefined) {
                let member = serializeKey(key) + ':';
                if (gap !== '') {
                    member += ' ';
                }
                member += propertyString;
                partial.push(member);
            }
        }

        let final;
        if (partial.length === 0) {
            final = '{}';
        } else {
            let properties;
            if (gap === '') {
                properties = partial.join(',');
                final = '{' + properties + '}';
            } else {
                let separator = ',\n' + indent;
                properties = partial.join(separator);
                final = '{\n' + indent + properties + ',\n' + stepback + '}';
            }
        }

        stack.pop();
        indent = stepback;
        return final
    }

    function serializeKey (key) {
        if (key.length === 0) {
            return quoteString(key, true)
        }

        const firstChar = String.fromCodePoint(key.codePointAt(0));
        if (!util.isIdStartChar(firstChar)) {
            return quoteString(key, true)
        }

        for (let i = firstChar.length; i < key.length; i++) {
            if (!util.isIdContinueChar(String.fromCodePoint(key.codePointAt(i)))) {
                return quoteString(key, true)
            }
        }

        return key
    }

    function serializeArray (value) {
        if (stack.indexOf(value) >= 0) {
            throw TypeError('Converting circular structure to JSON5')
        }

        stack.push(value);

        let stepback = indent;
        indent = indent + gap;

        let partial = [];
        for (let i = 0; i < value.length; i++) {
            const propertyString = serializeProperty(String(i), value);
            partial.push((propertyString !== undefined) ? propertyString : 'null');
        }

        let final;
        if (partial.length === 0) {
            final = '[]';
        } else {
            if (gap === '') {
                let properties = partial.join(',');
                final = '[' + properties + ']';
            } else {
                let separator = ',\n' + indent;
                let properties = partial.join(separator);
                final = '[\n' + indent + properties + ',\n' + stepback + ']';
            }
        }

        stack.pop();
        indent = stepback;
        return final
    }
};

const JSON5 = {
    parse,
    stringify,
};

var lib = JSON5;

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (lib);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
var exports = __webpack_exports__;
/*!**************************!*\
  !*** ./build/src/cli.js ***!
  \**************************/

Object.defineProperty(exports, "__esModule", ({ value: true }));
const minimist = __webpack_require__(/*! minimist */ "./node_modules/minimist/index.js");
const _1 = __webpack_require__(/*! . */ "./build/src/index.js");
const parsed = minimist(process.argv.slice(2), { boolean: ["p", "c", "fix", "rename"] });
let format = "standard";
if (parsed["f"] !== undefined || parsed["format"] !== undefined) {
    format = parsed["f"] ? parsed["f"] : parsed["format"];
}
const arg = {
    configFilename: parsed._[0],
    format,
    compress: parsed["c"],
    performanceInformation: parsed["p"],
    showHelp: parsed["h"] !== undefined || parsed["help"] !== undefined,
    showVersion: parsed["v"] !== undefined || parsed["version"] !== undefined,
    outputDefaultConfig: parsed["d"] !== undefined || parsed["default"] !== undefined,
    runFix: parsed["fix"],
    runRename: parsed["rename"],
    outFormat: parsed["outformat"],
    outFile: parsed["outfile"],
    file: parsed["file"],
};
(0, _1.run)(arg).then(({ output, issues }) => {
    if (output.length > 0) {
        process.stdout.write(output, () => {
            if (issues.length > 0) {
                if (issues[0].getKey() === _1.GENERIC_ERROR) {
                    process.exit(2); // eg. "git" does not exist in system
                }
                else {
                    process.exit(1);
                }
            }
            else {
                process.exit();
            }
        });
    }
    else {
        process.exit();
    }
}).catch((err) => {
    console.log(err);
    process.exit(2);
});
//# sourceMappingURL=cli.js.map
})();

/******/ })()
;